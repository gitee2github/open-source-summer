{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_SDK应用开发.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/SDK%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html", "text_entry": "['基于openEuler Embedded的SDK应用开发\\n', '当前发布的镜像除了体验openEuler Embedded的基本功能外，还可以进行基本的应用开发，也即在openEuler Embedded上运行用户自己的程序。本章主要介绍如何基于openEuler Embedded的SDK进行应用开发。\\n', '\\n', '安装SDK\\n', '\\n', '[使用SDK编译hello world样例](#使用SDK编译hello world样例)\\n', '\\n', '使用SDK编译内核模块样例\\n', '\\n', '安装SDK\\n', '执行SDK自解压安装脚本\\n', '运行如下命令：\\n', '\\n', 'sh openeuler-glibc-x86_64-openeuler-image-aarch64-qemu-aarch64-toolchain-22.03.sh\\n', '根据提示输入工具链的安装路径，默认路径是/opt/openeuler/\\\\<openeuler version\\\\>/；若不设置，则按默认路径安装；也可以配置相对路径或绝对路径。\\n', '\\n', '举例如下：\\n', '\\n', 'sh ./openeuler-glibc-x86_64-openeuler-image-armv7a-qemu-arm-toolchain-22.03.sh``\\n', 'openEuler embedded(openEuler Embedded Reference Distro) SDK installer version 22.03\\n', '================================================================\\n', 'Enter target directory for SDK (default: /opt/openeuler/22.03): sdk\\n', 'You are about to install the SDK to \"/usr1/openeuler/sdk\". Proceed [Y/n]? y\\n', 'Extracting SDK...............................................done\\n', 'Setting it up...SDK has been successfully set up and is ready to be used.\\n', 'Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.\\n', '$ . /usr1/openeuler/sdk/environment-setup-armv7a-openeuler-linux-gnueabi\\n', '设置SDK环境变量\\n', '运行source命令。上例中前一步执行结束最后已打印source命令，运行即可。\\n', '\\n', '. /usr1/openeuler/myfiles/sdk/environment-setup-armv7a-openeuler-linux-gnueabi\\n', '查看是否安装成功\\n', '运行如下命令，查看是否安装成功、环境设置成功。\\n', '\\n', 'arm-openeuler-linux-gnueabi-gcc -v\\n', '使用SDK编译hello world样例\\n', '准备代码\\n', '以构建一个hello world程序为例，运行在openEuler Embedded根文件系统镜像中。\\n', '\\n', '创建一个hello.c文件，源码如下：\\n', '\\n', '#include <stdio.h>\\n', '\\n', 'int main(void)\\n', '{\\n', '    printf(\"hello world\\\\n\");\\n', '}\\n', '编写CMakelist.txt，和hello.c文件放在同一个目录。\\n', '\\n', 'project(hello C)\\n', '\\n', 'add_executable(hello hello.c)\\n', '编译生成二进制\\n', '进入hello.c文件所在目录，使用工具链编译，命令如下：\\n', '\\n', 'cmake ..\\n', 'make\\n', '把编译好的hello程序拷贝到openEuler Embedded系统的/tmp/某个目录下（例如/tmp/myfiles/）。如何拷贝可以参考前文所述使能共享文件系统场景。\\n', '\\n', '运行用户态程序\\n', '在openEuler Embedded系统中运行hello程序。\\n', '\\n', 'cd /tmp/myfiles/\\n', './hello\\n', '如运行成功，则会输出\"hello world\"。\\n', '\\n', '使用SDK编译内核模块样例\\n', '准备环境\\n', '在设置好SDK环境的基础之上，编译内核模块还需准备相应环境，但只需要准备一次即可。运行如下命令会创建相应的内核模块编译环境：\\n', '\\n', 'cd <SDK_PATH>/sysroots/<target>-openeuler-linux/usr/src/kernel\\n', 'make  modules_prepare\\n', '准备代码\\n', '以编译一个内核模块为例，运行在openEuler Embedded内核中。\\n', '\\n', '创建一个hello.c文件，源码如下：\\n', '\\n', '#include <linux/init.h>\\n', '#include <linux/module.h>\\n', '\\n', 'static int hello_init(void)\\n', '{\\n', '    printk(\"Hello, openEuler Embedded!\\\\r\\\\n\");\\n', '    return 0;\\n', '}\\n', '\\n', 'static void hello_exit(void)\\n', '{\\n', '    printk(\"Byebye!\");\\n', '}\\n', '\\n', 'module_init(hello_init);\\n', 'module_exit(hello_exit);\\n', '\\n', 'MODULE_LICENSE(GPL);\\n', '编写Makefile，和hello.c文件放在同一个目录：\\n', '\\n', ' KERNELDIR := ${KERNEL_SRC_DIR}\\n', ' CURRENT_PATH := $(shell pwd)\\n', '\\n', ' target := hello\\n', ' obj-m := $(target).o\\n', '\\n', ' build := kernel_modules\\n', '\\n', ' kernel_modules:\\n', ' \\t\\t$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules\\n', ' clean:\\n', ' \\t\\t$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean\\n', 'KERNEL_SRC_DIR 为SDK中内核源码树的目录，该变量在安装SDK后会被自动设置。\\n', '\\n', '编译生成内核模块\\n', '进入hello.c文件所在目录，使用工具链编译，命令如下：\\n', '\\n', 'make\\n', '将编译好的hello.ko拷贝到openEuler Embedded系统的目录下。\\n', '\\n', '如何拷贝可以参考前文所述使能共享文件系统场景。\\n', '\\n', '插入内核模块\\n', '在openEuler Embedded系统中插入内核模块:\\n', '\\n', 'insmod hello.ko\\n', '如运行成功，则会在内核日志中出现\"Hello, openEuler Embedded!\"。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_安装与运行.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C.html", "text_entry": "['安装与运行\\n', '本章主要介绍如何获取预先构建好的镜像，如何运行镜像。\\n', '\\n', '安装与运行\\n', '获取镜像\\n', '镜像内容\\n', '运行镜像\\n', '极简运行场景\\n', '使能共享文件系统场景\\n', '使能网络场景\\n', '获取镜像\\n', '当前发布的已构建好的镜像，只支持arm和aarch64两种架构，且只支持qemu中ARM virt-4.0平台，您可以通过如下链接获得相应的镜像：\\n', '\\n', 'qemu_arm：32位arm架构，ARM Cortex A15处理器\\n', 'qemu_aarch64：64位aarch64架构，ARM Cortex A57处理器\\n', '只要相应环境支持qemu仿真器（版本5.0以上），您可以将提供的openEuler Embedded镜像部署在物理裸机、云环境、容器或虚拟机上。\\n', '\\n', '镜像内容\\n', '所下载的镜像，由以下几部分组成：\\n', '\\n', '内核镜像zImage: 基于openEuler社区Linux 5.10代码构建得到。相应的内核配置可通过如下链接获取：\\n', '\\n', 'arm(cortex a15)\\n', 'arm(cortex a57)，针对aarch64架构，额外增加了镜像自解压功能，可以参见相应的patch\\n', '根文件系统镜像\\n', '\\n', 'openeuler-image-qemu-xxx.cpio.gz：标准根文件系统镜像，进行了必要安全加固，增加了audit、cracklib、OpenSSH、Linux PAM、shadow、iSula容器所支持的软件包。\\n', 'SDK(Software Development Kit)工具\\n', '\\n', 'openeuler-glibc-x86_64-xxxxx.sh：openEuler Embedded SDK自解压安装包，SDK包含了进行开发（用户态程序、内核模块等)所必需的工具、库和头文件等。\\n', '运行镜像\\n', '通过运行镜像，一方面您可以体验openEuler Embedded的功能，一方面也可以完成基本的嵌入式Linux开发。\\n', '\\n', '注意事项\\n', '\\n', '建议使用QEMU 5.0以上版本运行镜像，由于一些额外功能（网络、共享文件系统)需要依赖QEMU的virtio-net, virtio-fs等特性，如未在QEMU中使能，则运行时可能会产生错误，此时可能需要从源码重新编译QEMU。\\n', '运行镜像时，建议把内核镜像和根文件系统镜像放在同一目录下。\\n', 'QEMU的下载与安装可以参考QEMU官方网站 , 或者下载源码单独编译安装。安装好后可以运行如下命令确认：\\n', '\\n', 'qemu-system-aarch64 --version\\n', '极简运行场景\\n', '该场景下，QEMU未使能网络和共享文件系统，适合快速的功能体验。\\n', '\\n', '启动QEMU\\n', '针对arm(ARM Cortex A15)，运行如下命令：\\n', '\\n', 'qemu-system-arm -M virt-4.0 -cpu cortex-a15 -nographic -kernel zImage -initrd initrd\\n', '针对aarch64(ARM Cortex A57)，运行如下命令：\\n', '\\n', 'qemu-system-aarch64 -M virt-4.0 -cpu cortex-a57 -nographic -kernel zImage -initrd initrd\\n', ' 说明：\\n', '\\n', '由于标准根文件系统镜像进行了安全加固，因此第一次启动时，需要为登录用户名root设置密码，且密码强度有相应要求， 需要数字、字母、特殊字符组合最少8位，例如openEuler@2021。\\n', '\\n', '检查运行是否成功\\n', 'QEMU运行成功并登录后，将会呈现openEuler Embedded的Shell。\\n', '\\n', '使能共享文件系统场景\\n', '通过共享文件系统，可以使得运行QEMU仿真器的宿主机和openEuler Embedded共享文件，这样在宿主机上交叉编译的程序，拷贝到共享目录中，即可在openEuler Embedded上运行。\\n', '\\n', '假设将宿主机的/tmp目录作为共享目录，并事先在其中创建了名为hello_openeuler.txt的文件，使能共享文件系统功能的操作指导如下：\\n', '\\n', '启动QEMU\\n', '针对arm(ARM Cortex A15)，运行如下命令：\\n', '\\n', 'qemu-system-arm -M virt-4.0 -cpu cortex-a15 -nographic -kernel zImage -initrd initrd -device virtio-9p-device,fsdev=fs1,mount_tag=host -fsdev local,security_model=passthrough,id=fs1,path=/tmp\\n', '针对aarch64(ARM Cortex A57)，运行如下命令：\\n', '\\n', 'qemu-system-aarch64 -M virt-4.0 -cpu cortex-a57 -nographic -kernel zImage -initrd initrd -device virtio-9p-device,fsdev=fs1,mount_tag=host -fsdev local,security_model=passthrough,id=fs1,path=/tmp\\n', '映射文件系统\\n', '在openEuler Embedded启动并登录之后，需要运行如下命令，映射(mount)共享文件系统\\n', '\\n', 'cd /tmp\\n', 'mkdir host\\n', 'mount -t 9p -o trans=virtio,version=9p2000.L host /tmp/host\\n', '即把共享文件系统映射到openEuler Embedded的/tmp/host目录下。\\n', '\\n', '检查共享是否成功\\n', '在openEuler Embedded中，运行如下命令:\\n', '\\n', 'cd /tmp/host\\n', 'ls\\n', '如能发现hello_openeuler.txt，则共享成功。\\n', '\\n', '使能网络场景\\n', '通过QEMU的virtio-net和宿主机上的虚拟网卡，可以实现宿主机和openEuler Embedded之间的网络通信。除了通过virtio-fs实现文件共享外，还可以通过网络的方式，例如 scp 命令，实现宿主机和 openEuler Embedded传输文件。\\n', '\\n', '启动QEMU\\n', '针对arm(ARM Cortex A15)，运行如下命令：\\n', '\\n', 'qemu-system-arm -M virt-4.0 -cpu cortex-a15 -nographic -kernel zImage -initrd initrd -device virtio-net-device,netdev=tap0 -netdev tap,id=tap0,script=/etc/qemu-ifup\\n', '针对aarch64(ARM Cortex A57)，运行如下命令：\\n', '\\n', 'qemu-system-aarch64 -M virt-4.0 -cpu cortex-a57 -nographic -kernel zImage -initrd initrd -device virtio-net-device,netdev=tap0 -netdev tap,id=tap0,script=/etc/qemu-ifup\\n', '宿主上建立虚拟网卡\\n', '在宿主机上需要建立名为tap0的虚拟网卡，可以借助脚本实现，创建qemu-ifup脚本，放在/etc/下，具体内容如下：\\n', '\\n', '#!/bin/bash\\n', 'ifconfig $1 192.168.10.1 up\\n', '其执行需要root权限：\\n', '\\n', 'chmod a+x qemu-ifup\\n', '通过qemu-ifup脚本，宿主机上将创建名为tap0的虚拟网卡，地址为192.168.10.1。\\n', '\\n', '配置openEuler Embedded网卡\\n', 'openEuler Embedded登录后，执行如下命令：\\n', '\\n', 'ifconfig eth0 192.168.10.2\\n', '确认网络连通\\n', '在openEuler Embedded中，执行如下命令：\\n', '\\n', 'ping 192.168.10.1\\n', '如能ping通，则宿主机和openEuler Embedded之间的网络是连通的。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_构建指导_容器构建指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/%E5%AE%B9%E5%99%A8%E6%9E%84%E5%BB%BA%E6%8C%87%E5%AF%BC.html", "text_entry": "['容器构建指导\\n', '由于openEuler Embedded构建过程需要基于openEuler操作系统，且需要安装较多系统工具和构建工具。为方便开发人员快速搭建构建环境，我们将构建过程所依赖的操作系统和工具封装到一个容器中，这就使得开发人员可以快速搭建一个构建环境，进而投入到代码开发中去，避免在准备环境阶段消耗大量时间。\\n', '\\n', '环境准备\\n', '安装docker\\n', '获取容器镜像\\n', '准备容器构建环境\\n', '版本构建\\n', '下载源码\\n', '编译构建\\n', '构建结果说明\\n', '环境准备\\n', '需要使用docker创建容器环境，为了确保docker成功安装，需满足以下软件硬件要求：\\n', '\\n', '操作系统: 推荐使用Ubuntu、Debian和RHEL（Centos、Fedora等）\\n', '内核: 推荐3.8及以上的内核\\n', '驱动: 内核必须支持一种合适的存储驱动，例如: Device Mapper、AUFS、vfs、btrfs、ZFS\\n', '架构: 运行64位架构的计算机（x86_64和amd64）\\n', '安装docker\\n', '检查当前环境是否已安装docker工具\\n', '运行如下命令，可以看到当前docker版本信息，则说明当前环境已安装docker，无需再次安装。\\n', '\\n', 'docker version\\n', '如果没有安装，可参考官方链接安装\\n', '官网地址: http://www.dockerinfo.net/document，openEuler环境可参考Centos安装Docker。\\n', '\\n', '例如openEuler环境docker安装命令如下：\\n', '\\n', 'sudo yum install docker\\n', '获取容器镜像\\n', '通过docker pull命令拉取华为云中的镜像到宿主机。命令如下：\\n', '\\n', 'docker pull swr.cn-north-4.myhuaweicloud.com/openeuler-embedded/openeuler-container:22.03-lts\\n', '准备容器构建环境\\n', '1.启动容器\\n', '可通过docker run命令启动容器，为了保证容器启动后可以在后台运行，且可以正常访问网络，建议使用如下命令启动：\\n', '\\n', 'docker run -idt --network host swr.cn-north-4.myhuaweicloud.com/openeuler-embedded/openeuler-container:22.03-lts bash\\n', '参数说明:\\n', '\\n', '-i 让容器的标准输入保持打开\\n', '-d 让 Docker 容器在后台以守护态（Daemonized）形式运行\\n', '-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上\\n', '–network 将容器连接到（host）网络\\n', 'swr.cn-north-4.myhuaweicloud.com/openeuler-embedded/openeuler-container 指定镜像名称\\n', 'bash 进入容器的方式\\n', '2.查看已启动的容器id\\n', 'docker ps\\n', '3.进入容器\\n', 'docker exec -it 容器id bash\\n', '构建环境已准备完成，下面就可以在容器中进行构建了。\\n', '\\n', '版本构建\\n', '下载源码\\n', '获取源码下载脚本\\n', 'git clone https://gitee.com/openeuler/yocto-meta-openeuler.git -b openEuler-22.03-LTS -v /usr1/openeuler/src/yocto-meta-openeuler\\n', '通过脚本下载源码\\n', 'cd /usr1/openeuler/src/yocto-meta-openeuler/scripts\\n', 'sh download_code.sh /usr1/openeuler/src\\n', '编译构建\\n', '编译架构: aarch64-std、aarch64-pro、arm-std、raspberrypi4-64\\n', '构建目录: /usr1/build\\n', '源码目录: /usr1/openeuler/src\\n', '编译器所在路径: /usr1/openeuler/gcc/openeuler_gcc_arm64le\\n', ' 说明：\\n', '\\n', '不同的编译架构使用不同的编译器，aarch64-std、aarch64-pro、raspberrypi4-64使用openeuler_gcc_arm64le编译器，arm-std使用openeuler_gcc_arm32le编译器。\\n', '下面以以aarch64-std目标架构编译为例。\\n', '将/usr1目录所属群组改为openeuler，否则切换至openeuler用户构建会存在权限问题。\\n', 'chown -R openeuler:users /usr1\\n', '切换至openeuler用户。\\n', 'su openeuler\\n', '进入构建脚本所在路径，运行编译脚本。\\n', 'cd /usr1/openeuler/src/yocto-meta-openeuler/scripts\\n', 'source compile.sh aarch64-std /usr1/build /usr1/openeuler/gcc/openeuler_gcc_arm64le\\n', 'bitbake openeuler-image\\n', '构建结果说明\\n', '结果件默认生成在构建目录下的output目录下，例如上面aarch64-std的构建结果件生成在/usr1/build/output目录下，如下表：\\n', '\\n', 'filename\\tdescription\\n', 'Image-*\\topenEuler Embedded image\\n', 'openeuler-glibc-x86_64-openeuler-image-*-toolchain-*.sh\\topenEuler Embedded sdk toolchain\\n', 'openeuler-image-qemu-aarch64-*.rootfs.cpio.gz\\topenEuler Embedded file system\\n', 'zImage\\topenEuler Embedded compressed image\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_构建指导_快速构建指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%8C%87%E5%AF%BC.html", "text_entry": "['快速构建指导\\n', '本章主要介绍如何构建openEuler Embedded。\\n', '\\n', '快速构建指导\\n', '环境准备\\n', 'Yocto中主机端命令使用\\n', 'openEuler Embedded所需构建工具\\n', '已安装好工具的构建容器\\n', '版本构建\\n', '构建代码下载\\n', '编译构建\\n', '构建结果说明\\n', '环境准备\\n', 'Yocto中主机端命令使用\\n', 'Yocto或者说Bitbake本质上是一组python程序，其最小运行环境要求如下：\\n', '\\n', 'Python3 > 3.6.0\\n', 'Git > 1.8.3.1\\n', 'Tar > 1.28\\n', '在构建过程中所需要的其他工具，Yocto都可以根据相应的软件包配方自行构建出来，从而达到自包含的效果。在这个过程中，Yocto还会依据自身需要，对相应的工具打上yocto专属补丁（如dnf，rpm等）。这些主机工具会在第一次的构建中从源码开始构建，因此Yocto第一次构建比较费时。\\n', '\\n', '为了加速构建特别是第一次构建，openEuler Embedded采取了\"能用原生工具就用原生工具，能不构建就不构建\"的策略，尽可能使用主机上预编译的原生的工具。这就需要依赖主机上软件包管理工具（apt, dnf, yum, zypper等)事先安装好。\\n', '\\n', 'Yocto是通过HOSTTOOLS变量来实现主机工具的引入，为会每个在HOSTTOOLS中列出的工具建立相应的软链接。为了避免来自主机对构建环境的污染，Yocto会重新准备不同于主机的环境，例如PATH变量等，因此如果新增依赖主机上的某个命令，需显示在Yocto的HOSTTOOLS变量中增加，否则即使主机上存在，Yocto构建时也会报错找不到相应的工具。相应流程如下图所示：\\n', '\\n', '\\n', '\\n', '当前openEuler Embedded所需要主机工具已经默认在local.conf.sample中的HOSTTOOLS定义，主要工具描述如下：\\n', '\\n', '工具名\\t用途\\n', 'cmake\\tcmake构建工具\\n', 'ninjia\\tninja构建系统\\n', 'openEuler Embedded所需构建工具\\n', '构建OS\\n', '\\n', '操作系统:openEuler-20.03-LTS-SP2\\n', '\\n', '安装系统额外工具\\n', '\\n', 'yum -y install tar cmake gperf sqlite-devel chrpath gcc-c++ patch rpm-build flex autoconf automake m4 bison bc libtool gettext-devel createrepo\\\\_c rpcgen texinfo hostname python meson dosfstools mtools parted ninja-build autoconf-archive libmpc-devel gmp-devel\\n', '预编译的交叉工具链和库\\n', '\\n', 'Yocto可以构建出交叉编译所需的交叉工具链和C库，但整个流程复杂且耗时，不亚于内核乃至镜像的构建，而且除了第一次构建，后面很少会再涉及。同时，绝大部分开发者都不会直接与工具链和C库构建打交道。所以为了简化该流程，openEuler Embedded采取的策略是采用预编译的交叉工具链和库，会专门维护和发布相应的带有C库的工具链。\\n', '\\n', '目前我们提供了对arm32位和aarch64位两种架构的工具链支持，通过如下方式可以获得：\\n', '\\n', '下载rpm包: wget https://repo.openeuler.org/openEuler-22.03-LTS/EPOL/main/x86_64/Packages/gcc-cross-1.0-0.oe2203.x86_64.rpm\\n', '解压rpm包: rpm2cpio gcc-cross-1.0-0.oe2203.x86_64.rpm | cpio -id\\n', '解压后可以看到当前路径下会有tmp目录，编译链存放于该目录下\\n', 'ARM 32位工具链: openeuler_gcc_arm32le.tar.xz\\n', 'ARM 64位工具链: openeuler_gcc_arm64le.tar.xz\\n', '已安装好工具的构建容器\\n', 'openEuler Embedded的构建过程中会使用到大量的各式各样的主机工具。如前文所述，为了加速构建，openEuler Embedded依赖主机事先安装好相应的工具，但这也会带来一不同主机环境会有不同的工具版本的问题，例如构建需要cmake高于1.9版本，但主机上最高只有cmake 1.8。为了解决这一问题，openEuler Embedded提供了专门的构建容器，提供统一的构建环境。\\n', '\\n', '使用者可以通过如下链接获得容器镜像直接用于编译：\\n', '\\n', '\\u200b openEuler Embedded构建容器的基础镜像\\n', '\\n', '具体构建指导请参考容器构建指导。\\n', '\\n', '版本构建\\n', '构建代码下载\\n', 'openEuler Embedded整个构建工程的文件布局如下，假设openeuler_embedded为顶层目录：\\n', '\\n', '<顶层目录openeuler_embedded> ├── src 源代码目录，包含所有软件包代码、内核代码和Yocto构建代码 ├── build openEuler Embedded的构建目录，生成的各种镜像放在此目录下\\n', '\\n', '获取源码下载脚本\\n', '\\n', '将脚本下载到指定目录，例如下载到src/yocto-meta-openeuler目录下：\\n', '\\n', 'git clone https://gitee.com/openeuler/yocto-meta-openeuler.git -b openEuler-22.03-LTS -v src/yocto-meta-openeuler\\n', '脚本为src/yocto-meta-openeuler/scripts/download_code.sh，此脚本有3个参数：\\n', '\\n', '参数1：下载的源码路径，默认相对脚本位置下载，例如前面样例，代码仓会下到src/下\\n', '参数2：下载的分支，默认值见脚本，不同分支按版本确定\\n', '参数3：下代码的xml文件，标准manifest格式，按xml配置下代码\\n', '通过脚本下载源码\\n', '\\n', '下载最新代码:\\n', '\\n', 'sh src/yocto-meta-openeuler/scripts/download_code.sh\\n', '下载指定版本代码:\\n', '\\n', 'sh src/yocto-meta-openeuler/scripts/download_code.sh \"\" \"\" \"manifest.xml\"\\n', '指定openEuler Embedded版本的代码的manifest.xml文件从openEuler Embedded发布件目录embedded_img/source-list/下获取。\\n', '\\n', '编译构建\\n', '一键式构建脚本：src/yocto-meta-openeuler/scripts/compile.sh, 具体细节可以参考该脚本。\\n', '\\n', '编译脚本的主要流程说明：\\n', '\\n', '设置PATH增加额外工具路径\\n', 'TEMPLATECONF指定local.conf.sample等配置文件路径\\n', '调用poky仓的oe-init-build-env进行初始化配置\\n', '在编译目录的conf/local.conf中配置MACHINE，按需增加额外新增的层\\n', '在编译目录执行bitbake openeuler-image编译openEuler Embedded的image和sdk\\n', '执行完发布件在编译目录的output目录下\\n', '运行编译脚本，以编译标准arm架构为例，编译方法如下:\\n', '\\n', 'source src/yocto-meta-openeuler/scripts/compile.sh arm-std\\n', 'bitbake openeuler-image  #执行第一条source后，会提示出bitbake命令\\n', '构建结果说明\\n', '结果件默认生成在构建目录下的output目录下，例如上面arm的构建结果件生成在/usr1/build/output目录下，如下表：\\n', '\\n', 'filename\\tdescription\\n', 'Image-*\\topenEuler Embedded image\\n', 'openeuler-glibc-x86_64-openeuler-image-*-toolchain-*.sh\\topenEuler Embedded sdk toolchain\\n', 'openeuler-image-qemu-aarch64-*.rootfs.cpio.gz\\topenEuler Embedded file system\\n', 'zImage\\topenEuler Embedded compressed']"}
{"index": {"_index": "new-open", "_id": "openEuler_KubeEdge部署指南_KubeEdge部署指南.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KubeEdge/KubeEdge%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97.html", "text_entry": "['KubeEdge 部署指南\\n', '介绍\\n', 'KubeEdge\\n', 'KubeEdge 是一个致力于解决边缘场景问题的开源系统，它将容器化应用程序编排和设备管理的能力扩展到边缘设备。基于 Kubernetes，KubeEdge 为网络、应用程序部署以及云侧与边缘侧之间的元数据同步提供核心基础设施支持。KubeEdge 支持 MQTT，并允许开发人员编写自定义逻辑，在边缘上启用资源受限的设备通信。KubeEdge 由云部分和边缘部分组成，目前均已开源。\\n', '\\n', 'https://kubeedge.io/\\n', '\\n', 'iSulad\\n', 'iSulad 是一个轻量级容器 runtime 守护程序，专为 IOT 和 Cloud 基础设施而设计，具有轻便、快速且不受硬件规格和体系结构限制的特性，可以被更广泛地应用在云、IoT、边缘计算等多个场景。\\n', '\\n', 'https://gitee.com/openeuler/iSulad\\n', '\\n', '集群概览\\n', '组件版本\\n', '组件\\t版本\\n', 'OS\\topenEuler 22.03\\n', 'Kubernetes\\t1.20.2-4\\n', 'iSulad\\t2.0.11\\n', 'KubeEdge\\tv1.8.0\\n', '节点规划（示例）\\n', '节点名\\t位置\\t组件\\n', 'cloud.kubeedge\\t云侧（cloud）\\tk8s（master）、isulad、cloudcore\\n', 'edge.kubeedge\\t边缘侧（edge）\\tisulad、edgecore\\n', '提示：云侧和边缘侧的主机名可以使用 hostnamectl set-hostname [cloud,edge].kubeedge 命令提前设置好\\n', '\\n', '准备\\n', '下载工具包\\n', 'kubeedge-tools 工具包提供了完备的离线安装包以及部署脚本，降低了部署复杂度并且支持在节点无法访问外网的条件下快速搭建 KubeEdge 集群。\\n', '\\n', '# 下载 kubeedge-tools 工具包并解压（包括云侧和边缘侧）\\n', '$ wget -O kubeedge-tools.zip https://gitee.com/Poorunga/kubeedge-tools/repository/archive/master.zip\\n', '$ unzip kubeedge-tools.zip\\n', '\\n', '# 进入 kubeedge-tools 工具包目录（后续所有操作基于此目录）\\n', '$ cd kubeedge-tools-master\\n', '部署 k8s\\n', '以下操作仅在云侧执行\\n', '\\n', '初始化云侧环境\\n', '$ ./setup-cloud.sh\\n', '参考 部署 k8s\\n', '提示：在云侧节点可以访问外网的条件下建议优先选用 kubeadm 工具部署 k8s，示例：\\n', '\\n', '$ kubeadm init --apiserver-advertise-address=云侧IP --kubernetes-version v1.20.15 --pod-network-cidr=10.244.0.0/16 --upload-certs --cri-socket=/var/run/isulad.sock\\n', '...\\n', 'Your Kubernetes control-plane has initialized successfully!\\n', '...\\n', '\\n', '# 成功安装 k8s 后还需根据最后的提示将指定文件复制到指定目录：\\n', '#   mkdir -p $HOME/.kube\\n', '#   sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\\n', '#   sudo chown $(id -u):$(id -g) $HOME/.kube/config\\n', '安装云侧容器网络\\n', '目前有丰富的 cni 软件可以为 k8s 节点提供容器网络功能，比如 flannel、calico、cilium 等，如果你暂时不明确选用哪款 cni 软件，可以使用下方命令安装云侧容器网络：\\n', '\\n', '$ ./install-flannel-cloud.sh\\n', '检查部署情况\\n', '# 查看节点状态（Ready 即正常）\\n', '$ kubectl get nodes\\n', 'NAME             STATUS   ROLES                  AGE   VERSION\\n', 'cloud.kubeedge   Ready    control-plane,master   12m   v1.20.2\\n', '\\n', '# 查看所有 k8s 组件运行状态（Running 即正常）\\n', '$ kubectl get pods -n kube-system\\n', 'NAME                                     READY   STATUS    RESTARTS   AGE\\n', 'coredns-74ff55c5b-4ptkh                  1/1     Running   0          15m\\n', 'coredns-74ff55c5b-zqx5n                  1/1     Running   0          15m\\n', 'etcd-cloud.kubeedge                      1/1     Running   0          15m\\n', 'kube-apiserver-cloud.kubeedge            1/1     Running   0          15m\\n', 'kube-controller-manager-cloud.kubeedge   1/1     Running   0          15m\\n', 'kube-flannel-cloud-ds-lvh4n              1/1     Running   0          13m\\n', 'kube-proxy-2tcnn                         1/1     Running   0          15m\\n', 'kube-scheduler-cloud.kubeedge            1/1     Running   0          15m\\n', '部署\\n', '部署 cloudcore\\n', '以下操作仅在云侧执行\\n', '\\n', '初始化集群\\n', '# --advertise-address 填写云侧节点的主机 IP 地址\\n', '$ keadm init --advertise-address=\"云侧IP\" --kubeedge-version=1.8.0\\n', '...\\n', 'CloudCore started\\n', '调整 cloudcore 配置\\n', '$ ./patch-cloud.sh\\n', '检查部署情况\\n', '# active (running)即正常\\n', '$ systemctl status cloudcore | grep running\\n', '     Active: active (running) since Fri 2022-03-04 10:54:30 CST; 5min ago\\n', '至此，云侧的 cloudcore 已部署完成，接下来部署边缘侧 edgecore。\\n', '\\n', '部署 edgecore\\n', '以下命令如无特殊说明则仅在边缘侧执行\\n', '\\n', '初始化边缘侧环境\\n', '$ ./setup-edge.sh\\n', '纳管边缘节点\\n', '# keadm gettoken 命令需要在云侧执行\\n', '$ keadm gettoken\\n', '96058ab80ffbeb87fe58a79bfb19ea13f9a5a6c3076a17c00f80f01b406b4f7c.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDY0NDg4NzF9.1mJegWB7SUVjgf-OvAqILgbZXeMHR9eOzMxpNFc42SI\\n', '# 记录并保存此 token 值，后续步骤需要使用\\n', '\\n', '\\n', '# keadm join 命令在边缘侧执行\\n', '# --cloudcore-ipport 填写云侧节点的主机 IP 地址:10000，--token 填写上方 token 值\\n', '$ keadm join --cloudcore-ipport=云侧IP:10000 --kubeedge-version=1.8.0 --token=96058ab80ffbeb87fe58a79bfb19ea13f9a5a6c3076a17c00f80f01b406b4f7c.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDY0NDg4NzF9.1mJegWB7SUVjgf-OvAqILgbZXeMHR9eOzMxpNFc42SI\\n', '...\\n', 'KubeEdge edgecore is running...\\n', '调整 edgecore 配置\\n', '$ ./patch-edge.sh\\n', '安装边缘侧容器网络\\n', '如果你暂时不明确选用哪款 cni 软件，可以使用下方命令安装边缘侧容器网络：\\n', '\\n', '# 下方命令需要在云侧执行\\n', '$ ./install-flannel-edge.sh\\n', '检查边缘节点是否纳管成功\\n', '# 下方命令需要在云侧执行（发现已经有了边缘节点）\\n', '$ kubectl get nodes\\n', 'NAME             STATUS   ROLES                  AGE     VERSION\\n', 'cloud.kubeedge   Ready    control-plane,master   1h      v1.20.2\\n', 'edge.kubeedge    Ready    agent,edge             10m     v1.19.3-kubeedge-v1.8.0\\n', '至此，KubeEdge 集群部署完成，接下来我们测试一下从云侧下发应用到边缘侧。\\n', '\\n', '部署应用\\n', '以下命令在云侧执行\\n', '\\n', '部署nginx\\n', '$ kubectl apply -f yamls/nginx-deployment.yaml\\n', 'deployment.apps/nginx-deployment created\\n', '\\n', '# 查看应用是否部署到了边缘侧（Running 即正常）\\n', '$ kubectl get pod -owide | grep nginx\\n', 'nginx-deployment-84b99f4bf-jb6sz   1/1     Running   0          30s   10.244.1.2   edge.kubeedge   <none>           <none>\\n', '测试功能\\n', '# 进入边缘侧节点，访问 nginx 应用\\n', '$ curl 10.244.1.2:80\\n', '<!DOCTYPE html>\\n', '<html>\\n', '<head>\\n', '<title>Welcome to nginx!</title>\\n', '<style>\\n', 'html { color-scheme: light dark; }\\n', 'body { width: 35em; margin: 0 auto;\\n', 'font-family: Tahoma, Verdana, Arial, sans-serif; }\\n', '</style>\\n', '</head>\\n', '<body>\\n', '<h1>Welcome to nginx!</h1>\\n', '<p>If you see this page, the nginx web server is successfully installed and\\n', 'working. Further configuration is required.</p>\\n', '\\n', '<p>For online documentation and support please refer to\\n', '<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\\n', 'Commercial support is available at\\n', '<a href=\"http://nginx.com/\">nginx.com</a>.</p>\\n', '\\n', '<p><em>Thank you for using nginx.</em></p>\\n', '</body>\\n', '</html>\\n', '至此，KubeEdge 部署已经全流程打通。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_准备虚拟机.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%87%86%E5%A4%87%E8%99%9A%E6%8B%9F%E6%9C%BA.html", "text_entry": "['准备虚拟机\\n', '本章介绍使用 virt manager 安装虚拟机的方法，如果您已经准备好虚拟机，可以跳过本章节。\\n', '\\n', '安装依赖工具\\n', '安装虚拟机，会依赖相关工具，安装依赖并使能 libvirtd 服务的参考命令如下（如果需要代理，请先配置代理）：\\n', '\\n', '$ dnf install virt-install virt-manager libvirt-daemon-qemu edk2-aarch64.noarch virt-viewer\\n', '$ systemctl start libvirtd\\n', '$ systemctl enable libvirtd\\n', '准备虚拟机磁盘文件\\n', '$ dnf install -y qemu-img\\n', '$ virsh pool-define-as vmPool --type dir --target /mnt/vm/images/\\n', '$ virsh pool-build vmPool\\n', '$ virsh pool-start vmPool\\n', '$ virsh pool-autostart  vmPool\\n', '$ virsh vol-create-as --pool vmPool --name master0.img --capacity 200G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name master1.img --capacity 200G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name master2.img --capacity 200G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name node1.img --capacity 300G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name node2.img --capacity 300G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name node3.img --capacity 300G --allocation 1G --format qcow2\\n', '打开 VNC 防火墙端口\\n', '方法一\\n', '\\n', '查询端口\\n', '\\n', '$ netstat -lntup | grep qemu-kvm\\n', '打开 VNC 的防火墙端口。假设端口从 5900 开始，参考命令如下：\\n', '\\n', '$ firewall-cmd --zone=public --add-port=5900/tcp\\n', '$ firewall-cmd --zone=public --add-port=5901/tcp\\n', '$ firewall-cmd --zone=public --add-port=5902/tcp\\n', '$ firewall-cmd --zone=public --add-port=5903/tcp\\n', '$ firewall-cmd --zone=public --add-port=5904/tcp\\n', '$ firewall-cmd --zone=public --add-port=5905/tcp\\n', '方法二\\n', '\\n', '直接关闭防火墙\\n', '\\n', '$ systemctl stop firewalld\\n', '准备虚拟机配置文件\\n', '创建虚拟机需要虚拟机配置文件。假设配置文件为 master.xml ，以虚拟机 hostname 为 k8smaster0 的节点为例，参考配置如下：\\n', '\\n', ' cat master.xml\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>k8smaster0</name>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    <vcpu>8</vcpu>\\n', '    <os>\\n', \"\\t<type arch='aarch64' machine='virt'>hvm</type>\\n\", \"\\t<loader readonly='yes' type='pflash'>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw</loader>\\n\", '\\t<nvram>/var/lib/libvirt/qemu/nvram/k8smaster0.fd</nvram>\\n', '    </os>\\n', '    <features>\\n', '\\t<acpi/>\\n', \"\\t<gic version='3'/>\\n\", '    </features>\\n', \"    <cpu mode='host-passthrough'>\\n\", \"        <topology sockets='2' cores='4' threads='1'/>\\n\", '    </cpu>\\n', '    <iothreads>1</iothreads>\\n', \"    <clock offset='utc'/>\\n\", '    <on_poweroff>destroy</on_poweroff>\\n', '    <on_reboot>restart</on_reboot>\\n', '    <on_crash>restart</on_crash>\\n', '    <devices>\\n', '\\t<emulator>/usr/libexec/qemu-kvm</emulator>\\n', \"\\t<disk type='file' device='disk'>\\n\", '\\t    <driver name=\\'qemu\\' type=\\'qcow2\\' iothread=\"1\"/>\\n', \"\\t    <source file='/mnt/vm/images/master0.img'/>\\n\", \"\\t    <target dev='vda' bus='virtio'/>\\n\", \"\\t    <boot order='1'/>\\n\", '\\t</disk>\\n', \"\\t<disk type='file' device='cdrom'>\\n\", \"\\t    <driver name='qemu' type='raw'/>\\n\", \"\\t    <source file='/mnt/openEuler-21.09-everything-aarch64-dvd.iso'/>\\n\", '\\t    <readonly/>\\n', \"\\t    <target dev='sdb' bus='scsi'/>\\n\", \"\\t    <boot order='2'/>\\n\", '\\t</disk>\\n', \"        <interface type='network'>\\n\", \"           <mac address='52:54:00:00:00:80'/>\\n\", \"           <source network='default'/>\\n\", \"           <model type='virtio'/>\\n\", '        </interface>\\n', \"\\t<console type='pty'/>\\n\", '        <video>\\n', \"           <model type='virtio'/>\\n\", '        </video>\\n', \"        <controller type='scsi' index='0' model='virtio-scsi'/>\\n\", \"\\t<controller type='usb' model='ehci'/>\\n\", \"\\t<input type='tablet' bus='usb'/>\\n\", \"\\t<input type='keyboard' bus='usb'/>\\n\", \"\\t<graphics type='vnc' listen='0.0.0.0'/>\\n\", '    </devices>\\n', \"    <seclabel type='dynamic' model='dac' relabel='yes'/>\\n\", '</domain>\\n', '由于虚拟机相关配置必须唯一，新增虚拟机需要适配修改如下内容，保证虚拟机的唯一性：\\n', '\\n', 'name：虚拟机 hostname，建议尽量小写。例中为 k8smaster0\\n', 'nvram：nvram的句柄文件路径，需要全局唯一。例中为 /var/lib/libvirt/qemu/nvram/k8smaster0.fd\\n', 'disk 的 source file：虚拟机磁盘文件路径。例中为 /mnt/vm/images/master0.img\\n', 'interface 的 mac address：interface 的 mac 地址。例中为 52:54:00:00:00:80\\n', '安装虚拟机\\n', '创建并启动虚拟机\\n', '\\n', '$ virsh define master.xml\\n', '$ virsh start k8smaster0\\n', '获取虚拟机的 VNC 端口号\\n', '\\n', '$ virsh vncdisplay k8smaster0\\n', '使用虚拟机链接工具，例如 VNC Viewer 远程链接虚拟机，并根据提示依次选择配置，完成系统安装\\n', '\\n', '设置虚拟机 hostname，例如设置为 k8smaster0\\n', '\\n', '$ hostnamectl set-hostname k8smaster0']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_准备证书.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%87%86%E5%A4%87%E8%AF%81%E4%B9%A6.html", "text_entry": "['准备证书\\n', '声明：本文使用的证书为自签名，不能用于商用环境\\n', '\\n', '部署集群前，需要生成集群各组件之间通信所需的证书。本文使用开源 CFSSL 作为验证部署工具，以便用户了解证书的配置和集群组件之间证书的关联关系。用户可以根据实际情况选择合适的工具，例如 OpenSSL 。\\n', '\\n', '编译安装 CFSSL\\n', '编译安装 CFSSL 的参考命令如下（需要互联网下载权限，需要配置代理的请先完成配置），\\n', '\\n', '$ wget --no-check-certificate  https://github.com/cloudflare/cfssl/archive/v1.5.0.tar.gz\\n', '$ tar -zxf v1.5.0.tar.gz\\n', '$ cd cfssl-1.5.0/\\n', '$ make -j6\\n', '$ cp bin/* /usr/local/bin/\\n', '生成根证书\\n', '编写 CA 配置文件，例如 ca-config.json：\\n', '\\n', '$ cat ca-config.json | jq\\n', '{\\n', '  \"signing\": {\\n', '    \"default\": {\\n', '      \"expiry\": \"8760h\"\\n', '    },\\n', '    \"profiles\": {\\n', '      \"kubernetes\": {\\n', '        \"usages\": [\\n', '          \"signing\",\\n', '          \"key encipherment\",\\n', '          \"server auth\",\\n', '          \"client auth\"\\n', '        ],\\n', '        \"expiry\": \"8760h\"\\n', '      }\\n', '    }\\n', '  }\\n', '}\\n', '编写 CA CSR 文件，例如 ca-csr.json：\\n', '\\n', '$ cat ca-csr.json  | jq\\n', '{\\n', '  \"CN\": \"Kubernetes\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"openEuler\",\\n', '      \"OU\": \"WWW\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成 CA 证书和密钥：\\n', '\\n', '$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca\\n', '得到如下证书：\\n', '\\n', 'ca.csr  ca-key.pem  ca.pem\\n', '生成 admin 账户证书\\n', 'admin 是 K8S 用于系统管理的一个账户，编写 admin 账户的 CSR 配置，例如 admin-csr.json：\\n', '\\n', 'cat admin-csr.json | jq\\n', '{\\n', '  \"CN\": \"admin\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:masters\",\\n', '      \"OU\": \"Containerum\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin\\n', '结果如下：\\n', '\\n', 'admin.csr  admin-key.pem  admin.pem\\n', '生成 service-account 账户证书\\n', '编写 service-account 账户的 CSR 配置文件，例如 service-account-csr.json：\\n', '\\n', 'cat service-account-csr.json | jq\\n', '{\\n', '  \"CN\": \"service-accounts\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"Kubernetes\",\\n', '      \"OU\": \"openEuler k8s install\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -profile=kubernetes service-account-csr.json | cfssljson -bare service-account\\n', '结果如下：\\n', '\\n', 'service-account.csr  service-account-key.pem  service-account.pem\\n', '生成 kube-controller-manager 组件证书\\n', '编写 kube-controller-manager 的 CSR 配置：\\n', '\\n', '{\\n', '  \"CN\": \"system:kube-controller-manager\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:kube-controller-manager\",\\n', '      \"OU\": \"openEuler k8s kcm\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json-profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager\\n', '结果如下：\\n', '\\n', 'kube-controller-manager.csr  kube-controller-manager-key.pem  kube-controller-manager.pem\\n', '生成 kube-proxy 证书\\n', '编写 kube-proxy 的 CSR 配置：\\n', '\\n', '{\\n', '  \"CN\": \"system:kube-proxy\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:node-proxier\",\\n', '      \"OU\": \"openEuler k8s kube proxy\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy\\n', '结果如下：\\n', '\\n', 'kube-proxy.csr  kube-proxy-key.pem  kube-proxy.pem\\n', '生成 kube-scheduler 证书\\n', '编写 kube-scheduler 的 CSR 配置：\\n', '\\n', '{\\n', '  \"CN\": \"system:kube-scheduler\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:kube-scheduler\",\\n', '      \"OU\": \"openEuler k8s kube scheduler\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler\\n', '结果如下：\\n', '\\n', 'kube-scheduler.csr  kube-scheduler-key.pem  kube-scheduler.pem\\n', '生成 kubelet 证书\\n', '由于证书涉及到 kubelet 所在机器的 hostname 和 IP 地址信息，因此每个 node 节点配置不尽相同，所以编写脚本完成，生成脚本如下：\\n', '\\n', '$ cat node_csr_gen.bash\\n', '\\n', '#!/bin/bash\\n', '\\n', 'nodes=(k8snode1 k8snode2 k8snode3)\\n', 'IPs=(\"192.168.122.157\" \"192.168.122.158\" \"192.168.122.159\")\\n', '\\n', 'for i in \"${!nodes[@]}\"; do\\n', '\\n', 'cat > \"${nodes[$i]}-csr.json\" <<EOF\\n', '{\\n', '  \"CN\": \"system:node:${nodes[$i]}\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:nodes\",\\n', '      \"OU\": \"openEuler k8s kubelet\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', 'EOF\\n', '\\n', '\\t# generate ca\\n', '\\techo \"generate: ${nodes[$i]} ${IPs[$i]}\"\\n', '\\tcfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -hostname=${nodes[$i]},${IPs[$i]}-profile=kubernetes ${nodes[$i]}-csr.json | cfssljson -bare ${nodes[$i]}\\n', 'done\\n', '说明：如果节点存在多个 IP 或者其他别名，-hostname 可以增加其他的 IP 或者 hostname\\n', '\\n', '结果如下：\\n', '\\n', 'k8snode1.csr       k8snode1.pem       k8snode2-key.pem  k8snode3-csr.json\\n', 'k8snode1-csr.json  k8snode2.csr       k8snode2.pem      k8snode3-key.pem\\n', 'k8snode1-key.pem   k8snode2-csr.json  k8snode3.csr      k8snode3.pem\\n', 'CSR 配置信息，以 k8snode1 为例如下：\\n', '\\n', '$ cat k8snode1-csr.json\\n', '{\\n', '  \"CN\": \"system:node:k8snode1\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:nodes\",\\n', '      \"OU\": \"openEuler k8s kubelet\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '注意：由于每个 node 所属的账户组为 system:node，因此 CSR 的 CN 字段都为 system:node 加上hostname。\\n', '\\n', '生成 kube-apiserver 证书\\n', '编写 kube api server 的 CSR 配置文件：\\n', '\\n', '$ cat kubernetes-csr.json | jq\\n', '{\\n', '  \"CN\": \"kubernetes\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"Kubernetes\",\\n', '      \"OU\": \"openEuler k8s kube api server\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书和密钥：\\n', '\\n', 'cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -hostname=10.32.0.1,192.168.122.154,192.168.122.155,192.168.122.156,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.svc.cluster.local -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes\\n', '结果如下：\\n', '\\n', 'kubernetes.csr  kubernetes-key.pem  kubernetes.pem\\n', '说明：10.32.0.1 是内部 services 使用的 IP 地址区间，可以设置为其他值，后面启动 apiserver 服务时，会设置该参数。\\n', '\\n', '生成 etcd 证书（可选）\\n', '部署 etcd 有两种方式：\\n', '\\n', '在每个 api-server 对应的机器都启动一个 etcd 服务\\n', '独立部署一个 etcd 集群服务\\n', '如果是和 api-server 一起部署，那么直接使用上面生成的 kubernetes-key.pem 和 kubernetes.pem 证书即可。\\n', '\\n', '如果是独立的etcd集群，那么需要创建证书如下：\\n', '\\n', '编写 etcd 的 CSR 配置：\\n', '\\n', 'cat etcd-csr.json | jq\\n', '{\\n', '  \"CN\": \"ETCD\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"ETCD\",\\n', '      \"OU\": \"openEuler k8s etcd\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -hostname=192.168.122.154,192.168.122.155,192.168.122.156,127.0.0.1 -profile=kubernetes etcd-csr.json | cfssljson -bare etcd\\n', '说明：假设 etcd 集群的 IP地址是 192.168.122.154,192.168.122.155,192.168.122.156\\n', '\\n', '结果如下：\\n', '\\n', 'etcd.csr  etcd-key.pem  etcd.pem\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_安装 Kubernetes 软件包.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%AE%89%E8%A3%85Kubernetes%E8%BD%AF%E4%BB%B6%E5%8C%85.html", "text_entry": "['安装 Kubernetes 软件包\\n', '$ dnf install -y docker conntrack-tools socat\\n', 'EPOL 之后，可以直接通过 dnf 安装 K8S\\n', '\\n', '$ rpm -ivh kubernetes*.rpm']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_安装etcd.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%AE%89%E8%A3%85etcd.html", "text_entry": "['安装 etcd\\n', '准备环境\\n', '使能 etcd 使用的端口：\\n', '\\n', 'firewall-cmd --zone=public --add-port=2379/tcp\\n', 'firewall-cmd --zone=public --add-port=2380/tcp\\n', '安装 etcd 二进制\\n', '当前是通过 rpm 包安装\\n', '\\n', 'rpm -ivh etcd*.rpm\\n', '准备目录\\n', '\\n', 'mkdir -p /etc/etcd /var/lib/etcd\\n', 'cp ca.pem /etc/etcd/\\n', 'cp kubernetes-key.pem /etc/etcd/\\n', 'cp kubernetes.pem /etc/etcd/\\n', '# 关闭selinux\\n', 'setenforce 0\\n', '# 禁用/etc/etcd/etcd.conf文件的默认配置\\n', '# 注释掉即可，例如：ETCD_LISTEN_CLIENT_URLS=\"http://localhost:2379\"\\n', '编写 etcd.service 文件\\n', '以 k8smaster0 机器为例：\\n', '\\n', '$ cat /usr/lib/systemd/system/etcd.service\\n', '[Unit]\\n', 'Description=Etcd Server\\n', 'After=network.target\\n', 'After=network-online.target\\n', 'Wants=network-online.target\\n', '\\n', '[Service]\\n', 'Type=notify\\n', 'WorkingDirectory=/var/lib/etcd/\\n', 'EnvironmentFile=-/etc/etcd/etcd.conf\\n', '# set GOMAXPROCS to number of processors\\n', 'ExecStart=/bin/bash -c \"ETCD_UNSUPPORTED_ARCH=arm64 /usr/bin/etcd --name=k8smaster0 --cert-file=/etc/etcd/kubernetes.pem --key-file=/etc/etcd/kubernetes-key.pem --peer-cert-file=/etc/etcd/kubernetes.pem --peer-key-file=/etc/etcd/kubernetes-key.pem --trusted-ca-file=/etc/etcd/ca.pem --peer-trusted-ca-file=/etc/etcd/ca.pem --peer-client-cert-auth --client-cert-auth --initial-advertise-peer-urls https://192.168.122.154:2380 --listen-peer-urls https://192.168.122.154:2380 --listen-client-urls https://192.168.122.154:2379,https://127.0.0.1:2379 --advertise-client-urls https://192.168.122.154:2379 --initial-cluster-token etcd-cluster-0 --initial-cluster k8smaster0=https://192.168.122.154:2380,k8smaster1=https://192.168.122.155:2380,k8smaster2=https://192.168.122.156:2380 --initial-cluster-state new --data-dir /var/lib/etcd\"\\n', '\\n', 'Restart=always\\n', 'RestartSec=10s\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '注意:\\n', '\\n', 'arm64上面需要增加启动设置ETCD_UNSUPPORTED_ARCH=arm64；\\n', '由于本文把etcd和k8s control部署在相同机器，所以使用了kubernetes.pem和kubernetes-key.pem证书来启动；\\n', 'ca证书，在整个部署流程里面使用了一个，etcd可以生成自己的ca，然后用自己的ca签名其他证书，但是需要在apiserver访问etcd的client用该ca签名的证书；\\n', 'initial-cluster需要把所有部署etcd的配置加上；\\n', '为了提高etcd的存储效率，可以使用ssd硬盘的目录，作为data-dir；\\n', '启动服务\\n', '\\n', '$ systemctl enable etcd\\n', '$ systemctl start etcd\\n', '然后，依次部署其他机器即可。\\n', '\\n', '验证基本功能\\n', '$  ETCDCTL_API=3 etcdctl -w table endpoint status --endpoints=https://192.168.122.155:2379,https://192.168.122.156:2379,https://192.168.122.154:2379   --cacert=/etc/etcd/ca.pem   --cert=/etc/etcd/kubernetes.pem   --key=/etc/etcd/kubernetes-key.pem\\n', '+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\\n', '|           ENDPOINT           |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFTAPPLIED INDEX | ERRORS |\\n', '+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\\n', '| https://192.168.122.155:2379 | b50ec873e253ebaa |  3.4.14 |  262 kB |     false |      false |       819 |         21 |           21 |        |\\n', '| https://192.168.122.156:2379 | e2b0d126774c6d02 |  3.4.14 |  262 kB |      true |      false |       819 |         21 |           21 |        |\\n', '| https://192.168.122.154:2379 | f93b3808e944c379 |  3.4.14 |  328 kB |     false |      false |       819 |         21 |           21 |        |\\n', '+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_部署 Node 节点组件.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E9%83%A8%E7%BD%B2Node%E8%8A%82%E7%82%B9%E7%BB%84%E4%BB%B6.html", "text_entry": "['署 Node 节点组件\\n', '本章节仅以k8snode1节点为例。\\n', '\\n', '环境准备\\n', '# 内网需要配置代理\\n', '$ dnf install -y docker iSulad conntrack-tools socat containernetworking-plugins\\n', '$ swapoff -a\\n', '$ mkdir -p /etc/kubernetes/pki/\\n', '$ mkdir -p /etc/cni/net.d\\n', '$ mkdir -p /opt/cni\\n', '# 删除默认kubeconfig\\n', '$ rm /etc/kubernetes/kubelet.kubeconfig\\n', '\\n', '## 使用isulad作为运行时 ########\\n', '# 配置iSulad\\n', 'cat  /etc/isulad/daemon.json\\n', '{\\n', '        \"registry-mirrors\": [\\n', '                \"docker.io\"\\n', '        ],\\n', '        \"insecure-registries\": [\\n', '                \"k8s.gcr.io\",\\n', '                \"quay.io\"\\n', '        ],\\n', '        \"pod-sandbox-image\": \"k8s.gcr.io/pause:3.2\",# pause类型\\n', '        \"network-plugin\": \"cni\", # 置空表示禁用cni网络插件则下面两个路径失效， 安装插件后重启isulad即可\\n', '        \"cni-bin-dir\": \"/usr/libexec/cni/\",\\n', '        \"cni-conf-dir\": \"/etc/cni/net.d\",\\n', '}\\n', '\\n', '# 在iSulad环境变量中添加代理，下载镜像\\n', 'cat /usr/lib/systemd/system/isulad.service\\n', '[Service]\\n', 'Type=notify\\n', 'Environment=\"HTTP_PROXY=http://name:password@proxy:8080\"\\n', 'Environment=\"HTTPS_PROXY=http://name:password@proxy:8080\"\\n', '\\n', '# 重启iSulad并设置为开机自启\\n', 'systemctl daemon-reload\\n', 'systemctl restart isulad\\n', '\\n', '\\n', '\\n', '\\n', '## 如果使用docker作为运行时 ########\\n', '$ dnf install -y docker\\n', '# 如果需要代理的环境，可以给docker配置代理，新增配置文件http-proxy.conf，并编写如下内容，替换name，password和proxy-addr为实际的配置。\\n', '$ cat /etc/systemd/system/docker.service.d/http-proxy.conf\\n', '[Service]\\n', 'Environment=\"HTTP_PROXY=http://name:password@proxy-addr:8080\"\\n', '$ systemctl daemon-reload\\n', '$ systemctl restart docker\\n', '创建 kubeconfig 配置文件\\n', '对各节点依次如下操作创建配置文件：\\n', '\\n', '$ kubectl config set-cluster openeuler-k8s \\\\\\n', '    --certificate-authority=/etc/kubernetes/pki/ca.pem \\\\\\n', '    --embed-certs=true \\\\\\n', '    --server=https://192.168.122.154:6443 \\\\\\n', '    --kubeconfig=k8snode1.kubeconfig\\n', '\\n', '$ kubectl config set-credentials system:node:k8snode1 \\\\\\n', '    --client-certificate=/etc/kubernetes/pki/k8snode1.pem \\\\\\n', '    --client-key=/etc/kubernetes/pki/k8snode1-key.pem \\\\\\n', '    --embed-certs=true \\\\\\n', '    --kubeconfig=k8snode1.kubeconfig\\n', '\\n', '$ kubectl config set-context default \\\\\\n', '    --cluster=openeuler-k8s \\\\\\n', '    --user=system:node:k8snode1 \\\\\\n', '    --kubeconfig=k8snode1.kubeconfig\\n', '\\n', '$ kubectl config use-context default --kubeconfig=k8snode1.kubeconfig\\n', '注：修改k8snode1为对应节点名\\n', '\\n', '拷贝证书\\n', '和控制面一样，所有证书、密钥和相关配置都放到/etc/kubernetes/pki/目录。\\n', '\\n', '$ ls /etc/kubernetes/pki/\\n', 'ca.pem                 k8snode1.kubeconfig  kubelet_config.yaml     kube-proxy-key.pem     kube-proxy.pem\\n', 'k8snode1-key.pem  k8snode1.pem         kube_proxy_config.yaml  kube-proxy.kubeconfig\\n', 'CNI 网络配置\\n', '先通过 containernetworking-plugins 作为 kubelet 使用的 cni 插件，后续可以引入 calico，flannel 等插件，增强集群的网络能力。\\n', '\\n', '# 桥网络配置\\n', '$ cat /etc/cni/net.d/10-bridge.conf\\n', '{\\n', '  \"cniVersion\": \"0.3.1\",\\n', '  \"name\": \"bridge\",\\n', '  \"type\": \"bridge\",\\n', '  \"bridge\": \"cnio0\",\\n', '  \"isGateway\": true,\\n', '  \"ipMasq\": true,\\n', '  \"ipam\": {\\n', '    \"type\": \"host-local\",\\n', '    \"subnet\": \"10.244.0.0/16\",\\n', '    \"gateway\": \"10.244.0.1\"\\n', '  },\\n', '  \"dns\": {\\n', '    \"nameservers\": [\\n', '      \"10.244.0.1\"\\n', '    ]\\n', '  }\\n', '}\\n', '\\n', '# 回环网络配置\\n', '$ cat /etc/cni/net.d/99-loopback.conf\\n', '{\\n', '    \"cniVersion\": \"0.3.1\",\\n', '    \"name\": \"lo\",\\n', '    \"type\": \"loopback\"\\n', '}\\n', '部署 kubelet 服务\\n', 'kubelet 依赖的配置文件\\n', '$ cat /etc/kubernetes/pki/kubelet_config.yaml\\n', 'kind: KubeletConfiguration\\n', 'apiVersion: kubelet.config.k8s.io/v1beta1\\n', 'authentication:\\n', '  anonymous:\\n', '    enabled: false\\n', '  webhook:\\n', '    enabled: true\\n', '  x509:\\n', '    clientCAFile: /etc/kubernetes/pki/ca.pem\\n', 'authorization:\\n', '  mode: Webhook\\n', 'clusterDNS:\\n', '- 10.32.0.10\\n', 'clusterDomain: cluster.local\\n', 'runtimeRequestTimeout: \"15m\"\\n', 'tlsCertFile: \"/etc/kubernetes/pki/k8snode1.pem\"\\n', 'tlsPrivateKeyFile: \"/etc/kubernetes/pki/k8snode1-key.pem\"\\n', '注意：clusterDNS 的地址为：10.32.0.10，必须和之前设置的 service-cluster-ip-range 一致\\n', '\\n', '编写 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kubelet.service\\n', '[Unit]\\n', 'Description=kubelet: The Kubernetes Node Agent\\n', 'Documentation=https://kubernetes.io/docs/\\n', 'Wants=network-online.target\\n', 'After=network-online.target\\n', '\\n', '[Service]\\n', 'ExecStart=/usr/bin/kubelet \\\\\\n', '\\t--config=/etc/kubernetes/pki/kubelet_config.yaml \\\\\\n', '\\t--network-plugin=cni \\\\\\n', '\\t--pod-infra-container-image=k8s.gcr.io/pause:3.2 \\\\\\n', '\\t--kubeconfig=/etc/kubernetes/pki/k8snode1.kubeconfig \\\\\\n', '\\t--register-node=true \\\\\\n', '\\t--hostname-override=k8snode1 \\\\\\n', '\\t--cni-bin-dir=\"/usr/libexec/cni/\" \\\\\\n', '\\t--v=2\\n', '\\n', 'Restart=always\\n', 'StartLimitInterval=0\\n', 'RestartSec=10\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '注意：如果使用isulad作为runtime，需要增加如下配置\\n', '\\n', '--container-runtime=remote \\\\\\n', '--container-runtime-endpoint=unix:///var/run/isulad.sock \\\\\\n', '部署 kube-proxy\\n', 'kube-proxy 依赖的配置文件\\n', 'cat /etc/kubernetes/pki/kube_proxy_config.yaml\\n', 'kind: KubeProxyConfiguration\\n', 'apiVersion: kubeproxy.config.k8s.io/v1alpha1\\n', 'clientConnection:\\n', '  kubeconfig: /etc/kubernetes/pki/kube-proxy.kubeconfig\\n', 'clusterCIDR: 10.244.0.0/16\\n', 'mode: \"iptables\"\\n', '编写 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kube-proxy.service\\n', '[Unit]\\n', 'Description=Kubernetes Kube-Proxy Server\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-proxy/\\n', 'After=network.target\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/proxy\\n', 'ExecStart=/usr/bin/kube-proxy \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    --config=/etc/kubernetes/pki/kube_proxy_config.yaml \\\\\\n', '\\t    --hostname-override=k8snode1 \\\\\\n', '\\t    $KUBE_PROXY_ARGS\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '启动组件服务\\n', '$ systemctl enable kubelet kube-proxy\\n', '$ systemctl start kubelet kube-proxy\\n', '其他节点依次部署即可。\\n', '\\n', '验证集群状态\\n', '等待几分钟，使用如下命令查看node状态：\\n', '\\n', '$ kubectl get nodes --kubeconfig /etc/kubernetes/pki/admin.kubeconfig\\n', 'NAME            STATUS   ROLES    AGE   VERSION\\n', 'k8snode1   Ready    <none>   17h   v1.20.2\\n', 'k8snode2   Ready    <none>   19m   v1.20.2\\n', 'k8snode3   Ready    <none>   12m   v1.20.2\\n', '部署 coredns\\n', 'coredns可以部署到node节点或者master节点，本文这里部署到节点k8snode1。\\n', '\\n', '编写 coredns 配置文件\\n', '$ cat /etc/kubernetes/pki/dns/Corefile\\n', '.:53 {\\n', '    errors\\n', '    health {\\n', '      lameduck 5s\\n', '    }\\n', '    ready\\n', '    kubernetes cluster.local in-addr.arpa ip6.arpa {\\n', '      pods insecure\\n', '      endpoint https://192.168.122.154:6443\\n', '      tls /etc/kubernetes/pki/ca.pem /etc/kubernetes/pki/admin-key.pem /etc/kubernetes/pki/admin.pem\\n', '      kubeconfig /etc/kubernetes/pki/admin.kubeconfig default\\n', '      fallthrough in-addr.arpa ip6.arpa\\n', '    }\\n', '    prometheus :9153\\n', '    forward . /etc/resolv.conf {\\n', '      max_concurrent 1000\\n', '    }\\n', '    cache 30\\n', '    loop\\n', '    reload\\n', '    loadbalance\\n', '}\\n', '说明：\\n', '\\n', '监听53端口；\\n', '设置kubernetes插件配置：证书、kube api的URL；\\n', '准备 systemd 的 service 文件\\n', 'cat /usr/lib/systemd/system/coredns.service\\n', '[Unit]\\n', 'Description=Kubernetes Core DNS server\\n', 'Documentation=https://github.com/coredns/coredns\\n', 'After=network.target\\n', '\\n', '[Service]\\n', 'ExecStart=bash -c \"KUBE_DNS_SERVICE_HOST=10.32.0.10 coredns -conf /etc/kubernetes/pki/dns/Corefile\"\\n', '\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '启动服务\\n', '$ systemctl enable coredns\\n', '$ systemctl start coredns\\n', '创建 coredns 的 Service 对象\\n', '$ cat coredns_server.yaml\\n', 'apiVersion: v1\\n', 'kind: Service\\n', 'metadata:\\n', '  name: kube-dns\\n', '  namespace: kube-system\\n', '  annotations:\\n', '    prometheus.io/port: \"9153\"\\n', '    prometheus.io/scrape: \"true\"\\n', '  labels:\\n', '    k8s-app: kube-dns\\n', '    kubernetes.io/cluster-service: \"true\"\\n', '    kubernetes.io/name: \"CoreDNS\"\\n', 'spec:\\n', '  clusterIP: 10.32.0.10\\n', '  ports:\\n', '  - name: dns\\n', '    port: 53\\n', '    protocol: UDP\\n', '  - name: dns-tcp\\n', '    port: 53\\n', '    protocol: TCP\\n', '  - name: metrics\\n', '    port: 9153\\n', '    protocol: TCP\\n', '创建 coredns 的 endpoint 对象\\n', '$ cat coredns_ep.yaml\\n', 'apiVersion: v1\\n', 'kind: Endpoints\\n', 'metadata:\\n', '  name: kube-dns\\n', '  namespace: kube-system\\n', 'subsets:\\n', '  - addresses:\\n', '      - ip: 192.168.122.157\\n', '    ports:\\n', '      - name: dns-tcp\\n', '        port: 53\\n', '        protocol: TCP\\n', '      - name: dns\\n', '        port: 53\\n', '        protocol: UDP\\n', '      - name: metrics\\n', '        port: 9153\\n', '        protocol: TCP\\n', '确认 coredns 服务\\n', '# 查看service对象\\n', '$ kubectl get service -n kube-system kube-dns\\n', 'NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE\\n', 'kube-dns   ClusterIP   10.32.0.10   <none>        53/UDP,53/TCP,9153/TCP   51m\\n', '# 查看endpoint对象\\n', '$ kubectl get endpoints -n kube-system kube-dns\\n', 'NAME       ENDPOINTS                                                    AGE\\n', 'kube-dns   192.168.122.157:53,192.168.122.157:53,192.168.122.157:9153   52m\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_部署控制面组件.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E9%83%A8%E7%BD%B2%E6%8E%A7%E5%88%B6%E9%9D%A2%E7%BB%84%E4%BB%B6.html", "text_entry": "['部署控制面组件\\n', '准备所有组件的 kubeconfig\\n', 'kube-proxy\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://192.168.122.154:6443 --kubeconfig=kube-proxy.kubeconfig\\n', '$ kubectl config set-credentials system:kube-proxy --client-certificate=/etc/kubernetes/pki/kube-proxy.pem --client-key=/etc/kubernetes/pki/kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig\\n', '$ kubectl config set-context default --cluster=openeuler-k8s --user=system:kube-proxy --kubeconfig=kube-proxy.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig\\n', 'kube-controller-manager\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://127.0.0.1:6443 --kubeconfig=kube-controller-manager.kubeconfig\\n', '$ kubectl config set-credentials system:kube-controller-manager --client-certificate=/etc/kubernetes/pki/kube-controller-manager.pem --client-key=/etc/kubernetes/pki/kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig\\n', '$ kubectl config set-context default --cluster=openeuler-k8s --user=system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=kube-controller-manager.kubeconfig\\n', 'kube-scheduler\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://127.0.0.1:6443 --kubeconfig=kube-scheduler.kubeconfig\\n', '$ kubectl config set-credentials system:kube-scheduler --client-certificate=/etc/kubernetes/pki/kube-scheduler.pem --client-key=/etc/kubernetes/pki/kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig\\n', '$ kubectl config set-context default  --cluster=openeuler-k8s --user=system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=kube-scheduler.kubeconfig\\n', 'admin\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://127.0.0.1:6443 --kubeconfig=admin.kubeconfig\\n', '$ kubectl config set-credentials admin --client-certificate=/etc/kubernetes/pki/admin.pem --client-key=/etc/kubernetes/pki/admin-key.pem --embed-certs=true --kubeconfig=admin.kubeconfig\\n', '$ kubectl config set-context default --cluster=openeuler-k8s --user=admin --kubeconfig=admin.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=admin.kubeconfig\\n', '获得相关 kubeconfig 配置文件\\n', 'admin.kubeconfig kube-proxy.kubeconfig  kube-controller-manager.kubeconfig  kube-scheduler.kubeconfig\\n', '生成密钥提供者的配置\\n', 'api-server 启动时需要提供一个密钥对--encryption-provider-config=/etc/kubernetes/pki/encryption-config.yaml，本文通过 urandom 生成一个：\\n', '\\n', '$ cat generate.bash\\n', '#!/bin/bash\\n', '\\n', 'ENCRYPTION_KEY=$(head -c 32 /dev/urandom | base64)\\n', '\\n', 'cat > encryption-config.yaml <<EOF\\n', 'kind: EncryptionConfig\\n', 'apiVersion: v1\\n', 'resources:\\n', '  - resources:\\n', '      - secrets\\n', '    providers:\\n', '      - aescbc:\\n', '          keys:\\n', '            - name: key1\\n', '              secret: ${ENCRYPTION_KEY}\\n', '      - identity: {}\\n', 'EOF\\n', '# api-server启动配置 --encryption-provider-config=/etc/kubernetes/pki/encryption-config.yaml\\n', '拷贝证书\\n', '本文把所有组件使用的证书、密钥以及配置统一放到/etc/kubernetes/pki/目录下。\\n', '\\n', '# 准备证书目录\\n', '$ mkdir -p /etc/kubernetes/pki/\\n', '$ ls /etc/kubernetes/pki/\\n', 'admin-key.pem  encryption-config.yaml              kube-proxy-key.pem     kubernetes.pem             service-account-key.pem\\n', 'admin.pem      kube-controller-manager-key.pem     kube-proxy.kubeconfig  kube-scheduler-key.pem     service-account.pem\\n', 'ca-key.pem     kube-controller-manager.kubeconfig  kube-proxy.pem         kube-scheduler.kubeconfig\\n', 'ca.pem         kube-controller-manager.pem         kubernetes-key.pem     kube-scheduler.pem\\n', '部署 admin 角色的 RBAC\\n', '使能 admin role\\n', '\\n', '$ cat admin_cluster_role.yaml\\n', 'apiVersion: rbac.authorization.k8s.io/v1\\n', 'kind: ClusterRole\\n', 'metadata:\\n', '  annotations:\\n', '    rbac.authorization.kubernetes.io/autoupdate: \"true\"\\n', '  labels:\\n', '    kubernetes.io/bootstrapping: rbac-defaults\\n', '  name: system:kube-apiserver-to-kubelet\\n', 'rules:\\n', '  - apiGroups:\\n', '      - \"\"\\n', '    resources:\\n', '      - nodes/proxy\\n', '      - nodes/stats\\n', '      - nodes/log\\n', '      - nodes/spec\\n', '      - nodes/metrics\\n', '    verbs:\\n', '      - \"*\"\\n', '\\n', '# 使能admin role \\n', '$ kubectl apply --kubeconfig admin.kubeconfig -f admin_cluster_role.yaml\\n', '绑定 admin role\\n', '\\n', '$ cat admin_cluster_rolebind.yaml\\n', 'apiVersion: rbac.authorization.k8s.io/v1\\n', 'kind: ClusterRoleBinding\\n', 'metadata:\\n', '  name: system:kube-apiserver\\n', '  namespace: \"\"\\n', 'roleRef:\\n', '  apiGroup: rbac.authorization.k8s.io\\n', '  kind: ClusterRole\\n', '  name: system:kube-apiserver-to-kubelet\\n', 'subjects:\\n', '  - apiGroup: rbac.authorization.k8s.io\\n', '    kind: User\\n', '    name: kubernetes\\n', '\\n', '# 绑定admin role\\n', '$ kubectl apply --kubeconfig admin.kubeconfig -f admin_cluster_rolebind.yaml\\n', '部署 api server 服务\\n', '修改 apiserver 的 etc 配置文件：\\n', '\\n', '$ cat /etc/kubernetes/apiserver\\n', 'KUBE_ADVERTIS_ADDRESS=\"--advertise-address=192.168.122.154\"\\n', 'KUBE_ALLOW_PRIVILEGED=\"--allow-privileged=true\"\\n', 'KUBE_AUTHORIZATION_MODE=\"--authorization-mode=Node,RBAC\"\\n', 'KUBE_ENABLE_ADMISSION_PLUGINS=\"--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota\"\\n', 'KUBE_SECURE_PORT=\"--secure-port=6443\"\\n', 'KUBE_ENABLE_BOOTSTRAP_TOKEN_AUTH=\"--enable-bootstrap-token-auth=true\"\\n', 'KUBE_ETCD_CAFILE=\"--etcd-cafile=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_ETCD_CERTFILE=\"--etcd-certfile=/etc/kubernetes/pki/kubernetes.pem\"\\n', 'KUBE_ETCD_KEYFILE=\"--etcd-keyfile=/etc/kubernetes/pki/kubernetes-key.pem\"\\n', 'KUBE_ETCD_SERVERS=\"--etcd-servers=https://192.168.122.154:2379,https://192.168.122.155:2379,https://192.168.122.156:2379\"\\n', 'KUBE_CLIENT_CA_FILE=\"--client-ca-file=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_KUBELET_CERT_AUTH=\"--kubelet-certificate-authority=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_KUBELET_CLIENT_CERT=\"--kubelet-client-certificate=/etc/kubernetes/pki/kubernetes.pem\"\\n', 'KUBE_KUBELET_CLIENT_KEY=\"--kubelet-client-key=/etc/kubernetes/pki/kubernetes-key.pem\"\\n', 'KUBE_KUBELET_HTTPS=\"--kubelet-https=true\"\\n', 'KUBE_PROXY_CLIENT_CERT_FILE=\"--proxy-client-cert-file=/etc/kubernetes/pki/kube-proxy.pem\"\\n', 'KUBE_PROXY_CLIENT_KEY_FILE=\"--proxy-client-key-file=/etc/kubernetes/pki/kube-proxy-key.pem\"\\n', 'KUBE_TLS_CERT_FILE=\"--tls-cert-file=/etc/kubernetes/pki/kubernetes.pem\"\\n', 'KUBE_TLS_PRIVATE_KEY_FILE=\"--tls-private-key-file=/etc/kubernetes/pki/kubernetes-key.pem\"\\n', 'KUBE_SERVICE_CLUSTER_IP_RANGE=\"--service-cluster-ip-range=10.32.0.0/16\"\\n', 'KUBE_SERVICE_ACCOUNT_ISSUER=\"--service-account-issuer=https://kubernetes.default.svc.cluster.local\"\\n', 'KUBE_SERVICE_ACCOUNT_KEY_FILE=\"--service-account-key-file=/etc/kubernetes/pki/service-account.pem\"\\n', 'KUBE_SERVICE_ACCOUNT_SIGN_KEY_FILE=\"--service-account-signing-key-file=/etc/kubernetes/pki/service-account-key.pem\"\\n', 'KUBE_SERVICE_NODE_PORT_RANGE=\"--service-node-port-range=30000-32767\"\\n', 'KUB_ENCRYPTION_PROVIDER_CONF=\"--encryption-provider-config=/etc/kubernetes/pki/encryption-config.yaml\"\\n', 'KUBE_REQUEST_HEADER_ALLOWED_NAME=\"--requestheader-allowed-names=front-proxy-client\"\\n', 'KUBE_REQUEST_HEADER_EXTRA_HEADER_PREF=\"--requestheader-extra-headers-prefix=X-Remote-Extra-\"\\n', 'KUBE_REQUEST_HEADER_GROUP_HEADER=\"--requestheader-group-headers=X-Remote-Group\"\\n', 'KUBE_REQUEST_HEADER_USERNAME_HEADER=\"--requestheader-username-headers=X-Remote-User\"\\n', 'KUBE_API_ARGS=\"\"\\n', '所有apiserver的配置都/etc/kubernetes/config文件中定义，然后在后面的service文件中直接使用即可。\\n', '\\n', '大部分配置都是比较固定的，部分需要注意：\\n', '\\n', '--service-cluster-ip-range该地址需要和后面的设置的clusterDNS需要一致；\\n', '编写 apiserver 的 systemd 配置\\n', 'cat /usr/lib/systemd/system/kube-apiserver.service\\n', '[Unit]\\n', 'Description=Kubernetes API Server\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-apiserver/\\n', 'After=network.target\\n', 'After=etcd.service\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/apiserver\\n', 'ExecStart=/usr/bin/kube-apiserver \\\\\\n', '\\t    $KUBE_ADVERTIS_ADDRESS \\\\\\n', '\\t    $KUBE_ALLOW_PRIVILEGED \\\\\\n', '\\t    $KUBE_AUTHORIZATION_MODE \\\\\\n', '\\t    $KUBE_ENABLE_ADMISSION_PLUGINS \\\\\\n', ' \\t    $KUBE_SECURE_PORT \\\\\\n', '\\t    $KUBE_ENABLE_BOOTSTRAP_TOKEN_AUTH \\\\\\n', '\\t    $KUBE_ETCD_CAFILE \\\\\\n', '\\t    $KUBE_ETCD_CERTFILE \\\\\\n', '\\t    $KUBE_ETCD_KEYFILE \\\\\\n', '\\t    $KUBE_ETCD_SERVERS \\\\\\n', '\\t    $KUBE_CLIENT_CA_FILE \\\\\\n', '\\t    $KUBE_KUBELET_CERT_AUTH \\\\\\n', '\\t    $KUBE_KUBELET_CLIENT_CERT \\\\\\n', '\\t    $KUBE_KUBELET_CLIENT_KEY \\\\\\n', '\\t    $KUBE_PROXY_CLIENT_CERT_FILE \\\\\\n', '\\t    $KUBE_PROXY_CLIENT_KEY_FILE \\\\\\n', '\\t    $KUBE_TLS_CERT_FILE \\\\\\n', '\\t    $KUBE_TLS_PRIVATE_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_CLUSTER_IP_RANGE \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_ISSUER \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_SIGN_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_NODE_PORT_RANGE \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    $KUBE_API_PORT \\\\\\n', '\\t    $KUBELET_PORT \\\\\\n', '\\t    $KUBE_ALLOW_PRIV \\\\\\n', '\\t    $KUBE_SERVICE_ADDRESSES \\\\\\n', '\\t    $KUBE_ADMISSION_CONTROL \\\\\\n', '\\t    $KUB_ENCRYPTION_PROVIDER_CONF \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_ALLOWED_NAME \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_EXTRA_HEADER_PREF \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_GROUP_HEADER \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_USERNAME_HEADER \\\\\\n', '\\t    $KUBE_API_ARGS\\n', 'Restart=on-failure\\n', 'Type=notify\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '部署 controller-manager 服务\\n', '修改 controller-manager 配置文件：\\n', '\\n', '$ cat /etc/kubernetes/controller-manager\\n', 'KUBE_BIND_ADDRESS=\"--bind-address=127.0.0.1\"\\n', 'KUBE_CLUSTER_CIDR=\"--cluster-cidr=10.200.0.0/16\"\\n', 'KUBE_CLUSTER_NAME=\"--cluster-name=kubernetes\"\\n', 'KUBE_CLUSTER_SIGNING_CERT_FILE=\"--cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_CLUSTER_SIGNING_KEY_FILE=\"--cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem\"\\n', 'KUBE_KUBECONFIG=\"--kubeconfig=/etc/kubernetes/pki/kube-controller-manager.kubeconfig\"\\n', 'KUBE_LEADER_ELECT=\"--leader-elect=true\"\\n', 'KUBE_ROOT_CA_FILE=\"--root-ca-file=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_SERVICE_ACCOUNT_PRIVATE_KEY_FILE=\"--service-account-private-key-file=/etc/kubernetes/pki/service-account-key.pem\"\\n', 'KUBE_SERVICE_CLUSTER_IP_RANGE=\"--service-cluster-ip-range=10.32.0.0/24\"\\n', 'KUBE_USE_SERVICE_ACCOUNT_CRED=\"--use-service-account-credentials=true\"\\n', 'KUBE_CONTROLLER_MANAGER_ARGS=\"--v=2\"\\n', '编写 controller-manager 的 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kube-controller-manager.service\\n', '[Unit]\\n', 'Description=Kubernetes Controller Manager\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-controller-manager/\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/controller-manager\\n', 'ExecStart=/usr/bin/kube-controller-manager \\\\\\n', '\\t    $KUBE_BIND_ADDRESS \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    $KUBE_CLUSTER_CIDR \\\\\\n', '\\t    $KUBE_CLUSTER_NAME \\\\\\n', '\\t    $KUBE_CLUSTER_SIGNING_CERT_FILE \\\\\\n', '\\t    $KUBE_CLUSTER_SIGNING_KEY_FILE \\\\\\n', '\\t    $KUBE_KUBECONFIG \\\\\\n', '\\t    $KUBE_LEADER_ELECT \\\\\\n', '\\t    $KUBE_ROOT_CA_FILE \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_PRIVATE_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_CLUSTER_IP_RANGE \\\\\\n', '\\t    $KUBE_USE_SERVICE_ACCOUNT_CRED \\\\\\n', '\\t    $KUBE_CONTROLLER_MANAGER_ARGS\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '部署 scheduler 服务\\n', '修改 scheduler 配置文件：\\n', '\\n', '$ cat /etc/kubernetes/scheduler\\n', 'KUBE_CONFIG=\"--kubeconfig=/etc/kubernetes/pki/kube-scheduler.kubeconfig\"\\n', 'KUBE_AUTHENTICATION_KUBE_CONF=\"--authentication-kubeconfig=/etc/kubernetes/pki/kube-scheduler.kubeconfig\"\\n', 'KUBE_AUTHORIZATION_KUBE_CONF=\"--authorization-kubeconfig=/etc/kubernetes/pki/kube-scheduler.kubeconfig\"\\n', 'KUBE_BIND_ADDR=\"--bind-address=127.0.0.1\"\\n', 'KUBE_LEADER_ELECT=\"--leader-elect=true\"\\n', 'KUBE_SCHEDULER_ARGS=\"\"\\n', '编写 scheduler 的 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kube-scheduler.service\\n', '[Unit]\\n', 'Description=Kubernetes Scheduler Plugin\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-scheduler/\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/scheduler\\n', 'ExecStart=/usr/bin/kube-scheduler \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    $KUBE_CONFIG \\\\\\n', '\\t    $KUBE_AUTHENTICATION_KUBE_CONF \\\\\\n', '\\t    $KUBE_AUTHORIZATION_KUBE_CONF \\\\\\n', '\\t    $KUBE_BIND_ADDR \\\\\\n', '\\t    $KUBE_LEADER_ELECT \\\\\\n', '\\t    $KUBE_SCHEDULER_ARGS\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '使能各组件\\n', '$ systemctl enable kube-controller-manager kube-scheduler kube-proxy\\n', '$ systemctl restart kube-controller-manager kube-scheduler kube-proxy\\n', '基本功能验证\\n', '$ curl --cacert /etc/kubernetes/pki/ca.pem https://192.168.122.154:6443/version\\n', '{\\n', '  \"major\": \"1\",\\n', '  \"minor\": \"20\",\\n', '  \"gitVersion\": \"v1.20.2\",\\n', '  \"gitCommit\": \"faecb196815e248d3ecfb03c680a4507229c2a56\",\\n', '  \"gitTreeState\": \"archive\",\\n', '  \"buildDate\": \"2021-03-02T07:26:14Z\",\\n', '  \"goVersion\": \"go1.15.7\",\\n', '  \"compiler\": \"gc\",\\n', '  \"platform\": \"linux/arm64\"\\n', '}']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_自动部署集群_工具介绍.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/eggo%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html", "text_entry": "['工具介绍\\n', '本章介绍自动化部署工具的相关内容，建议用户在部署前阅读。\\n', '\\n', '部署方式\\n', 'openEuler 提供的 Kubernetes 集群自动化部署工具使用命令行方式进行集群的一键部署。它提供了如下几种部署方式：\\n', '\\n', '离线部署：本地准备好所有需要用到的 RPM 软件包、二进制文件、插件、容器镜像，并将它们按照一定的格式打包成一个 tar.gz 文件，然后完成对应 YAML 配置文件的编写，即可执行命令实现一键部署。当虚拟机无法访问外部网络时，可以采用该部署方式。\\n', '在线部署：只需要完成对应 YAML 配置文件的编写，所需的RPM 软件包、二进制文件、插件、容器镜像，都在安装部署阶段连接互联网自动下载。该方式需要虚拟机能够访问软件源、集群依赖的镜像仓库，例如 Docker Hub 。\\n', '配置介绍\\n', '使用工具自动化部署 Kubernetes 集群时，使用 YAML 配置文件描述集群部署的信息，此处介绍各配置项含义以及配置示例。\\n', '\\n', '配置项介绍\\n', 'cluster-id：集群名称，请遵循 DNS 域名的命名规范。例如 k8s-cluster\\n', '\\n', 'username：需要部署 k8s 集群的机器的 ssh 登录用户名，所有机器都需要使用同一个用户名。\\n', '\\n', 'private-key-path：ssh 免密登录的秘钥存储文件的路径。private-key-path 和 password 只需要配置其中一项，如果两者都进行了配置，优先使用 private-key-path\\n', '\\n', 'masters：master 节点列表，建议每个 master 节点同时作为 worker 节点。每个 master 节点包含如下配置子项，多个 master 节点配置多组子项内容：\\n', '\\n', 'name：master 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：master 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：master 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'workers：worker 节点列表。每个 worker 节点包含如下配置子项，多个 worker 节点配置多个子项内容：\\n', '\\n', 'name：worker 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：worker 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：worker 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'etcds：etcd 节点的列表。如果该项为空，则会为每个 master 节点部署一个 etcd，否则只会部署配置的 etcd 节点。每个 etcd 节点包含如下配置子项，多个 etcd 节点配置多组子项内容：\\n', '\\n', 'name：etcd 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：etcd 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：etcd 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'loadbalance：loadbalance 节点列表。每个 loadbalance 节点包含如下配置子项，多个 loadbalance 节点配置多组子项内容：\\n', '\\n', 'name：loadbalance 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：loadbalance 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：loadbalance 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'bind-port：负载均衡服务的侦听端口\\n', 'external-ca：是否使用外部 CA 证书，使用则配置为 true，反之，配置为 false\\n', '\\n', 'external-ca-path：外部 CA 证书文件的路径 。仅 external-ca 为 true 时有效\\n', '\\n', 'service：k8s 创建的 service 信息。service 配置包含如下配置子项：\\n', '\\n', 'cidr：k8s 创建的 service 的 IP 地址网段\\n', 'dnsaddr：k8s 创建的 service 的 DNS 地址\\n', 'gateway：k8s创建的 service 的网关地址\\n', 'dns：k8s 创建的 coredns 的配置。dns 配置包含如下配置子项：\\n', 'corednstype：k8s 创建的 coredns 的部署类型，支持 pod 和 binary\\n', 'imageversion：pod 部署类型的 coredns 镜像版本\\n', 'replicas：pod 部署类型的 coredns 副本数量\\n', 'network：k8s 集群网络配置。network 配置包含如下配置子项：\\n', '\\n', 'podcidr：k8s 集群网络的 IP 地址网段\\n', 'plugin：k8s 集群部署的网络插件\\n', 'plugin-args：k8s 集群网络的网络插件的配置文件路径。例如 : {“NetworkYamlPath”: “/etc/kubernetes/addons/calico.yaml”}\\n', 'apiserver-endpoint：进群外部可访问的 APISERVER 服务的地址或域名，如果配置了 loadbalances 则填loadbalance 地址，否则填写第 1 个 master 节点地址。\\n', '\\n', 'apiserver-cert-sans：apiserver 相关证书中需要额外配置的 IP 和域名。它包含如下子配置项\\n', '\\n', 'dnsnames：apiserver 相关证书中需要额外配置的域名数组列表。\\n', 'ips：apiserver 相关证书中需要额外配置的 IP 地址数组列表。\\n', 'apiserver-timeout：apiserver 响应超时时间\\n', '\\n', 'etcd-token：etcd 集群名称\\n', '\\n', 'dns-vip：dns 的虚拟 IP 地址\\n', '\\n', 'dns-domain：DNS 域名后缀\\n', '\\n', 'pause-image：pause 容器的完整镜像名称\\n', '\\n', 'network-plugin：网络插件类型。仅支持配置 cni ，配置为空时使用 k8s 默认网络。\\n', '\\n', 'cni-bin-dir：网络插件地址，多个地址使用 “,” 分隔，例如：/usr/libexec/cni,/opt/cni/bin\\n', '\\n', 'runtime：指定容器运行时类型，目前支持 docker 和 iSulad\\n', '\\n', 'runtime-endpoint：容器运行时 endpoint，当 runtime 为 docker 时，可以不指定\\n', '\\n', 'registry-mirrors：下载容器镜像时，使用的镜像仓库的 mirror 站点地址\\n', '\\n', 'insecure-registries：下载容器镜像时，使用 http 协议下载镜像的镜像仓库地址\\n', '\\n', 'config-extra-args：各个组件（例如 kube-apiserver、etcd）服务启动配置的额外参数。它包含如下子配置项：\\n', '\\n', 'name：组件名称，支持 etcd、kube-apiserver、kube-controller-manager、kube-scheduler、kube-proxy、kubelet\\n', '\\n', 'extra-args：组件的拓展参数，格式为 key: value 格式，注意 key 对应的组件参数前需要加上 “-” 或者 “–” 。\\n', '\\n', 'open-ports：配置需要额外打开的端口，k8s 自身所需端口不需要进行配置，k8s 以外的插件端口需要进行额外配置。\\n', '\\n', 'worker | master | etcd | loadbalance：指定打开端口的节点类型，每项配置包含一个多或者多个 port 和 protocol 子配置项。\\n', 'port：端口地址\\n', 'protocol：端口类型，可选值为 tcp 或者 udp\\n', 'install：配置各种类型节点上需要安装的安装包或者二进制文件的详细信息，注意将对应文件放到在 tar.gz 安装包中。以下给全量配置说明，具体配置请根据实际情况选择。\\n', '\\n', 'package-source：配置安装包的详细信息\\n', 'type：安装包的压缩类型，目前只支持 tar.gz 类型的安装包\\n', 'dstpath：安装包在对端机器上的路径，必须是可用的绝对路径\\n', 'srcpath：不同架构安装包的存放路径，架构必须与机器架构相对应，必须是可用的绝对路径\\n', 'arm64：arm64 架构安装包的路径，配置的机器中存在 arm64 机器场景下需要配置\\n', 'amd64：amd64 类型安装包的路径，配置的机器中存在 x86_64 机器场景下需要配置\\n', '说明：\\n', '\\n', 'install 配置中 etcd、kubernetes-master、kubernetes-worker、network、loadbalance、container、image、dns 中的子配置项相同，都是 name、type、dst，schedule、TimeOut 。其中 dst，schedule、TimeOut 为可选项，用户根据安装的文件决定是否配置。下述仅以 etcd 和 kubernetes-master 节点的配置为例说明。\\n', 'etcd：etcd 类型节点需要安装的包或二进制文件列表\\n', 'name：需要安装的软件包或二进制文件的名称，如果是安装包则只写名称，不填写具体的版本号，安装时会使用 $name* 识别，例如 etcd 。如果为多个软件包，各名称使用 ，分隔 。\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'dst：目的文件夹路径，type 为 bin、file、dir 类型时需要配置。表示将文件/文件夹放到节点的哪个目录下，为了防止用户误配置路径，导致 cleanup 时删除重要文件，此配置必须配置为白名单中的路径。详见 “白名单说明”\\n', 'kubernetes-master：k8s master 类型节点需要安装的包或二进制文件列表\\n', 'kubernetes-worker：k8s worker 类型节点需要安装的包或二进制文件列表\\n', 'network：网络需要安装的包或二进制文件列表\\n', 'loadbalance：loadbalance 类型节点需要安装的包或二进制文件列表\\n', 'container：容器需要安装的包或二进制文件列表\\n', 'image：容器镜像 tar 包\\n', 'dns：k8s coredns 安装包。如果 corednstype 配置为 pod，此处无需配置\\n', 'addition：额外的安装包或二进制文件列表\\n', 'master：以下配置会安装在所有 master 节点\\n', 'name：需要安装的软件包包或二进制文件的名称\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'schedule：仅在 type 为 shell 时有效，代表用户想要执行脚本的时机，支持 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）。\\n', 'TimeOut：脚本执行超时时间，超时时该进程被强制终止运行。未配置默认为 30s\\n', 'worker：配置会安装在所有 worker 节点，具体配置格式和 addition 下的 master 相同\\n', '白名单介绍\\n', 'install 配置中 dst 项的值必须符合白名单规则，配置为白名单对应路径及其子目录。当前白名单如下：\\n', '\\n', '/usr/bin\\n', '/usr/local/bin\\n', '/opt/cni/bin\\n', '/usr/libexec/cni\\n', '/etc/kubernetes\\n', '/usr/lib/systemd/system\\n', '/etc/systemd/system\\n', '/tmp\\n', '配置示例\\n', '此处给出一个 YAML 文件配置示例。从示例可知，同一台机器，可以部署多个类型的节点，但是不同节点的配置必须一致，例如 test0 机器部署了 master 和 worker 类型。\\n', '\\n', 'cluster-id: k8s-cluster\\n', 'username: root\\n', 'private-key-path: /root/.ssh/private.key\\n', 'masters:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', 'workers:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', '- name: test1\\n', '  ip: 192.168.0.3\\n', '  port: 22\\n', '  arch: arm64\\n', 'etcds:\\n', '- name: etcd-0\\n', '  ip: 192.168.0.4\\n', '  port: 22\\n', '  arch: amd64\\n', 'loadbalance:\\n', '  name: k8s-loadbalance\\n', '  ip: 192.168.0.5\\n', '  port: 22\\n', '  arch: amd64\\n', '  bind-port: 8443\\n', 'external-ca: false\\n', 'external-ca-path: /opt/externalca \\n', 'service:\\n', '  cidr: 10.32.0.0/16\\n', '  dnsaddr: 10.32.0.10\\n', '  gateway: 10.32.0.1\\n', '  dns:  \\n', '    corednstype: pod\\n', '    imageversion: 1.8.4\\n', '    replicas: 2\\n', 'network:\\n', '  podcidr: 10.244.0.0/16\\n', '  plugin: calico\\n', '  plugin-args: {\"NetworkYamlPath\": \"/etc/kubernetes/addons/calico.yaml\"}  \\n', 'apiserver-endpoint: 192.168.122.222:6443      \\n', 'apiserver-cert-sans:\\n', '  dnsnames: []\\n', '  ips: []\\n', 'apiserver-timeout: 120s\\n', 'etcd-external: false\\n', 'etcd-token: etcd-cluster\\n', 'dns-vip: 10.32.0.10 \\n', 'dns-domain: cluster.local\\n', 'pause-image: k8s.gcr.io/pause:3.2\\n', 'network-plugin: cni \\n', 'cni-bin-dir: /usr/libexec/cni,/opt/cni/bin\\n', 'runtime: docker\\n', 'runtime-endpoint: unix:///var/run/docker.sock \\n', 'registry-mirrors: []\\n', 'insecure-registries: []\\n', 'config-extra-args:\\n', '  - name: kubelet\\n', '    extra-args:\\n', '      \"--cgroup-driver\": systemd\\n', 'open-ports:\\n', '  worker:\\n', '  - port: 111\\n', '    protocol: tcp\\n', '  - port: 179\\n', '    protocol: tcp\\n', 'install:\\n', '  package-source:\\n', '    type: tar.gz\\n', '    dstpath: \"\"\\n', '    srcpath: \\n', '      arm64: /root/rpms/packages-arm64.tar.gz \\n', '      amd64: /root/rpms/packages-x86.tar.gz\\n', '  etcd:\\n', '  - name: etcd\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  kubernetes-master:\\n', '  - name: kubernetes-client,kubernetes-master\\n', '    type: pkg\\n', '  kubernetes-worker:\\n', '  - name: docker-engine,kubernetes-client,kubernetes-node,kubernetes-kubelet\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: conntrack-tools,socat\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  network:\\n', '  - name: containernetworking-plugins\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  loadbalance:\\n', '  - name: gd,gperftools-libs,libunwind,libwebp,libxslt\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: nginx,nginx-all-modules,nginx-filesystem,nginx-mod-http-image-filter,nginx-mod-http-perl,nginx-mod-http-xslt-filter,nginx-mod-mail,nginx-mod-stream\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  container:\\n', '  - name: emacs-filesystem,gflags,gpm-libs,re2,rsync,vim-filesystem,vim-common,vim-enhanced,zlib-devel\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: libwebsockets,protobuf,protobuf-devel,grpc,libcgroup\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: yajl,lxc,lxc-libs,lcr,clibcni,iSulad\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  image:  \\n', '  - name: pause.tar\\n', '    type: image\\n', '    dst: \"\"\\n', '  dns:    \\n', '  - name: coredns\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  addition:\\n', '    master:\\n', '    - name: prejoin.sh\\n', '      type: shell\\n', '      schedule: \"prejoin\"\\n', '      TimeOut:  \"30s\"\\n', '    - name: calico.yaml\\n', '      type: yaml\\n', '      dst: \"\"\\n', '    worker:\\n', '    - name: docker.service\\n', '      type: file\\n', '      dst: /usr/lib/systemd/system/\\n', '    - name: postjoin.sh\\n', '      type: shell\\n', '      schedule: \"postjoin\"\\n', '安装包结构\\n', '如果是离线部署，需要准备 Kubernetes 以及相关的离线安装包，并遵循特定目录结构存放离线安装包。需要遵循的目录结构如下：\\n', '\\n', 'package\\n', '├── bin\\n', '├── dir\\n', '├── file\\n', '├── image\\n', '├── pkg\\n', '└── packages_notes.md\\n', '上述各目录的含义如下：\\n', '\\n', '离线部署包的目录结构与集群配置 config 中的 package 的类型对应，package 类型有 pkg、repo、bin、file、dir、image、yaml、shell 八种。\\n', '\\n', 'bin 目录存放二进制文件，对应 package 类型 bin 。\\n', '\\n', 'dir 目录存放需要拷贝到目标机器的目录，需要配置 dst 目的地路径，对应 package 类型 dir 。\\n', '\\n', 'file 目录存放 file、yaml、shell 三种类型的文件。其中 file 类型代表需要拷贝到目标机器的文件，同时需要配置 dst 目的地路径；yaml 类型代表用户自定义的 YAML 文件，会在集群部署完成后 apply 该 YAML 文件；shell 类型代表用户想要执行的脚本，同时需要配置 schedule 执行时机，执行时机包括 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）四个阶段。\\n', '\\n', 'image 目录存放需要导入的容器镜像。这些容器镜像必须兼容 docker 的 tar 包格式（例如由 docker 或 isula-build 导出镜像）。\\n', '\\n', 'pkg 目录下存放需要安装的 rpm/deb 包，对应 package 类型 pkg 。建议使用二进制文件，便于跨发行版本的部署。\\n', '\\n', '命令参考\\n', 'openEuler 提供的集群部署工具，使用命令行 eggo 进行集群部署。\\n', '\\n', '部署 k8s 集群\\n', '通过指定的 YAML 配置部署 k8s 集群：\\n', '\\n', 'eggo deploy [ -d ] -f deploy.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t是\\t指定部署 k8s 集群的 YAML 文件路径\\n', '加入单节点\\n', '将指定的单节点加入到 k8s 集群中：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster [ –type master,worker ] –arch arm64 –port 22 [ –name master1] IP\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–type | -t\\t否\\t指定加入节点的类型，支持 master、worker 。多个类型使用 “,” 隔开，默认值为 worker 。\\n', '–arch | -a\\t是\\t指定加入节点的 CPU 架构\\n', '–port | -p\\t是\\t指定 ssh 登录所加入节点的端口号\\n', '–name | -n\\t否\\t指定加入节点的名称\\n', 'IP\\t是\\t加入节点的实际 IP 地址\\n', '加入多节点\\n', '将指定的多个节点加入到 k8s 集群：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster -f nodes.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–file | -f\\t是\\t指定加入节点的 YAML 配置文件路径\\n', '删除节点\\n', '删除 k8s 集群中的一个或者多个节点：\\n', '\\n', 'eggo delete [ -d ] –id k8s-cluster node [node…]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要删除的节点所在的集群名称\\n', 'node\\t是\\t要删除的单个或多个节点的 IP 地址或者节点名称\\n', '删除集群\\n', '删除整个 k8s 集群：\\n', '\\n', 'eggo cleanup [ -d ] –id k8s-cluster [ -f deploy.yaml ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要清除的 k8s 集群名称\\n', '–file | -f\\t否\\t指定清除 k8s 集群的 YAML 文件路径。不指定时，默认使用部署集群时缓存的集群配置。正常情况下，建议不配置该选项，仅异常情况下配置。\\n', '说明\\n', '\\n', '建议使用部署集群时缓存的集群配置删除集群，即正常情况下，不建议配置 –file | -f 参数。当异常导致缓存配置破坏或者丢失时，才配置该参数。\\n', '查询集群\\n', '查询当前所有通过 eggo 部署的 k8s 集群：\\n', '\\n', 'eggo list [ -d ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '生成集群配置文件\\n', '快速生成部署 k8s 集群所需的 YAML 配置文件：\\n', '\\n', 'eggo template -d -f template.yaml -n k8s-cluster -u username -p password –etcd [192.168.0.1,192.168.0.2] –masters [192.168.0.1,192.168.0.2] –workers 192.168.0.3 –loadbalance 192.168.0.4\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t否\\t指定生成的 YAML 文件的路径\\n', '–name | -n\\t否\\t指定 k8s 集群的名称\\n', '–username | -u\\t否\\t指定 ssh 登录所配置节点的用户名\\n', '–password | -p\\t否\\t指定 ssh 登录所配置节点的密码\\n', '–etcd\\t否\\t指定 etcd 节点的 IP 列表\\n', '–masters\\t否\\t指定 master 节点的 IP 列表\\n', '–workers\\t否\\t指定 worker 节点的 IP 列表\\n', '–loadbalance | -l\\t否\\t指定 loadbalance 节点的 IP\\n', '查询帮助信息\\n', '查询 eggo 命令的帮助信息：\\n', '\\n', 'eggo help\\n', '\\n', '查询子命令帮助信息\\n', '查询 eggo 子命令的帮助信息：\\n', '\\n', 'eggo deploy | join | delete | cleanup | list | template -h\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–help| -h\\t是\\t打印帮助信息\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_自动部署集群_拆除集群.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/eggo%E6%8B%86%E9%99%A4%E9%9B%86%E7%BE%A4.html", "text_entry": "['拆除集群\\n', '当业务需求下降，不需要原有数量的节点时，可以通过删除集群中的节点，节省系统资源，从而降低成本。当业务不需要集群时，也可以直接删除整个集群。\\n', '\\n', '删除节点\\n', '可以使用命令行删除集群中的节点。例如，删除 k8s-cluster 集群中 IP 地址为 192.168.0.5 和 192.168.0.6 所有节点类型，参考命令如下：\\n', '\\n', '$ eggo -d delete --id k8s-cluster 192.168.0.5 192.168.0.6\\n', '删除整个集群\\n', '说明\\n', '\\n', '删除集群会删除整个集群的数据，且无法恢复，请谨慎操作。\\n', '当前，拆除集群不会清理容器和容器镜像，但若部署 Kubernetes 集群时，配置了需要安装容器引擎，则会清除容器引擎，这可能导致容器运行异常。\\n', '拆除集群过程中可能会打印一些错误信息，一般是由于清理过程中操作集群时反馈了错误的结果导致，集群仍然能够正常拆除\\n', '可以使用命令行方式删除整个集群。例如，删除 k8s-cluster 集群的参考命令如下：\\n', '\\n', '$ eggo -d cleanup --id k8s-cluster\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_自动部署集群_部署集群.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/eggo%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4.html", "text_entry": "['工具介绍\\n', '本章介绍自动化部署工具的相关内容，建议用户在部署前阅读。\\n', '\\n', '部署方式\\n', 'openEuler 提供的 Kubernetes 集群自动化部署工具使用命令行方式进行集群的一键部署。它提供了如下几种部署方式：\\n', '\\n', '离线部署：本地准备好所有需要用到的 RPM 软件包、二进制文件、插件、容器镜像，并将它们按照一定的格式打包成一个 tar.gz 文件，然后完成对应 YAML 配置文件的编写，即可执行命令实现一键部署。当虚拟机无法访问外部网络时，可以采用该部署方式。\\n', '在线部署：只需要完成对应 YAML 配置文件的编写，所需的RPM 软件包、二进制文件、插件、容器镜像，都在安装部署阶段连接互联网自动下载。该方式需要虚拟机能够访问软件源、集群依赖的镜像仓库，例如 Docker Hub 。\\n', '配置介绍\\n', '使用工具自动化部署 Kubernetes 集群时，使用 YAML 配置文件描述集群部署的信息，此处介绍各配置项含义以及配置示例。\\n', '\\n', '配置项介绍\\n', 'cluster-id：集群名称，请遵循 DNS 域名的命名规范。例如 k8s-cluster\\n', '\\n', 'username：需要部署 k8s 集群的机器的 ssh 登录用户名，所有机器都需要使用同一个用户名。\\n', '\\n', 'private-key-path：ssh 免密登录的秘钥存储文件的路径。private-key-path 和 password 只需要配置其中一项，如果两者都进行了配置，优先使用 private-key-path\\n', '\\n', 'masters：master 节点列表，建议每个 master 节点同时作为 worker 节点。每个 master 节点包含如下配置子项，多个 master 节点配置多组子项内容：\\n', '\\n', 'name：master 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：master 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：master 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'workers：worker 节点列表。每个 worker 节点包含如下配置子项，多个 worker 节点配置多个子项内容：\\n', '\\n', 'name：worker 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：worker 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：worker 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'etcds：etcd 节点的列表。如果该项为空，则会为每个 master 节点部署一个 etcd，否则只会部署配置的 etcd 节点。每个 etcd 节点包含如下配置子项，多个 etcd 节点配置多组子项内容：\\n', '\\n', 'name：etcd 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：etcd 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：etcd 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'loadbalance：loadbalance 节点列表。每个 loadbalance 节点包含如下配置子项，多个 loadbalance 节点配置多组子项内容：\\n', '\\n', 'name：loadbalance 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：loadbalance 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：loadbalance 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'bind-port：负载均衡服务的侦听端口\\n', 'external-ca：是否使用外部 CA 证书，使用则配置为 true，反之，配置为 false\\n', '\\n', 'external-ca-path：外部 CA 证书文件的路径 。仅 external-ca 为 true 时有效\\n', '\\n', 'service：k8s 创建的 service 信息。service 配置包含如下配置子项：\\n', '\\n', 'cidr：k8s 创建的 service 的 IP 地址网段\\n', 'dnsaddr：k8s 创建的 service 的 DNS 地址\\n', 'gateway：k8s创建的 service 的网关地址\\n', 'dns：k8s 创建的 coredns 的配置。dns 配置包含如下配置子项：\\n', 'corednstype：k8s 创建的 coredns 的部署类型，支持 pod 和 binary\\n', 'imageversion：pod 部署类型的 coredns 镜像版本\\n', 'replicas：pod 部署类型的 coredns 副本数量\\n', 'network：k8s 集群网络配置。network 配置包含如下配置子项：\\n', '\\n', 'podcidr：k8s 集群网络的 IP 地址网段\\n', 'plugin：k8s 集群部署的网络插件\\n', 'plugin-args：k8s 集群网络的网络插件的配置文件路径。例如 : {“NetworkYamlPath”: “/etc/kubernetes/addons/calico.yaml”}\\n', 'apiserver-endpoint：进群外部可访问的 APISERVER 服务的地址或域名，如果配置了 loadbalances 则填loadbalance 地址，否则填写第 1 个 master 节点地址。\\n', '\\n', 'apiserver-cert-sans：apiserver 相关证书中需要额外配置的 IP 和域名。它包含如下子配置项\\n', '\\n', 'dnsnames：apiserver 相关证书中需要额外配置的域名数组列表。\\n', 'ips：apiserver 相关证书中需要额外配置的 IP 地址数组列表。\\n', 'apiserver-timeout：apiserver 响应超时时间\\n', '\\n', 'etcd-token：etcd 集群名称\\n', '\\n', 'dns-vip：dns 的虚拟 IP 地址\\n', '\\n', 'dns-domain：DNS 域名后缀\\n', '\\n', 'pause-image：pause 容器的完整镜像名称\\n', '\\n', 'network-plugin：网络插件类型。仅支持配置 cni ，配置为空时使用 k8s 默认网络。\\n', '\\n', 'cni-bin-dir：网络插件地址，多个地址使用 “,” 分隔，例如：/usr/libexec/cni,/opt/cni/bin\\n', '\\n', 'runtime：指定容器运行时类型，目前支持 docker 和 iSulad\\n', '\\n', 'runtime-endpoint：容器运行时 endpoint，当 runtime 为 docker 时，可以不指定\\n', '\\n', 'registry-mirrors：下载容器镜像时，使用的镜像仓库的 mirror 站点地址\\n', '\\n', 'insecure-registries：下载容器镜像时，使用 http 协议下载镜像的镜像仓库地址\\n', '\\n', 'config-extra-args：各个组件（例如 kube-apiserver、etcd）服务启动配置的额外参数。它包含如下子配置项：\\n', '\\n', 'name：组件名称，支持 etcd、kube-apiserver、kube-controller-manager、kube-scheduler、kube-proxy、kubelet\\n', '\\n', 'extra-args：组件的拓展参数，格式为 key: value 格式，注意 key 对应的组件参数前需要加上 “-” 或者 “–” 。\\n', '\\n', 'open-ports：配置需要额外打开的端口，k8s 自身所需端口不需要进行配置，k8s 以外的插件端口需要进行额外配置。\\n', '\\n', 'worker | master | etcd | loadbalance：指定打开端口的节点类型，每项配置包含一个多或者多个 port 和 protocol 子配置项。\\n', 'port：端口地址\\n', 'protocol：端口类型，可选值为 tcp 或者 udp\\n', 'install：配置各种类型节点上需要安装的安装包或者二进制文件的详细信息，注意将对应文件放到在 tar.gz 安装包中。以下给全量配置说明，具体配置请根据实际情况选择。\\n', '\\n', 'package-source：配置安装包的详细信息\\n', 'type：安装包的压缩类型，目前只支持 tar.gz 类型的安装包\\n', 'dstpath：安装包在对端机器上的路径，必须是可用的绝对路径\\n', 'srcpath：不同架构安装包的存放路径，架构必须与机器架构相对应，必须是可用的绝对路径\\n', 'arm64：arm64 架构安装包的路径，配置的机器中存在 arm64 机器场景下需要配置\\n', 'amd64：amd64 类型安装包的路径，配置的机器中存在 x86_64 机器场景下需要配置\\n', '说明：\\n', '\\n', 'install 配置中 etcd、kubernetes-master、kubernetes-worker、network、loadbalance、container、image、dns 中的子配置项相同，都是 name、type、dst，schedule、TimeOut 。其中 dst，schedule、TimeOut 为可选项，用户根据安装的文件决定是否配置。下述仅以 etcd 和 kubernetes-master 节点的配置为例说明。\\n', 'etcd：etcd 类型节点需要安装的包或二进制文件列表\\n', 'name：需要安装的软件包或二进制文件的名称，如果是安装包则只写名称，不填写具体的版本号，安装时会使用 $name* 识别，例如 etcd 。如果为多个软件包，各名称使用 ，分隔 。\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'dst：目的文件夹路径，type 为 bin、file、dir 类型时需要配置。表示将文件/文件夹放到节点的哪个目录下，为了防止用户误配置路径，导致 cleanup 时删除重要文件，此配置必须配置为白名单中的路径。详见 “白名单说明”\\n', 'kubernetes-master：k8s master 类型节点需要安装的包或二进制文件列表\\n', 'kubernetes-worker：k8s worker 类型节点需要安装的包或二进制文件列表\\n', 'network：网络需要安装的包或二进制文件列表\\n', 'loadbalance：loadbalance 类型节点需要安装的包或二进制文件列表\\n', 'container：容器需要安装的包或二进制文件列表\\n', 'image：容器镜像 tar 包\\n', 'dns：k8s coredns 安装包。如果 corednstype 配置为 pod，此处无需配置\\n', 'addition：额外的安装包或二进制文件列表\\n', 'master：以下配置会安装在所有 master 节点\\n', 'name：需要安装的软件包包或二进制文件的名称\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'schedule：仅在 type 为 shell 时有效，代表用户想要执行脚本的时机，支持 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）。\\n', 'TimeOut：脚本执行超时时间，超时时该进程被强制终止运行。未配置默认为 30s\\n', 'worker：配置会安装在所有 worker 节点，具体配置格式和 addition 下的 master 相同\\n', '白名单介绍\\n', 'install 配置中 dst 项的值必须符合白名单规则，配置为白名单对应路径及其子目录。当前白名单如下：\\n', '\\n', '/usr/bin\\n', '/usr/local/bin\\n', '/opt/cni/bin\\n', '/usr/libexec/cni\\n', '/etc/kubernetes\\n', '/usr/lib/systemd/system\\n', '/etc/systemd/system\\n', '/tmp\\n', '配置示例\\n', '此处给出一个 YAML 文件配置示例。从示例可知，同一台机器，可以部署多个类型的节点，但是不同节点的配置必须一致，例如 test0 机器部署了 master 和 worker 类型。\\n', '\\n', 'cluster-id: k8s-cluster\\n', 'username: root\\n', 'private-key-path: /root/.ssh/private.key\\n', 'masters:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', 'workers:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', '- name: test1\\n', '  ip: 192.168.0.3\\n', '  port: 22\\n', '  arch: arm64\\n', 'etcds:\\n', '- name: etcd-0\\n', '  ip: 192.168.0.4\\n', '  port: 22\\n', '  arch: amd64\\n', 'loadbalance:\\n', '  name: k8s-loadbalance\\n', '  ip: 192.168.0.5\\n', '  port: 22\\n', '  arch: amd64\\n', '  bind-port: 8443\\n', 'external-ca: false\\n', 'external-ca-path: /opt/externalca \\n', 'service:\\n', '  cidr: 10.32.0.0/16\\n', '  dnsaddr: 10.32.0.10\\n', '  gateway: 10.32.0.1\\n', '  dns:  \\n', '    corednstype: pod\\n', '    imageversion: 1.8.4\\n', '    replicas: 2\\n', 'network:\\n', '  podcidr: 10.244.0.0/16\\n', '  plugin: calico\\n', '  plugin-args: {\"NetworkYamlPath\": \"/etc/kubernetes/addons/calico.yaml\"}  \\n', 'apiserver-endpoint: 192.168.122.222:6443      \\n', 'apiserver-cert-sans:\\n', '  dnsnames: []\\n', '  ips: []\\n', 'apiserver-timeout: 120s\\n', 'etcd-external: false\\n', 'etcd-token: etcd-cluster\\n', 'dns-vip: 10.32.0.10 \\n', 'dns-domain: cluster.local\\n', 'pause-image: k8s.gcr.io/pause:3.2\\n', 'network-plugin: cni \\n', 'cni-bin-dir: /usr/libexec/cni,/opt/cni/bin\\n', 'runtime: docker\\n', 'runtime-endpoint: unix:///var/run/docker.sock \\n', 'registry-mirrors: []\\n', 'insecure-registries: []\\n', 'config-extra-args:\\n', '  - name: kubelet\\n', '    extra-args:\\n', '      \"--cgroup-driver\": systemd\\n', 'open-ports:\\n', '  worker:\\n', '  - port: 111\\n', '    protocol: tcp\\n', '  - port: 179\\n', '    protocol: tcp\\n', 'install:\\n', '  package-source:\\n', '    type: tar.gz\\n', '    dstpath: \"\"\\n', '    srcpath: \\n', '      arm64: /root/rpms/packages-arm64.tar.gz \\n', '      amd64: /root/rpms/packages-x86.tar.gz\\n', '  etcd:\\n', '  - name: etcd\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  kubernetes-master:\\n', '  - name: kubernetes-client,kubernetes-master\\n', '    type: pkg\\n', '  kubernetes-worker:\\n', '  - name: docker-engine,kubernetes-client,kubernetes-node,kubernetes-kubelet\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: conntrack-tools,socat\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  network:\\n', '  - name: containernetworking-plugins\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  loadbalance:\\n', '  - name: gd,gperftools-libs,libunwind,libwebp,libxslt\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: nginx,nginx-all-modules,nginx-filesystem,nginx-mod-http-image-filter,nginx-mod-http-perl,nginx-mod-http-xslt-filter,nginx-mod-mail,nginx-mod-stream\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  container:\\n', '  - name: emacs-filesystem,gflags,gpm-libs,re2,rsync,vim-filesystem,vim-common,vim-enhanced,zlib-devel\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: libwebsockets,protobuf,protobuf-devel,grpc,libcgroup\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: yajl,lxc,lxc-libs,lcr,clibcni,iSulad\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  image:  \\n', '  - name: pause.tar\\n', '    type: image\\n', '    dst: \"\"\\n', '  dns:    \\n', '  - name: coredns\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  addition:\\n', '    master:\\n', '    - name: prejoin.sh\\n', '      type: shell\\n', '      schedule: \"prejoin\"\\n', '      TimeOut:  \"30s\"\\n', '    - name: calico.yaml\\n', '      type: yaml\\n', '      dst: \"\"\\n', '    worker:\\n', '    - name: docker.service\\n', '      type: file\\n', '      dst: /usr/lib/systemd/system/\\n', '    - name: postjoin.sh\\n', '      type: shell\\n', '      schedule: \"postjoin\"\\n', '安装包结构\\n', '如果是离线部署，需要准备 Kubernetes 以及相关的离线安装包，并遵循特定目录结构存放离线安装包。需要遵循的目录结构如下：\\n', '\\n', 'package\\n', '├── bin\\n', '├── dir\\n', '├── file\\n', '├── image\\n', '├── pkg\\n', '└── packages_notes.md\\n', '上述各目录的含义如下：\\n', '\\n', '离线部署包的目录结构与集群配置 config 中的 package 的类型对应，package 类型有 pkg、repo、bin、file、dir、image、yaml、shell 八种。\\n', '\\n', 'bin 目录存放二进制文件，对应 package 类型 bin 。\\n', '\\n', 'dir 目录存放需要拷贝到目标机器的目录，需要配置 dst 目的地路径，对应 package 类型 dir 。\\n', '\\n', 'file 目录存放 file、yaml、shell 三种类型的文件。其中 file 类型代表需要拷贝到目标机器的文件，同时需要配置 dst 目的地路径；yaml 类型代表用户自定义的 YAML 文件，会在集群部署完成后 apply 该 YAML 文件；shell 类型代表用户想要执行的脚本，同时需要配置 schedule 执行时机，执行时机包括 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）四个阶段。\\n', '\\n', 'image 目录存放需要导入的容器镜像。这些容器镜像必须兼容 docker 的 tar 包格式（例如由 docker 或 isula-build 导出镜像）。\\n', '\\n', 'pkg 目录下存放需要安装的 rpm/deb 包，对应 package 类型 pkg 。建议使用二进制文件，便于跨发行版本的部署。\\n', '\\n', '命令参考\\n', 'openEuler 提供的集群部署工具，使用命令行 eggo 进行集群部署。\\n', '\\n', '部署 k8s 集群\\n', '通过指定的 YAML 配置部署 k8s 集群：\\n', '\\n', 'eggo deploy [ -d ] -f deploy.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t是\\t指定部署 k8s 集群的 YAML 文件路径\\n', '加入单节点\\n', '将指定的单节点加入到 k8s 集群中：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster [ –type master,worker ] –arch arm64 –port 22 [ –name master1] IP\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–type | -t\\t否\\t指定加入节点的类型，支持 master、worker 。多个类型使用 “,” 隔开，默认值为 worker 。\\n', '–arch | -a\\t是\\t指定加入节点的 CPU 架构\\n', '–port | -p\\t是\\t指定 ssh 登录所加入节点的端口号\\n', '–name | -n\\t否\\t指定加入节点的名称\\n', 'IP\\t是\\t加入节点的实际 IP 地址\\n', '加入多节点\\n', '将指定的多个节点加入到 k8s 集群：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster -f nodes.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–file | -f\\t是\\t指定加入节点的 YAML 配置文件路径\\n', '删除节点\\n', '删除 k8s 集群中的一个或者多个节点：\\n', '\\n', 'eggo delete [ -d ] –id k8s-cluster node [node…]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要删除的节点所在的集群名称\\n', 'node\\t是\\t要删除的单个或多个节点的 IP 地址或者节点名称\\n', '删除集群\\n', '删除整个 k8s 集群：\\n', '\\n', 'eggo cleanup [ -d ] –id k8s-cluster [ -f deploy.yaml ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要清除的 k8s 集群名称\\n', '–file | -f\\t否\\t指定清除 k8s 集群的 YAML 文件路径。不指定时，默认使用部署集群时缓存的集群配置。正常情况下，建议不配置该选项，仅异常情况下配置。\\n', '说明\\n', '\\n', '建议使用部署集群时缓存的集群配置删除集群，即正常情况下，不建议配置 –file | -f 参数。当异常导致缓存配置破坏或者丢失时，才配置该参数。\\n', '查询集群\\n', '查询当前所有通过 eggo 部署的 k8s 集群：\\n', '\\n', 'eggo list [ -d ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '生成集群配置文件\\n', '快速生成部署 k8s 集群所需的 YAML 配置文件：\\n', '\\n', 'eggo template -d -f template.yaml -n k8s-cluster -u username -p password –etcd [192.168.0.1,192.168.0.2] –masters [192.168.0.1,192.168.0.2] –workers 192.168.0.3 –loadbalance 192.168.0.4\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t否\\t指定生成的 YAML 文件的路径\\n', '–name | -n\\t否\\t指定 k8s 集群的名称\\n', '–username | -u\\t否\\t指定 ssh 登录所配置节点的用户名\\n', '–password | -p\\t否\\t指定 ssh 登录所配置节点的密码\\n', '–etcd\\t否\\t指定 etcd 节点的 IP 列表\\n', '–masters\\t否\\t指定 master 节点的 IP 列表\\n', '–workers\\t否\\t指定 worker 节点的 IP 列表\\n', '–loadbalance | -l\\t否\\t指定 loadbalance 节点的 IP\\n', '查询帮助信息\\n', '查询 eggo 命令的帮助信息：\\n', '\\n', 'eggo help\\n', '\\n', '查询子命令帮助信息\\n', '查询 eggo 子命令的帮助信息：\\n', '\\n', 'eggo deploy | join | delete | cleanup | list | template -h\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–help| -h\\t是\\t打印帮助信息\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_StratoVirt VFIO 使用说明.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/StratoVirt-VFIO-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html", "text_entry": "['管理设备直通\\n', '虚拟化平台使用设备直通，可以使虚拟机直接使用相关硬件设备，提升虚拟机性能。本章介绍 StratoVirt 支持的设备直通特性。\\n', '\\n', '前提条件\\n', '使用设备直通，主机需要满足如下条件：\\n', '\\n', '开启 IOMMU 功能\\n', '\\n', 'IOMMU 全称是 Input/Output Memory Management Unit，该技术可以让 PCI/PCIe 设备的资源直接分配给虚拟机。\\n', '\\n', '在主机上执行如下命令，查看 IOMMU 是否已经开启。\\n', '\\n', '# dmesg | grep iommu\\n', '若已开启，回显如下：\\n', '\\n', 'iommu: Default domain type: Translated\\n', 'hibmc-drm 0000:0a:00.0: Adding to iommu group 0\\n', 'ehci-pci 0000:7a:01.0: Adding to iommu group 1\\n', 'ehci-pci 0000:ba:01.0: Adding to iommu group 2\\n', 'ohci-pci 0000:7a:00.0: Adding to iommu group 3\\n', 'ohci-pci 0000:ba:00.0: Adding to iommu group 4\\n', 'xhci_hcd 0000:7a:02.0: Adding to iommu group 5\\n', '......\\n', '若未开启，则没有回显或只显示如下信息：\\n', '\\n', 'iommu: Default domain type: Translated\\n', '开启IOMMU：\\n', '\\n', '1.为linux内核增加启动参数: intel_iommu=on iommu=pt;\\n', '\\n', 'vim /boot/grub2/grub.cfg\\n', 'linux /vmlinuz-5.15.0+ root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M intel_iommu=on iommu=pt\\n', '2.重启Host OS;\\n', '\\n', '加载 vfio-pci 内核模块\\n', '\\n', '# modprobe vfio-pci\\n', '# lsmod | grep vfio_pci\\n', '成功加载 vfio-pci 模块，则回显如下：\\n', '\\n', 'vfio_pci              327680  0\\n', 'vfio_virqfd           327680  1 vfio_pci\\n', 'vfio                  327680  2 vfio_iommu_type1,vfio_pci\\n', '将 PCI 设备从主机解绑，重新绑定到 vfio-pci 驱动\\n', '\\n', '假设使用 VFIO 直通 Hi1822 网卡设备，首先查看网卡设备对应的 PCI 设备信息：\\n', '\\n', '# lspci -v | grep \"Eth\" | grep 1822\\n', '03:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '04:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '05:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '06:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '选择其中 bus 号 03，slot 号 00，function 号 0 的设备，即上述的 03:00.0。然后将该 PCI 设备从主机上解绑\\n', '\\n', '# echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind\\n', '最后将该 PCI 设备重新绑定到 vfio-pci 驱动。\\n', '\\n', 'lspci -ns 0000:03:00.0 |awk -F\\':| \\' \\'{print 5\" \"6}\\' > /sys/bus/pci/drivers/vfio-pci/new_id\\n', '将网卡绑定到 vfio-pci 驱动后，在主机上无法查询到对应网卡信息，只能查询到对应的 PCI 设备信息。\\n', '\\n', 'VFIO 设备直通\\n', '简介\\n', 'VFIO(Virtual Function I/O) 是内核提供的一种用户态设备驱动方案。VFIO 驱动可以安全地把设备 I/O，中断，DMA 等能力呈现给用户空间。StratoVirt 虚拟化平台使用 VFIO 设备直通方案后，在虚拟机可以极大限度地提升 I/O 性能。\\n', '\\n', '使用 VFIO 直通\\n', 'StratoVirt 支持 libvirt 管理，可以使用 XML 文件配置虚拟机。以下内容介绍通过修改虚拟机 XML 文件的方式，使用 VFIO 设备直通功能。\\n', '\\n', '一、修改 XML 文件\\n', '\\n', '在主机上执行如下命令，查询 CPU 架构信息\\n', '\\n', '# uname -m\\n', 'aarch64 和 x86_64 架构分别下载 StratoVirt 自带的 XML 文件 stratovirt_aarch64.xml 或 stratovirtvirt_x86.xml，并存放到任一目录，例如 /home：\\n', '\\n', '# cp stratovirt/docs/stratovirt_$arch.xml /home\\n', '根据实际需求，修改XML文件中的VFIO配置。 bus，slot，function 为上述绑定到 vfio-pci 驱动的 PCI 设备。相关配置如下：\\n', '\\n', '<!-- vfio -->\\n', \"<hostdev mode='subsystem' type='pci' managed='yes'>\\n\", \"<driver name='vfio'/>\\n\", '<source>\\n', \"    <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>\\n\", '</source>\\n', '</hostdev>\\n', \"上例中，设备类型为 PCI 设备，managed='yes' 表示 libvirt 将把 PCI 设备从主机解绑，并重新绑定到 vfio-pci 驱动。source 项配置了需要作为 VFIO 直通设备的 domain，bus，slot，function 信息。\\n\", '\\n', '二、使用 libvirt 命令行创建并登陆虚拟机\\n', '\\n', '# virsh create stratovirt_$arch.xml\\n', '# virsh list --all\\n', 'Id \\tName \\t\\tState\\n', '--------------------\\n', '1 \\tStratoVirt \\trunning\\n', '# virsh console 1\\n', '三、在虚拟机内查看并使用 VFIO 直通网卡。\\n', '\\n', '配置前查看网卡信息\\n', '\\n', '# ip a\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '\\tlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '\\tinet 127.0.0.1/8 scope host lo\\n', '     valid_lft forever preferred_lft forever\\n', '2: enp1s0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\\n', '\\tlink/ether 72:b8:51:9d:d1:27 brd ff:ff:ff:ff:ff:ff\\n', '动态配置网卡的 IP 地址\\n', '\\n', '# dhclient\\n', '查询 IP 是否配置成功\\n', '\\n', '# ip a\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '\\tlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '\\tinet 127.0.0.1/8 scope host lo\\n', '     valid_lft forever preferred_lft forever\\n', '2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n', '\\tlink/ether 72:b8:51:9d:d1:27 brd ff:ff:ff:ff:ff:ff\\n', '\\tinet 192.168.1.3/16 brd 192.168.255.255 scope global dynamic enp1s0\\n', '     valid_lft 86453sec preferred_lft 86453sec\\n', '如上回显可知，成功分配了 IP 地址 192.168.1.3，虚拟机可以直接使用配置的网卡\\n', '\\n', '说明：使用的直通网卡如果没有连接物理网络，将获取不到网络信息。\\n', '\\n', '解绑 VFIO 驱动\\n', '如果需要将直通给虚拟机使用的网卡解除绑定，可以登录主机，执行如下命令，将网卡设备重新绑定到主机上。其中，hinic是对应网卡设备驱动的类型：\\n', '\\n', '# echo 0000:03:00.0 > /sys/bus/pci/drivers/vfio-pci/unbind\\n', '# echo 0000:03:00.0 > /sys/bus/pci/drivers/hinic/bind\\n', '说明：绑定 VFIO 驱动前，可以再主机上执行 ethtool -i enp0 命令，获取网卡设备驱动类型。enp0 为对应网卡名称。\\n', '\\n', 'SR-IOV 直通\\n', '简介\\n', '使用 VFIO 设备直通时，虚拟机能直接访问硬件，但每个设备只能被一个虚拟机独占。SR-IOV 直通技术支持将一个 PF(Physical Function) 虚拟出多个 VF (Virtual Function)，并直通给不同虚拟机，解决了设备直通的独占问题，增加可用的设备。\\n', '\\n', '操作步骤\\n', '创建多个 VF：\\n', '\\n', 'sriov_numvfs 文件用于描述 SR-IOV 提供的 VF 个数，存放在 /sys/bus/pci/devices/domain:bus:slot.function/ 路径下，例如上述例子中的 bus 号 03，slot 号 00，function 号 0 的设备，可以使用如下命令创建4个 VF：\\n', '\\n', '# echo 4 > /sys/bus/pci/devices/0000\\\\:03\\\\:00.0/sriov_numvfs\\n', '确认 VF 设备创建成功\\n', '\\n', '# lspci -v | grep \"Eth\" | grep 1822\\n', '回显如下，说明成功创建了4个 VF 03:00.1、03:00.2、03:00.3、03:00.4：\\n', '\\n', '03:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '03:00.1 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.2 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.3 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.4 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '上述创建的 VF 设备均可以直通给虚拟机，使用 SR-IOV 设备的方法与普通 PCI 设备的直通方法相同。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_StratoVirt介绍.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/StratoVirt%E4%BB%8B%E7%BB%8D.html", "text_entry": "['StratoVirt介绍\\n', '概述\\n', 'StratoVirt是计算产业中面向云数据中心的企业级虚拟化平台，实现了一套架构统一支持虚拟机、容器、Serverless三种场景。StratoVirt在轻量低噪、软硬协同、Rust语言级安全等方面具备核心竞争力，在架构设计上预留了组件化拼装的能力和接口，可以按需灵活组装高级特性直至演化到支持标准虚拟化，在特性需求、应用场景和轻快灵巧之间达到平衡。\\n', '\\n', '架构说明\\n', 'StratoVirt核心架构自顶向下分为三层：\\n', '\\n', '外部接口：兼容QMP（QEMU Monitor Protocol）协议，具有完备的OCI兼容能力，同时支持对接libvirt。\\n', 'BootLoader：轻量化场景下抛弃传统BIOS+GRUB的启动模式实现快速启动，同时标准虚拟化场景下支持UEFI启动。\\n', '模拟主板：\\n', 'microvm: 充分利用软硬协同能力，精简化设备模型，低时延资源伸缩能力。\\n', '标准机型：提供ACPI表实现UEFI启动，支持添加virtio-pci以及VFIO直通设备等，极大提高虚拟机的I/O性能。\\n', '整体架构视图如图1所示。\\n', '\\n', '图1 StratoVirt整体架构图\\n', '\\n', '\\n', '\\n', '特性\\n', '基于硬件的高隔离能力；\\n', '快速冷启动：得益于极简设计，StratoVirt可以在50ms内启动microvm机型；\\n', '低内存开销： StratoVirt的内存占用小于4MB ；\\n', 'IO增强： StratoVirt提供普通IO能力与极简IO设备仿真；\\n', 'OCI兼容性：StratoVirt与isula和kata容器配合使用，可以完美融入Kubernetes生态系统；\\n', '多平台支持：全面支持Intel和ARM平台；\\n', '可扩展性：StratoVirt保留接口和设计，用于导入更多特性，甚至扩展到标准虚拟化支持；\\n', '安全性：运行时系统调用数小于46；\\n', '实现\\n', '运行架构\\n', 'StratoVirt虚拟机是Linux中一个独立的进程。进程有三种线程：主线程、VCPU线程、I/O线程：\\n', '主线程是异步收集和处理来自外部模块（如VCPU线程）的事件的循环；\\n', '每个VCPU都有一个线程处理本VCPU的trap事件；\\n', '可以为I/O设备配置iothread提升I/O性能；\\n', '约束\\n', '仅支持Linux操作系统，推荐内核版本为4.19, 5.10；\\n', '虚拟机操作系统仅支持Linux，内核版本建议为4.19, 5.10；\\n', '最大支持254个CPU；\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_准备使用环境.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%87%86%E5%A4%87%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83.html", "text_entry": "['准备环境\\n', '使用说明\\n', 'StratoVirt仅支持运行于x86_64和AArch64处理器架构下并启动相同架构的Linux虚拟机。\\n', '建议在 openEuler 22.03 LTS 版本编译、调测和部署该版本 StratoVirt。\\n', 'StratoVirt支持以非root权限运行。\\n', '环境要求\\n', '运行StratoVirt需要具备如下环境：\\n', '\\n', '/dev/vhost-vsock设备（用于实现mmio）\\n', 'nmap工具\\n', 'Kernel镜像和rootfs镜像\\n', '准备设备和工具\\n', 'StratoVirt运行需要实现mmio设备，所以运行之前确保存在设备/dev/vhost-vsock\\n', '\\n', '查看该设备是否存在：\\n', '\\n', '$ ls /dev/vhost-vsock\\n', '/dev/vhost-vsock\\n', '若该设备不存在，请执行如下命令生成/dev/vhost-vsock设备。\\n', '\\n', '$ modprobe vhost_vsock\\n', '为了能够使用QMP命令，需要安装nmap工具，在配置yum源的前提下，可执行如下命令安装nmap。\\n', '\\n', '# yum install nmap\\n', '准备镜像\\n', '制作kernel镜像\\n', '当前版本的StratoVirt仅支持x86_64和AArch64平台的PE格式内核镜像。此格式内核映像可通过以下方法生成。\\n', '\\n', '获取openEuler的kernel源代码，参考命令如下：\\n', '\\n', '$ git clone https://gitee.com/openeuler/kernel.git\\n', '$ cd kernel\\n', '查看并切换kernel的版本到openEuler-22.03-LTS，参考命令如下：\\n', '\\n', '$ git checkout openEuler-22.03-LTS\\n', '配置并编译Linux kernel。目前有两种方式可以生成配置文件：1. 使用推荐配置（获取配置文件），将指定版本的推荐文件复制到kernel路径下并重命名为.config， 并执行命令make olddefconfig更新到最新的默认配置（否则后续编译可能有选项需要手动选择）。2. 通过以下命令进行交互，根据提示完成kernel配置，可能会提示缺少指定依赖，按照提示使用yum install命令进行安装。\\n', '\\n', '$ make menuconfig\\n', '使用下面的命令制作并转换kernel镜像为PE格式，转化后的镜像为vmlinux.bin。\\n', '\\n', '$ make -j vmlinux && objcopy -O binary vmlinux vmlinux.bin\\n', '如果想在x86平台使用bzImzge格式的kernel，可以使用如下命令进行编译。\\n', '\\n', '$ make -j bzImage\\n', '\\u200b\\n', '\\n', '制作rootfs镜像\\n', 'rootfs镜像是一种文件系统镜像，在StratoVirt启动时可以装载带有init的ext4格式的镜像。下面是制作ext4 rootfs镜像的简单方法。\\n', '\\n', '准备一个大小合适的文件（例如在/home中创建10GiB空间大小的文件）。\\n', '\\n', '$ cd /home\\n', '$ dd if=/dev/zero of=./rootfs.ext4 bs=1G count=10\\n', '在此文件上创建空的ext4文件系统。\\n', '\\n', '$ mkfs.ext4 ./rootfs.ext4\\n', '挂载文件镜像。创建/mnt/rootfs，使用root权限，将rootfs.ext4挂载到/mnt/rootfs目录。\\n', '\\n', '$ mkdir /mnt/rootfs\\n', '# 返回刚刚创建文件系统的目录（如/home）\\n', '$ cd /home\\n', '$ sudo mount ./rootfs.ext4 /mnt/rootfs && cd /mnt/rootfs\\n', '获取对应处理器架构的最新alpine-mini rootfs。\\n', '\\n', '对于AArch64处理器架构，从alpine网站获取最新alpine-mini rootfs，例如：alpine-minirootfs-3.16.0-aarch64.tar.gz ，参考命令如下：\\n', '$ wget http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/aarch64/alpine-minirootfs-3.16.0-aarch64.tar.gz\\n', '$ tar -zxvf alpine-minirootfs-3.16.0-aarch64.tar.gz\\n', '$ rm alpine-minirootfs-3.16.0-aarch64.tar.gz\\n', '对于x86_64处理器架构，从alpine网站获取指定架构最新alpine-mini rootfs，例如：alpine-minirootfs-3.16.0-x86_64.tar.gz，参考命令如下：\\n', '$ wget http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/x86_64/alpine-minirootfs-3.16.0-x86_64.tar.gz\\n', '$ tar -zxvf alpine-minirootfs-3.16.0-x86_64.tar.gz\\n', '$ rm alpine-minirootfs-3.16.0-x86_64.tar.gz\\n', '为ext4文件镜像制作一个简单的/sbin/init，参考命令如下：\\n', '\\n', '$ rm sbin/init; touch sbin/init && cat > sbin/init <<EOF\\n', '#! /bin/sh\\n', 'mount -t devtmpfs dev /dev\\n', 'mount -t proc proc /proc\\n', 'mount -t sysfs sysfs /sys\\n', 'ip link set up dev lo\\n', '\\n', 'exec /sbin/getty -n -l /bin/sh 115200 /dev/ttyS0\\n', 'poweroff -f\\n', 'EOF\\n', '\\n', 'sudo chmod +x sbin/init\\n', '卸载rootfs镜像。\\n', '\\n', '$ cd /home; umount /mnt/rootfs\\n', '至此， rootfs制作成功，已可使用ext4 rootfs镜像文件rootfs.ext4，该文件在/home目录下。\\n', '\\n', '获取标准启动所需固件\\n', '固件 (firmware) 是指设备内部保存的设备驱动程序。操作系统只有通过固件才能按照标准启动的方式进行启动。 StratoVirt 当前只支持在 x86_64 和 aarch64 架构下按照 UEFI (Unified Extensible Firmware Interface) 接口进行标准启动。\\n', '\\n', 'EDK II 是实现了 UEFI 标准的开源软件，StratoVirt 使用 EDK II 作为标准启动的固件。因此需要获取EDK II的固件文件。可以通过 yum 命令来进行 EDK II 固件文件的安装，具体命令如下。\\n', '\\n', 'x86_64 架构上运行以下命令：\\n', '\\n', '$ sudo yum install -y edk2-ovmf\\n', 'aarch64 架构上运行以下命令：\\n', '\\n', '$ sudo yum install -y edk2-aarch64\\n', 'EDK II 的固件包括两个文件：一个文件用于保存可执行代码，另一个文件用于保存启动配置信息。安装成功之后，在 x86_64 架构上，固件文件 OVMF_CODE.fd 与固件配置文件 OVMF_VARS.fd 会保存在 /usr/share/edk2/ovmf 路径下；在 aarch64 架构上, 固件文件 QEMU_EFI-pflash.raw 和固件配置文件 vars-template-pflash.raw 则是保存在 /usr/share/edk2/aarch64 路径下。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_安装StratoVirt.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%AE%89%E8%A3%85StratoVirt.html", "text_entry": "['安装StratoVirt\\n', '软硬件要求\\n', '最低硬件要求\\n', '处理器架构：仅支持AArch64和x86_64处理器架构。AArch64需要ARMv8及更高版本且支持虚拟化扩展；x86_64支持VT-x。\\n', '\\n', '2核CPU\\n', '\\n', '4GiB内存\\n', '\\n', '16GiB可用磁盘空间\\n', '\\n', '软件要求\\n', '操作系统：openEuler 22.03 LTS\\n', '\\n', '安装组件\\n', '使用StratoVirt虚拟化，需要安装StratoVirt。安装前，请确保已经配置了openEuler yum源。\\n', '\\n', '使用root权限，安装StratoVirt组件，参考命令如下。\\n', '\\n', '# yum install stratovirt\\n', '查看是否安装成功。\\n', '\\n', '$ stratovirt -version\\n', 'StratoVirt 2.1.0\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_对接 libvirt.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%AF%B9%E6%8E%A5libvirt.html", "text_entry": "['对接 libvirt\\n', '[[toc]]\\n', '\\n', '概述\\n', 'libvirt 是一个管理 hypervisor 的上层软件，它通过不同的驱动统一管理不同类型的 hypervisor ，并对外提供统一、稳定的应用程序接口。\\n', '\\n', '在云场景中，业内广泛使用 libvirt 管理大规模的虚拟机。为了方便地对大规模的 StratoVirt 虚拟机进行部署、编排和管理，StratoVirt 标准虚拟化支持对接 libvirt，打通了 libvirt 北向接口。用户可以通过 libvirt 对应的 XML 文件描述一个虚拟机，包括虚拟机名称、CPU、磁盘等。\\n', '\\n', '本章介绍 StratoVirt 平台支持的 XML 配置，以及如何使用 virsh 命令管理虚拟机。\\n', '\\n', '前提条件\\n', 'StratoVirt 对接 libvirt，主机需要满足如下条件：\\n', '\\n', '已正确配置 yum 源\\n', '已正确安装并启动 libvirt\\n', '已正确安装 StratoVirt\\n', '虚拟机配置\\n', 'libvirt 工具采用 XML 格式的文件描述一个虚拟机特征，包括虚拟机名称、CPU、内存、磁盘、网卡等信息。用户可以通过修改配置文件，对虚拟机进行管理。\\n', '\\n', 'StratoVirt 对接 libvirt 之前，需要先配置 XML 文件。本小节介绍 StratoVirt 对接 libvirt 时支持的 XML 配置项以及配置方式。\\n', '\\n', '说明\\n', '\\n', '使用 libvirt 管理 StratoVirt 虚拟机前，应该注意到 StratoVirt 当前支持的特性、特性之间的互斥关系、特性的配置前提条件、规格等，详细信息请参见命令行方式的 “虚拟机配置”章节。\\n', '\\n', '虚拟机描述\\n', '虚拟机 XML 文件必须包含描述虚拟机的最基本元素： domain 和 name 。\\n', '\\n', '元素介绍\\n', 'domain ： 虚拟机配置的根元素，用于配置运行 StratoVirt 虚拟机的 hypervisor 类型。\\n', '\\n', '属性 type ：domain 的类型，在 StratoVirt 虚拟化中，该值为 kvm 。\\n', '\\n', 'name ：虚拟机名称。\\n', '\\n', '虚拟机名称是一个长度不超过 255 字符的字符串。同一个主机上的虚拟机名称不能重复，虚拟机名称必须由数字、字母、“_”、“－”、“:” 组成。\\n', '\\n', '配置示例\\n', '假设配置虚拟机名称为 StratoVirt ，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>StratoVirt</name>\\n', '    ... \\n', '</domain>\\n', '虚拟CPU和内存\\n', '本节介绍虚拟 CPU 和虚拟内存的配置。\\n', '\\n', '元素介绍\\n', 'vcpu：虚拟处理器的个数。\\n', '\\n', 'memory：虚拟内存大小。\\n', '\\n', '属性 unit ：指定内存单位，属性值支持 KiB（210 字节）、MiB（220 字节）、GiB（230 字节）、TiB（240 字节）等。\\n', '\\n', '说明\\n', '\\n', 'StratoVirt 暂不支持 CPU 拓扑结构，请勿配置该项。\\n', '\\n', '配置示例\\n', '配置 8GiB 内存，4 个虚拟处理器的示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ... \\n', '    <vcpu>4</vcpu>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    ... \\n', '</domain>\\n', '虚拟机设备\\n', '本节介绍如何使用 XML 文件配置虚拟机设备：磁盘，网卡，rng，balloon，console，vsock 设备。\\n', '\\n', '磁盘\\n', '元素介绍\\n', '属性 type ：指定后端存储介质类型，在 StratoVirt 虚拟化中，该值为 file 。\\n', '\\n', '属性 device：呈现给虚拟机的存储介质类型，在 StratoVirt 虚拟化中，该值为 disk 。\\n', '\\n', 'driver：指定后端驱动的详细信息。\\n', '\\n', '属性 type ：磁盘的格式类型，在 StratoVirt 虚拟化中，该值为 raw 。StratoVirt 当前只支持 raw 格式的磁盘。\\n', '\\n', '属性 iothread：为磁盘配置 iothread ，取值为 iothread 编号。在配置磁盘的 iothread 之前，需使用 iothread 元素配置 iothread 的个数。\\n', '\\n', 'source： 指定后端存储介质。\\n', '\\n', '属性 file：指定磁盘路径。\\n', '\\n', 'target：指定后端驱动的详细信息。\\n', '\\n', '属性 dev：指定磁盘名称。\\n', '\\n', '属性 bus：指定磁盘设备的类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'iotune： 指定磁盘 IO 特性。\\n', '\\n', '属性 total_iops_sec：设置磁盘 iops 的值。\\n', '\\n', 'address：用于设置设备所要挂载的总线属性。\\n', '\\n', '属性 type：总线类型，在 StratoVirt 虚拟化中，该值为 pci 。\\n', '\\n', '属性 domain：虚拟机的域。\\n', '\\n', '属性 bus：设备将要挂载的 bus 号。\\n', '\\n', '属性 slot：设备将要挂载的 slot 号，取值范围为：[0, 31] 。\\n', '\\n', '属性 function：设备将要挂载的 function 号，取值范围为：[0, 7] 。\\n', '\\n', '配置示例\\n', '配置磁盘路径为：/home/openEuler-21.09-stratovirt.img，配置 1 个 iothread，并且磁盘 iothread 配置为 iothread1 ，iops 为 10000，并将其挂载在 bus 为 1、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <iothreads>1</iothreads>\\n', '    <devices>\\n', \"        <disk type='file' device='disk'>\\n\", '\\t    <driver name=\\'qemu\\' type=\\'raw\\' iothread=\"1\"/>\\n', \"\\t    <source file='/home/openEuler-21.09-stratovirt.img'/>\\n\", \"\\t    <target dev='hda' bus='virtio'/>\\n\", '        <iotune>\\n', '        \\t<total_iops_sec>10000</total_iops_sec>    \\n', '        </iotune>\\n', \"\\t    <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x00' />\\n\", '\\t</disk>\\n', '    ...\\n', '    </devices>\\n', '</domain>\\n', '网络设备\\n', '元素介绍\\n', 'interface：网络接口\\n', '\\n', '属性 type：指定网络设备类型。\\n', '\\n', 'mac：虚拟网卡地址\\n', '\\n', '属性 address：虚拟网卡地址。\\n', '\\n', 'source： 指定后端网桥\\n', '\\n', '属性 bridge：指定网桥。\\n', '\\n', 'target：指定后端网卡\\n', '\\n', '属性 dev：指定后端的 tap 设备。\\n', '\\n', 'model： 虚拟网卡类型\\n', '\\n', '属性 type： 虚拟网卡类型，在 StratoVirt 虚拟化中，该值为 virtio。\\n', '\\n', 'driver：用来指定是否开启 vhost 。\\n', '\\n', '属性 name：如果设置 name 为 qemu 则使用 virtio-net 设备，如果不配置 driver 或者 name 值为 vhost ，则使用 vhost-net 设备。\\n', '\\n', '配置示例\\n', '配置网络前请参考 配置linux网桥，配置好 Linux 网桥。配置 mac 地址为：de:ad:be:ef:00:01，网桥为配置好的 br0 ，使用 virtio-net 设备，并将其挂载在 bus 为 2、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <interface type='bridge'>\\n\", \"            <mac address='de:ad:be:ef:00:01' />\\n\", \"            <source bridge='br0'/> \\n\", \"            <model type='virtio'/>\\n\", \"            <driver name='qemu'/>\\n\", \"            <address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x00' />\\n\", '        </interface>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'balloon 设备\\n', '元素介绍\\n', 'memballoon：balloon 设备类型\\n', '\\n', '属性 model ：指定 balloon 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'alias：balloon 设备的别名\\n', '\\n', '属性 name ：balloon 设备的 id 。\\n', '\\n', '属性 autodeflate ：设置 auto deflate（自动收缩）特性，可选值为：on 、off 。\\n', '\\n', '配置示例\\n', '配置 balloon 设备，开启 autodeflate 特性，并将其挂载在 bus 为 3、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <memballoon model='virtio'>\\n\", \"            <alias name='balloon0' autodeflate='on'/>\\n\", '            \\n', \"            <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x00' />\\n\", '        </memballoon>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'console 设备\\n', '由于 console 设备挂载在 virtio-serial 下的总线上，所以在创建 console 设备时，需要创建 virtio-serial 设备。\\n', '\\n', '说明\\n', '\\n', 'StratoVirt 的 console 设备暂时不支持多端口特性，每个虚拟机只能配置一个 console 设备。\\n', '\\n', '元素介绍\\n', 'controller：控制器\\n', '\\n', '属性 type：控制器类型，此处值为 virtio-serial 。\\n', '\\n', 'alias：别名\\n', '\\n', '属性 name：设备的 id。\\n', '\\n', 'console：console 设备\\n', '\\n', '属性 type：指定 console 设备的重定向方式。支持的重定向方式有：pty ， file 和 unix 。\\n', '\\n', 'target：配置 console 设备。\\n', '\\n', '属性 type：指定 console 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', '配置示例\\n', '配置重定向方式为 pty ，并将其挂载在 bus 为 4、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <controller type='virtio-serial'>\\n\", \"            <alias name='virt-serial0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x04' slot='0x00' function='0x00'/>\\n\", '        </controller>\\n', \"        <console type='pty'>\\n\", \"            <target type='virtio'/>\\n\", \"            <alias name='console0'/>\\n\", '        </console>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'rng 设备\\n', '元素介绍\\n', 'rng：rng 设备\\n', '\\n', '属性 model：指定 rng 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'rate：rng 设备产生随机数速率\\n', '\\n', '属性 period ：用于设置随机数产生周期，单位为毫秒，当前 StratoVirt 不支持设置周期值，默认值为1000毫秒，请将该值设置为1000。\\n', '\\n', '属性 bytes ：周期内产生的最大字节数。\\n', '\\n', 'backend：设置 rng 设备后端，值为 host 中 rng 设备的路径\\n', '\\n', '属性 model：用于指定后端设备类型，在 StratoVirt 虚拟化中，该值为 random 。\\n', '\\n', '配置示例\\n', '配置周期为 1000ms 内最多产生 1234 字节，rng 设备在 host 中路径为 /dev/random ，并将其挂载在 bus 为 5、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <rng model='virtio'>\\n\", \"            <rate period='1000' bytes='1234'/>\\n\", \"            <backend model='random'>/dev/random`</backend>\\n\", \"            <address type='pci' domain='0x000' bus='0x05' slot='0x00' function='0x00'/>\\n\", '        </rng>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'vsock 设备\\n', '元素介绍\\n', 'vsock：vsock 设备\\n', '\\n', '属性 model：指定 vsock 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'cid ：设置 vsock 设备的 cid\\n', '\\n', '属性 address：用于设置 cid 的值\\n', '\\n', '配置示例\\n', '配置 cid 为 8，并将其挂载在 bus 为 6、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <vsock model='virtio'>\\n\", \"            <cid auto='no' address='8'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x06' slot='0x00' function='0x00'/>\\n\", '        </vsock>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', '体系架构相关配置\\n', 'XML 中还有一些体系架构相关的配置，如 pflash、主板等。\\n', '\\n', '元素介绍\\n', 'os：定义虚拟机启动参数\\n', '\\n', '子元素 type ：指定虚拟机类型，属性 arch 表示架构，属性 machine 表示主板类型，在 StratoVirt 虚拟化中，AArch64 架构只支持 virt 主板，x86_64 架构只支持 Q35 主板。\\n', '\\n', '子元素 kernel ：用于指定 kernel 路径。\\n', '\\n', '子元素 cmdline ：指定命令行启动参数。\\n', '\\n', '子元素 loader ：指定加载固件，属性 readonly 表示是否只读；属性 type 表示类型，在 StratoVirt 虚拟化中，该值为 pflash 。\\n', '\\n', 'features：hypervisor 支持的以下特性\\n', '\\n', '子元素 acpi ：是否支持 ACPI，在 StratoVirt 虚拟化中使用了 ACPI 特性，所以该特性必须配置。\\n', '\\n', '子元素 gic ：ARM 处理器指定中断处理器，属性 version 表示 GIC 的版本，在 StratoVirt 虚拟化中，该值为 3 。\\n', '\\n', '配置示例\\n', '配置虚拟机 CPU 架构 ARM，主板为 virt ，启动命令行为：console=ttyAMA0 root=/dev/vda reboot=k panic=1 rw 。pflash 路径为：/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw，属性为只读。 kernel 路径为：/home/std-vmlinuxz。示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <os>\\n', \"        <type arch='aarch64' machine='virt'>hvm</type>\\n\", '        <kernel>/home/std-vmlinuxz</kernel>\\n', '        <cmdline>console=ttyAMA0 root=/dev/vda reboot=k panic=1 rw</cmdline>\\n', \"        <loader readonly='yes' type='pflash'>`/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw`</loader>\\n\", '    </os>\\n', '    ...\\n', '</domain>\\n', '内存大页\\n', '元素介绍\\n', 'memoryBacking：表示配置内存相关的信息\\n', '\\n', 'hugepages ：配置内存大页\\n', '\\n', 'page ：大页配置\\n', '\\n', '属性 size ：内存大页的大小\\n', '\\n', '属性 unit ：大页大小的单位\\n', '\\n', '配置示例\\n', '配置 2MiB 大页示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <memoryBacking>\\n', '    <hugepages>\\n', \"        <page size='2' unit='MiB' />\\n\", '    </hugepages>\\n', '    </memoryBacking>\\n', '    ...\\n', '</domain>\\n', '配置示例\\n', 'x86 配置示例\\n', '配置一台名为 StratoVirt ，内存 8GiB ，配置 1GiB 单位的内存大页，4 个虚拟 CPU，架构为 x86_64 ，主板类型为 Q35 ，对应 XML 文件的配置示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>StratoVirt</name>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    <!-- hugepages -->\\n', '    <memoryBacking>\\n', '    <hugepages>\\n', \"        <page size='1' unit='GiB' />\\n\", '    </hugepages>\\n', '    </memoryBacking>\\n', '    <vcpu>4</vcpu>\\n', '    <!-- iothread -->\\n', '    <iothreads>1</iothreads>\\n', '    <os>\\n', \"    <type arch='x86_64' machine='q35'>hvm</type>\\n\", '    <kernel>/path/to/standard_vm_kernel</kernel>\\n', '    <cmdline>console=hvc0 root=/dev/vda reboot=k panic=1 rw</cmdline>\\n', \"    <loader readonly='yes' type='pflash'>/path/to/pflash</loader>\\n\", '    <nvram>/path/to/OVMF_VARS</nvram>\\n', '    </os>\\n', '    <features>\\n', '        <acpi/>\\n', '    </features>\\n', '    <devices>\\n', '        <emulator>/path/to/StratoVirt_binary_file</emulator>\\n', \"        <controller type='pci' index='0' model='pcie-root' />\\n\", '        <!-- pcie-root-port -->\\n', \"        <controller type='pci' index='1' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='2' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='3' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='4' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='5' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='6' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='7' model='pcie-root-port' />\\n\", '        <!-- block -->\\n', \"        <disk type='file' device='disk'>\\n\", \"            <driver name='qemu'  type='raw' iothread='1'/>\\n\", \"            <source file='/path/to/rootfs'/>\\n\", \"            <target dev='hda' bus='virtio'/>\\n\", '            <iotune>\\n', '                <total_iops_sec>1000</total_iops_sec>\\n', '            </iotune>\\n', \"            <address type='pci' domain='0x000' bus='0x01' slot='0x00' function='0x00'/>\\n\", '        </disk>\\n', '        <!-- net -->\\n', \"        <interface type='bridge'>\\n\", \"            <mac address='de:ad:be:ef:00:01'/>\\n\", \"            <source bridge='qbr0'/>\\n\", \"            <model type='virtio'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x02' slot='0x00' function='0x00'/>\\n\", '        </interface>\\n', '        <!-- virtio-serial -->\\n', \"        <controller type='virtio-serial' index='0'>\\n\", \"            <alias name='virt-serial0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x03' slot='0x00' function='0x00'/>\\n\", '        </controller>\\n', \"        <console type='pty'>\\n\", \"            <target type='virtio' port='0'/>\\n\", \"            <alias name='console0'/>\\n\", '        </console>\\n', '        <!-- balloon -->\\n', \"        <memballoon model='virtio'>\\n\", \"            <alias name='balloon0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x04' slot='0x00' function='0x00'/>\\n\", '        </memballoon>\\n', '        <!-- rng -->\\n', \"        <rng model='virtio'>\\n\", \"            <rate period='1000' bytes='1234'/>\\n\", \"            <backend model='random'>/path/to/random_file</backend>\\n\", \"            <address type='pci' domain='0x000' bus='0x05' slot='0x00' function='0x00'/>\\n\", '        </rng>\\n', '        <!-- vsock -->\\n', \"        <vsock model='virtio'>\\n\", \"            <cid auto='no' address='3'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x06' slot='0x00' function='0x00'/>\\n\", '        </vsock>\\n', '    </devices>\\n', '</domain>\\n', 'ARM 配置示例\\n', '如果想要配置一台名为 StratoVirt ，内存 8GiB，配置 1GiB 单位大页，4 个虚拟 CPU，架构为 aarch64 ，主板类型为 virt ，对应 XML 文件的配置示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>StratoVirt</name>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    <!-- hugepages -->\\n', '    <memoryBacking>\\n', '    <hugepages>\\n', \"        <page size='1' unit='GiB' />\\n\", '    </hugepages>\\n', '    </memoryBacking>\\n', '    <vcpu>4</vcpu>\\n', '    <!-- iothread -->\\n', '    <iothreads>1</iothreads>\\n', '    <os>\\n', \"    <type arch='aarch64' machine='virt'>hvm</type>\\n\", '    <kernel>/path/to/standard_vm_kernel</kernel>\\n', '    <cmdline>console=ttyAMA0 root=/dev/vda reboot=k panic=1 rw</cmdline>\\n', \"    <loader readonly='yes' type='pflash'>/path/to/pflash</loader>\\n\", '    </os>\\n', '    <features>\\n', '        <acpi/>\\n', \"        <gic version='3'/>\\n\", '    </features>\\n', '    <devices>\\n', '        <emulator>/path/to/StratoVirt_binary_file</emulator>\\n', \"        <controller type='pci' index='0' model='pcie-root'/>\\n\", '        <!-- block -->\\n', \"        <disk type='file' device='disk'>\\n\", \"            <driver name='qemu'  type='raw' iothread='1'/>\\n\", \"            <source file='/path/to/rootfs'/>\\n\", \"            <target dev='hda' bus='virtio'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x01' function='0x00'/>\\n\", '            <iotune>\\n', '                <total_iops_sec>1000</total_iops_sec>\\n', '            </iotune>\\n', '        </disk>\\n', '        <!-- net -->\\n', \"        <interface type='bridge'>\\n\", \"            <mac address='de:ad:be:ef:00:01'/>\\n\", \"            <source bridge='qbr0'/>\\n\", \"            <model type='virtio'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x02' function='0x00'/>\\n\", '        </interface>\\n', '        <!-- virtio-serial -->\\n', \"        <controller type='virtio-serial' index='0'>\\n\", \"            <alias name='virt-serial0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x03' function='0x00'/>\\n\", '        </controller>\\n', \"        <console type='pty'>\\n\", \"            <target type='virtio' port='0'/>\\n\", \"            <alias name='console0'/>\\n\", '        </console>\\n', '        <!-- balloon -->\\n', \"        <memballoon model='virtio'>\\n\", \"            <alias name='balloon0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x04' function='0x00'/>\\n\", '        </memballoon>\\n', '        <!-- rng -->\\n', \"        <rng model='virtio'>\\n\", \"            <rate period='1000' bytes='1234'/>\\n\", \"            <backend model='random'>/path/to/random_file</backend>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x05' function='0x00'/>\\n\", '        </rng>\\n', '        <!-- vsock -->\\n', \"        <vsock model='virtio'>\\n\", \"            <cid auto='no' address='3'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x06' function='0x00'/>\\n\", '        </vsock>\\n', '    </devices>\\n', '</domain>\\n', '管理虚拟机\\n', 'libvirt 使用 virsh 命令来管理虚拟机，当 StratoVirt 平台和 libvirt 对接时，仅支持以下与 StratoVirt 交互的命令：\\n', '\\n', 'create：创建虚拟机\\n', '\\n', 'suspend：挂起虚拟机\\n', '\\n', 'resume：恢复虚拟机\\n', '\\n', 'destroy：销毁虚拟机\\n', '\\n', 'console：通过 console 登录虚拟机\\n', '\\n', '说明\\n', '\\n', 'StratoVirt 暂不支持虚拟机重启、虚拟机关机等命令。\\n', '\\n', '管理虚拟机生命周期\\n', '假设用户已经按照需要完成一个名为 StratoVirt 的虚拟机配置文件 st.xml ，则对应生命周期管理的命令如下：\\n', '\\n', '创建虚拟机\\n', '\\n', 'virsh create st.xml\\n', '虚拟机创建完成后，可以通过 virsh list 命令查看，会存在一个名为 StratoVirt 的虚拟机。\\n', '\\n', '挂起虚拟机\\n', '\\n', 'virsh suspend StratoVirt\\n', '虚拟机挂起后，虚拟机暂停运行。可以通过 virsh list 命令查看，虚拟机 StratoVirt 的状态为 paused 。\\n', '\\n', '恢复虚拟机\\n', '\\n', 'virsh resume StratoVirt\\n', '虚拟机恢复后，可以通过 virsh list 命令查看，虚拟机 StratoVirt 的状态为 running 。\\n', '\\n', '销毁虚拟机\\n', '\\n', 'virsh destroy StratoVirt\\n', '虚拟机销毁后，使用 virsh list 查看虚拟机，发现虚拟机 StratoVirt 不存在。\\n', '\\n', '登录虚拟机\\n', '虚拟机创建完成后，可以通过 virsh console 登录虚拟机内部操作虚拟机。假设虚拟机名称为 StratoVirt，参考命令如下：\\n', '\\n', 'virsh console StratoVirt\\n', '说明\\n', '\\n', '为了可以正常使用 virsh console 命令，需要在 XML 中配置 console 设备的重定向类型为 pty 。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_对接iSula安全容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%AF%B9%E6%8E%A5iSula%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8.html", "text_entry": "['对接iSula安全容器\\n', '概述\\n', '为了给容器提供更好的隔离环境，提高系统安全性，可以使用 iSula 安全容器，即将 StratoVirt 对接 iSula 安全容器。\\n', '\\n', '对接iSula安全容器\\n', '前提条件\\n', '已安装 iSulad 和 kata-containers，并确保 iSulad 支持 containerd-kata-shim-v2 容器运行时和 devicemapper 存储驱动。\\n', '\\n', '此处给出安装 iSulad 和 kata-containers 并进行相应配置的参考方法。\\n', '\\n', '配置 yum 源，使用 root 权限安装 iSulad 和 kata-containers ：\\n', '\\n', '# yum install iSulad\\n', '# yum install kata-containers\\n', '制作并配置存储 Storage：\\n', '\\n', '需要用户规划好磁盘如/dev/sdxx,该磁盘会被格式化。\\n', '\\n', ' # pvcreate /dev/sdxx\\n', ' # vgcreate isulaVG0 /dev/sdxx\\n', ' # lvcreate --wipesignatures y -n thinpool isulaVG0 -l 95%VG\\n', ' # lvcreate --wipesignatures y -n thinpoolmeta isulaVG0 -l 1%VG\\n', ' # lvconvert -y --zero n -c 512K --thinpool isulaVG0/thinpool --poolmetadata isulaVG0/thinpoolmeta\\n', '在配置文件 /etc/lvm/profile/isulaVG0-thinpool.profile 中添加如下：\\n', '\\n', 'activation {\\n', '    thin_pool_autoextend_threshold=80\\n', '    thin_pool_autoextend_percent=20\\n', '}\\n', '更改配置文件/etc/isulad/daemon.json中的storage-driver 和 storage-opts 如下：将默认存储驱动类型 overlay 配置成 devicemapper 。\\n', '\\n', '\"storage-driver\": \"devicemapper\",\\n', '\"storage-opts\": [\\n', ' \"dm.thinpooldev=/dev/mapper/isulaVG0-thinpool\",\\n', ' \"dm.fs=ext4\",\\n', ' \"dm.min_free_space=10%\"\\n', '],\\n', '重启 isulad ：\\n', '\\n', ' # systemctl daemon-reload\\n', ' # systemctl restart isulad\\n', '确认 iSula 存储驱动是否配置成功：\\n', '\\n', ' # isula info\\n', '若回显有如下信息，说明配置成功。\\n', '\\n', 'Storage Driver: devicemapper\\n', '对接指导\\n', 'StratoVirt 通过对接 kata-containers来接入 isula 容器生态，此处给出对接 kata-containers 的操作指导。\\n', '\\n', '对接轻量虚拟机\\n', '修改 kata 配置文件（默认路径为 /usr/share/defaults/kata-containers/configuration.toml，也可以参考同一目录下的configration-stratovirt.toml进行配置） 。将安全容器的 hypervisor 类型修改为 stratovirt，kernel 修改为 kata-containers 的 kernel 镜像绝对路径，initrd 修改为 kata-containers 的 initrd 镜像文件（使用 yum 安装 kata-containers 时，默认会下载这两个镜像文件并存放在 /var/lib/kata/ 目录，配置时也可以使用其他镜像 ）。\\n', '\\n', '替换的配置内容参考如下：\\n', '\\n', '[hypervisor.stratovirt]\\n', 'path = \"/usr/bin/stratovirt\"\\n', 'kernel = \"/var/lib/kata/kernel\"\\n', 'initrd = \"/var/lib/kata/kata-containers-initrd.img\"\\n', 'machine_type = \"microvm\"\\n', 'block_device_driver = \"virtio-mmio\"\\n', 'use_vsock = true\\n', 'enable_netmon = true\\n', 'internetworking_model=\"tcfilter\"\\n', 'sandbox_cgroup_with_emulator = false\\n', 'disable_new_netns = false\\n', 'disable_block_device_use = false\\n', 'disable_vhost_net = true\\n', '使用 root 权限和 isula 命令运行 busybox 安全容器，完成 StratoVirt 和 安全容器的对接。\\n', '\\n', '# isula run -tid --runtime \"io.containerd.kata.v2\" --net=none --name test busybox:latest sh\\n', '使用 isula ps 确认安全容器 test 正常运行，然后通过以下命令进入 test 容器。\\n', '\\n', '# isula exec -ti test sh\\n', '通过虚拟机快照加速安全容器的启动速度，降低虚拟机内存开销。\\n', '\\n', '修改 kata 配置文件 configuration.toml，将配置项 enable_template 设置为 true，即允许虚拟机通过制作快照方式进行启动：\\n', '\\n', '[factory]\\n', '# VM templating support. Once enabled, new VMs are created from template\\n', '# using vm cloning. They will share the same initial kernel, initramfs and\\n', '# agent memory by mapping it readonly. It helps speeding up new container\\n', '# creation and saves a lot of memory if there are many kata containers running\\n', '# on the same host.\\n', '#\\n', '# When disabled, new VMs are created from scratch.\\n', '#\\n', '# Note: Requires \"initrd=\" to be set (\"image=\" is not supported).\\n', '#\\n', '# Default false\\n', 'enable_template = true\\n', '配置项 enable_template 设置为 true 后，kata-containers 创建安全容器时，将会检查默认路径（/run/vc/vm/template）下是否存在快照文件，如果存在，直接以该快照文件启动虚拟机，如果不存在，则会创建虚拟机快照，创建完成后，以该快照文件启动虚拟机。\\n', '\\n', '通过安全组件 ozone 进一步增强安全容器的隔离性。\\n', '\\n', '修改 kata 配置文件 configuration.toml，将配置项 ozone_path 设置为 ozone 可执行文件的路径（如果使用 yum 安装 stratovirt，ozone 可执行文件默认在 /usr/bin 目录下）。配置该项后，将打开 ozone 安全沙箱功能，作为虚拟化层隔离被攻击者突破后的保险，进一步增强 StratoVirt 安全容器的隔离性:\\n', '\\n', '# Path for the ozone specific to stratovirt\\n', '# If the ozone path is set, stratovirt will be launched in\\n', '# ozone secure environment. It is disabled by default.\\n', 'ozone_path = \"/usr/bin/ozone\"\\n', '至此，可以在 test 容器内运行容器命令。\\n', '\\n', '对接标准虚拟机\\n', '使用 StratoVirt 标准虚拟机作为安全容器的 sandbox，需要额外修改少量配置。具体步骤如下：\\n', '\\n', '配置参考如下：\\n', '\\n', '[hypervisor.stratovirt]\\n', 'path = \"/usr/bin/stratovirt\"\\n', 'kernel = \"/var/lib/kata/kernel\"\\n', 'initrd = \"/var/lib/kata/kata-containers-initrd.img\"\\n', '# x86_64 架构\\n', 'machine_type = \"q35\"\\n', '# aarch64 架构\\n', 'machine_type = \"virt\"\\n', 'block_device_driver = \"virtio-blk\"\\n', 'pcie_root_port = 2\\n', 'use_vsock = true\\n', 'enable_netmon = true\\n', 'internetworking_model = \"tcfilter\"\\n', 'sandbox_cgroup_with_emulator = false\\n', 'disable_new_netns = false\\n', 'disable_block_device_use = false\\n', 'disable_vhost_net = true\\n', '上述配置中，需要根据主机架构，修改对应的虚拟机机型。需要将 block_device_driver 驱动类型改为 virtio-blk。另外，StratoVirt 只支持将设备热插到root port，根据需要热插的设备数量，合理设置 pcie_root_port 值。\\n', '\\n', '安装启动标准虚拟机需要的固件\\n', '\\n', 'x86_64 架构：\\n', '\\n', '# yum install -y edk2-ovmf\\n', 'aarch64 架构：\\n', '\\n', '# yum install -y edk2-aarch64\\n', '编译替换为 kata-containers 2.x 版本二进制\\n', '\\n', '当前只为 kata-containers 2.x 版本（对应 kata-containers 源码仓的 openEuler-21.09 分支）适配了 StratoVirt 标准虚拟机作为 sandbox。因此，需要手动下载 kata-containers 源码，编译并替换 /usr/bin 目录下的 containerd-shim-kata-v2 二进制文件。\\n', '\\n', '# mkdir -p /root/go/src/github.com/\\n', '# cd /root/go/src/github.com/\\n', '# git clone https://gitee.com/src-openeuler/kata-containers.git\\n', '# cd kata-containers\\n', '# git checkout openEuler-21.09\\n', '# ./apply-patches\\n', '# cd src/runtime\\n', '# make\\n', '编译出的二进制位 containerd-shim-kata-v2，需要将默认 /usr/bin/ 目录的 kata 二进制备份后替换：\\n', '\\n', '# cp /usr/bin/containerd-shim-kata-v2 /usr/bin/containerd-shim-kata-v2.bk\\n', '# cp containerd-shim-kata-v2 /usr/bin/containerd-shim-kata-v2\\n', '使用 root 权限 和 isula 命令运行 busybox 安全容器，完成 StratoVirt 和 安全容器的对接。\\n', '\\n', '# isula run -tid --runtime \"io.containerd.kata.v2\" --net=none --name test busybox:latest sh\\n', '使用 isula ps 确认安全容器 test 正常运行，然后通过以下命令进入 test 容器。\\n', '\\n', '# isula exec -ti test sh\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_虚拟机管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86.html", "text_entry": "['管理虚拟机\\n', '概述\\n', 'StratoVirt可以查询虚拟机信息并对虚拟机的资源和生命周期进行管理。由于StratoVirt使用QMP管理虚拟机，所以查询虚拟机信息，也需要先连接到虚拟机。\\n', '\\n', '查询虚拟机信息\\n', '简介：\\n', 'StratoVirt可以查询虚拟机状态、vCPU拓扑信息、vCPU上线情况等。\\n', '\\n', '查询状态\\n', '使用query-status命令查询虚拟机的运行状态。\\n', '\\n', '用法：\\n', '\\n', '{ “execute”: “query-status” }\\n', '\\n', '示例：\\n', '\\n', '<- { \"execute\": \"query-status\" }\\n', '-> { \"return\": { \"running\": true,\"singlestep\": false,\"status\": \"running\" } \\n', '查询拓扑\\n', '使用query-cpus命令查询所有CPU的拓扑结构。\\n', '\\n', '用法：\\n', '{ “execute”: “query-cpus” }\\n', '\\n', '示例：\\n', '<- { \"execute\": \"query-cpus\" }\\n', '-> {\"return\":[{\"CPU\":0,\"arch\":\"x86\",\"current\":true,\"halted\":false,\"props\":{\"core-id\":0,\"socket-id\":0,\"thread-id\":0},\"qom_path\":\"/machine/unattached/device[0]\",\"thread_id\":8439},{\"CPU\":1,\"arch\":\"x86\",\"current\":true,\"halted\":false,\"props\":{\"core-id\":0,\"socket-id\":1,\"thread-id\":0},\"qom_path\":\"/machine/unattached/device[1]\",\"thread_id\":8440}]}\\n', '查询vCPU上线情况\\n', '使用query-hotpluggable-cpus命令查询所有vCPU的online/offline情况。\\n', '\\n', '用法：\\n', '{ “execute”: “query-hotpluggable-cpus” }\\n', '\\n', '示例：\\n', '<- { \"execute\": \"query-hotpluggable-cpus\" }\\n', '-> {\"return\":[{\"props\":{\"core-id\":0,\"socket-id\":0,\"thread-id\":0},\"qom-path\":\"/machine/unattached/device[0]\",\"type\":\"host-x86-cpu\",\"vcpus-count\":1},{\"props\":{\"core-id\":0,\"socket-id\":1,\"thread-id\":0},\"qom-path\":\"/machine/unattached/device[1]\",\"type\":\"host-x86-cpu\",\"vcpus-count\":1}]}\\n', '其中，online的vCPU具有qom-path项，offline的vCPU则没有。\\n', '\\n', '管理虚拟机生命周期\\n', '简介\\n', 'StratoVirt可以对虚拟机进行启动、暂停、恢复、退出等生命周期进行管理。\\n', '\\n', '创建并启动虚拟机\\n', '通过命令行参数指定虚拟机配置，创建并启动虚拟机。\\n', '\\n', '使用命令行参数给出虚拟机配置，创建并启动虚拟机的命令如下：\\n', '$ /path/to/stratovirt -[参数1] [参数选项] -[参数2] [参数选项] ...\\n', '说明：\\n', '\\n', '轻量虚拟启动后，内部会有eth0和eth1两张网卡。这两张网卡预留用于网卡热插拔。热插的第一张网卡是eth0，热插的第二张网卡是eth1，目前只支持热插两张virtio-net网卡。\\n', '\\n', '连接虚拟机\\n', 'StratoVirt当前采用QMP管理虚拟机，暂停、恢复、退出虚拟机等操作需要通过QMP连接到虚拟机进行管理。\\n', '\\n', '在主机上打开新的命令行窗口B，并使用root权限进行api-channel连接，参考命令如下：\\n', '\\n', '# ncat -U /path/to/socket\\n', '连接建立后，会收到来自StratoVirt的问候消息，如下所示：\\n', '\\n', '{\"QMP\":{\"version\":{\"qemu\":{\"micro\":1,\"minor\":0,\"major\":4},\"package\":\"\"},\"capabilities\":[]}}\\n', '现在，可以在窗口B中输入QMP命令来管理虚拟机。\\n', '\\n', '说明：\\n', '\\n', 'QMP提供了stop、cont、quit和query-status等来管理和查询虚拟机状态。\\n', '\\n', '管理虚拟机的QMP命令均在窗口B中进行输入。符号：<-表示命令输入，->表示QMP结果返回。\\n', '\\n', '暂停虚拟机\\n', 'QMP提供了stop命令用于暂停虚拟机，即暂停虚拟机所有的vCPU。命令格式如下：\\n', '\\n', '{“execute”:“stop”}\\n', '\\n', '示例：\\n', '\\n', '使用stop暂停该虚拟机的命令和回显如下：\\n', '\\n', '<- {\"execute\":\"stop\"}\\n', '-> {\"event\":\"STOP\",\"data\":{},\"timestamp\":{\"seconds\":1583908726,\"microseconds\":162739}}\\n', '-> {\"return\":{}}\\n', '恢复虚拟机\\n', 'QMP提供了cont命令用于恢复处于暂停状态suspend的虚拟机，即恢复虚拟机所有vCPU的运行。命令格式如下：\\n', '\\n', '{“execute”:“cont”}\\n', '\\n', '示例：\\n', '\\n', '使用cont恢复该虚拟机的命令和回显如下：\\n', '\\n', '<- {\"execute\":\"cont\"}\\n', '-> {\"event\":\"RESUME\",\"data\":{},\"timestamp\":{\"seconds\":1583908853,\"microseconds\":411394}}\\n', '-> {\"return\":{}}\\n', '退出虚拟机\\n', 'QMP提供了quit命令用于退出虚拟机，即退出StratoVirt进程。命令格式如下：\\n', '\\n', '{“execute”:“quit”}\\n', '\\n', '示例：\\n', '\\n', '<- {\"execute\":\"quit\"}\\n', '-> {\"return\":{}}\\n', '-> {\"event\":\"SHUTDOWN\",\"data\":{\"guest\":false,\"reason\":\"host-qmp-quit\"},\"timestamp\":{\"ds\":1590563776,\"microseconds\":519808}}\\n', '管理虚拟机资源\\n', '热插拔磁盘\\n', 'StratoVirt支持在虚拟机运行过程中调整磁盘数量，即在不中断业务前提下，增加或删除虚拟机磁盘。\\n', '\\n', '注意事项\\n', '\\n', '对于标准机型，需要虚拟机内核开启 CONFIG_HOTPLUG_PCI_PCIE=y 配置。\\n', '\\n', '对于标准机型，目前支持热插拔设备到 Root Port 设备，Root Port 设备需要在虚拟机启动前配置。\\n', '\\n', '不建议在虚拟机启动、关闭、内部高压力等状态下进行设备热插拔，可能会因为虚拟机内驱动没有及时响应导致虚拟机出现异常。\\n', '\\n', '热插磁盘\\n', '用法：\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '{\"execute\": \"device_add\", \"arguments\": {\"id\": \"drive-0\", \"driver\": \"virtio-blk-mmio\", \"addr\": \"0x1\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"drive-0\", \"driver\":\"virtio-blk-pci\", \"drive\": \"drive-0\", \"addr\":\"0x0\", \"bus\": \"pcie.1\"}}\\n', '参数\\n', '\\n', '对于轻量机型，blockdev-add 中的 node-name 要和 device_add 中的 id 一致，如上都是 drive-0。\\n', '\\n', '对于标准机型 drive 参数需要和 blockdev-add 中的 node-name 一致。\\n', '\\n', '/path/to/block 是被热插磁盘的镜像路径，不能是启动 rootfs 的磁盘镜像。\\n', '\\n', '对于轻量机型，addr 参数从 0x0 开始与虚拟机的 vda 映射，0x1 与 vdb 映射，以此类推。为了兼容 QMP 协议，“addr” 也可以用 “lun” 代替，但是 lun=0 与客户机的 vdb 映射。对于标准机型，目前 addr 参数需要指定为 0x0。\\n', '\\n', '对于标准机型，bus 为设备要挂载的总线名称，目前只支持热插到 Root Port 设备，需要和 Root Port 的 id 保持一致。\\n', '\\n', '对于轻量机型，StratoVirt 支持的最大 virtio-blk 磁盘数量是6个，热插磁盘时请注意规格约束。对于标准机型，热插磁盘的数量取决于 Root Port 设备的数量。\\n', '\\n', '示例\\n', '\\n', '轻量机型：\\n', '\\n', '<- {\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\": \"device_add\", \"arguments\": {\"id\": \"drive-0\", \"driver\": \"virtio-blk-mmio\", \"addr\": \"0x1\"}}\\n', '-> {\"return\": {}}\\n', '标准机型：\\n', '\\n', '<- {\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"drive-0\", \"driver\":\"virtio-blk-pci\", \"drive\": \"drive-0\", \"addr\":\"0x0\", \"bus\": \"pcie.1\"}}\\n', '-> {\"return\": {}}\\n', '热拔磁盘\\n', '用法：\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\":\"drive-0\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\":\"drive-0\"}}\\n', '{\"execute\": \"blockdev-del\", \"arguments\": {\"node-name\": \"drive-0\"}}\\n', '参数：\\n', '\\n', 'id 为热拔磁盘的 ID 号。\\n', 'node-name 为磁盘后端名称。\\n', '示例\\n', '\\n', '轻量机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\": \"drive-0\"}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"drive-0\",\"path\":\"drive-0\"},\"timestamp\":{\"seconds\":1598513162,\"microseconds\":367129}}\\n', '-> {\"return\": {}}\\n', '标准机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\":\"drive-0\"}}\\n', '-> {\"return\": {}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"drive-0\",\"path\":\"drive-0\"},\"timestamp\":{\"seconds\":1598513162,\"microseconds\":367129}}\\n', '<- {\"execute\": \"blockdev-del\", \"arguments\": {\"node-name\": \"drive-0\"}}\\n', '-> {\"return\": {}}\\n', '当收到 DEVICE_DELETED 事件时，表示设备在 StratoVirt 侧被移除。\\n', '\\n', '热插拔网卡\\n', 'StratoVirt支持在虚拟机运行过程中调整网卡数量，即在不中断业务前提下，给虚拟机增加或删除网卡。\\n', '\\n', '注意事项\\n', '\\n', '对于标准机型，需要虚拟机内核开启 CONFIG_HOTPLUG_PCI_PCIE=y 配置。\\n', '\\n', '对于标准机型，目前支持热插拔设备到 Root Port 设备，Root Port 设备需要在虚拟机启动前配置。\\n', '\\n', '不建议在虚拟机启动、关闭、内部高压力等状态下进行设备热插拔，可能会因为虚拟机内驱动没有及时响应导致虚拟机出现异常。\\n', '\\n', '热插网卡\\n', '准备工作（需要使用root权限）\\n', '\\n', '创建并启用Linux网桥，例如网桥名为 qbr0 的参考命令如下：\\n', '# brctl addbr qbr0\\n', '# ifconfig qbr0 up\\n', '创建并启用 tap 设备，例如设备名为 tap0 的参考命令如下：\\n', '# ip tuntap add tap0 mode tap\\n', '# ifconfig tap0 up\\n', '添加 tap 设备到网桥：\\n', '# brctl addif qbr0 tap0\\n', '用法\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-mmio\", \"addr\":\"0x0\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-pci\", \"addr\":\"0x0\", \"netdev\": \"net-0\", \"bus\": \"pcie.1\"}}\\n', '参数\\n', '\\n', '对于轻量机型，netdev_add 中的 id 应该和 device_add 中的 id 一致，ifname 是后端的 tap 设备名称。\\n', '\\n', '对于标准机型，netdev 参数需要和 netdev_add 中的 id 一致。\\n', '\\n', '对于轻量机型，addr 参数从 0x0 开始与虚拟机的 eth0 映射，0x1 和虚拟机的 eth1 映射。对于标准机型，目前 addr 参数需要指定为 0x0。\\n', '\\n', '对于标准机型，bus 为设备要挂载的总线名称，目前只支持热插到 Root Port 设备，需要和 Root Port 的 id 保持一致。\\n', '\\n', '对于轻量机型，由于 StratoVirt 支持的最大 virtio-net 数量为2个，热插网卡时请注意规格约束。对于标准机型，热插磁盘的数量取决于 Root Port 设备的数量。\\n', '\\n', '示例\\n', '\\n', '轻量机型:\\n', '\\n', '<- {\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-mmio\", \"addr\":\"0x0\"}} \\n', '-> {\"return\": {}}\\n', '其中，addr:0x0,对应虚拟机内部的eth0。\\n', '\\n', '标准机型：\\n', '\\n', '<- {\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-pci\", \"addr\":\"0x0\", \"netdev\": \"net-0\", \"bus\": \"pcie.1\"}}\\n', '-> {\"return\": {}}\\n', '热拔网卡\\n', '用法\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\":\"net-0\"}}\\n', '{\"execute\": \"netdev_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '参数\\n', '\\n', 'id：网卡的ID号，例如 net-0。\\n', '\\n', 'netdev_del 中的 id 是网卡后端的名称。\\n', '\\n', '示例\\n', '\\n', '轻量机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"net-0\",\"path\":\"net-0\"},\"timestamp\":{\"seconds\":1598513339,\"microseconds\":97310}}\\n', '-> {\"return\": {}}\\n', '标准机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\":\"net-0\"}}\\n', '-> {\"return\": {}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"net-0\",\"path\":\"net-0\"},\"timestamp\":{\"seconds\":1598513339,\"microseconds\":97310}}\\n', '<- {\"execute\": \"netdev_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '-> {\"return\": {}}\\n', '当收到 DEVICE_DELETED 事件时，表示设备在 StratoVirt 侧被移除。\\n', '\\n', '热插拔直通设备\\n', 'StratoVirt 标准机型支持在虚拟机运行过程中调整直通设备数量，即在不中断业务前提下，给虚拟机增加或删除直通设备。\\n', '\\n', '注意事项\\n', '\\n', '需要虚拟机内核开启 CONFIG_HOTPLUG_PCI_PCIE=y 配置。\\n', '\\n', '目前支持热插拔设备到 Root Port 设备，Root Port 设备需要在虚拟机启动前配置。\\n', '\\n', '不建议在虚拟机启动、关闭、内部高压力等状态下进行设备热插拔，可能会因为虚拟机内驱动没有及时响应导致虚拟机出现异常。\\n', '\\n', '热插直通设备\\n', '用法\\n', '\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"vfio-0\", \"driver\":\"vfio-pci\", \"bus\": \"pcie.1\", \"addr\":\"0x0\", \"host\": \"0000:1a:00.3\"}}\\n', '参数\\n', '\\n', 'id 为热插设备的 ID 号。\\n', '\\n', 'bus 为设备要挂载的总线名称。\\n', '\\n', 'addr 为设备要挂载的 slot 和 function 号，目前 addr 参数需要指定为 0x0。\\n', '\\n', 'host 为直通设备在主机上的 domain 号, bus 号, slot 号和 function 号。\\n', '\\n', '示例\\n', '\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"vfio-0\", \"driver\":\"vfio-pci\", \"bus\": \"pcie.1\", \"addr\":\"0x0\", \"host\": \"0000:1a:00.3\"}}\\n', '-> {\"return\": {}}\\n', '热拔直通设备\\n', '用法\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\": \"vfio-0\"}}\\n', '参数\\n', '\\n', 'id 为热拔设备的 ID 号。在热插设备时指定。\\n', '示例\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\": \"vfio-0\"}}\\n', '-> {\"return\": {}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"vfio-0\",\"path\":\"vfio-0\"},\"timestamp\":{\"seconds\":1614310541,\"microseconds\":554250}}\\n', '当收到 DEVICE_DELETED 事件时，表示设备在 StratoVirt 侧被移除。\\n', '\\n', 'Balloon设备使用\\n', '使用balloon设备可以从虚拟机回收空闲的内存。Balloon通过qmp命令来调用。qmp命令使用如下：\\n', '\\n', '用法：\\n', '\\n', '{\"execute\": \"balloon\", \"arguments\": {\"value\": 2147483648}}\\n', '参数：\\n', '\\n', 'value： 想要设置的guest内存大小值，单位为字节。如果该值大于虚拟机启动时配置的内存值，则以启动时配置的内存值为准。\\n', '示例：\\n', '\\n', '启动时配置的内存大小为4GiB，在虚拟机内部通过free命令查询虚拟机空闲内存大于2GiB，那么可以通过qmp命令设置guest内存大小为2147483648字节。\\n', '\\n', '<- {\"execute\": \"balloon\", \"arguments\": {\"value\": 2147483648}}\\n', '-> {\"return\": {}}\\n', '查询虚拟机的当前实际内存：\\n', '\\n', '<- {\"execute\": \"query-balloon\"}\\n', '-> {\"return\":{\"actual\":2147483648}}\\n', '虚拟机内存快照\\n', '简介\\n', '虚拟机内存快照是指将虚拟机的设备状态和内存信息保存在快照文件中。当虚拟机系统损坏时，可以使用内存快照将虚拟机恢复到快照对应时间点，从而提升系统的可靠性。\\n', '\\n', 'StratoVirt 支持对处于暂停状态（suspend）的虚拟机制作快照，并且支持虚拟机以快照文件为虚拟机模板批量创建新的虚拟机。只要制作快照的时间点在虚拟机启动完成并进入用户态之后，快速启动就能够跳过内核启动阶段和用户态服务初始化阶段，在毫秒级完成虚拟机启动。\\n', '\\n', '互斥特性\\n', '虚拟机配置了如下设备或使用了如下特性时，不能制作和使用内存快照：\\n', '\\n', 'vhost-net 设备\\n', 'vfio 直通设备\\n', 'balloon 设备\\n', '大页内存\\n', 'mem-shared 特性\\n', '配置了内存后端文件 mem-path\\n', '制作快照\\n', '针对 StratoVirt 虚拟机，可以参考如下步骤制作存储快照：\\n', '\\n', '创建并启动虚拟机。\\n', '\\n', '在 Host 上执行 QMP 命令暂停虚拟机：\\n', '\\n', '<- {\"execute\":\"stop\"}\\n', '-> {\"event\":\"STOP\",\"data\":{},\"timestamp\":{\"seconds\":1583908726,\"microseconds\":162739}}\\n', '-> {\"return\":{}}\\n', '\\n', '确认虚拟机处于暂停状态：\\n', '\\n', '<- {\"execute\":\"query-status\"}\\n', '-> {\"return\":{\"running\":true,\"singlestep\":false,\"status\":\"paused\"}}\\n', '\\n', '执行如下 QMP 命令，在任一指定的绝对路径下创建虚拟机快照，例如 /path/to/template 路径，参考命令如下：\\n', '\\n', '<- {\"execute\":\"migrate\", \"arguments\":{\"uri\":\"file:/path/to/template\"}}\\n', '-> {\"return\":{}}\\n', '\\n', '确认快照是否创建成功。\\n', '\\n', '<- {\"execute\":\"query-migrate\"}\\n', '\\n', '如果回显 {“return”:{“status”:“completed”}} ，说明快照创建成功。\\n', '\\n', '快照创建成功，会在指定路径 /path/to/template 生成 memory 和 state 两个目录。state文件包含虚拟机设备状态的信息，memory文件包含虚拟机内存的数据信息，memory 文件大小接近配置的虚拟机内存。\\n', '\\n', '查询快照状态\\n', '当前在整个快照过程中，存在5种状态：\\n', '\\n', 'None: 快照资源没有准备完成\\n', 'Setup: 快照资源准备完成，可以进行快照\\n', 'Active: 处于制作快照状态中\\n', 'Completed: 快照制作成功\\n', 'Failed: 快照制作失败\\n', '可以通过在 Host 执行query-migrateqmp 命令查询当前快照的状态，如当虚拟机快照制作成功时查询：\\n', '\\n', '<- {\"execute\":\"query-migrate\"}\\n', '-> {\"return\":{\"status\":\"completed\"}}\\n', '\\n', '恢复虚拟机\\n', '注意事项\\n', '快照以及从快照启动特性支持的机型包括：\\n', 'microvm\\n', 'q35（x86_64）\\n', 'virt（aarch64平台）\\n', '在使用快照恢复时，配置的设备必须与制作快照时保持一致\\n', '当使用 microvm 机型，并且在快照前使用了磁盘/网卡的热插特性，在恢复时需要将热插的磁盘/网卡配置进启动命令行\\n', '从快照文件中恢复虚拟机\\n', '命令格式\\n', '\\n', 'stratovirt -incoming URI\\n', '\\n', '参数说明\\n', '\\n', 'URI：快照的路径，当前版本只支持 file 类型，后加上快照文件的绝对路径\\n', '\\n', '示例\\n', '\\n', '假设制作快照所使用的虚拟机是通过以下命令创建的：\\n', '\\n', '$ stratovirt \\\\\\n', '    -machine microvm \\\\\\n', '    -kernel /path/to/kernel \\\\\\n', '    -smp 1 -m 1024 \\\\\\n', '    -append \"console=ttyS0 pci=off reboot=k quiet panic=1 root=/dev/vda\" \\\\\\n', '    -drive file=/path/to/rootfs,id=rootfs,readonly=off,direct=off \\\\\\n', '    -device virtio-blk-device,drive=rootfs \\\\\\n', '    -qmp unix:/path/to/socket,server,nowait \\\\\\n', '    -serial stdio\\n', '\\n', '那么，使用快照恢复虚拟机的参考命令如下（此处假设快照存放的路径为 /path/to/template ）:\\n', '\\n', '$ stratovirt \\\\\\n', '    -machine microvm \\\\\\n', '    -kernel /path/to/kernel \\\\\\n', '    -smp 1 -m 1024 \\\\\\n', '    -append \"console=ttyS0 pci=off reboot=k quiet panic=1 root=/dev/vda\" \\\\\\n', '    -drive file=/path/to/rootfs,id=rootfs,readonly=off,direct=off \\\\\\n', '    -device virtio-blk-device,drive=rootfs \\\\\\n', '    -qmp unix:/path/to/another_socket,server,nowait \\\\\\n', '    -serial stdio \\\\\\n', '    -incoming file:/path/to/template\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_虚拟机配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE.html", "text_entry": "['虚拟机配置\\n', '概述\\n', '使用 StratoVirt 时，可以通过命令行参数指定虚拟机配置，也支持对接 libvirt ，通过 XML 文件配置。本章介绍命令行方式的配置方式。\\n', '\\n', '说明\\n', '\\n', '本文中的 /path/to/socket 为用户自定义路径下的 socket 文件。\\n', '\\n', '从 openEuler 22.03 LTS 版本开始，取消了对 json 文件的支持。\\n', '\\n', '规格说明\\n', 'StratoVirt 支持启动轻量级虚拟机和标准虚拟机。\\n', '\\n', '轻量级虚拟机使用轻量级 microVM 主板，以及 mmio 总线。\\n', '标准虚拟机支持标准启动，在 x86 平台使用 Q35 主板，AArch64 架构下使用 virt 主板以及 PCI 总线。\\n', '轻量级虚拟机\\n', '虚拟机 CPU 个数：[1, 254]\\n', '虚拟机内存大小：[256 MiB, 512 GiB]\\n', '虚拟机磁盘个数（包括热插的磁盘）：[0, 6]\\n', '虚拟机网卡个数（包括热插的网卡）：[0, 2]\\n', '虚拟机 console 设备仅支持单路连接\\n', '主机 CPU 架构为 x86_64 时，最多可以配置 11 个 mmio 设备，但是除了磁盘和网卡，建议最多配置 2 个其他设备; AArch64 平台，最多可以配置 160 个 mmio 设备，但是除了磁盘和网卡，建议最多配置 12 个其他设备。\\n', '标准虚拟机\\n', '虚拟机 CPU 个数：[1, 254]\\n', '虚拟机内存大小：[256 MiB, 512 GiB]\\n', '虚拟机 console 设备仅支持单路连接\\n', '只支持 1 个 console 设备\\n', '最多支持 32 个 PCI 设备\\n', 'PCI 设备挂载的 PCI 总线 slot 取值范围： [0, 32)；function 取值范围 [0, 8)\\n', '最小配置\\n', 'StratoVirt 能够运行的最小配置为：\\n', '\\n', 'PE 格式或 bzImage 格式（仅 x86_64）的 Linux 内核镜像\\n', '将 rootfs 镜像设置成 virtio-blk 设备，并添加到内核参数中\\n', '使用 api-channel 控制 StratoVirt\\n', '如果要使用串口 登录，添加一个串口到内核启动命令行，AArch64平台标准机型为ttyAMA0，其他情况为ttyS0.\\n', '配置介绍\\n', '命令格式\\n', '使用 cmdline 配置的命令格式如下：\\n', '\\n', '$ /path/to/stratovirt -[参数1] [参数选项] -[参数2] [参数选项] …\\n', '\\n', '使用说明\\n', '首先，为确保可以创建 api-channel 需要的 socket，可以参考如下命令清理环境：\\n', '\\n', '$ rm [参数] [用户自定义socket文件路径]\\n', '然后，运行 cmdline 命令。\\n', '\\n', '$ /path/to/stratovirt -[参数1] [参数选项] -[参数2] [参数选项] ...\\n', '基本信息配置\\n', '基本配置信息如下表所示：\\n', '\\n', '参数\\t参数选项\\t说明\\n', '-name\\tVMname\\t配置虚拟机名称（字符长度：1-255字符）\\n', '-kernel\\t/path/to/vmlinux.bin\\t配置内核镜像\\n', '-append\\tconsole=ttyS0 root=/dev/vda reboot=k panic=1 rw\\t配置内核命令行参数，标准虚拟化AArch64平台使用console=ttyAMA0，而不是ttyS0.\\n', '-initrd\\t/path/to/initrd.img\\t配置initrd文件\\n', '-smp\\t[cpus=]个数\\t配置cpu个数，范围[1, 254]\\n', '-m\\t内存大小MiB、内存大小GiB，默认单位MiB\\t配置内存大小，范围[256MiB, 512GiB]\\n', '-qmp\\tunix:/path/to/socket,server,nowait\\t配置api-channel，运行前须保证socket文件不存在\\n', '-D\\t/path/to/logfile\\t配置日志文件\\n', '-pidfile\\t/path/to/pidfile\\t配置pid文件，必须和-daemonize一起使用。运行前须保证pid文件不存在\\n', '-disable-seccomp\\tNA\\t关闭Seccomp，默认打开\\n', '-daemonize\\tNA\\t开启进程daemon化\\n', '虚拟机类型\\n', '通过-machine参数来指定启动的虚拟机的类型。\\n', '\\n', '参数说明\\n', '\\n', 'type：启动虚拟机的类型（轻量级虚拟化为“MicroVm”类型，标准虚拟化在x86_64平台为”q35“，在aarch64平台为”virt”）。\\n', 'dump-guest-core：进程panic时，是否dump虚拟机内存（可选配置）。\\n', 'mem-share：是否与其他进程共享内存（可选配置）。\\n', '磁盘配置\\n', '虚拟机磁盘配置包含以下配置项\\n', '\\n', 'drive_id： 磁盘的id。\\n', 'path_on_host： 磁盘的路径。\\n', 'serial_num： 磁盘的串号（可选配置）。\\n', 'read_only： 是否只读（可选配置）。\\n', 'direct： 是否以“O_DIRECT”模式打开（可选配置）。\\n', 'iothread： 配置iothread属性（可选配置）。\\n', 'throttling.iops-total： 配置磁盘QoS，以限制磁盘的io操作（可选配置）。\\n', 'if：driver的类型，block设备为“none”（可选配置，默认值为“none”）\\n', 'bus：设备要挂载的bus。\\n', 'addr：设备要挂载的slot和function号。\\n', 'multifunction：是否开启pci多功能。（可选配置）\\n', '磁盘配置方式\\n', '磁盘的配置分为两步：driver的配置和block设备的配置\\n', '\\n', '轻量虚拟机配置格式为：\\n', '\\n', '-drive id=drive_id,file=path_on_host[,readonly=off][,direct=off][,throttling.iops-total=200][,if=none]\\n', '-device virtio-blk-device,drive=drive_id,id=blkid[,iothread=iothread1][,serial=serial_num]\\n', '标准虚拟机配置格式为：\\n', '\\n', '-drive id=drive_id,file=path_on_host[,readonly=off][,direct=off][,throttling.iops-total=200][,if=none]\\n', '-device virtio-blk-pci,drive=drive_id,bus=pcie.0,addr=0x3.0x0,id=blkid[,iothread=iothread1,][serial=serial_num][,multifunction=on]\\n', '下面对throttling.iops-total和iothread两个配置项进行详细说明：\\n', '\\n', '磁盘QoS\\n', '简介\\n', 'QoS（Quality of Service）是服务质量的意思。在云场景中，单主机内会启动多台虚拟机，当某台虚拟机对磁盘访问压力大时，由于同主机的磁盘访问总带宽有限，这会挤占其他虚拟机的访问带宽，从而造成对其他虚拟机IO影响。为了降低影响，可以为虚拟机配置QoS属性，限制它们对磁盘访问的速率，从而降低对彼此的影响。\\n', '\\n', '注意事项\\n', '当前QoS支持配置磁盘的iops。\\n', 'iops的设定范围是[0, 1000000]，0为不限速；实际iops不会超过设定值，并且不会超过后端磁盘实际性能的上限。\\n', '只能限制平均iops，无法限速瞬时的突发流量。\\n', '配置方式\\n', '用法：\\n', '\\n', '命令行\\n', '\\n', '-drive xxx,throttling.iops-total=200\\n', '参数：\\n', '\\n', 'throttling.iops-total：当配置了iops后，本磁盘在虚拟机内部的IO下发速度，不会超过此配置值。\\n', 'xxx：表示磁盘的其他设置。\\n', 'iothread\\n', 'iothread配置细节见iothread配置\\n', '\\n', '网卡配置\\n', '虚拟机网卡的配置包含以下配置项：\\n', '\\n', 'id：唯一的设备 id。\\n', 'tap：指定 tap 设备。\\n', 'ifname：host 上的 tap 设备名。\\n', 'mac：设置虚拟机 mac 地址（可选配置）。\\n', 'iothread：配置磁盘的 iothread 属性（可选配置）。网卡 iothread 配置详见 iothread配置 。\\n', '配置方式\\n', '说明\\n', '\\n', '使用网络前请先使用如下命令配置好 host 网桥和 tap 设备。\\n', '\\n', '$ yum install -y bridge-utils iproute net-tools\\n', '$ brctl addbr qbr0\\n', '$ ip tuntap add tap0 mode tap\\n', '$ brctl addif qbr0 tap0\\n', '$ ifconfig qbr0 up; ifconfig tap0 up\\n', '$ ifconfig qbr0 192.168.0.1\\n', '配置 virtio-net（本文中 [] 表示可选参数）\\n', '轻量级虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name[,vhostfd=2]\\n', '-device virtio-net-device,netdev=netdevid,id=netid[,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', '标准虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name[,vhostfd=2]\\n', '-device virtio-net-pci,netdev=netdevid,id=netid,bus=pcie.0,addr=0x2.0x0[,multifunction=on,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', '配置 vhost-net\\n', '轻量级虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name,vhost=on[,vhostfd=2]\\n', '-device virtio-net-device,netdev=netdevid,id=netid[,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', '标准虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name,vhost=on[,vhostfd=2]\\n', '-device virtio-net-pci,netdev=netdevid,id=netid,bus=pcie.0,addr=0x2.0x0[,multifunction=on,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', 'chardev 配置\\n', '将来自 Guest 的 I/O 重定向到宿主机的 chardev。chardev 后端的类型可以是：stdio、pty、socket 和 file。其中 file 仅支持输出时设置。配置项：\\n', '\\n', 'id：唯一的设备 id。\\n', 'backend：重定向的类型。\\n', 'path：设备重定向文件路径。仅 socket 和 file 类型的设备需要此参数。\\n', 'server：将 chardev 作为服务器运行。仅 socket 类型的设备需要此参数。\\n', 'nowait：预期状态为断开连接。仅 socket 类型的设备需要此参数。\\n', '使用 chardev 时，会创建并使用 console 文件，所以启动 stratovirt 之前，请确保 console 文件不存在。\\n', '\\n', '配置方式\\n', '-chardev backend,id=chardev_id[,path=path,server,nowait]\\n', '串口配置\\n', '串口是虚拟机的设备，用于主机和虚拟机之间传送数据。使用串口时，kernel 命令行中配置 console=ttyS0 ，在 AArch64 平台上标准启动时，配置 console=ttyAMA0 。配置项：\\n', '\\n', 'chardev：重定向的 chardev 设备\\n', 'backend、path、server、nowait：这些参数的含义与 chardev 中的相同。\\n', '配置方式\\n', '-serial chardev:chardev_id\\n', '或者：\\n', '\\n', '-chardev backend[,path=path,server,nowait]\\n', 'console 设备配置\\n', 'virtio-console 是通用的串口设备，用于主机和虚拟机之间传送数据。当只配 console 并通过 console 进行 I/O 操作时，kernel 启动参数中配置 console=hvc0。console 设备有如下配置项：\\n', '\\n', 'id： 设备的 id。\\n', 'path：virtio console 文件路径。\\n', 'socket：以 socket 的方式重定向。\\n', 'chardev：重定向的 chardev 设备。\\n', '配置方式\\n', 'console 配置分为三步：首先指定 virtio-serial，然后创建字符设备，最后创建 virtconsole 设备。\\n', '\\n', '轻量级虚拟机：\\n', '\\n', '-device virtio-serial-device[,id=virtio-serial0]\\n', '-chardev socket,path=socket_path,id=virtioconsole1,server,nowait\\n', '-device virtconsole,chardev=virtioconsole1,id=console_id\\n', '标准虚拟机：\\n', '\\n', '-device virtio-serial-pci,bus=pcie.0,addr=0x1.0x0[,multifunction=on,id=virtio-serial0]\\n', '-chardev socket,path=socket_path,id=virtioconsole1,server,nowait\\n', '-device virtconsole,chardev=virtioconsole1,id=console_id\\n', 'vsock 设备配置\\n', 'vsock 也是主机和虚拟机之间通信的设备，类似于 console，但具有更好的性能。配置项：\\n', '\\n', 'id： 唯一的设备 id。\\n', 'guest_cid： 唯一的 context id 。\\n', '配置方式：\\n', '轻量级虚拟机：\\n', '\\n', '-device vhost-vsock-device,id=vsock_id,guest-cid=3\\n', '标准虚拟机：\\n', '\\n', '-device vhost-vsock-pci,id=vsock_id,guest-cid=3,bus=pcie.0,addr=0x1.0x0[,multifunction=on]\\n', '内存大页配置\\n', '概述\\n', 'StratoVirt 支持为虚拟机配置内存大页，相比传统的 4KiB 内存分页模式，大页内存可以有效减少 TLB Miss 次数和缺页中断次数，能够显著提升内存密集型业务性能。\\n', '\\n', '注意事项\\n', '指定的大页挂载的目录，必须是绝对路径。\\n', '仅支持在启动时配置。\\n', '仅支持静态大页。\\n', '使用大页前， 在Host上需要配置好大页。\\n', '使用大页特性， 指定虚拟机内存规格必须是大页页面大小的整数倍。\\n', '互斥特性\\n', '内存大页和 ballon 特性互斥，同时配置时，balloon 特性无效。\\n', '配置方式\\n', '配置Host上大页\\n', '挂载\\n', '将大页文件系统挂载到指定目录上，其中 /path/to/hugepages为用户自定义的空目录。\\n', '\\n', '$ mount -t hugetlbfs hugetlbfs /path/to/hugepages\\n', '设置大页数目\\n', '设置静态大页数目, num为指定的大页数目\\n', '\\n', '$ sysctl vm.nr_hugepages=num\\n', '查询大页统计信息\\n', '\\n', '$ cat /proc/meminfo | grep Hugepages\\n', '如果需要查看其它页面大小的大页统计信息， 可以查看 /sys/kernel/mm/hugepages/hugepages-*/目录下相关信息。\\n', '\\n', '说明\\n', '\\n', '请根据大页使用情况，配置StratoVirt内存规格和大页。如果大页资源不足，虚拟机会启动失败。\\n', '\\n', '启动StratoVirt时添加大页配置\\n', '命令行\\n', '\\n', '-mem-path /page/to/hugepages\\n', '其中 /page/to/hugepages为大页文件系统挂载的目录，仅支持绝对路径。\\n', '\\n', '\\n', '说明\\n', '\\n', '**典型配置：**指定StratoVirt命令行中的mem-path项为：大页文件系统挂载的目录。 推荐使用典型配置使用StratoVirt大页特性。\\n', '\\n', '配置iothread\\n', '简介\\n', '当StratoVirt启动了带iothread配置的虚拟机后，会在主机上启动独立于主线程的单独线程，这些单独线程可以用来处理设备的IO请求，一方面提升设备的IO性能，另一方面降低对管理面消息处理的影响。\\n', '\\n', '注意事项\\n', '支持配置最多8个iothread线程\\n', '支持磁盘和网卡配置iothread属性\\n', 'iothread线程会占用主机CPU资源，在虚拟机内部大IO压力情况下，单个iothread占用的CPU资源取决于磁盘的访问速度，例如普通的SATA盘会占用20%以内CPU资源。\\n', '创建iothread线程\\n', '命令行：\\n', '\\n', '-object iothread,id=iothread1 -object iothread,id=iothread2\\n', '参数：\\n', '\\n', 'id：用于标识此iothread线程，该id可以被设置到磁盘或网卡的iothread属性。当启动参数配置了iothread线程信息，虚拟机启动后会在主机上启动相应id名的线程。\\n', '配置磁盘或网卡的iothread属性\\n', '命令行配置\\n', '\\n', '轻量虚拟机：\\n', '\\n', '磁盘\\n', '\\n', '-device virtio-blk-device xxx,iothread=iothread1\\n', '网卡\\n', '\\n', '-device virtio-net-device xxx,iothread=iothread2\\n', '标准虚拟机：\\n', '\\n', '磁盘\\n', '\\n', '-device virtio-blk-pci xxx,iothread=iothread1\\n', '网卡\\n', '\\n', '-device virtio-net-pci xxx,iothread=iothread2\\n', '参数：\\n', 'iothread：设置成 iothread 线程的 id，指明处理本设备 I/O 的线程。\\n', 'xxx: 表示磁盘或者网卡的其他配置\\n', '配置balloon设备\\n', '简介\\n', '在虚拟机运行过程中,由虚拟机里的balloon驱动来动态占用或释放内存,从而动态改变这台虚拟机当前可用内存，达到内存弹性的效果。\\n', '\\n', '注意事项\\n', '启用balloon前须确保guest和host的页面大小相同。\\n', 'guest内核须开启balloon特性支持。\\n', '开启内存弹性时，有可能造成虚拟机内部轻微卡顿、内存性能下降。\\n', '互斥特性\\n', '大页内存互斥。\\n', '在x86下，由于中断数量有限，所以balloon设备和其他virtio的数量（默认使用6个block设备，2个net设备和1个串口设备）总和不得超过11个。\\n', '规格\\n', '每个VM只能配置1个balloon设备。\\n', '配置方式\\n', '轻量级虚拟机：\\n', '\\n', '-device virtio-balloon-device,deflate-on-oom=true\\n', '标准虚拟机：\\n', '\\n', '-device virtio-balloon-pci,bus=pcie.0,addr=0x4.0x0,deflate-on-oom=true[,multifunction=on]\\n', '说明\\n', '\\n', 'deflate-on-oom的取值为bool类型，表示是否开启auto deflate特性。开启时，如果balloon已经回收部分内存，当guest需要内存时，balloon设备会自动放气，归还内存给guest。不开启则不会自动归还。\\n', '使用qmp命令回收虚拟机内存时，应确保回收后虚拟机仍然有足够的内存来保持最基本的运行。否则可能会出现一些操作超时，以及导致虚拟机内部无法申请到空闲内存等现象。\\n', '如果虚拟机内部开启内存大页，balloon不能回收大页占用内存。\\n', 'deflate-on-oom=false时，当Guest中内存不足时，balloon不会自动放气并归还内存，可能会引起Guest内部OOM，进程被Kill，甚至虚拟机无法正常运行。\\n', '\\n', '配置示例\\n', '轻量级虚拟机\\n', '此处给出创建一个轻量级虚拟机的最小配置示例。\\n', '\\n', '登录主机，删除 socket 文件，确保可以创建 QMP。\\n', '\\n', '$ rm -f /tmp/stratovirt.socket\\n', '运行 StratoVirt 。\\n', '\\n', '$ /path/to/stratovirt \\\\\\n', '    -kernel /path/to/vmlinux.bin \\\\\\n', '    -append console=ttyS0 root=/dev/vda rw reboot=k panic=1 \\\\\\n', '    -drive file=/home/rootfs.ext4,id=rootfs,readonly=false \\\\\\n', '    -device virtio-blk-device,drive=rootfs \\\\\\n', '    -qmp unix:/tmp/stratovirt.socket,server,nowait \\\\\\n', '    -serial stdio\\n', '运行成功后，将根据指定的配置参数创建并启动虚拟机。\\n', '\\n', '标准虚拟机\\n', '此处给出在 ARM 平台创建一个标准虚拟机的最小配置示例。\\n', '\\n', '删除 socket 文件，确保可以创建 QMP 。\\n', '\\n', '$ rm -f /tmp/stratovirt.socket\\n', '运行 StratoVirt 。\\n', '\\n', '$ /path/to/stratovirt \\\\\\n', '    -kernel /path/to/vmlinux.bin \\\\\\n', '    -append console=ttyAMA0 root=/dev/vda rw reboot=k panic=1 \\\\\\n', '    -drive file=/path/to/code_storage_file,if=pflash,unit=0[,readonly=true] \\\\\\n', '    -drive file=/path/to/data_storage_file,if=pfalsh,unit=1, \\\\\\n', '    -drive file=/home/rootfs.ext4,id=rootfs,readonly=false \\\\\\n', '    -device virtio-blk-device,drive=rootfs,bus=pcie.0,addr=0x1 \\\\\\n', '    -qmp unix:/tmp/stratovirt.socket,server,nowait \\\\\\n', '    -serial stdio\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_内核热升级指南_使用方法.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KernelLiveUpgrade/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html", "text_entry": "['使用方法\\n', '命令用法\\n', '的使用限制\\n', '加速特性说明及使用\\n', '产生的日志信息\\n', '命令用法\\n', 'nvwa help\\n', '\\n', '打印帮助信息，打印的信息如下:\\n', '\\n', 'NAME:\\n', 'nvwa - a tool used for openEuler kernel update.\\n', '\\n', 'USAGE:\\n', 'nvwa [global options] command [command options] [arguments...]\\n', '\\n', 'VERSION:\\n', '0.1\\n', '\\n', 'COMMANDS:\\n', 'update   specify kernel version for nvwa to update\\n', 'init     init nvwa running environment\\n', 'help, h  Shows a list of commands or help for one command\\n', '\\n', 'GLOBAL OPTIONS:\\n', '--help, -h     show help (default: false)\\n', '--version, -v  print the version (default: false)\\n', 'nvwa update\\n', '\\n', '热升级到内核某一版本，nvwa会去/boot目录下寻找内核镜像和ramfs，kernel的命名格式需为vmlinuz-, rootfs命名格式需为initramfs-.img\\n', '\\n', '需要注意的是，升级过程有可能会失败，如果失败，部分被dump的进程或者服务，将停止运行。\\n', '\\n', 'nvwa init\\n', '\\n', '清除nvwa产生的现场信息以及对systemd的配置修改，用于nvwa执行前或者执行失败后，对现场进行清理\\n', '\\n', '使用限制\\n', '对于需要通过nvwa保存的service，其配置中需要设置标准输出(StandardOutput)和错误输出(StandardError)，以redis为例:\\n', '\\n', '[Unit]\\n', 'Description=Redis persistent key-value database\\n', 'After=network.target\\n', '[Service]\\n', 'ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd\\n', 'Type=notify\\n', 'User=redis\\n', 'Group=redis\\n', 'RuntimeDirectory=redis\\n', 'RuntimeDirectoryMode=0755\\n', 'StandardOutput=file:/root/log1.log\\n', 'StandardError=file:/root/log2.log\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '使用加速特性需要修改cmdline以及分配合适的内存，参见此处\\n', '\\n', '运行过程中需要关闭SELINUX\\n', '\\n', '理论上，仅需要在执行nvwa update之后和系统重启nvwa恢复现场这段时间前需要关闭。稳妥起见，建议全程关闭SELINUX。\\n', '\\n', '加速特性说明及使用\\n', 'cpu park(加速内核重启过程)\\n', '\\n', 'cpu park，是在使用kexec过程，使cpu进入一种忙等的状态，更快的响应主核发送的中断请求，减少状态的变化。\\n', '\\n', '使用cpu park，需要在cmdline中加入\"cpuparkmem=0x200000000\"，其中0x200000000是一段未被其他程序使用的内存起始地址，cpuparkmem将占用从该地址开始，size为1M左右的内存空间。\\n', '\\n', '需要注意的是，在内存允许的情况下，此处的地址选择，建议范围在4G(0x100000000)之后，前4G通常被系统各组件预留，容易冲突。\\n', '\\n', 'quick kexec(加速内核启动过程)\\n', '\\n', 'quick kexec，是对kexec加载镜像过程中的一种加速。\\n', '\\n', '使用quick kexec，需要在配置文件中使能相关选项，更多信息参考«安装与部署»(配置介绍)\\n', '\\n', 'pin_memory(加速现场保存恢复过程)\\n', '\\n', 'pin memory，是对criu进行现场保存恢复过程中的一种加速。\\n', '\\n', '使用pin memory，需要在配置文件中使能相关选项，更多信息参考«安装与部署»(配置介绍)\\n', '\\n', '产生的日志信息\\n', '内核热升级工具产生的日志分为两部分:\\n', '\\n', '运行过程产生的日志\\n', '\\n', '通过service nvwa status查看\\n', '\\n', '保留现场过程中产生的日志\\n', '\\n', '日志位于criu_dir指定的路径对应命名的进程/服务文件夹中\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_内核热升级指南_安装部署.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KernelLiveUpgrade/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2.html", "text_entry": "['安装与部署\\n', '本章介绍如何安装和部署内核热升级工具。\\n', '\\n', '安装与部署\\n', '软硬件要求\\n', '硬件要求\\n', '软件要求\\n', '环境准备\\n', '安装内核热升级工具\\n', '部署内核热升级工具\\n', '配置介绍\\n', '使能内核热升级工具\\n', '软硬件要求\\n', '硬件要求\\n', '当前仅支持arm64架构\\n', '软件要求\\n', '操作系统：openEuler 22.03 LTS\\n', '环境准备\\n', '安装openEuler系统，安装方法参考 《openEuler 22.03 LTS 安装指南》\\n', '\\n', '安装内核热升级工具需要使用root权限\\n', '\\n', '安装内核热升级工具\\n', '本章介绍内核热升级工具的安装方法\\n', '\\n', '安装内核热升级工具的操作步骤如下：\\n', '\\n', '挂载openEuler的iso文件\\n', '\\n', '# mount openEuler-22.03-LTS-aarch64-dvd.iso /mnt\\n', '配置本地yum源\\n', '\\n', '# vim /etc/yum.repos.d/local.repo\\n', '配置内容如下所示：\\n', '\\n', '[local]\\n', 'name=local\\n', 'baseurl=file:///mnt\\n', 'gpgcheck=1\\n', 'enabled=1\\n', '将RPM数字签名的GPG公钥导入系统\\n', '\\n', '# rpm --import /mnt/RPM-GPG-KEY-openEuler\\n', '安装内核热升级工具\\n', '\\n', '# yum install nvwa -y\\n', '验证是否安装成功。命令和回显如下表示安装成功\\n', '\\n', '# rpm -qa | grep nvwa\\n', 'nvwa-xxx\\n', '部署内核热升级工具\\n', '本章介绍内核热升级工具的配置部署：\\n', '\\n', '配置介绍\\n', '内核热升级工具的配置文件位于/etc/nvwa，配置文件包括:\\n', '\\n', 'nvwa-restore.yaml\\n', '\\n', '该配置文件用于指导内核热升级工具在内核热升级过程中如何保存和恢复现场，具体配置如下:\\n', '\\n', 'pids\\n', '\\n', 'pids用于指明nvwa热升级过程中需要保留和恢复的进程，此处的进程通过进程号(pid)进行标识，需要注意的是，nvwa管理的进程在nvwa服务启动后，会被自动恢复。\\n', '\\n', 'services\\n', '\\n', 'services用于指明nvwa热升级过程中需要保留和恢复的服务。与pids的区别在于，内核热升级工具可以直接保存和恢复进程的状态，对于服务，内核热升级工具则需要依赖systemd进行相关操作。此处的服务名称，应该使用systemd中使用的服务名称。需要注意的是，对于nvwa管理的服务，是否要在nvwa启动时自动恢复，取决于systemd中有没有使能该服务，且当前支持的服务类型只有notify和oneshot。\\n', '\\n', 'restore_net\\n', '\\n', 'restore_net用于指明是否需要内核热升级工具保存和恢复网络配置，如果网络配置有误，有可能导致恢复后网络不可用，默认关闭。\\n', '\\n', 'enable_quick_kexec\\n', '\\n', 'enable_quick_kexec用于指明是否需要使能quick kexec特性，quick kexec是nvwa社区推出的，加速内核重启过程的一个特性。使用该特性，需要在cmdline中，加入\"quickkexec=128M\"。128指分配给quick kexec特性的内存大小，该内存将用于在升级过程中加载kernel和initramfs，因此大小需要大于升级过程中涉及到的kernel，initramfs大小之和。该特性默认关闭。\\n', '\\n', 'enable_pin_memory\\n', '\\n', 'enable_pin_memory用于指明是否需要使能pin memory特性，pin memory是nvwa社区推出的，加速进程保存恢复过程的一个特性。使用该特性，需要在cmdline中，加入\"max_pin_pid_num=10 redirect_space_size=2M pinmemory=200M@0x640000000\"。\\n', '\\n', '其中，max_pin_pid_num代表支持pin memory恢复的最大进程数目，redirect_space_size代表pin memory过程中重定向物理页所需要的预留内存空间，建议配置为pin memory总预留内存的1/100，pinmemory指明这段内存的起点和大小。从0x640000000开始的200M空间，是pin memory使用的全部内存空间，这段空间不应该被其他程序使用。\\n', '\\n', 'nvwa-restore.yaml的配置示例\\n', '\\n', 'pids:\\n', '  - 14109\\n', 'services:\\n', '  - redis\\n', 'restore_net: false\\n', 'enable_quick_kexec: true\\n', 'enable_pin_memory: true\\n', 'nvwa-server.yaml\\n', '\\n', '该文件包含了内核热升级工具运行过程中，需要使用到的配置信息，具体如下：\\n', '\\n', 'criu_dir\\n', '\\n', '用于指明内核热升级工具在保存现场过程中，存储产生的信息文件夹路径。需要注意的是，这些信息可能会占用较大的磁盘空间。\\n', '\\n', 'criu_exe\\n', '\\n', '用于指明内核热升级工具使用的criu可执行文件路径，除非是对criu进行调测，一般不建议修改。\\n', '\\n', 'kexec_exe\\n', '\\n', '用于指明内核热升级工具使用的kexec可执行文件路径，除非是对kexec进行调测，一般不建议修改。\\n', '\\n', 'systemd_etc\\n', '\\n', '用于指明覆盖systemd配置过程中，使用到的文件夹路径。该路径由systemd决定，一般不需要修改。\\n', '\\n', 'log_dir\\n', '\\n', '存放内核热升级工具产生的log信息，log模块当前未启用。内核热升级工具日志信息的查看，参考其他章节«使用方法»\\n', '\\n', 'nvwa-server.yaml的配置示例\\n', '\\n', 'criu_dir: /var/nvwa/running/\\n', 'criu_exe: /usr/sbin/criu\\n', 'kexec_exe: /usr/sbin/kexec\\n', 'systemd_etc: /etc/systemd/system/\\n', 'log_dir: /etc/nvwa/log/\\n', '使能内核热升级工具\\n', '内核热升级工具的运行依赖配置文件，配置文件修改后应该重新运行内核热升级工具程序。\\n', '\\n', '安装成功后，可以通过systemd的相关命令来操作内核热升级工具\\n', '\\n', '使能nvwa\\n', '\\n', 'systemctl enable nvwa\\n', '\\n', '启动nvwa\\n', '\\n', 'systemctl start nvwa\\n', '\\n', '查看nvwa日志\\n', '\\n', 'service nvwa status\\n', '\\n', '更多用法参考systemd用法\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_内核热升级指南_常见问题与解决方法.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KernelLiveUpgrade/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html", "text_entry": "['执行nvwa update后未升级\\n', '\\n', '原因：保留现场或者内核替换过程中出现错误。\\n', '\\n', '解决方法：查看日志，找出错误原因。\\n', '\\n', '开启加速特性后，nvwa执行命令失败\\n', '\\n', '原因：nvwa提供了诸多加速特性，包括quick kexec，pin memory，cpu park等等。这些特性都涉及到cmdline的配置和内存的分配，在选取内存时，通过cat /proc/iomemory确保选取的内存没有与其他程序冲突。必要时，通过dmesg查看使能特性后是否存在错误日志。\\n', '\\n', '热升级后，相关现场未被恢复\\n', '\\n', '原因：首先检查nvwa服务是否运行，运行情况下，可能存在两种情况，一种是服务恢复失败，一种是进程恢复失败。\\n', '\\n', '解决方法：通过service nvwa status查看nvwa的日志，如果是服务启动失败，首先确认是否使能了该服务，再通过systemd查看对应服务的日志。进一步的日志，去criu_dir指定的路径对应命名的进程/服务文件夹中。其中dump.log为保存现场产生的日志，restore.log为恢复现场产生的。\\n', '\\n', \"恢复失败，日志显示Can't fork for 948: File exists\\n\", '\\n', '原因：内核热升级工具在恢复程序过程中，发现程序的pid已经被占用。\\n', '\\n', '解决方法：当前内核没有提供保留pid的机制，相关策略正在开发，预计会在将来的内核版本中解决这一限制，当前仅能手动重启相关进程。\\n', '\\n', '使用nvwa去保存和恢复简单程序(hello world)，显示失败或者程序未在执行\\n', '\\n', '原因: criu使用存在诸多限制\\n', '\\n', '解决办法：查看nvwa的日志，如果显示是criu相关的错误，去相应的目录下检查dump.log或者restore.log，criu相关的使用限制，可以参考w']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_SELinux配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/SELinux%E9%85%8D%E7%BD%AE.html", "text_entry": "['SELinux配置\\n', '概述\\n', '自主访问控制DAC（Discretionary Access Control）基于用户、组和其他权限，决定一个资源是否能被访问的因素是某个资源是否拥有对应用户的权限，它不能使系统管理员创建全面和细粒度的安全策略。SELinux（Security-Enhanced Linux）是Linux内核的一个模块，也是Linux的一个安全子系统。SELinux的实现了强制访问控制MAC（Mandatory Access Control ），每个进程和系统资源都有一个特殊的安全标签，资源能否被访问除了DAC规定的原则外，还需要判断每一类进程是否拥有对某一类资源的访问权限。\\n', '\\n', 'openEuler默认使用SELinux提升系统安全性。SELinux分为三种模式：\\n', '\\n', 'permissive：SELinux仅打印告警而不强制执行。\\n', 'enforcing：SELinux安全策略被强制执行。\\n', 'disabled：不加载SELinux安全策略。\\n', '配置说明\\n', '获取当前SELinux运行状态：\\n', '\\n', '# getenforce\\n', 'Enforcing\\n', 'SELinux开启的前提下，设置运行状态为enforcing模式：\\n', '\\n', '# setenforce 1\\n', '# getenforce\\n', 'Enforcing\\n', 'SELinux开启的前提下，设置运行状态为permissive模式：\\n', '\\n', '# setenforce 0\\n', '# getenforce\\n', 'Permissive\\n', 'SELinux开启的前提下，设置当前SELinux运行状态为disabled（关闭SELinux，需要重启系统）。\\n', '\\n', '修改SELinux配置文件/etc/selinux/config，设置“SELINUX=disabled”。\\n', '# cat /etc/selinux/config | grep \"SELINUX=\"\\n', 'SELINUX=disabled\\n', '重启系统：\\n', '# reboot\\n', '状态切换成功：\\n', '# getenforce\\n', 'Disabled\\n', 'SELinux关闭的前提下，设置SELinux运行状态为permissive：\\n', '\\n', '修改SELinux配置文件/etc/selinux/config，设置“SELINUX=permissive”：\\n', '# cat /etc/selinux/config | grep \"SELINUX=\"\\n', 'SELINUX=permissive\\n', '在根目录下创建.autorelabel文件：\\n', '# touch /.autorelabel\\n', '重启系统，此时系统会重启两次：\\n', '# reboot\\n', '状态切换成功：\\n', '# getenforce\\n', 'Permissive\\n', 'SELinux关闭的前提下，设置SELinux运行状态为enforcing：\\n', '\\n', '按照上一步骤所述，设置SELinux运行状态为permissive。\\n', '修改SELinux配置文件/etc/selinux/config，设置“SELINUX=enforcing”：\\n', '# cat /etc/selinux/config | grep \"SELINUX=\"\\n', 'SELINUX=enforcing\\n', '重启系统：\\n', '# reboot\\n', '状态切换成功：\\n', '# getenforce\\n', 'Enforcing\\n', 'SELinux相关命令\\n', '查询运行SELinux的系统状态。SELinux status表示SELinux的状态，enabled表示启用SELinux，disabled表示关闭SELinux。Current mode表示SELinux当前的安全策略。\\n', '\\n', '# sestatus\\n', 'SELinux status:                 enabled\\n', 'SELinuxfs mount:                /sys/fs/selinux\\n', 'SELinux root directory:         /etc/selinux\\n', 'Loaded policy name:             targeted\\n', 'Current mode:                   enforcing\\n', 'Mode from config file:          enforcing\\n', 'Policy MLS status:              enabled\\n', 'Policy deny_unknown status:     allowed\\n', 'Memory protection checking:     actual (secure)\\n', 'Max kernel policy version:      31\\n', '注意事项\\n', '如用户需使能SELinux功能，建议通过dnf升级方式将selinux-policy更新为最新版本，否则应用程序有可能无法正常运行。升级命令示例：\\n', '\\n', 'dnf update selinux-policy -y\\n', '如果用户由于SELinux配置不当（如误删策略或未配置合理的规则或安全上下文）导致系统无法启动，可以在启动参数中添加selinux=0，关闭SELinux功能，系统即可正常启动。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_内核参数.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0.html", "text_entry": "['内核参数\\n', '内核参数\\n', '加固内核参数\\n', '加固内核参数\\n', '说明\\n', '内核参数决定配置和应用特权的状态。内核提供用户可配置的系统控制，这一系统控制可微调或配置，该功能特性可通过控制各种可配置的内核参数，来提高操作系统的安全特性。比如：通过微调或配置网络选项，可有效提高系统的安全性。\\n', '\\n', '实现\\n', '将表3中的加固项写入/etc/sysctl.conf文件中。\\n', '\\n', ' 说明：\\n', '写入方式如下：\\n', '\\n', 'net.ipv4.icmp_echo_ignore_broadcasts = 1  \\n', 'net.ipv4.conf.all.rp_filter = 1  \\n', 'net.ipv4.conf.default.rp_filter = 1  \\n', '表 3 内核参数加固策略说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '加固建议\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'net.ipv4.icmp_echo_ignore_broadcasts\\n', '\\n', '是否接受ICMP广播报文。加固策略为不接受。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.rp_filter\\n', '\\n', '验证数据包使用的实际源地址是否与路由表相关，以及使用该特定源IP地址的数据包是否通过接口获取其响应。加固策略为启用该项。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.rp_filter\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.ip_forward\\n', '\\n', 'IP Forwarding可阻止未授权的IP数据包渗透至网络。加固策略为禁用该特性。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.accept_source_route\\n', '\\n', 'accept_source_route指允许数据包的发送者指定数据包的发送路径，以及返回给发送者的数据包所走的路径。加固策略为禁用该特性。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.accept_source_route\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.accept_redirects\\n', '\\n', '是否发送ICMP重定向报文。加固策略为禁止发送。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.accept_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv6.conf.all.accept_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv6.conf.default.accept_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.send_redirects\\n', '\\n', '是否将ICMP重定向报文发送至其他主机。只有当主机作为路由时，应启用该策略。加固策略为禁用该项。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.send_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.icmp_ignore_bogus_error_responses\\n', '\\n', '忽略伪造的ICMP数据包，不会将其记录到日志，将节省大量的硬盘空间。加固策略为启用该项。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.tcp_syncookies\\n', '\\n', 'SYN Attack是一种通过占用系统资源迫使系统重启的DoS攻击。加固策略为开启TCP-SYN cookie保护。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'kernel.dmesg_restrict\\n', '\\n', '加固dmesg信息，仅允许管理员查看。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'kernel.sched_autogroup_enabled\\n', '\\n', '该选项决定内核是否对线程进行自动分组调度。开启后调度组之间互相竞争时间片，调度组内的线程再竞争调度组分配到的时间片。加固策略为不启用该项。\\n', '\\n', '0\\n', '\\n', '否\\n', '\\n', 'kernel.sysrq\\n', '\\n', '禁用魔术键。\\n', '\\n', '说明：\\n', '建议禁用魔术键，避免由于直接发送命令到内核对系统造成影响，增强内核安全性。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.secure_redirects\\n', '\\n', '设置系统是接收来自任何主机的ICMP重定向消息还是从默认网关列表中的网关处接收ICMP重定向消息。加固策略为采用前者。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.secure_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', '加载sysctl.conf文件中设置的内核参数。\\n', '\\n', 'sysctl -p  /etc/sysctl.conf\\n', '其它安全建议\\n', 'net.ipv4.icmp_echo_ignore_all：忽略ICMP请求。\\n', '\\n', '出于安全考虑，建议开启此项（当前默认值为0，开启将值设为1）。\\n', '\\n', '但开启后会忽略所有接收到的icmp echo请求的包(会导致机器无法ping通)，建议用户根据实际组网场景决定是否开启此项。\\n', '\\n', 'net.ipv4.conf.all.log_martians/net.ipv4.conf.default.log_martians：对于仿冒/源路由/重定向数据包开启日志记录。\\n', '\\n', '出于安全考虑，建议开启此项（当前默认值为0，开启将值设为1）。\\n', '\\n', '但是开启后会记录带有不允许的地址的数据到内核日志中，存在冲日志风险，建议用户根据实际使用场景决定是否开启此项。\\n', '\\n', 'net.ipv4.tcp_timestamps：关闭tcp_timestamps。\\n', '\\n', '出于安全考虑，建议关闭tcp_timestamps（当前默认值为1，关闭将值设为0）。\\n', '\\n', '但是关闭此项会影响TCP超时重发的性能，建议用户根据实际使用场景决定是否关闭此项。\\n', '\\n', 'net.ipv4.tcp_max_syn_backlog：决定了SYN_RECV状态队列的数量。\\n', '\\n', '该参数决定了SYN_RECV状态队列的数量，超过这个数量，系统将不再接受新的TCP连接请求，一定程度上可以防止系统资源耗尽。建议由用户根据实际使用场景配置合适的值。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_授权认证.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81.html", "text_entry": "['授权认证\\n', '授权认证\\n', '设置网络远程登录的警告信息\\n', '禁止通过Ctrl+Alt+Del重启系统\\n', '设置终端的自动退出时间\\n', '设置用户的默认umask值为077\\n', '设置GRUB2加密口令\\n', '安全单用户模式\\n', '禁止交互式启动\\n', '设置网络远程登录的警告信息\\n', '说明\\n', '设置网络远程登录的警告信息，用于在登录进入系统之前向用户提示警告信息，明示非法侵入系统可能受到的惩罚，吓阻潜在的攻击者。同时也可以隐藏系统架构及其他系统信息，避免招致对系统的目标性攻击。\\n', '\\n', '实现\\n', '该设置可以通过修改/etc/issue.net文件的内容实现。将/etc/issue.net文件原有内容替换为如下信息（openEuler默认已设置）：\\n', '\\n', 'Authorized users only. All activities may be monitored and reported. \\n', '禁止通过Ctrl+Alt+Del重启系统\\n', '说明\\n', '操作系统默认能够通过“Ctrl+Alt+Del”进行重启，建议禁止该项特性，防止因为误操作而导致数据丢失。\\n', '\\n', '实现\\n', '禁止通过“Ctrl+Alt+Del”重启系统的操作步骤如下：\\n', '\\n', '删除两个ctrl-alt-del.target文件，参考命令如下：\\n', '\\n', 'rm -f /etc/systemd/system/ctrl-alt-del.target\\n', 'rm -f /usr/lib/systemd/system/ctrl-alt-del.target\\n', '修改/etc/systemd/system.conf文件，将#CtrlAltDelBurstAction=reboot-force修改为CtrlAltDelBurstAction=none。\\n', '\\n', '重启systemd，使修改生效，参考命令如下：\\n', '\\n', 'systemctl daemon-reexec\\n', '设置终端的自动退出时间\\n', '说明\\n', '无人看管的终端容易被侦听或被攻击，可能会危及系统安全。因此建议设置终端在停止运行一段时间后能够自动退出。\\n', '\\n', '实现\\n', '自动退出时间由/etc/profile文件的TMOUT字段（单位为秒）控制，在/etc/profile的尾部添加如下配置：\\n', '\\n', 'export TMOUT=300\\n', '设置用户的默认umask值为077\\n', '说明\\n', 'umask值用于为用户新创建的文件和目录设置缺省权限。如果umask的值设置过小，会使群组用户或其他用户的权限过大，给系统带来安全威胁。因此设置所有用户默认的umask值为0077，即用户创建的目录默认权限为700，文件的默认权限为600。umask值代表的是权限的“补码”，umask值和权限的换算方法请参见umask值含义。\\n', '\\n', ' 说明：\\n', 'openEuler默认已设置用户的默认umask值为022。\\n', '\\n', '实现\\n', '分别在/etc/bashrc文件和/etc/profile.d/目录下的所有文件中加入“umask 0077”。\\n', '\\n', 'echo \"umask 0077\" >> $FILE\\n', ' 说明：\\n', '$FILE 为具体的文件名，例如：echo “umask 0077” >> /etc/bashrc\\n', '\\n', '设置/etc/bashrc文件和/etc/profile.d/目录下所有文件的属主为root，群组为root。\\n', '\\n', 'chown root.root $FILE\\n', ' 说明：\\n', '$FILE 为具体的文件名，例如：chown root.root /etc/bashrc\\n', '\\n', '设置GRUB2加密口令\\n', '说明\\n', 'GRUB是GRand UnifiedBootloader的缩写，它是一个操作系统启动管理器，用来引导不同系统（如Windows、Linux），GRUB2是GRUB的升级版。\\n', '\\n', '系统启动时，可以通过GRUB2界面修改系统的启动参数。为了确保系统的启动参数不被任意修改，需要对GRUB2界面进行加密，仅在输入正确的GRUB2口令时才能修改启动参数。\\n', '\\n', ' 说明：\\n', 'GRUB2默认设置的口令为openEuler#12，建议用户首次登录时修改默认密码并定期更新，避免密码泄露后，启动选项被篡改，导致系统启动异常。\\n', '\\n', '实现\\n', '使用grub2-mkpasswd-pbkdf2命令生成加密的口令\\n', '\\n', ' 说明：\\n', 'GRUB2加密算法使用sha512。\\n', '\\n', '# grub2-mkpasswd-pbkdf2\\n', 'Enter password: \\n', 'Reenter password: \\n', 'PBKDF2 hash of your password is \\n', 'grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08\\n', ' 说明：\\n', '在Enter password和Reenter password输入相同的口令。\\n', 'grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08为openEuler#12经过grub2-mkpasswd-pbkdf2加密后的输出，每次输出的密文不同。\\n', '\\n', '使用vi工具打开/boot/efi/EFI/openEuler/grub.cfg的开始位置追加如下字段：\\n', '\\n', 'set superusers=\"root\"\\n', 'password_pbkdf2 root grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08\\n', ' 说明：\\n', '\\n', 'superusers字段用于设置GRUB2的超级管理员的帐户名。\\n', 'password_pbkdf2字段后的参数，第1个参数为GRUB2的帐户名，第2个为该帐户的加密口令。\\n', '安全单用户模式\\n', '说明\\n', '单用户模式是以root权限进入系统，如不设置密码，将存在较大安全隐患。\\n', '\\n', '实现\\n', '该设置可以通过修改/etc/sysconfig/init文件内容实现。将SINGLE选项配置为SINGLE=/sbin/sulogin。\\n', '\\n', '禁止交互式启动\\n', '说明\\n', '使用交互式引导，控制台用户可以禁用审计、防火墙或其他服务，削弱了系统安全性。用户可以禁止使用交互式引导，提升安全性。openEuler默认已禁止。\\n', '\\n', '实现\\n', '该设置可以通过修改/etc/sysconfig/init文件内容实现。将PROMPT选项配置为PROMPT=no。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n', '\\n', 'openEuler 是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目\\n', '\\n', 'footerLogo.png\\n', 'contact@openeuler.io\\n', '\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_文件权限.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.html", "text_entry": "['文件权限\\n', '文件权限\\n', '设置文件的权限和属主\\n', '删除无主文件\\n', '处理空链接文件\\n', '设置守护进程的umask值\\n', '为全局可写目录添加粘滞位属性\\n', '删除非授权文件的全局可写属性\\n', '限制at命令的使用权限\\n', '限制cron命令的使用权限\\n', '限制sudo命令的使用权限\\n', '设置文件的权限和属主\\n', '说明\\n', 'Linux将所有对象都当作文件来处理，即使一个目录也被看作是包含有多个其他文件的大文件。因此，Linux中最重要的就是文件和目录的安全性。文件和目录的安全性主要通过权限和属主来保证。\\n', '\\n', 'openEuler默认对系统中的常用目录、可执行文件和配置文件设置了权限和属主。\\n', '\\n', '实现\\n', '以/bin目录为例，修改文件权限和文件属主的操作如下：\\n', '\\n', '修改文件权限。例如将/bin目录权限设置为755。\\n', '\\n', 'chmod 755 /bin\\n', '修改文件属主。例如将/bin目录的拥有者和群组设置为root:root。\\n', '\\n', 'chown root:root /bin\\n', '删除无主文件\\n', '说明\\n', '系统管理员在删除用户/群组时，存在着忘记删除该用户/该群组所拥有文件的问题。如果后续新创建的用户/群组与被删除的用户/群组同名，则新用户/新群组会拥有部分不属于其权限的文件，建议将此类文件删除。\\n', '\\n', '实现\\n', '删除用户ID不存在的文件\\n', '\\n', '查找用户ID不存在的文件。\\n', '\\n', 'find / -nouser\\n', '删除查找到的文件。其中 filename 为用户ID不存在文件的文件名。\\n', '\\n', 'rm -f filename\\n', '删除群组ID不存在的文件\\n', '\\n', '查找群主ID不存在的文件。\\n', '\\n', 'find / -nogroup\\n', '删除查找到的文件。其中 filename 为用户ID不存在文件的文件名。\\n', '\\n', 'rm -f filename\\n', '处理空链接文件\\n', '说明\\n', '无指向的空链接文件，可能会被恶意用户利用，影响系统安全性。建议用户删除无效的空链接文件，提高系统安全性。\\n', '\\n', '特殊场景\\n', 'openEuler系统安装完成后，可能存在空链接文件，这些空链接文件可能有对应用途（有些空链接文件是预制的，会被其他组件依赖）。请用户根据实际环境进行处理，处理方式请参见实现。\\n', '\\n', '例如，openEuler支持UEFI和legacy BIOS两种安装模式，两种引导场景支持的grub相关包默认都安装，当用户选择legacy BIOS模式安装时，形成空链接文件“/etc/grub2-efi.cfg”；当用户选择UEFI模式安装时，会形成空链接文件“/etc/grub2.cfg”，需要用户根据实际情况处理空链接。\\n', '\\n', '实现\\n', '通过如下命令查找系统中的空链接文件。\\n', '\\n', 'find dirname -type l -follow 2>/dev/null\\n', ' 说明：\\n', 'dirname为搜索目录的名称，通常需要关注系统关键目录：/bin、/boot、/usr、/lib64、/lib、/var等。\\n', '\\n', '如果此类文件无实际作用，可通过如下命令删除。\\n', '\\n', 'rm -f filename\\n', ' 说明：\\n', 'filename为步骤1找出的文件名。\\n', '\\n', '设置守护进程的umask值\\n', '说明\\n', 'umask值用来为新创建的文件和目录设置缺省权限。如果没有设定umask值，则生成的文件具有全局可写权限，存在一定的风险。守护进程负责系统上某个服务，让系统可以接受来自用户或者是网络客户的要求。为了提高守护进程所创建文件和目录的安全性，建议设置其umask值为0027。umask值代表的是权限的“补码”，umask值和权限的换算方法请参见 “附录 > umask值含义” 。\\n', '\\n', ' 说明：\\n', 'openEuler默认已设置守护进程的umask值为0022。\\n', '\\n', '实现\\n', '在配置文件/etc/sysconfig/init中新增一行：umask 0027。\\n', '\\n', '为全局可写目录添加粘滞位属性\\n', '说明\\n', '任意用户可以删除、修改全局可写目录中的文件和目录，为了确保全局可写目录中的文件和目录不会被任意删除，需要为全局可写目录添加粘滞位属性。\\n', '\\n', '实现\\n', '搜索全局可写目录。\\n', '\\n', 'find / -type d -perm -0002 ! -perm -1000 -ls | grep -v proc\\n', '为全局可写目录添加粘滞位属性。dirname 为实际查找到的目录名。\\n', '\\n', 'chmod +t dirname\\n', '删除非授权文件的全局可写属性\\n', '说明\\n', '全局可写文件可被系统中的任意用户修改，影响系统完整性。\\n', '\\n', '实现\\n', '列举系统中所有的全局可写文件。\\n', '\\n', 'find / -type d ( -perm -o+w ) | grep -v proc\\n', 'find / -type f ( -perm -o+w ) | grep -v proc\\n', '查看步骤1列举的所有文件(粘滞位位的文件和目录可以排除在外)，删除文件或去掉其全局可写权限。使用以下命令去掉权限，其中filename为对应文件名：\\n', '\\n', 'chmod o-w  filename\\n', ' 说明：\\n', '可通过如下命令确定对应文件或目录是否设置了粘滞位，若回显中包含T标记，则为粘滞位文件或目录。命令中的filename为需要查询文件或目录的名称。\\n', '\\n', 'ls -l filename  \\n', '限制at命令的使用权限\\n', '说明\\n', 'at命令用于创建在指定时间自动执行的任务。为避免任意用户通过at命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户。\\n', '\\n', '实现\\n', '删除/etc/at.deny文件。\\n', '\\n', 'rm -f /etc/at.deny\\n', '将/etc/at.allow的文件属主改为root:root。\\n', '\\n', 'chown root:root /etc/at.allow\\n', '控制/etc/at.allow的文件权限，仅root可操作。\\n', '\\n', 'chmod og-rwx /etc/at.allow\\n', '限制cron命令的使用权限\\n', '说明\\n', 'cron命令用于创建例行性任务。为避免任意用户通过cron命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户。\\n', '\\n', '实现\\n', '删除/etc/cron.deny文件。\\n', '\\n', 'rm -f /etc/cron.deny\\n', '将/etc/cron.allow的文件属主改为root:root。\\n', '\\n', 'chown root:root /etc/cron.allow\\n', '控制/etc/cron.allow的文件权限，仅root可操作。\\n', '\\n', 'chmod og-rwx /etc/cron.allow\\n', '限制sudo命令的使用权限\\n', '说明\\n', 'sudo命令用于普通用户以root权限执行命令。为了增强系统安全性，有必要对sudo命令的使用权进行控制，只允许root使用sudo命令，限制其他帐户使用。openEuler默认未限制非root用户使用sudo命令的权限。\\n', '\\n', '实现\\n', 'sudo命令的使用控制通过修改/etc/sudoers文件实现，需要注释掉如下配置行：\\n', '\\n', '#%wheel ALL=(ALL)       ALL\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_系统服务.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1.html", "text_entry": "['系统服务\\n', '系统服务\\n', '加固SSH服务\\n', '加固SSH服务\\n', '说明\\n', 'SSH（Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性保障的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透过SSH可以对所有传输的数据进行加密，并防止DNS欺骗和IP欺骗。OpenSSH是SSH协议的免费开源实现。\\n', '\\n', '加固SSH服务，是指修改SSH服务中的配置来设置系统使用OpenSSH协议时的算法、认证等参数，从而提高系统的安全性。表1中详细说明了各加固项含义、建议加固值及其默认策略。\\n', '\\n', '实现\\n', '服务端加固操作如下：\\n', '\\n', '打开服务端SSH服务的配置文件/etc/ssh/sshd_config，在该文件中修改或添加对应加固项及其加固值。\\n', '\\n', '保存/etc/ssh/sshd_config文件。\\n', '\\n', '重启SSH服务，命令如下：\\n', '\\n', 'systemctl restart sshd\\n', '客户端加固操作如下：\\n', '\\n', '打开客户端SSH服务的配置文件/etc/ssh/ssh_config，在该文件中修改或添加对应加固项及其加固值。\\n', '\\n', '保存/etc/ssh/ssh_config文件。\\n', '\\n', '重启SSH服务，命令如下：\\n', '\\n', 'systemctl restart sshd\\n', '加固项说明\\n', '服务端加固策略\\n', '\\n', 'SSH服务的所有加固项均保存在配置文件/etc/ssh/sshd_config中，服务端各加固项的含义、加固建议以及openEuler默认是否已经加固为建议加固值请参见表1。\\n', '\\n', '表 1 SSH服务端加固项说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '加固建议\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'Protocol\\n', '\\n', '设置使用SSH协议的版本\\n', '\\n', '2\\n', '\\n', '是\\n', '\\n', 'SyslogFacility\\n', '\\n', '设置SSH服务的日志类型。加固策略将其设置为“AUTH”，即认证类日志\\n', '\\n', 'AUTH\\n', '\\n', '是\\n', '\\n', 'LogLevel\\n', '\\n', '设置记录sshd日志消息的层次\\n', '\\n', 'VERBOSE\\n', '\\n', '是\\n', '\\n', 'X11Forwarding\\n', '\\n', '设置使用SSH登录后，能否使用图形化界面\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'MaxAuthTries\\n', '\\n', '最大认证尝试次数\\n', '\\n', '3\\n', '\\n', '否\\n', '\\n', 'PubkeyAuthentication\\n', '\\n', '设置是否允许公钥认证。\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'RSAAuthentication\\n', '\\n', '设置是否允许只有RSA安全验证\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'IgnoreRhosts\\n', '\\n', '设置是否使用rhosts文件和shosts文件进行验证。rhosts文件和shosts文件用于记录可以访问远程计算机的计算机名及关联的登录名\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'RhostsRSAAuthentication\\n', '\\n', '设置是否使用基于rhosts的RSA算法安全验证。rhosts文件记录可以访问远程计算机的计算机名及关联的登录名\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'HostbasedAuthentication\\n', '\\n', '设置是否使用基于主机的验证。基于主机的验证是指已信任客户机上的任何用户都可以使用SSH连接\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'PermitRootLogin\\n', '\\n', '\\n', '是否允许root帐户直接使用SSH登录系统\\n', '\\n', '说明：\\n', '若需要直接使用root帐户通过SSH登录系统，请修改/etc/ssh/sshd_config文件的PermitRootLogin字段的值为yes。\\n', '\\n', 'no\\n', '\\n', '否\\n', '\\n', 'PermitEmptyPasswords\\n', '\\n', '设置是否允许用口令为空的账号登录\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'PermitUserEnvironment\\n', '\\n', '设置是否解析 ~/.ssh/environment和~/.ssh/authorized_keys中设定的环境变量\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'Ciphers\\n', '\\n', '设置SSH数据传输的加密算法\\n', '\\n', 'aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com,aes128-gcm@openssh.com,aes256-gcm@openssh.com\\n', '\\n', '是\\n', '\\n', 'ClientAliveCountMax\\n', '\\n', '设置超时次数。服务器发出请求后，客户端没有响应的次数达到一定值，连接自动断开\\n', '\\n', '0\\n', '\\n', '否\\n', '\\n', 'Banner\\n', '\\n', '指定登录SSH前后显示的提示信息的文件\\n', '\\n', '/etc/issue.net\\n', '\\n', '是\\n', '\\n', 'MACs\\n', '\\n', '设置SSH数据校验的哈希算法\\n', '\\n', 'hmac-sha2-512,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-256-etm@openssh.com\\n', '\\n', '是\\n', '\\n', 'StrictModes\\n', '\\n', '设置SSH在接收登录请求之前是否检查用户HOME目录和rhosts文件的权限和所有权\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'UsePAM\\n', '\\n', '使用PAM登录认证\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'AllowTcpForwarding\\n', '\\n', '设置是否允许TCP转发\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'Subsystem sftp /usr/libexec/openssh/sftp-server\\n', '\\n', 'sftp日志记录级别，记录INFO级别以及认证日志。\\n', '\\n', '-l INFO -f AUTH\\n', '\\n', '是\\n', '\\n', 'AllowAgentForwarding\\n', '\\n', '设置是否允许SSH Agent转发\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'GatewayPorts\\n', '\\n', '设置是否允许连接到转发客户端端口\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'PermitTunnel\\n', '\\n', 'Tunnel设备是否允许使用\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'KexAlgorithms\\n', '\\n', '设置SSH密钥交换算法\\n', '\\n', 'curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256\\n', '\\n', '  \\n', 'LoginGraceTime\\n', '\\n', '限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 60 秒。\\n', '\\n', '60\\n', '\\n', '否\\n', '\\n', ' 说明：\\n', '默认情况下，登录SSH前后显示的提示信息保存在/etc/issue.net文件中，/etc/issue.net默认信息为“Authorized users only. All activities may be monitored and reported.”。\\n', '\\n', '客户端加固策略\\n', '\\n', 'SSH服务的所有加固项均保存在配置文件/etc/ssh/ssh_config中，客户端各加固项的含义、加固建议以及openEuler默认是否已经加固为建议加固值请参见表2。\\n', '\\n', '表 2 SSH客户端加固项说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '加固建议\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'KexAlgorithms\\n', '\\n', '设置SSH密钥交换算法\\n', '\\n', 'ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256\\n', '\\n', '否\\n', '\\n', 'VerifyHostKeyDNS\\n', '\\n', '是否使用DNS或者SSHFP资源记录验证HostKey\\n', '\\n', 'ask\\n', '\\n', '否\\n', '\\n', ' 说明：\\n', '对于使用dh算法进行密钥交换的第三方客户端和服务端工具，要求允许建立连接的最低长度为2048bits。\\n', '\\n', '其他安全建议\\n', 'SSH服务仅侦听指定IP地址\\n', '\\n', '出于安全考虑，建议用户在使用SSH服务时，仅在必需的IP上进行绑定侦听，而不是侦听0.0.0.0，可修改/etc/ssh/sshd_config文件中的ListenAddress配置项。\\n', '\\n', '打开并修改/etc/ssh/sshd_config文件\\n', '\\n', 'vi /etc/ssh/sshd_config\\n', '修改内容如下，表示绑定侦听IP为 192.168.1.100，用户可根据实际情况修改需要侦听的IP\\n', '\\n', '...\\n', 'ListenAddress 192.168.1.100\\n', '...\\n', '重启SSH服务\\n', '\\n', 'systemctl restart sshd.service\\n', '限制SFTP用户向上跨目录访问\\n', '\\n', 'SFTP是FTP over SSH的安全FTP协议，对于访问SFTP的用户建议使用专用账号，只能上传或下载文件，不能用于SSH登录，同时对SFTP可以访问的目录进行限定，防止目录遍历攻击，具体配置如下：\\n', '\\n', ' 说明：\\n', 'sftpgroup为示例用户组，sftpuser为示例用户名。\\n', '\\n', '创建SFTP用户组\\n', '\\n', 'groupadd sftpgroup\\n', '创建SFTP根目录\\n', '\\n', 'mkdir /sftp\\n', '修改SFTP根目录属主和权限\\n', '\\n', 'chown root:root /sftp\\n', 'chmod 755 /sftp\\n', '创建SFTP用户\\n', '\\n', 'useradd -g sftpgroup -s /sbin/nologin sftpuser\\n', '设置SFTP用户的口令\\n', '\\n', 'passwd sftpuser\\n', '创建SFTP用户上传目录\\n', '\\n', 'mkdir /sftp/sftpuser\\n', '修改SFTP用户上传目录属主和权限\\n', '\\n', 'chown root:root /sftp/sftpuser\\n', 'chmod 777 /sftp/sftpuser\\n', '修改/etc/ssh/sshd_config文件\\n', '\\n', 'vi /etc/ssh/sshd_config\\n', '修改内容如下：\\n', '\\n', '#Subsystem sftp /usr/libexec/openssh/sftp-server -l INFO -f AUTH\\n', 'Subsystem sftp internal-sftp -l INFO -f AUTH\\n', '...\\n', '\\n', 'Match Group sftpgroup                  \\n', '    ChrootDirectory /sftp/%u\\n', '    ForceCommand internal-sftp\\n', ' 说明：\\n', '\\n', '%u代表当前sftp用户的用户名，这是一个通配符，用户原样输入即可。\\n', '以下内容必须加在/etc/ssh/sshd_config文件的末尾。\\n', '  Match Group sftpgroup                    \\n', '    ChrootDirectory /sftp/%u  \\n', '    ForceCommand internal-sftp  \\n', '重启SSH服务\\n', '\\n', 'systemctl restart sshd.service\\n', 'SSH远程执行命令\\n', '\\n', 'OpenSSH通用机制，在远程执行命令时，默认不开启tty，如果执行需要密码的命令，密码会明文回显。出于安全考虑，建议用户增加-t选项，确保密码输入安全。如下：\\n', '\\n', 'ssh -t testuser@192.168.1.100 su\\n', ' 说明：\\n', '192.168.1.100为示例IP，testuser为示例用户。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_账户口令.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E5%B8%90%E6%88%B7%E5%8F%A3%E4%BB%A4.html", "text_entry": "['帐户口令\\n', '帐户口令\\n', '屏蔽系统帐户\\n', '限制使用su命令的帐户\\n', '设置口令复杂度\\n', '设置口令有效期\\n', '设置口令的加密算法\\n', '登录失败超过三次后锁定\\n', '加固su命令\\n', '屏蔽系统帐户\\n', '说明\\n', '除了用户帐户外，其他账号称为系统帐户。系统帐户仅系统内部使用，禁止用于登录系统或其他操作，因此屏蔽系统帐户。\\n', '\\n', '实现\\n', '将系统帐户的Shell修改为/sbin/nologin。\\n', '\\n', 'usermod -L -s /sbin/nologin $systemaccount\\n', ' 说明：\\n', '$systemaccount 指系统帐户。\\n', '\\n', '限制使用su命令的帐户\\n', '说明\\n', 'su命令用于在不同帐户之间切换。为了增强系统安全性，有必要对su命令的使用权进行控制，只允许root和wheel群组的帐户使用su命令，限制其他帐户使用。\\n', '\\n', '实现\\n', 'su命令的使用控制通过修改/etc/pam.d/su文件实现，配置如下：\\n', '\\n', 'auth         required      pam_wheel.so use_uid\\n', '表 1 pam_wheel.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'use_uid\\n', '\\n', '基于当前帐户的uid。\\n', '\\n', '设置口令复杂度\\n', '说明\\n', '用户可以通过修改对应配置文件设置口令的复杂度要求，建议用户根据实际情况设置口令复杂度。\\n', '\\n', '实现\\n', '口令复杂度通过/etc/pam.d/password-auth和/etc/pam.d/system-auth文件中的pam_pwquality.so和pam_pwhistory.so模块实现。用户可以通过修改这两个模块中的配置项修改口令复杂度要求。\\n', '\\n', '设置举例\\n', '这里给出一个配置口令复杂度的例子，供用户参考。\\n', '\\n', '密码复杂度要求\\n', '\\n', '口令长度至少8个字符。\\n', '\\n', '口令必须包含如下至少3种字符的组合：\\n', '\\n', '－至少一个小写字母\\n', '\\n', '－至少一个大写字母\\n', '\\n', '－至少一个数字\\n', '\\n', '－至少一个特殊字符：`~!@#$%^&*()-_=+\\\\|[{}];:\\'\",<.>/?和空格\\n', '\\n', '口令不能和帐号或者帐号的倒写一样。\\n', '\\n', '不能修改为过去5次使用过的旧口令。\\n', '\\n', '配置实现\\n', '\\n', '在/etc/pam.d/password-auth和/etc/pam.d/system-auth文件中password配置项的前两行添加如下配置内容：\\n', '\\n', 'password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0 \\n', 'password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root\\n', '配置项说明\\n', '\\n', 'pam_pwquality.so和pam_pwhistory.so的配置项请分别参见表2和表3。\\n', '\\n', '表 2 pam_pwquality.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'minlen=8\\n', '\\n', '口令长度至少包含8个字符\\n', '\\n', 'minclass=3\\n', '\\n', '口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种\\n', '\\n', 'ucredit=0\\n', '\\n', '口令包含任意个大写字母\\n', '\\n', 'lcredit=0\\n', '\\n', '口令包含任意个小写字母\\n', '\\n', 'dcredit=0\\n', '\\n', '口令包含任意个数字\\n', '\\n', 'ocredit=0\\n', '\\n', '口令包含任意个特殊字符\\n', '\\n', 'retry=3\\n', '\\n', '每次修改最多可以尝试3次\\n', '\\n', 'enforce_for_root\\n', '\\n', '本设置对root帐户同样有效\\n', '\\n', '表 3 pam_pwhistory.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'remember=5\\n', '\\n', '口令不能修改为过去5次使用过的旧口令\\n', '\\n', 'enforce_for_root\\n', '\\n', '本设置对root帐户同样有效\\n', '\\n', '设置口令有效期\\n', '说明\\n', '出于系统安全性考虑，建议设置口令有效期限，且口令到期前通知用户更改口令。\\n', '\\n', '实现\\n', '口令有效期的设置通过修改/etc/login.defs文件实现，加固项如表7所示。表中所有的加固项都在文件/etc/login.defs中。表中字段直接通过修改配置文件完成。\\n', '\\n', '表 4 login.defs配置项说明所示\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '建议加固\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'PASS_MAX_DAYS\\n', '\\n', '口令最大有效期\\n', '\\n', '90\\n', '\\n', '否\\n', '\\n', 'PASS_MIN_DAYS\\n', '\\n', '两次修改口令的最小间隔时间\\n', '\\n', '0\\n', '\\n', '否\\n', '\\n', 'PASS_WARN_AGE\\n', '\\n', '口令过期前开始提示天数\\n', '\\n', '7\\n', '\\n', '否\\n', '\\n', ' 说明：\\n', 'login.defs是设置用户帐号限制的文件，可配置口令的最大过期天数、最大长度约束等。该文件里的配置对root用户无效。如果/etc/shadow文件里有相同的选项，则以/etc/shadow配置为准，即/etc/shadow的配置优先级高于/etc/login.defs。口令过期后用户重新登录时，提示口令过期并强制要求修改，不修改则无法进入系统。\\n', '\\n', '设置口令的加密算法\\n', '说明\\n', '出于系统安全考虑，口令不允许明文存储在系统中，应该加密保护。在不需要还原口令的场景，必须使用不可逆算法加密。设置口令的加密算法为sha512，openEuler默认已设置。通过上述设置可以有效防范口令泄露，保证口令安全。\\n', '\\n', '实现\\n', '口令的加密算法设置通过修改/etc/pam.d/password-auth和/etc/pam.d/system-auth文件实现，添加如下配置：\\n', '\\n', 'password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok\\n', '表 5 pam_unix.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'sha512\\n', '\\n', '使用sha512算法对口令加密。\\n', '\\n', '登录失败超过三次后锁定\\n', '说明\\n', '为了保障用户系统的安全，建议用户设置口令出错次数的阈值（建议3次），以及由于口令尝试被锁定用户的自动解锁时间（建议300秒）。\\n', '\\n', '用户锁定期间，任何输入被判定为无效，锁定时间不因用户的再次输入而重新计时；解锁后，用户的错误输入记录被清空。通过上述设置可以有效防范口令被暴力破解，增强系统的安全性。\\n', '\\n', ' 说明：\\n', 'openEuler默认口令出错次数的阈值为3次，系统被锁定后自动解锁时间为60秒。\\n', '\\n', '实现\\n', '口令复杂度的设置通过修改/etc/pam.d/password-auth和/etc/pam.d/system-auth文件实现，设置口令最大的出错次数3次，系统锁定后的解锁时间为300秒的配置如下：\\n', '\\n', 'auth        required      pam_faillock.so preauth audit deny=3 even_deny_root unlock_time=300\\n', 'auth        [default=die] pam_faillock.so authfail audit deny=3 even_deny_root unlock_time=300\\n', 'auth        sufficient    pam_faillock.so authsucc audit deny=3 even_deny_root unlock_time=300\\n', '表 6 pam_faillock.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'authfail\\n', '\\n', '捕获用户登录失败的事件。\\n', '\\n', 'deny=3\\n', '\\n', '用户连续登录失败次数超过3次即被锁定。\\n', '\\n', 'unlock_time=300\\n', '\\n', '普通用户自动解锁时间为300秒（即5分钟）。\\n', '\\n', 'even_deny_root\\n', '\\n', '同样限制root帐户。\\n', '\\n', '加固su命令\\n', '说明\\n', '为了增强系统安全性，防止使用“su”切换用户时将当前用户环境变量带入其他环境，openEuler默认已做配置。总是在使用su切换用户时初始化PATH。\\n', '\\n', '实现\\n', '通过修改/etc/login.defs实现，配置如下：\\n', '\\n', 'ALWAYS_SET_PATH=yes']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_安全加固工具.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%B7%A5%E5%85%B7.html", "text_entry": "['安全加固工具\\n', '安全加固工具\\n', '加固操作\\n', '加固生效\\n', '加固操作\\n', '概述\\n', '安全加固工具会根据usr-security.conf设置加固策略，使用加固工具设置加固策略需要用户修改usr-security.conf。本节介绍usr-security.conf的修改规则。用户可配置的加固项请参见加固指导对应内容。\\n', '\\n', '注意事项\\n', '修改配置后，需要重启安全加固服务使配置生效。重启方法请参见加固生效对应内容。\\n', '用户修改加固配置时，仅修改/etc/openEuler_security/usr-security.conf文件，不建议修改/etc/openEuler_security/security.conf。security.conf中为基本加固项，仅运行一次。\\n', '当重启安全加固服务使配置生效后，在usr-security.conf中删除对应加固项并重启安全加固服务并不能清除之前的配置。\\n', '安全加固操作记录在日志文件/var/log/openEuler-security.log中。\\n', '配置格式\\n', 'usr-security.conf中的每一行代表一项配置，根据配置内容的不同有不同配置格式，这里给出各类配置的格式说明。\\n', '\\n', ' 说明：\\n', '\\n', '所有配置项以执行ID开头，执行ID仅为了方便用户识别配置内容，取值为正整数，由用户自行定义。\\n', '配置项的各内容之间使用@作为分隔符。\\n', '若实际配置内容中包含@，需要使用@@表示以和分隔符区分，例如实际内容为xxx@yyy，则配置为xxx@@yyy。目前不支持@位于配置内容的开头和结尾。\\n', 'd：注释\\n', '\\n', '格式：执行ID@d@对象文件@匹配项\\n', '\\n', '功能：将对象文件中以匹配项开头（行首可以有空格）的行注释（在行首添加#）。\\n', '\\n', '示例：执行ID为401，注释/etc/sudoers文件中以%wheel开头的行。\\n', '\\n', '401@d@/etc/sudoers@%wheel\\n', 'm：替换\\n', '\\n', '格式：执行ID@m@对象文件@匹配项@替换目标值\\n', '\\n', '功能：将对象文件中以匹配项开头（行首可以有空格）的行替换为“匹配项加替换目标值 ”。若匹配行开头有空格，替换后将删除这些空格。\\n', '\\n', '示例：执行ID为101，将/etc/ssh/sshd_config文件中以Protocol 开头的行替换为Protocol 2。匹配和替换时也会考虑Protocol后的空格。\\n', '\\n', '101@m@/etc/ssh/sshd_config@Protocol @2\\n', 'sm：精确修改\\n', '\\n', '格式：执行ID@sm@对象文件@匹配项@替换目标值\\n', '\\n', '功能：将对象文件中以匹配项开头（行首可以有空格）的行替换为“匹配项加替换目标值 ”。若匹配行开头有空格，替换后将保留这些空格，这是sm和m的区别。\\n', '\\n', '示例：执行ID为201，将/etc/audit/hzqtest文件中以size开头的行替换为size 2048。\\n', '\\n', '201@sm@/etc/audit/hzqtest@size@ 2048\\n', 'M：修改子项\\n', '\\n', '格式：执行ID@M@对象文件@匹配项@匹配子项[@匹配子项的值]\\n', '\\n', '功能：匹配对象文件中以匹配项开头（行首可以有空格）的行，并将该行中以匹配子项开始的内容替换为“匹配子项和匹配子项的值”，其中匹配子项的值可选。\\n', '\\n', '示例：执行ID为101，找到file文件中以key开头的行，并将这些行中以key2开始的内容替换为key2value2。\\n', '\\n', '101@M@file@key@key2@value2\\n', 'systemctl：管理服务\\n', '\\n', '格式：执行ID@systemctl@对象服务@具体操作\\n', '\\n', '功能：使用systemctl管理对象服务，具体操作可取值为start、stop、restart、disable等systemctl所有可用的命令。\\n', '\\n', '示例：执行ID为218，停止cups.service服务，等同于systemctl stop cups.service的配置行。\\n', '\\n', '218@systemctl@cups.service@stop\\n', '其他命令\\n', '\\n', '格式：执行ID@命令@对象文件\\n', '\\n', '功能：执行对应命令，即执行命令行“命令 对象文件”。\\n', '\\n', '示例一：执行ID为402，使用rm -f命令删除文件/etc/pki/ca-trust/extracted/pem/email-ca-bundle.pem。\\n', '\\n', '402@rm -f @/etc/pki/ca-trust/extracted/pem/email-ca-bundle.pem\\n', '示例二：执行ID为215，使用touch命令创建文件/etc/cron.allow。\\n', '\\n', '215@touch @/etc/cron.allow\\n', '示例三：执行ID为214，使用chown命令将文件/etc/at.allow的属主改为root:root。\\n', '\\n', '214@chown root:root @/etc/at.allow\\n', '示例四：执行ID为214，使用chmod命令去除文件/etc/at.allow属主所在群组及其他非属主用户的rwx权限。\\n', '\\n', '214@chmod og-rwx @/etc/at.allow\\n', '加固生效\\n', '完成修改usr-security.conf文件后，请运行如下命令使新添加的配置生效。\\n', '\\n', 'systemctl restart openEuler-security.service\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_操作系统加固概述.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA%E6%A6%82%E8%BF%B0.html", "text_entry": "['操作系统加固概述\\n', '介绍对openEuler系统进行加固的目的和加固方案。\\n', '\\n', '操作系统加固概述\\n', '加固目的\\n', '加固方案\\n', '加固影响\\n', '须知\\n', '由于安全加固对系统至关重要，因此只有root用户允许修改并应用安全加固策略。\\n', '\\n', '加固目的\\n', '操作系统作为信息系统的核心，承担着管理硬件资源和软件资源的重任，是整个信息系统安全的基础。操作系统之上的各种应用，要想获得信息的完整性、机密性、可用性和可控性，必须依赖于操作系统。脱离了对操作系统的安全保护，仅依靠其他层面的防护手段来阻止黑客和病毒等对网络信息系统的攻击，是无法满足安全需求的。\\n', '\\n', '因此，需要对操作系统进行安全加固，构建动态、完整的安全体系，增强产品的安全性，提升产品的竞争力。\\n', '\\n', '加固方案\\n', '本章描述openEuler的安全加固方案，包括加固方式和加固内容。\\n', '\\n', '加固方式\\n', '用户可以通过手动修改加固配置或执行相关命令对系统进行加固，也可以通过加固工具批量修改加固项。openEuler的安全加固工具security tool以openEuler-security.service服务的形式运行。系统首次启动时会自动运行该服务去执行默认加固策略，且自动设置后续开机不启动该服务。\\n', '\\n', '用户可以通过修改security.conf，使用安全加固工具实现个性化安全加固的效果。\\n', '\\n', '加固内容\\n', 'openEuler系统加固内容主要分为以下5个部分：\\n', '\\n', '系统服务\\n', '文件权限\\n', '内核参数\\n', '授权认证\\n', '账号口令\\n', '加固影响\\n', '对文件权限、帐户口令等安全加固，可能造成用户使用习惯变更，从而影响系统的易用性。影响系统易用性的常见加固项请参见表1。\\n', '\\n', '表 1 加固影响说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '建议加固\\n', '\\n', '易用性影响\\n', '\\n', 'openEuler默认是否设置了该加固项\\n', '\\n', '字符界面等待超时限制\\n', '\\n', '当字符界面长时间处在空闲状态，字符界面会自动退出。\\n', '\\n', '说明：\\n', '当用户通过SSH登录，超时时间由/etc/profile文件的TMOUT字段和/etc/ssh/sshd_config文件的ClientAliveInterval字段两个值中较小的值决定。建议加固为300秒。\\n', '\\n', '用户长时间不操作字符界面，字符界面会自动退出。\\n', '\\n', '否\\n', '\\n', '口令复杂度限制\\n', '\\n', '口令长度最小为8位，口令至少包含大写字母、小写字母、数字和特殊字符中的3种。\\n', '\\n', '系统中所有用户不能设置简单的口令，口令必须符合复杂度要求。\\n', '\\n', '否\\n', '\\n', '限定登录失败时的尝试次数\\n', '\\n', '当用户登录系统时，口令连续输错3次，帐户将被锁定60秒，锁定期间不能登录系统。\\n', '\\n', '用户不能随意登录系统，帐户被锁定后必须等待60秒。\\n', '\\n', '是\\n', '\\n', '用户默认umask值限制\\n', '\\n', '设置所有用户的默认umask值为077，使用户创建文件的默认权限为600、目录权限为700。\\n', '\\n', '用户需要按照需求修改指定文件或目录的权限。\\n', '\\n', '是\\n', '\\n', '口令有效期\\n', '\\n', '口令有效期的设置通过修改/etc/login.defs文件实现，加固默认值为口令最大有效期90天，两次修改口令的最小间隔时间为0，口令过期前开始提示天数为7。\\n', '\\n', '口令过期后用户重新登录时，提示口令过期并强制要求修改，不修改则无法进入系统。\\n', '\\n', '否\\n', '\\n', 'su权限限制\\n', '\\n', 'su命令用于在不同帐户之间切换。为了增强系统安全性，有必要对su命令的使用权进行控制，只允许root和wheel群组的帐户使用su命令，限制其他帐户使用。\\n', '\\n', '普通帐户执行su命令失败，必须加入wheel群组才可以su成功。\\n', '\\n', '是\\n', '\\n', '禁止root帐户直接SSH登录系统\\n', '\\n', '设置/etc/ssh/sshd_config文件的PermitRootLogin字段的值为no，用户无法使用root帐户直接SSH登录系统。\\n', '\\n', '用户需要先使用普通帐户SSH登录后，再切换至root帐户。\\n', '\\n', '否\\n', '\\n', 'SSH强加密算法\\n', '\\n', 'SSH服务的MACs和Ciphers配置，禁止对CBC、MD5、SHA1算法的支持，修改为CTR、SHA2算法。\\n', '\\n', '当前Windows下使用的部分低版本的Xshell、PuTTY不支持aes128-ctr、aes192-ctr、aes256-ctr、hmac-sha2-256、hmac-sha2-512算法，可能会出现无法通过SSH登录系统的情况，请使用最新的PuTTY（0.63版本以上）、Xshell（5.0版本及以上版本）登录。\\n', '\\n', '是']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_FAQ.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/FAQ.html", "text_entry": "['FAQ\\n', '安装openEuler时选择第二盘位为安装目标，操作系统无法启动\\n', '问题现象\\n', '安装操作系统时，直接将系统安装到第二块磁盘sdb，重启系统后启动失败。\\n', '\\n', '原因分析\\n', '当安装系统到第二块磁盘时，MBR和GRUB会默认安装到第二块磁盘sdb。这样会有下面两种情况：\\n', '\\n', '如果第一块磁盘中有完整系统，则加载第一块磁盘中的系统启动。\\n', '如果第一块磁盘中没有完好的操作系统，则会导致硬盘启动失败。\\n', '以上两种情况都是因为BIOS默认从第一块磁盘sda中加载引导程序启动系统，如果sda没有系统，则会导致启动失败。\\n', '\\n', '解决方法\\n', '有以下两种解决方案：\\n', '\\n', '当系统处于安装过程中，在选择磁盘（选择第一块或者两块都选择）后，指定引导程序安装到第一块盘sda中。\\n', '当系统已经安装完成，若BIOS支持选择从哪个磁盘启动，则可以通过修改BIOS中磁盘启动顺序，尝试重新启动系统。\\n', 'openEuler开机后进入emergency模式\\n', '问题现象\\n', 'openEuler系统开机后进入emergency模式，如下图所示：\\n', '\\n', '\\n', '\\n', '原因分析\\n', '操作系统文件系统损坏导致磁盘挂载失败，或者io压力过大导致磁盘挂载超时（超时时间为90秒）。\\n', '\\n', '系统异常掉电、物理磁盘io性能低等情况都可能导致该问题。\\n', '\\n', '解决方法\\n', '用户直接输入root账号的密码，登录系统。\\n', '\\n', '使用fsck工具，检测并修复文件系统，然后重启。\\n', '\\n', ' 说明：\\n', 'fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。 用户可以通过“fsck.ext3 -h”、“fsck.ext4 -h”命令查看fsck的使用方法。\\n', '\\n', '另外，如果用户需要取消磁盘挂载超时时间，可以直接在“/etc/fstab”文件中添加“x-systemd.device-timeout=0”。如下：\\n', '\\n', '#\\n', '# /etc/fstab\\n', '# Created by anaconda on Mon Sep 14 17:25:48 2015\\n', '#\\n', \"# Accessible filesystems, by reference, are maintained under '/dev/disk'\\n\", '# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info\\n', '#\\n', '/dev/mapper/openEuler-root / ext4 defaults,x-systemd.device-timeout=0 0 0\\n', 'UUID=afcc811f-4b20-42fc-9d31-7307a8cfe0df /boot ext4 defaults,x-systemd.device-timeout=0 0 0\\n', '/dev/mapper/openEuler-home /home ext4 defaults 0 0\\n', '/dev/mapper/openEuler-swap swap swap defaults 0 0\\n', '系统中存在无法激活的逻辑卷组时，重装系统失败\\n', '问题现象\\n', '由于磁盘故障，系统中存在无法激活的逻辑卷组，重装系统出现异常。\\n', '\\n', '原因分析\\n', '安装时有激活逻辑卷组的操作，无法激活时会提示异常。\\n', '\\n', '解决方法\\n', '重装系统前如果系统中存在无法激活的逻辑卷组，为了避免重装系统过程出现异常，需在重装前将逻辑卷组恢复到正常状态或者清除这些逻辑卷组。举例如下：\\n', '\\n', '恢复逻辑卷组状态\\n', '\\n', \"使用以下命令清除vg激活状态， 防止出现“Can't open /dev/sdc exclusively mounted filesystem”。\\n\", '\\n', ' vgchange -a n testvg32947\\n', '根据备份文件重新创建pv。\\n', '\\n', 'pvcreate --uuid JT7zlL-K5G4-izjB-3i5L-e94f-7yuX-rhkLjL --restorefile /etc/lvm/backup/testvg32947 /dev/sdc\\n', '恢复vg信息。\\n', '\\n', 'vgcfgrestore testvg32947\\n', '重新激活vg。\\n', '\\n', ' vgchange -ay testvg32947\\n', '清除逻辑卷组\\n', '\\n', 'vgchange -a n testvg32947\\n', 'vgremove -y testvg32947\\n', '选择安装源出现异常\\n', '问题现象\\n', '选择安装源后出现：“Error checking software selection”。\\n', '\\n', '原因分析\\n', '这种现象是由于安装源中的软件包依赖存在问题。\\n', '\\n', '解决方法\\n', '检查安装源是否存在异常。如果异常，使用新的安装源。\\n', '\\n', '如何手动开启kdump服务\\n', '问题现象\\n', '执行systemctl status kdump命令，显示状态信息如下，提示无预留内存。\\n', '\\n', '\\n', '\\n', '原因分析\\n', 'kdump服务需要系统预留一段内存用于运行kdump内核，而当前系统没有为kdump服务预留内存，所以无法运行kdump服务。\\n', '\\n', '解决方法\\n', '已安装操作系统的场景\\n', '\\n', '修改/boot/efi/EFI/openEuler/grub.cfg，添加crashkernel=1024M,high。\\n', '\\n', '重启系统使配置生效。\\n', '\\n', '执行如下命令，检查kdump状态：\\n', '\\n', 'systemctl status kdump\\n', '若回显如下，即kdump的状态为active，说明kdump已使能，操作结束。\\n', '\\n', '\\n', '\\n', '参数说明\\n', 'kdump内核预留内存参数说明如下：\\n', '\\n', '表 1 crashkernel参数说明\\n', '\\n', '\\n', '内核启动参数\\n', '\\n', '描述\\n', '\\n', '默认值\\n', '\\n', '备注\\n', '\\n', 'crashkernel=X\\n', '\\n', '在4G以下的物理内存预留X大小的内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整\\n', '\\n', '该配置方法只在4G以下内存预留，必须保证4G以下连续可用内存足够预留\\n', '\\n', 'crashkernel=X@Y\\n', '\\n', '在Y起始地址预留X大小的内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整\\n', '\\n', '需要确保Y起始地址的X大小内存未被其他模块预留\\n', '\\n', 'crashkernel=X,high\\n', '\\n', '在4G以下的物理内存中预留256M大小，在4G以上预留X大小内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整，推荐值为1024M,high\\n', '\\n', '确保4G以下内存有256M连续可用内存，4G以上有连续X大小内存可预留。实际预留内存大小为256M+X\\n', '\\n', 'crashkernel=X,low\\n', '\\n', 'crashkernel=Y,high\\n', '\\n', '在4G以下的物理内存中预留X大小，在4G以上预留Y大小内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整\\n', '\\n', '需要确保4G以下有X大小连续可用内存，4G以上有Y大小连续可用内存。实际预留内存大小为X+Y\\n', '\\n', '多块磁盘组成逻辑卷安装系统后，再次安装不能只选其中一块磁盘\\n', '问题现象\\n', '在安装系统时，如果之前的系统选择多块磁盘组成逻辑卷进行安装，再次安装时，如果只选择了其中的一块或几块磁盘，没有全部选择，在保存配置时提示配置错误，如图1所示。\\n', '\\n', '图 1 配置错误提示\\n', '\\n', '\\n', '原因分析\\n', '之前的逻辑卷包含了多块磁盘，只在一块磁盘上安装会破坏逻辑卷。\\n', '\\n', '解决方法\\n', '因为多块磁盘组成逻辑卷相当于一个整体，所以只需要删除对应的卷组即可。\\n', '\\n', '按“Ctrl+Alt+F2”可以切换到命令行，执行如下命令找到卷组。\\n', '\\n', 'vgs\\n', '\\n', '\\n', '执行如下命令，删除卷组。\\n', '\\n', 'vgremove euleros\\n', '执行如下命令，重启安装程序即可生效。\\n', '\\n', 'systemctl restart anaconda\\n', ' 说明：\\n', '图形模式下也可以按“Ctrl+Alt+F6”回到图形界面，点击图1右下角的“Refresh”刷新存储配置生效。\\n', '\\n', 'x86物理机UEFI模式由于Secure Boot安全选项问题无法安装\\n', '问题现象\\n', 'x86物理机安装系统时，由于设置了BIOS选项Secure Boot 为enable（默认是disable），导致系统一直停留在“No bootable device”提示界面，无法继续安装，如图2所示。\\n', '\\n', '图 2 “No bootable device”提示界面\\n', '\\n', '\\n', '原因分析\\n', '开启Secure Boot后，主板会验证引导程序及操作系统 ，若没有用对应的私钥进行签名，则无法通过主板上内置公钥的认证。\\n', '\\n', '解决方法\\n', '进入BIOS，设置Secure Boot为disable，重新安装即可。\\n', '\\n', '系统启动时，按“F11”，输入密码“Admin@9000”进入BIOS。\\n', '\\n', '\\n', '\\n', '选择进入Administer Secure Boot。\\n', '\\n', '\\n', '\\n', '设置Enforce Secure Boot为Disabled。\\n', '\\n', '\\n', '\\n', ' 说明：\\n', '设置Secure Boot为disable之后，保存退出，重新安装即可。\\n', '\\n', '安装openEuler时，软件选择页面选择“服务器-性能工具”，安装后messages日志有pmie_check报错信息\\n', '问题现象\\n', '安装系统时软件选择勾选服务器-性能工具，会安装pcp相关软件包，正常安装并重启后，/var/log/messages日志文件中会产生报错：pmie_check failed in /usr/share/pcp/lib/pmie。\\n', '\\n', '原因分析\\n', 'anaconda不支持在chroot环境中安装selinux策略模块，当安装pcp-selinux时，postin脚本安装pcp相关selinux策略模块执行失败，从而导致重启后产生报错。\\n', '\\n', '解决办法\\n', '完成安装并重启后，以下方法选择其一。\\n', '\\n', '执行如下命令，安装selinux策略模块pcpupstream\\n', '\\n', '/usr/libexec/pcp/bin/selinux-setup /var/lib/pcp/selinux install \"pcpupstream\"\\n', '重新安装pcp-selinux\\n', '\\n', 'sudo dnf reinstall pcp-selinux\\n', '在两块已经安装了系统的磁盘上进行重复选择，并自定义分区时，安装失败\\n', '问题现象\\n', '用户在安装操作系统过程中，存在两块都已经安装过的磁盘，此时如果先选择一块盘，进行自定义分区，然后点击取消按钮，再选择第二块盘，并进行自定义分区时，会出现安装失败。\\n', '\\n', ' \\n', '\\n', '原因分析\\n', '用户存在两次选择磁盘的操作，当前点击取消后，再选择第二块磁盘，磁盘信息不正确，导致安装失败。\\n', '\\n', '解决方法\\n', '直接选择目标磁盘进行自定义分区，请勿频繁取消操作，如果一定要进行取消重选建议重新安装。\\n', '\\n', 'issue访问链接\\n', 'https://gitee.com/src-openeuler/anaconda/issues/I29P84?from=project-issue\\n', '\\n', '安装LSI MegaRAID卡的物理机kdump无法生成vmcore\\n', '问题现象\\n', '部署好kdump服务后，手动执行echo c > /proc/sysrq-trigger命令或由于kernel故障导致kernel宕机，触发kdump启动second kernel过程中，MegaRAID驱动报错“BRCM Debug mfi stat 0x2d，data len requested/completed 0x200/0x0”，报错信息如下图，最终导致无法生成vmcore。\\n', '\\n', '\\n', '\\n', '原因分析\\n', '由于默认配置了reset_devices启动参数，second kernel启动过程中会触发设备复位(reset_devices)操作，设备复位操作导致MegaRAID控制器或磁盘状态故障，转储vmcore文件时访问MegaRAID卡的磁盘报错，进而无法生成vmcore。\\n', '\\n', '解决方法\\n', '在物理机etc/sysconfig/kdump文件中将second kernel默认启动参数reset_devices删除，可以规避second kernel启动过程中由于MegaRAID卡驱动复位设备所致IO请求未完成问题，以成功生成vmcore。 ']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_使用kickstart自动化安装.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E4%BD%BF%E7%94%A8kickstart%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85.html", "text_entry": "['使用kickstart自动化安装\\n', '使用kickstart自动化安装\\n', '总体介绍\\n', '概述\\n', '优缺点对比\\n', '背景知识\\n', '半自动化安装指导\\n', '环境要求\\n', '操作步骤\\n', '全自动化安装指导\\n', '环境要求\\n', '操作步骤\\n', '总体介绍\\n', '概述\\n', '用户可以使用kickstart工具进行openEuler系统的自动化安装，包括如下两种方式：\\n', '\\n', '半自动化安装：安装人员不需要手动设定操作系统的键盘、语言、分区等具体属性（通过kickstart实现自动化），但是需要手动指定kickstart文件的位置。\\n', '全自动化安装：实现操作系统的安装过程全自动化。\\n', '优缺点对比\\n', '使用kickstart工具进行半自动化安装和全自动化安装的优缺点对比如表1所示，用户可以自行选择安装方式。\\n', '\\n', '表 1 优缺点对比\\n', '\\n', '\\n', '安装方式\\n', '\\n', '优点\\n', '\\n', '缺点\\n', '\\n', '半自动化安装\\n', '\\n', '不需要准备tftp，pxe，dhcp等服务\\n', '\\n', '需要手动指定kickstart文件的位置\\n', '\\n', '全自动化安装\\n', '\\n', '操作系统的全自动化安装\\n', '\\n', '需要配置tftp，dhcpd，pxe等服务\\n', '\\n', '背景知识\\n', 'kickstart\\n', '\\n', 'kickstart是一种无人值守的安装方式。它的工作原理是在安装过程中记录典型的需要人工干预填写的各种参数，并生成一个配置文件（ks.cfg），在安装过程中，安装程序首先会去查找ks配置文件，如果找到合适的参数，就采用所找到的参数；如果没有找到合适的参数，便需要安装者手工设定。所以，如果kickstart文件涵盖了安装过程中需要设定的所有参数，安装者只需要告诉安装程序从何处取ks.cfg文件，就能实现系统安装的自动化。\\n', '\\n', 'kickstart 安装提供一个安装过程自动化的方法，可以是部分自动化，也可以是完全自动化。\\n', '\\n', 'PXE\\n', '\\n', 'PXE（Pre-boot Execution Environment，预启动执行环境），工作于Client/Server的网络模式，支持PXE的客户端在启动过程中，能够从DHCP服务器获取IP结合TFTP等协议可以实现客户端的网络引导和安装。\\n', '\\n', 'TFTP\\n', '\\n', 'TFTP（Trivial File Transfer Protocol，简单文件传输协议），该协议用来实现客户机与服务器之间的简单文件传输，它提供不复杂、开销不大的文件传输服务。\\n', '\\n', '半自动化安装指导\\n', '环境要求\\n', '使用kickstart进行openEuler系统的半自动化安装的环境要求如下：\\n', '\\n', '物理机/虚拟机（虚拟机创建可参考对应厂商的资料）。包括使用kickstart工具进行自动化安装的计算机和被安装的计算机。\\n', 'httpd：存放kickstart文件。\\n', 'ISO： openEuler-22.03_LTS-aarch64-dvd.iso\\n', '操作步骤\\n', '使用kickstart进行openEuler系统的半自动化安装的操作步骤如下：\\n', '\\n', '环境准备\\n', '\\n', ' 说明：\\n', '安装之前，请确保http服务器的防火墙处于关闭状态。关闭防火墙可参照如下命令：\\n', '\\n', 'iptables -F  \\n', 'httpd的安装与服务启动。\\n', '\\n', '# dnf install httpd -y\\n', '# systemctl start httpd\\n', '# systemctl enable httpd\\n', 'kickstart文件的准备。\\n', '\\n', '# mkdir /var/www/html/ks\\n', '# vim /var/www/html/ks/openEuler-ks.cfg ===>根据已安装openEuler系统自动生成的anaconda-ks.cfg修改得到\\n', '====================================\\n', '***以下内容需要根据实际需求进行修改***\\n', '#version=DEVEL\\n', 'ignoredisk --only-use=sda\\n', 'autopart --type=lvm\\n', '# Partition clearing information\\n', 'clearpart --none --initlabel\\n', '# Use graphical install\\n', 'graphical\\n', '# Use CDROM installation media\\n', 'cdrom\\n', '# Keyboard layouts\\n', \"keyboard --vckeymap=cn --xlayouts='cn'\\n\", '# System language\\n', 'lang zh_CN.UTF-8\\n', '\\n', '# Network information\\n', 'network  --bootproto=dhcp --device=enp4s0 --ipv6=auto --activate\\n', 'network  --hostname=openeuler.com\\n', '# Root password\\n', 'rootpw --iscrypted $6$fQE83lxEZ48Or4zc$j7/PlUMHn29yTjCD4Fi44WTZL/RzVGxJ/7MGsZMl6QfE3KjIVT7M4UrhFXbafvRq2lUddAFcyWHd5WRmXfEK20\\n', '# Run the Setup Agent on first boot\\n', 'firstboot --enable\\n', '# Do not configure the X Window System\\n', 'skipx\\n', '# System services\\n', 'services --disabled=\"chronyd\"\\n', '# System timezone\\n', 'timezone Asia/Shanghai --isUtc--nontp\\n', '\\n', '%packages\\n', '@^minimal-environment\\n', '@standard\\n', '\\n', '%end\\n', '\\n', '%anaconda\\n', 'pwpolicy root --minlen=8 --minquality=1 --notstrict --nochanges --notempty\\n', 'pwpolicy user --minlen=8 --minquality=1 --notstrict --nochanges --emptyok\\n', 'pwpolicy luks --minlen=8 --minquality=1 --notstrict --nochanges --notempty\\n', '%end\\n', '\\n', '%post\\n', '#enable kdump\\n', 'sed  -i \"s/ ro / ro crashkernel=1024M,high /\" /boot/efi/EFI/openEuler/grub.cfg\\n', '%end\\n', '=====================================\\n', ' 说明：\\n', '密码密文生成方式：\\n', '\\n', '# python3  \\n', 'Python 3.7.0 (default, Apr  1 2019, 00:00:00)  \\n', '[GCC 7.3.0] on linux  \\n', 'Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.  \\n', '>>> import crypt  \\n', '>>> passwd = crypt.crypt(\"myPasswd\")  \\n', '>>> print (passwd)  \\n', '$6$63c4tDmQGn5SDayV$mZoZC4pa9Jdt6/ALgaaDq6mIExiOO2EjzomB.Rf6V1BkEMJDcMddZeGdp17cMyc9l9ML9ldthytBEPVcnboR/0  \\n', '将ISO镜像文件挂载到需要安装openEuler计算机的光驱上。\\n', '\\n', '另外，也可以选择NFS等网络安装，kickstart文件中需要指定安装源位置（默认是cdrom）。\\n', '\\n', '安装系统\\n', '\\n', '启动系统进入安装选择界面。\\n', '\\n', '在“启动安装”中的“安装引导界面”中选择“Install openEuler 22.03_LTS”，并按下“e”键。\\n', '\\n', '启动参数中追加“inst.ks=http://server ip/ks/openEuler-ks.cfg”。\\n', '\\n', '\\n', '\\n', '按“Ctrl+x”，开始系统的自动安装。\\n', '\\n', '确认系统安装完毕。\\n', '\\n', '系统安装完毕以后会自动重启，如果优先从光驱启动，会再次进入到安装界面，此时关闭计算机，调整启动顺序（优先从硬盘启动）。\\n', '\\n', '\\n', '\\n', '全自动化安装指导\\n', '环境要求\\n', '使用kickstart进行openEuler系统的全自动化安装的环境要求如下：\\n', '\\n', '物理机/虚拟机（虚拟机创建可参考对应厂商的资料）。包括使用kickstart工具进行自动化安装的计算机和被安装的计算机。\\n', 'httpd：存放kickstart文件。\\n', 'tftp：提供vmlinuz和initrd文件。\\n', 'dhcpd/pxe：提供DHCP服务。\\n', 'ISO：openEuler-22.03_LTS-aarch64-dvd.iso。\\n', '操作步骤\\n', '使用kickstart进行openEuler系统的全自动化安装的操作步骤如下：\\n', '\\n', '环境准备\\n', '\\n', ' 说明：\\n', '安装之前，请确保http服务器的防火墙处于关闭状态。关闭防火墙可参照如下命令：\\n', '\\n', 'iptables -F  \\n', 'httpd的安装与服务启动。\\n', '\\n', '# dnf install httpd -y\\n', '# systemctl start httpd\\n', '# systemctl enable httpd\\n', 'tftp的安装与配置。\\n', '\\n', '# dnf install tftp-server -y\\n', '# vim /etc/xinetd.d/tftp\\n', 'service tftp\\n', '{\\n', 'socket_type = dgram\\n', 'protocol = udp\\n', 'wait = yes\\n', 'user = root\\n', 'server = /usr/sbin/in.tftpd\\n', 'server_args = -s /var/lib/tftpboot\\n', 'disable = no\\n', 'per_source = 11\\n', 'cps = 100 2\\n', 'flags = IPv4\\n', '}\\n', '# systemctl start tftp\\n', '# systemctl enable tftp\\n', '# systemctl start xinetd\\n', '# systemctl status xinetd\\n', '# systemctl enable xinetd\\n', '安装源的制作。\\n', '\\n', '# mount openEuler-22.03_LTS-aarch64-dvd.iso /mnt\\n', '# cp -r /mnt/* /var/www/html/openEuler/\\n', '设置和修改kickstart配置文件 openEuler-ks.cfg，参考3安装源的目录，此处选择http安装源。\\n', '\\n', '#vim  /var/www/html/ks/openEuler-ks.cfg\\n', '====================================\\n', '***以下内容根据实际需求进行修改***\\n', '#version=DEVEL\\n', 'ignoredisk --only-use=sda\\n', 'autopart --type=lvm\\n', '# Partition clearing information\\n', 'clearpart --none --initlabel\\n', '# Use graphical install\\n', 'graphical\\n', '# Keyboard layouts\\n', \"keyboard --vckeymap=cn --xlayouts='cn'\\n\", '# System language\\n', 'lang zh_CN.UTF-8\\n', '#Use http installation source\\n', 'url --url=http://192.168.122.1/openEuler/\\n', '%post\\n', '#enable kdump\\n', 'sed  -i \"s/ ro / ro crashkernel=1024M,high /\" /boot/efi/EFI/openEuler/grub.cfg\\n', '%end\\n', '...\\n', '修改pxe配置文件grub.cfg， 可参考如下内容(注意：openEuler当前不支持bls格式的cfg文件)。\\n', '\\n', '# cp -r /mnt/images/pxeboot/* /var/lib/tftpboot/\\n', '# cp /mnt/EFI/BOOT/grubaa64.efi /var/lib/tftpboot/\\n', '# cp /mnt/EFI/BOOT/grub.cfg /var/lib/tftpboot/\\n', '# ls /var/lib/tftpboot/\\n', 'grubaa64.efi  grub.cfg  initrd.img  TRANS.TBL  vmlinuz\\n', '# vim /var/lib/tftpboot/grub.cfg\\n', 'set default=\"1\"\\n', '\\n', 'function load_video {\\n', '  if [ x$feature_all_video_module = xy ]; then\\n', '    insmod all_video\\n', '  else\\n', '    insmod efi_gop\\n', '    insmod efi_uga\\n', '    insmod ieee1275_fb\\n', '    insmod vbe\\n', '    insmod vga\\n', '    insmod video_bochs\\n', '    insmod video_cirrus\\n', '  fi\\n', '}\\n', '\\n', 'load_video\\n', 'set gfxpayload=keep\\n', 'insmod gzio\\n', 'insmod part_gpt\\n', 'insmod ext2\\n', '\\n', 'set timeout=60\\n', '\\n', '\\n', '### BEGIN /etc/grub.d/10_linux ###\\n', \"menuentry 'Install openEuler 22.03_LTS ' --class red --class gnu-linux --class gnu --class os {\\n\", '        set root=(tftp,192.168.1.1)\\n', '        linux /vmlinuz ro inst.geoloc=0 console=ttyAMA0 console=tty0 rd.iscsi.waitnet=0 inst.ks=http://192.168.122.1/ks/openEuler-ks.cfg\\n', '        initrd /initrd.img\\n', '}\\n', 'DHCP的配置（可以使用dnsmasq代替 ）。\\n', '\\n', '# dnf install dhcp -y\\n', '#\\n', '# DHCP Server Configuration file.\\n', '#   see /usr/share/doc/dhcp-server/dhcpd.conf.example\\n', '#   see dhcpd.conf(5) man page\\n', '#\\n', '# vim /etc/dhcp/dhcpd.conf\\n', 'ddns-update-style interim;\\n', 'ignore client-updates;\\n', 'filename \"grubaa64.efi\"; \\u3000\\u3000 # pxelinux 启动文件位置;\\n', 'next-server 192.168.122.1;\\u3000\\u3000# (重要)TFTP Server 的IP地址;\\n', 'subnet 192.168.122.0 netmask 255.255.255.0 {\\n', 'option routers 192.168.122.1; # 网关地址\\n', 'option subnet-mask 255.255.255.0; # 子网掩码\\n', 'range dynamic-bootp 192.168.122.50 192.168.122.200; # 动态ip范围\\n', 'default-lease-time 21600;\\n', 'max-lease-time 43200;\\n', '}\\n', '# systemctl start dhcpd\\n', '# systemctl enable dhcpd\\n', '安装系统\\n', '\\n', '在“Start boot option”界面按下“F2”选择从网络pxe启动，开始自动化安装。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '进入系统全自动化安装界面。\\n', '\\n', '确认系统安装完毕。\\n', '\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_安装准备.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E5%87%86%E5%A4%87.html", "text_entry": "['安装准备\\n', '介绍安装前需要考虑软硬件兼容性状况，以及相关的配置和准备工作。\\n', '\\n', '获取安装源\\n', '在安装开始前，您需要获取openEuler的发布包和校验文件。\\n', '\\n', '请按以下步骤获取openEuler的发布包和校验文件：\\n', '\\n', '登录openEuler社区网站。\\n', '单击“下载”进入页签，进入版本下载页面。\\n', '单击卡片 openEuler 22.03_LTS 上的“获取ISO”，显示ISO下载列表。\\n', 'aarch64：AArch64架构的ISO。\\n', 'x86_64：x86_64架构的ISO。\\n', 'source：openEuler源码ISO。\\n', '根据实际待安装环境的架构选择需要下载的 openEuler 的发布包和校验文件。\\n', '若为AArch64架构。\\n', '\\n', '单击“aarch64”。\\n', '若选择本地安装，分别将发布包 “openEuler-22.03_LTS-aarch64-dvd.iso”和校验文件“openEuler-22.03_LTS-aarch64-dvd.iso.sha256sum”下载到本地。\\n', '若选择网络安装，分别将发布包 “openEuler-22.03_LTS-netinst-aarch64-dvd.iso”和校验文件“openEuler-22.03_LTS-netinst-aarch64-dvd.iso.sha256sum”下载到本地。\\n', '若为x86_64架构。\\n', '\\n', '单击“x86_64”。\\n', '若选择本地安装，分别将发布包 “openEuler-22.03_LTS-x86_64-dvd.iso”和校验文件“openEuler-22.03_LTS-x86_64-dvd.iso.sha256sum”下载到本地。\\n', '若选择网络安装，分别将发布包 “openEuler-22.03_LTS-netinst-x86_64-dvd.iso ”和校验文件“openEuler-22.03_LTS-netinst-x86_64-dvd.iso.sha256sum”下载到本地。\\n', ' 说明：\\n', '\\n', '网络安装方式的 ISO 发布包较小，在有网络的安装环境可以选择网络安装方式。\\n', 'AArch64架构的发布包支持UEFI模式，x86_64架构的发布包支持UEFI模式和Legacy模式。\\n', '发布包完整性校验\\n', ' 说明：\\n', '本章节以AArch64架构的发布包完整性校验为例，x86_64架构的发布包完整性校验的操作方法相同。\\n', '\\n', '简介\\n', '为了防止软件包在传输过程中由于网络原因或者存储设备原因出现下载不完整的问题，在获取到软件包后，需要对软件包的完整性进行校验，通过了校验的软件包才能部署。\\n', '\\n', '这里通过对比校验文件中记录的校验值和手动方式计算的iso文件校验值，判断软件包是否完整。若两个值相同，说明iso文件完整，否则，iso完整性被破坏，请重新获取iso发布包。\\n', '\\n', '前提条件\\n', '在校验发布包完整性之前，需要准备如下文件：\\n', '\\n', 'iso文件：openEuler-22.03_LTS-aarch64-dvd.iso\\n', '\\n', '校验文件：openEuler-22.03_LTS-aarch64-dvd.iso.sha256sum\\n', '\\n', '操作指导\\n', '文件完整性校验操作步骤如下：\\n', '\\n', '获取校验文件中的校验值。执行命令如下：\\n', '\\n', '$ cat openEuler-22.03_LTS-aarch64-dvd.iso.sha256sum \\n', '计算文件的sha256校验值。执行命令如下：\\n', '\\n', '$ sha256sum openEuler-22.03_LTS-aarch64-dvd.iso\\n', '命令执行完成后，输出校验值。\\n', '\\n', '对比步骤1和步骤2计算的校验值是否一致。\\n', '\\n', '如果校验值一致说明iso文件完整性没有破坏，如果校验值不一致则可以确认文件完整性已被破坏，需要重新获取。\\n', '\\n', '物理机的安装要求\\n', '若需要在物理机环境上安装openEuler操作系统，则物理机需要满足如下的硬件兼容性和最小硬件要求。\\n', '\\n', '硬件兼容支持\\n', 'openEuler安装时，应注意硬件兼容性方面的问题，当前已支持的服务器类型如表1所示。\\n', '\\n', ' 说明：\\n', '\\n', 'TaiShan 200服务器基于华为鲲鹏920处理器。\\n', '当前仅支持华为TaiShan服务器和FusionServer Pro 机架服务器，后续将逐步增加对其他厂商服务器的支持。\\n', '表 1 支持的服务器类型\\n', '\\n', '服务器形态\\t服务器名称\\t服务器型号\\n', '机架服务器\\tTaiShan 200\\t2280均衡型\\n', '机架服务器\\tFusionServer Pro 机架服务器\\tFusionServer Pro 2288H V5\\n', '说明：\\n', '服务器要求配置Avago 3508 RAID控制卡和启用LOM-X722网卡\\n', '最小硬件要求\\n', 'openEuler所需的最小硬件要求如表2所示。\\n', '\\n', '表 2 最小硬件要求\\n', '\\n', '部件名称\\t最小硬件要求\\n', '架构\\tAArch64或x86_64\\n', 'CPU\\t2*CPU (1 core)\\n', '内存\\t不小于4GB（为了获得更好的应用体验，建议不小于8GB）\\n', '硬盘\\t不小于32GB（为了获得更好的应用体验，建议不小于120GB）\\n', '虚拟机的安装要求\\n', '若需要在虚拟机环境上安装openEuler操作系统，则虚拟机需要满足如下的虚拟化平台兼容性和最小虚拟化要求。\\n', '\\n', '虚拟化平台兼容性\\n', 'openEuler安装时，应注意虚拟化平台兼容性的问题，当前已支持的虚拟化平台为：\\n', '\\n', 'openEuler自有的虚拟化组件（HostOS为openEuler，虚拟化组件为发布包中的qemu、KVM）创建的虚拟化平台。\\n', '华为公有云的x86虚拟化平台。\\n', '最小虚拟化空间要求\\n', 'openEuler所需的最小虚拟化空间要求如表3所示。\\n', '\\n', '表 3 最小虚拟化空间要求\\n', '\\n', '部件名称\\t最小虚拟化空间要求\\n', '架构\\tAArch64或x86_64\\n', 'CPU\\t2个CPU\\n', '内存\\t不小于4GB（为了获得更好的应用体验，建议不小于8GB）\\n', '硬盘\\t不小于32GB（为了获得更好的应用体验，建议不小于120GB）']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_安装指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AF%BC.html", "text_entry": "['安装指导\\n', '本章以光盘安装为例介绍安装openEuler，其他安装方式除在启动安装时的引导方式不同外，待启动安装后则安装流程相同，在此不再说明。\\n', '\\n', '启动安装\\n', '使用光盘引导安装\\n', '在服务器的光驱中加载openEuler安装镜像，重启服务器，具体步骤如下。\\n', '\\n', ' 说明：\\n', '在安装开始前，需要保证服务器启动选项为光驱优先。安装步骤以BMC挂载虚拟光驱进行光盘安装的操作举例。通过物理光驱安装的操作简单，启动安装后的流程相同，在此不再说明。\\n', '\\n', '在虚拟界面工具栏中，单击虚拟光驱工具如下图所示。\\n', '\\n', '图 1 光驱图标\\n', '\\n', '\\n', '弹出镜像对话框，如下图所示。\\n', '\\n', '图 2 镜像对话框\\n', '\\n', '\\n', '在镜像对话框中，选择“镜像文件”， 并单击“浏览”。弹出“打开”对话框。\\n', '\\n', '选择镜像文件，单击“打开”。然后在镜像对话框中，单击“连接”。当“连接”显示为“断开”后，表示虚拟光驱已连接到服务器。\\n', '\\n', '在工具栏中，单击重启工具重启设备，如下图所示。\\n', '\\n', '图 3 重启图标\\n', '\\n', '\\n', '安装引导界面\\n', '系统使用引导介质完成引导后会显示引导菜单。该引导菜单除启动安装程序外还提供一些选项。安装系统时，默认采用“Test this media & install openEuler 22.03_LTS”方式进行安装。如果要选择默认选项之外的选项，请使用键盘中的“↑”和“↓”方向键进行选择，并在选项为高亮状态时按“Enter”。\\n', '\\n', ' 说明：\\n', '\\n', '如果60秒内未按任何键，系统将从默认选项“Test this media & install openEuler 22.03_LTS”自动进入安装界面。\\n', '安装物理机时，如果使用键盘上下键无法选择启动选项，按“Enter”键无响应，可以单击BMC界面上的鼠标控制图标“”，设置“键鼠复位”。\\n', '图 4 安装引导界面\\n', '\\n', '\\n', '安装引导选项说明如下：\\n', '\\n', 'Install openEuler 22.03_LTS —— 在您的服务器上使用图形用户界面模式安装。\\n', '\\n', 'Test this media & install openEuler 22.03_LTS —— 默认选项，在您的服务器上使用图形用户界面模式安装，但在启动安装程序前会进行安装介质的完整性检查。\\n', '\\n', 'Troubleshooting —— 问题定位模式，系统无法正常安装时使用。进入问题定位模式后，有如下两个选项。\\n', '\\n', 'Install openEuler 22.03_LTS in basic graphics mode —— 简单图形安装模式，该模式下在系统启动并运行之前不启动视频驱动程序。\\n', 'Rescue the openEuler system —— 救援模式，用于修复系统。该模式下输出定向到VNC或BMC（Baseboard Management Controller）端，串口不可用。\\n', '在安装引导界面，按“e”进入已选选项的参数编辑界面，按“c”进入命令行模式。\\n', '\\n', '图形化模式安装\\n', '在“安装引导界面”中选择“Test this media & install openEuler 22.03_LTS”进入图形化模式安装。\\n', '\\n', '可以通过键盘操作图形化安装程序。\\n', '\\n', '“Tab”、“shift Tab”：界面控件（按钮、区域框、复选框等）间的移动。\\n', '“↑”、“↓”方向键：列表里的移动。\\n', '“←”、“→”方向键：水平工具条和表条间移动。\\n', '“空格”、“Enter”：选择或删除高亮显示的选项、展开或折叠下拉菜单。\\n', '“Alt”+“快捷键”：选择快捷键所在的控件，其中快捷键可通过按住Alt高亮（加下划线）显示。\\n', '设置安装程序语言\\n', '启动安装后，在进入安装程序主界面之前，系统会提示用户设置安装过程中使用的语言。当前默认为英语，用户可根据实际情况进行调整，如图5所示，选择“中文”。\\n', '\\n', '图 5 选择语言\\n', '\\n', '\\n', '完成设置后，单击“继续”，进入安装设置主界面。\\n', '\\n', '如果您想退出安装，可以单击“退出”并在弹出的“您确定要退出安装程序吗？”对话框中单击“是”重新进入“安装引导界面”。\\n', '\\n', '进入安装界面\\n', '系统安装程序正常启动后，会进入图6所示的安装设置主界面。用户可以进行时间、语言、安装源、网络、安装位置等相关设置。\\n', '\\n', '部分配置项会有告警符号，用户完成该选项配置后，告警符号消失。当界面上不存在告警符号时，用户才能单击“开始安装”进行系统安装。\\n', '\\n', '如果您想退出安装，可以单击“退出”并在弹出的“您确定要退出安装程序吗？”对话框中单击“是”重新进入“安装引导界面”。\\n', '\\n', '图 6 安装概览\\n', '\\n', '\\n', '设置键盘\\n', '在“安装概览”页面中选择“键盘”，用户可以在系统中添加或者删除多个键盘布局。\\n', '\\n', '要查看键盘布局，请在左侧选框中单击选中该键盘布局，然后单击下面的“键盘”按钮。\\n', '要测试键盘布局，请在左侧选框中添加键盘布局，然后在右上角键盘图标处进行点击切换为目标键盘，单击右侧文本框内部，输入文本以确认所选键盘布局可正常工作。\\n', '图 7 键盘布局\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置系统语言\\n', '在“安装概览”页面中选择“语言支持”，设置系统的语言。如图8所示，用户也可根据实际情况进行调整，选择“中文”。\\n', '\\n', ' 说明：\\n', '若选择“中文”，系统安装完成后，使用VNC登录不支持中文显示，使用串口登录支持中文显示，使用SSH登录时是否支持中文显示与使用的SSH客户端有关。若选择“English”，则无影响。\\n', '\\n', '图 8 语言支持\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置时间和日期\\n', '在“安装概览”页面中选择“时间和日期”，设置系统的时区、日期、时间等。\\n', '\\n', '设置时区时，用户可通过鼠标在地图上单击指定的城市，也可以通过页面顶部的“地区”和“城市”下拉菜单中进行选择，如图9所示。\\n', '\\n', '如果您所在城市没有出现在地图或下拉菜单中，请选择同一时区中离您最近的城市。\\n', '\\n', ' 说明：\\n', '\\n', '手动设置时区时，请先关闭右上角“网络时间”同步开关。\\n', '如需使用网络时间，请保证网络能连通远程NTP服务器，设置网络具体请参见“设置网络和主机名”。\\n', '图 9 日期和时间\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置安装源\\n', '在“安装概览”页面中选择“安装源”，指定安装源的位置。\\n', '\\n', '当使用完整光盘安装，安装程序会自动探测并显示安装源信息，用户直接使用默认配置即可，不需要进行设置，如图10所示。\\n', '\\n', '图 10 安装源\\n', '\\n', '\\n', '当使用网络源进行安装的时候，需设置网络源的 URL。\\n', '\\n', 'http 或 https 方式\\n', '\\n', 'http 或 https 方式的安装源如下图所示。\\n', '\\n', '\\n', '\\n', '如果https服务器使用的是私有证书，则需要在安装引导界面按“e”进入已选选项的参数编辑界面，在参数中增加 inst.noverifyssl 参数。\\n', '\\n', '输入框内容以实际版本发布的安装源地址为准，如https://repo.openeuler.org/openEuler-22.03-LTS/OS/x86_64/ ，其中openEuler-22.03-LTS 为版本号，x86_64 为CPU 架构，可根据实际情况输入。\\n', '\\n', 'ftp 方式\\n', '\\n', 'ftp 方式的安装源如下图所示，输入框内容根据的 ftp 地址输入。\\n', '\\n', '\\n', '\\n', 'ftp服务器需要用户自己搭建，将openEuler-22.03_LTS-x86_64-dvd.iso镜像进行挂载，挂载出的文件拷贝到ftp的共享目录中。其中x86_64为CPU 架构，可根据实际情况使用镜像。\\n', '\\n', 'nfs 方式\\n', '\\n', 'nfs 方式的安装源如下图所示，输入框内容根据的 nfs 地址输入。\\n', '\\n', '\\n', '\\n', 'nfs服务器需要用户自己搭建，将openEuler-22.03_LTS-x86_64-dvd.iso镜像进行挂载，挂载出的文件拷贝到nfs的共享目录中。其中x86_64为CPU 架构，可根据实际情况使用镜像。\\n', '\\n', '安装过程中，如果“设置安装源”有疑问，可参考“选择安装源出现异常”。\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '选择安装软件\\n', '在“安装概览”页面中选择“软件选择”，指定需要安装的软件包。\\n', '\\n', '用户需要根据实际的业务需求，在左侧选择一个“最小安装”，在右侧选择安装环境的附加选项，如图11所示。\\n', '\\n', '图 11 软件选择\\n', '\\n', '\\n', ' 说明：\\n', '\\n', '在最小安装的环境下，并非安装源中所有的包都会安装。如果用户需要使用的包未安装，可将安装源挂载到本地制作repo源，通过DNF工具单独安装。\\n', '选择“虚拟化主机”时会默认安装虚拟化组件qemu、libvirt、edk2，且可在附件选项处选择是否安装ovs等组件。\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置安装目的地\\n', '在“安装概览”页面中选择“安装目的地”，设置操作系统的安装磁盘及分区。\\n', '\\n', '在图12所示的页面中您可以看到计算机中的本地可用存储设备。\\n', '\\n', '图 12 安装目标位置\\n', '\\n', '\\n', '存储配置\\n', '在“安装目标位置”界面，您需要进行存储配置以便对系统分区。您可以手动配置分区，也可以选择让安装程序自动分区。\\n', '\\n', ' 说明：\\n', '\\n', '在进行分区时，出于系统性能和安全的考虑，建议您划分如下单独分区：/boot、/var、/var/log 、/var/log/audit、/home、/tmp。\\n', '系统如果配置了swap分区，当系统的物理内存不够用时，会使用swap分区。虽然 swap分区可以增大物理内存大小的限制，但是如果由于内存不足使用到swap分区，会增加系统的响应时间，性能变差。因此在物理内存充足或者性能敏感的系统中，不建议配置swap分区。\\n', '如果需要拆分逻辑卷组则需要选择“自定义”进行手动分区，并在“手动分区”界面单击“卷组”区域中的“修改”按钮重新配置卷组。\\n', '自动\\n', '\\n', '如果是在未使用过的存储设备中执行全新安装，或者不需要保留该存储设备中任何数据，建议选择“自动”进行自动分区。设置完成后，请单击“完成”返回“安装概览”页面。\\n', '\\n', '自定义\\n', '\\n', '若用户需进行手动分区，选择“自定义”按钮，并单击左上角“完成”，出现手动分区界面。\\n', '\\n', '在“手动分区”界面可以通过如下两种方式进行分区，分区完成后如图13所示。\\n', '\\n', '自动创建：在界面单击“点击这里自动创建它们”，系统会根据可用的存储空间，自动分出4个挂载点：/boot 、/、/boot/efi、swap。\\n', '\\n', '手动创建：单击“”添加新挂载点，建议每个挂载点的期望容量不超过可用空间。\\n', '\\n', ' 说明：\\n', '若设置的挂载点期望容量超过了可用空间，系统将剩余的可用空间全部分配给该挂载点。\\n', '\\n', '图 13 手动分区\\n', '\\n', '\\n', ' 说明：\\n', '如果选择非 UEFI 引导，则不需要 /boot/efi 分区。若选择 UEFI 引导，则必须有 /boot/efi 分区。\\n', '\\n', '设置完成后，请单击左上角”完成“按钮，弹出“更改摘要”对话框，提示更改产生的变更信息。\\n', '\\n', '点击“接受更改”，返回“安装概览”页面。\\n', '\\n', '设置网络和主机名\\n', '在“安装概览”页面中选择“网络和主机名”，设置系统的网络功能。\\n', '\\n', '安装程序会自动探测可本地访问的接口。探测到的接口列在左侧方框中，右侧显示相应的接口详情，如图14所示。用户可以通过页面右上角的开关，来开启或者关闭网络接口。开关默认是关闭状态，若设置安装源选择的是在网络上安装，需要开启开关。用户还可以单击“配置”以配置选中的接口。勾选“自动以优先级连接”选项，即可将该网卡设置为开机自启动，如图15所示。\\n', '\\n', '用户可在页面下方“主机名”字段输入主机名。主机名可以是完全限定域名（FQDN），其格式为hostname.domainname；也可以是简要主机名，其格式为hostname。\\n', '\\n', '图 14 网络和主机名\\n', '\\n', '\\n', '图 15 配置网络\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置root密码\\n', '在“安装概览”页面中选择“根密码”，弹出设置“ROOT密码”界面，如图16所示，根据密码复杂度输入密码并再次输入密码进行确认。\\n', '\\n', ' 说明：\\n', '\\n', 'root帐户是用来执行关键系统管理任务，不建议您在日常工作及系统访问时使用root帐户。\\n', '\\n', '在“ROOT密码”界面若选择“锁定root帐户”则root帐户将禁用。\\n', '\\n', '图 16 root密码\\n', '\\n', '\\n', '密码复杂度\\n', '用户设置的root用户密码或新创建用户的密码均需要满足密码复杂度要求，否则会导致密码设置或用户创建失败。设置密码的复杂度的要求如下：\\n', '\\n', '口令长度至少8个字符。\\n', '\\n', '口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种。\\n', '\\n', '口令不能和账号一样。\\n', '\\n', '口令不能使用字典词汇。\\n', '\\n', ' 说明： 在已装好的openEuler环境中，可以通过cracklib-unpacker /usr/share/cracklib/pw_dict > dictionary.txt命令导出字典库文件dictionary.txt，用户可以查询密码是否在该字典中。\\n', '\\n', '完成设置后，单击左上角的“完成”返回“安装概览”页面。\\n', '\\n', '创建用户\\n', '在“安装概览”页面中选择“创建用户”，弹出“创建用户”的界面如图17所示。输入用户名，并设置密码。另外您还可以通过“高级”选项设置用户主目录、用户组等，如图18所示。\\n', '\\n', '图 17 创建用户\\n', '\\n', '\\n', '图 18 高级用户配置\\n', '\\n', '\\n', '完成设置后，单击左上角的“完成”返回“安装概览”页面。\\n', '\\n', '开始安装\\n', '在安装界面上完成所有必填选项的配置后，界面上的警告会消失。此时，用户可以单击“开始安装”进行系统安装。\\n', '\\n', '安装过程\\n', '开始安装后会出现进度页面，显示安装进度及所选软件包写入系统的进度，如图19所示。\\n', '\\n', '\\n', '若系统安装过程中，单击“退出”，或复位、下电服务器，则安装过程被中断，系统将不可用，需要重新进行安装。\\n', '\\n', '图 19 安装过程\\n', '\\n', '\\n', '安装完成\\n', '安装过程执行完成后，openEuler完成安装，单击“重启”后，系统将重新启动。\\n', '\\n', ' 说明：\\n', '\\n', '如果当前使用物理光盘安装操作系统，且在重启过程中安装光盘没有自动弹出，请手动取出光盘，则可以直接进入openEuler命令行登录界面。\\n', '如果当前使用虚拟光驱安装操作系统，则需要修改服务器的启动项为“硬盘”，然后重启服务器，则可以直接进入openEuler命令行登录界面。']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_FAQ.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/FAQ-1.html", "text_entry": "['FAQ\\n', 'FAQ\\n', '树莓派启动失败\\n', 'nmcli 命令连接 WIFI 失败\\n', '树莓派启动失败\\n', '问题现象\\n', '将 openEuler 发布的树莓派镜像刷写入 SD 卡后，树莓派启动失败。\\n', '\\n', '原因分析\\n', '刷写 openEuler 发布的树莓派镜像后，树莓派启动失败，大致有以下几种情况：\\n', '\\n', '下载的镜像文件不完整，请确保该镜像通过完整性校验。\\n', '镜像写入 SD 卡过程中出现问题，多出现在 Windows 环境下使用应用软件刷写镜像到 SD 卡的情况。\\n', '解决方法\\n', '将完整的镜像重新刷写入 SD 卡。\\n', '\\n', 'nmcli 命令连接 WIFI 失败\\n', '问题现象\\n', '执行 nmcli dev wifi connect SSID password PWD 命令连接 WIFI 失败。例如提示 Error: Connection activation failed: (7) Secrets were required, but not provided. 等错误。\\n', '\\n', '原因分析\\n', '执行的命令缺少密码。注意，如果密码中包含特殊字符，需要使用单引号将密码括起来。如果使用 nmcli 命令行连接 WIFI 失败，建议使用 nmtui 字符界面进行连接。\\n', '\\n', '解决方法\\n', '执行 nmtui 命令进入到 nmtui 字符界面，按照以下步骤连接 WIFI。\\n', '\\n', '选择 Edit a connection，按 Enter 进入编辑网络连接窗口。\\n', '\\n', '按下键盘右方向键选择 Add，按 Enter 进入新建网络连接窗口。\\n', '\\n', '连接类型选择 Wi-Fi ，然后按下键盘右方向键选择 Create，按 Enter 进入 WIFI 编辑连接信息的界面。\\n', '\\n', 'WIFI 连接信息界面主要需要编辑以下内容，其他信息根据实际情况而定。编辑结束后选择 OK，按 Enter 完成编辑并回退到编辑网络连接窗口。\\n', '\\n', 'Profile name 栏输入该 WIFI 连接的名称，这里可以使用默认名称，如 Wi-Fi connection 1；\\n', 'Device 栏输入要使用的无线网卡接口，这里输入 wlan0；\\n', 'SSID 栏输入要连接的 WIFI 的 SSID；\\n', 'Security 栏选择 WIFI 密码加密方式，这里根据实际情况选择，例如选择 WPA & WPA2 Personal；\\n', 'Password 栏输入 WIFI 密码。\\n', '选择 Back 回退到最初的 nmtui 字符界面。\\n', '\\n', '选择 Activate a connection，按 Enter 进入激活网络连接窗口。\\n', '\\n', '查看添加的 WIFI 连接是否已激活（已激活的连接名称前有 * 标记）。如果未激活，选择该 WIFI 连接，然后按下键盘右方向键选择 Activate，按 Enter 激活该连接。待激活完成后，选择 Back，按 Enter 退出该激活界面，回退到最初的 nmtui 字符界面。\\n', '\\n', '选择 Quit，然后按下键盘右方向键选择 OK，按 Enter 退出 nmtui 字符界面。']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_安装准备.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E5%87%86%E5%A4%87-1.html", "text_entry": "['安装准备\\n', '介绍安装前需要考虑软硬件兼容性状况，以及相关的配置和准备工作。\\n', '\\n', '安装准备\\n', '获取安装源\\n', '镜像完整性校验\\n', '简介\\n', '前提条件\\n', '操作指导\\n', '安装要求\\n', '硬件兼容支持\\n', '最小硬件要求\\n', '获取安装源\\n', '在安装开始前，您需要获取 openEuler 发布的树莓派镜像及其校验文件。\\n', '\\n', '登录openEuler社区网站。\\n', '\\n', '单击卡片 openEuler 22.03_LTS 上的“下载”按钮。\\n', '\\n', '单击“raspi_img”，进入树莓派镜像的下载列表。\\n', '\\n', 'aarch64：AArch64 架构的镜像。\\n', '单击“aarch64”，进入树莓派 AArch64 架构镜像的下载列表。\\n', '\\n', '单击“openEuler-22.03_LTS-raspi-aarch64.img.xz”，将 openEuler 发布的树莓派镜像下载到本地。\\n', '\\n', '单击“openEuler-22.03_LTS-raspi-aarch64.img.xz.sha256sum”，将 openEuler 发布的树莓派镜像的校验文件下载到本地。\\n', '\\n', '镜像完整性校验\\n', '简介\\n', '为了防止软件包在传输过程中由于网络原因或者存储设备原因出现下载不完整的问题，在获取到软件包后，需要对软件包的完整性进行校验，通过了校验的软件包才能部署。\\n', '\\n', '这里通过对比校验文件中记录的校验值和手动方式计算的文件校验值，判断软件包是否完整。若两个值相同，说明下载的文件完整，否则，下载的文件完整性被破坏，请重新获取软件包。\\n', '\\n', '前提条件\\n', '在校验镜像文件的完整性之前，需要准备如下文件：\\n', '\\n', '镜像文件：openEuler-22.03_LTS-raspi-aarch64.img.xz\\n', '\\n', '校验文件：openEuler-22.03_LTS-raspi-aarch64.img.xz.sha256sum\\n', '\\n', '操作指导\\n', '文件完整性校验操作步骤如下：\\n', '\\n', '获取校验文件中的校验值。执行命令如下：\\n', '\\n', '$ cat openEuler-22.03_LTS-raspi-aarch64.img.xz.sha256sum\\n', '计算文件的 sha256 校验值。执行命令如下：\\n', '\\n', '$ sha256sum openEuler-22.03_LTS-raspi-aarch64.img.xz\\n', '命令执行完成后，输出校验值。\\n', '\\n', '对比步骤 1 和步骤 2 计算的校验值是否一致。\\n', '\\n', '如果校验值一致说明下载的文件完整性没有破坏，如果校验值不一致则可以确认文件完整性已被破坏，需要重新获取。\\n', '\\n', '安装要求\\n', '在树莓派环境上安装 openEuler 操作系统，则树莓派需要满足如下的硬件兼容性和最小硬件要求。\\n', '\\n', '硬件兼容支持\\n', 'openEuler 树莓派版本镜像目前支持树莓派 3B/3B+/4B。\\n', '\\n', '最小硬件要求\\n', 'openEuler 树莓派版本镜像所需的最小硬件要求如表1所示。\\n', '\\n', '表 1 最小硬件要求\\n', '\\n', '\\n', '部件名称\\n', '\\n', '最小硬件要求\\n', '\\n', '说明\\n', '\\n', '树莓派版本\\n', '\\n', '树莓派 3B\\n', '树莓派 3B+\\n', '树莓派 4B\\n', '树莓派 400\\n', '-\\n', '\\n', '内存\\n', '\\n', '不小于 2GB（为了获得更好的应用体验，建议至少 4GB）\\n', '\\n', '-\\n', '\\n', '硬盘\\n', '\\n', '为了获得更好的应用体验，建议不小于 8GB\\n', '\\n', '-']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_安装指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AF%BC-1.html", "text_entry": "['安装指导\\n', '本章介绍将“树莓派镜像刷写入 SD 卡”后，启用树莓派的主要过程。\\n', '\\n', '安装指导\\n', '启动系统\\n', '登录系统\\n', '配置系统\\n', '扩展根目录分区\\n', '连接 WIFI\\n', '启动系统\\n', '将刷写镜像后的 SD 卡插入树莓派，通电启用。\\n', '\\n', '树莓派硬件相关信息请参考树莓派官网。\\n', '\\n', '登录系统\\n', '登录树莓派有以下两种方式：\\n', '\\n', '本地登录\\n', '\\n', '树莓派连接显示器（树莓派视频输出接口为 Micro HDMI）、键盘、鼠标后，启动树莓派，可以看到树莓派启动日志输出到显示器上。待树莓派启动成功，输入用户名（root）和密码（openeuler）登录。\\n', '\\n', 'ssh 远程登录\\n', '\\n', '树莓派默认采用 DHCP 的方式自动获取 IP。如果树莓派连接已知路由器，可登录路由器查看，新增的 IP 即为树莓派 IP。例如，树莓派对应 IP 为：192.168.31.109，使用命令 ssh root@192.168.31.109 后输入密码 openeuler，即可远程登录树莓派。\\n', '\\n', '配置系统\\n', '扩展根目录分区\\n', '默认根目录分区空间比较小，在使用之前，需要对分区进行扩容。\\n', '\\n', '请按照以下步骤扩展根目录分区：\\n', '\\n', '在 root 权限下执行 fdisk -l 命令查看磁盘分区信息。命令和回显如下：\\n', '\\n', '# fdisk -l\\n', 'Disk /dev/mmcblk0: 14.86 GiB, 15931539456 bytes, 31116288 sectors\\n', 'Units: sectors of 1 * 512 = 512 bytes\\n', 'Sector size (logical/physical): 512 bytes / 512 bytes\\n', 'I/O size (minimum/optimal): 512 bytes / 512 bytes\\n', 'Disklabel type: dos\\n', 'Disk identifier: 0xf2dc3842\\n', '\\n', 'Device         Boot   Start     End Sectors  Size Id Type\\n', '/dev/mmcblk0p1 *       8192  593919  585728  286M  c W95 FAT32 (LBA)\\n', '/dev/mmcblk0p2       593920 1593343  999424  488M 82 Linux swap / Solaris\\n', '/dev/mmcblk0p3      1593344 5044223 3450880  1.7G 83 Linux\\n', 'SD 卡对应盘符为 /dev/mmcblk0，包括 3 个分区，分别为\\n', '\\n', '/dev/mmcblk0p1：引导分区\\n', '/dev/mmcblk0p2：交换分区\\n', '/dev/mmcblk0p3：根目录分区\\n', '这里我们需要将根目录分区 /dev/mmcblk0p3 进行扩容。\\n', '\\n', '在 root 权限下执行 fdisk /dev/mmcblk0 命令进入到交互式命令行界面，按照以下步骤扩展分区，如图 1所示。\\n', '\\n', '输入 p，查看分区信息。\\n', '\\n', '记录分区 /dev/mmcblk0p3 的起始扇区号，即 /dev/mmcblk0p3 分区信息中 Start 列的值，示例中为 1593344。\\n', '\\n', '输入 d，删除分区。\\n', '\\n', '输入 3 或直接按 Enter，删除序号为 3 的分区，即 /dev/mmcblk0p3 分区。\\n', '\\n', '输入 n，创建新的分区。\\n', '\\n', '输入 p 或直接按 Enter，创建 Primary 类型的分区。\\n', '\\n', '输入 3 或直接按 Enter，创建序号为 3 的分区，即 /dev/mmcblk0p3 分区。\\n', '\\n', '输入新分区的起始扇区号，即第 1 步中记录的起始扇区号，示例中为 1593344。\\n', '\\n', ' 须知：\\n', '请勿直接按“Enter”或使用默认参数。\\n', '\\n', '按 Enter，使用默认的最后一个扇区号作为新分区的终止扇区号。\\n', '\\n', '输入 N，不修改扇区标记。\\n', '\\n', '输入 w，保存分区设置并退出交互式命令行界面。\\n', '\\n', '图 1 分区扩容\\n', '\\n', '\\n', '在 root 权限下执行 fdisk -l 命令查看磁盘分区信息，以确保磁盘分区正确。命令和回显如下：\\n', '\\n', '# fdisk -l\\n', 'Disk /dev/mmcblk0: 14.86 GiB, 15931539456 bytes, 31116288 sectors\\n', 'Units: sectors of 1 * 512 = 512 bytes\\n', 'Sector size (logical/physical): 512 bytes / 512 bytes\\n', 'I/O size (minimum/optimal): 512 bytes / 512 bytes\\n', 'Disklabel type: dos\\n', 'Disk identifier: 0xf2dc3842\\n', '\\n', 'Device         Boot   Start      End  Sectors  Size Id Type\\n', '/dev/mmcblk0p1 *       8192   593919   585728  286M  c W95 FAT32 (LBA)\\n', '/dev/mmcblk0p2       593920  1593343   999424  488M 82 Linux swap / Solaris\\n', '/dev/mmcblk0p3      1593344 31116287 29522944 14.1G 83 Linux\\n', '在 root 权限下执行 resize2fs /dev/mmcblk0p3，增大未加载的文件系统大小。\\n', '\\n', '执行 df -lh 命令查看磁盘空间信息，以确保根目录分区已扩展。\\n', '\\n', ' 须知：\\n', '如果根目录分区未扩展，可执行 reboot 命令重启树莓派之后再在 root 权限下执行 resize2fs /dev/mmcblk0p3。\\n', '\\n', '连接 WIFI\\n', '请按照以下步骤连接 WIFI：\\n', '\\n', '查看 IP 和网卡信息\\n', '\\n', 'ip a\\n', '\\n', '获取无线网卡 wlan0 信息：\\n', '\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '    inet 127.0.0.1/8 scope host lo\\n', '    valid_lft forever preferred_lft forever\\n', '    inet6 ::1/128 scope host\\n', '    valid_lft forever preferred_lft forever\\n', '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n', '    link/ether dc:a6:32:50:de:57 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.31.109/24 brd 192.168.31.255 scope global dynamic noprefixroute eth0\\n', '    valid_lft 41570sec preferred_lft 41570sec\\n', '    inet6 fe80::cd39:a969:e647:3043/64 scope link noprefixroute\\n', '    valid_lft forever preferred_lft forever\\n', '3: wlan0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000\\n', '    link/ether e2:e6:99:89:47:0c brd ff:ff:ff:ff:ff:ff\\n', '扫描可以连接的 WIFI 信息\\n', '\\n', 'nmcli dev wifi\\n', '\\n', '连接 WIFI\\n', '\\n', '在 root 权限下执行 nmcli dev wifi connect SSID password PWD 命令连接 WIFI。\\n', '\\n', '其中，SSID 为上一步扫描到的可供连接的 WIFI 的 SSID，PWD 为对应 WIFI 的密码。例如，SSID 为 openEuler-wifi，密码为 12345678，则连接该 WIFI 命令为：nmcli dev wifi connect openEuler-wifi password 12345678，连接成功：\\n', '\\n', \"Device 'wlan0' successfully activated with '26becaab-4adc-4c8e-9bf0-1d63cf5fa3f1'.\\n\", '查看 IP 和无线网卡信息\\n', '\\n', 'ip a\\n', '\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '    inet 127.0.0.1/8 scope host lo\\n', '    valid_lft forever preferred_lft forever\\n', '    inet6 ::1/128 scope host\\n', '    valid_lft forever preferred_lft forever\\n', '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n', '    link/ether dc:a6:32:50:de:57 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.31.109/24 brd 192.168.31.255 scope global dynamic noprefixroute eth0\\n', '    valid_lft 41386sec preferred_lft 41386sec\\n', '    inet6 fe80::cd39:a969:e647:3043/64 scope link noprefixroute\\n', '    valid_lft forever preferred_lft forever\\n', '3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\\n', '    link/ether dc:a6:32:50:de:58 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.31.110/24 brd 192.168.31.255 scope global dynamic noprefixroute wlan0\\n', '    valid_lft 43094sec preferred_lft 43094sec\\n', '    inet6 fe80::394:d086:27fa:deba/64 scope link noprefixroute\\n', '    valid_lft forever preferred_lft forever']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_安装方式介绍.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D-1.html", "text_entry": "['安装方式介绍\\n', ' 须知：\\n', '\\n', '硬件仅支持树莓派 3B/3B+/4B。\\n', '采用刷写镜像到 SD 卡方式安装。本章节提供 Windows/Linux/Mac 上刷写镜像的操作方法。\\n', '本章节使用的镜像是参考“安装准备”获取 openEuler 的树莓派版本镜像。\\n', '安装方式介绍\\n', 'Windows 下刷写镜像\\n', '格式化 SD 卡\\n', '写入 SD 卡\\n', 'Linux 下刷写镜像\\n', '查看磁盘分区信息\\n', '卸载 SD 卡挂载点\\n', '写入 SD 卡\\n', 'Mac 下刷写镜像\\n', '查看磁盘分区信息\\n', '卸载 SD 卡挂载点\\n', '写入 SD 卡\\n', 'Windows 下刷写镜像\\n', '本节以 Windows 10 为例，介绍如何在 Windows 环境下将镜像刷写到 SD 卡。\\n', '\\n', '格式化 SD 卡\\n', '请按照以下步骤格式化 SD 卡：\\n', '\\n', '下载并安装格式化 SD 卡工具，以下操作以 SD Card Formatter 格式化工具为例。\\n', '\\n', '打开 SD Card Formatter，在 “Select card” 中选择需要格式化的 SD 卡的盘符。\\n', '\\n', '若 SD 卡之前未安装过镜像，盘符只有一个。在 “Select card” 中选择需要格式化的 SD 卡对应盘符。\\n', '\\n', '若 SD 卡之前安装过镜像，盘符会有一个或多个。例如，SD 卡对应三个盘符：E、G、H。在 “Select card” 中选择需要格式化的 SD 卡对应 boot 分区盘符 E。\\n', '\\n', '在 “Formatting options” 中选择格式化方式。默认为 “Qick format”。\\n', '\\n', '单击“Format”开始格式化。界面通过进度条显示格式化进度。\\n', '\\n', '格式化完成后会弹出 “Formatting was successfully completed” 的提示框，单击“确定”完成格式化。\\n', '\\n', '写入 SD 卡\\n', ' 须知：\\n', '如果获取的是压缩后的镜像文件“openEuler-22.03_LTS-raspi-aarch64.img.xz”，需要先将压缩文件解压得到 “openEuler-22.03_LTS-raspi-aarch64.img”镜像文件。\\n', '\\n', '请按照以下步骤将“openEuler-22.03_LTS-raspi-aarch64.img”镜像文件写入 SD 卡：\\n', '\\n', '下载并安装刷写镜像的工具，以下操作以 Win32 Disk Imager 工具为例。\\n', '右键选择“以管理员身份运行”，打开 Win32 Disk Imager。\\n', '在“映像文件”中选择 img 格式的镜像文件路径。\\n', '在“设备”中选择待写入的 SD 卡盘符。\\n', '单击“写入”。界面通过任务进度条显示写入 SD 卡的进度。\\n', '写入完成后会弹出 “写入成功” 的提示框，单击“OK”完成写入。\\n', 'Linux 下刷写镜像\\n', '本节介绍如何在 Linux 环境下将镜像刷写到SD卡。\\n', '\\n', '查看磁盘分区信息\\n', '在 root 权限下执行 fdisk -l 获取 SD 卡磁盘信息，例如 SD 卡对应磁盘为 /dev/sdb。\\n', '\\n', '卸载 SD 卡挂载点\\n', '执行 df -lh 命令查看当前已挂载的卷。\\n', '\\n', '如果 SD 卡对应的分区未挂载，则跳过该步骤；如果 SD 卡对应分区已挂载，如 SD 卡对应的两个分区 /dev/sdb1 和 /dev/sdb3 已挂载，则需要卸载对应分区，在 root 权限下执行以下命令：\\n', '\\n', 'umount /dev/sdb1\\n', '\\n', 'umount /dev/sdb3\\n', '\\n', '写入 SD 卡\\n', '如果获取的是压缩后的镜像，需要先执行 xz -d openEuler-22.03_LTS-raspi-aarch64.img.xz 命令将压缩文件解压得到“openEuler-22.03_LTS-raspi-aarch64.img”镜像文件；否则，跳过该步骤。\\n', '\\n', '将镜像 openEuler-22.03_LTS-raspi-aarch64.img 刷写入 SD 卡，在 root 权限下执行以下命令：\\n', '\\n', 'dd bs=4M if=openEuler-22.03_LTS-raspi-aarch64.img of=/dev/sdb\\n', '\\n', ' 说明： 一般情况下，将块大小设置为 4M。如果写入失败或者写入的镜像无法使用，可以尝试将块大小设置为 1M 重新写入，但是设置为 1M 比较耗时。\\n', '\\n', 'Mac 下刷写镜像\\n', '本节介绍如何在 Mac 环境下将镜像刷写到SD卡。\\n', '\\n', '查看磁盘分区信息\\n', '在 root 权限下执行 diskutil list 获取 SD 卡磁盘信息，例如 SD 卡对应磁盘为 /dev/disk3。\\n', '\\n', '卸载 SD 卡挂载点\\n', '执行 df -lh 命令查看当前已挂载的卷。\\n', '\\n', '如果 SD 卡对应的分区未挂载，则跳过该步骤；如果 SD 卡对应分区已挂载，如 SD 卡对应的两个分区 /dev/disk3s1 和 /dev/disk3s3 已挂载，则需要卸载对应分区，在 root 权限下执行以下命令：\\n', '\\n', 'diskutil umount /dev/disk3s1\\n', '\\n', 'diskutil umount /dev/disk3s3\\n', '\\n', '写入 SD 卡\\n', '如果获取的是压缩后的镜像，需要先执行 xz -d openEuler-22.03_LTS-raspi-aarch64.img.xz 命令将压缩文件解压得到“openEuler-22.03_LTS-raspi-aarch64.img”镜像文件；否则，跳过该步骤。\\n', '\\n', '将镜像 openEuler-22.03_LTS-raspi-aarch64.img 刷入 SD 卡，在 root 权限下执行以下命令：\\n', '\\n', 'dd bs=4m if=openEuler-22.03_LTS-raspi-aarch64.img of=/dev/sdb\\n', '\\n', ' 说明： 一般情况下，将块大小设置为 4m。如果写入失败或者写入的镜像无法使用，可以尝试将块大小设置为 1m 重新写入，但是设置为 1m 比较耗时。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_Docker容器_安装配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-3.html", "text_entry": "['安装配置\\n', '本章节主要介绍和开源容器Docker安装相关的重要配置。\\n', '\\n', '安装配置\\n', '注意事项\\n', '基本安装配置\\n', '配置daemon参数\\n', 'daemon运行目录配置\\n', 'daemon自带网络配置\\n', 'daemon umask配置\\n', 'daemon启动时间\\n', '关联组件journald\\n', '关联组件firewalld\\n', '关联组件iptables\\n', '关联组件audit\\n', '安全配置seccomp\\n', '禁止修改docker daemon的私有目录\\n', '普通用户大量部署容器场景下的配置注意事项\\n', '存储驱动配置\\n', '配置overlay2存储驱动\\n', '配置devicemapper存储驱动\\n', '强制退出docker相关后台进程的影响\\n', '信号量残留\\n', '网卡残留\\n', '重启容器失败\\n', '服务无法正常重启\\n', '系统掉电影响\\n', '注意事项\\n', 'Docker容器的安装需要使用root权限。\\n', 'docker-engine rpm包与containerd rpm包、runc rpm包、podman rpm包不能同时安装。因为docker-engine rpm包中已经包含Docker运行所需的所有组件，其中包括containerd、runc、docker二进制，且containerd、runc和podman rpm包也分别提供了对应的二进制，所以重复安装时会出现软件包冲突。\\n', '基本安装配置\\n', '配置daemon参数\\n', '可以通过在/etc/docker/daemon.json文件中添加配置项自定义配置参数，相关配置项以及如何使用可以通过dockerd –help查看。配置示例如下：\\n', '\\n', 'cat /etc/docker/daemon.json \\n', '{        \\n', '    \"debug\": true,        \\n', '    \"storage-driver\": \"overlay2\",        \\n', '    \"storage-opts\": [\"overlay2.override_kernel_check=true\"] \\n', '}\\n', 'daemon运行目录配置\\n', '用户需要明白重新指定各种运行目录和文件（包括–graph、–exec-root等），可能会存在目录冲突，或文件属性变换，对应用的正常使用造成影响。\\n', '\\n', ' 须知：\\n', '用户指定的目录或文件应为docker专用，避免冲突导致的文件属性变化带来安全问题。\\n', '\\n', '以–graph为例，当我们使用/new/path/作为daemon新的Root Dir时，如果/new/path/下已经存在文件，且目录或文件名与docker需要使用的目录或文件名冲突（例如： containers、hooks、tmp等目录）时，docker可能会更新原有目录或文件的属性，包括属主、权限等为自己的属主和权限。\\n', ' 须知：\\n', '从docker-17.05开始，–graph参数被标记为Deprecated，用新的参数–data-root替代。\\n', '\\n', 'daemon自带网络配置\\n', 'Docker daemon使用–bip参数指定docker0网桥的网段之后，如果在下一次重启的时候去掉–bip参数，docker0网桥会沿用上一次的–bip配置，即使重启之前已经删除docker0网桥。原因是docker会保存网络配置并在下一次重启的时候默认恢复上一次配置。\\n', 'Docker network create 并发创建网络的时候，可以创建具有相同名字的两个网络。原因是docker network是通过id来区分的，name只是个便于识别的别名而已，不保证唯一性。\\n', 'Docker在桥接bridge网络模式下，Docker容器是通过宿主机上的NAT模式，建立与宿主机之外世界的通信。Docker Daemon在启动一个容器时，每在宿主机上映射一个端口都会启动一个docker-proxy进程来实现访问代理。建议用户在使用这种userland-proxy时，只映射必须的端口，减少docker-proxy进行端口映射所消耗的资源。\\n', 'daemon-umask配置\\n', '容器主进程和exec进程的默认umask为0022，为了满足安全性需求，避免容器受到攻击，修改runc的实现，将默认umask修改为0027。修改后others群组将无法访问新建文件或目录。\\n', '\\n', 'docker启动容器时的默认umask值为0027，可以在dockerd启动时，使用–exec-opt native.umask=normal参数将容器启动时的umask修改为0022。\\n', '\\n', ' 须知：\\n', '如果docker create/run也配置了native.umask参数，则以docker create/run中的配置为准。\\n', '\\n', '详细的配置见docker create和docker run章节的参数说明。\\n', '\\n', 'daemon启动时间\\n', 'Docker服务由systemd管理，systemd对各个服务的启动时间有限制，如果指定时间内docker服务未能成功启动，则可能由以下原因导致：\\n', '\\n', '如果使用devicemapper且为第一次启动，docker daemon需要对该设备做文件系统初始化操作，而该操作会进行大量磁盘IO操作，在磁盘性能不佳或存在大量IO竞争时，很可能会导致docker daemon启动超时。devicemapper设备只需要初始化一次，后续docker daemon启动时不再需要重复初始化。\\n', '如果当前系统资源占用太高，导致系统卡顿，系统所有的操作都会变慢，也可能会出现docker服务启动超时的情况。\\n', 'daemon重启过程中，需要遍历并读取docker工作目录下每一个容器的配置文件、容器init层和可写层的配置，如果当前系统存在过多容器（包含created和exited的容器），并且磁盘读写性能受限，也会出现daemon遍历文件过久导致docker服务启动超时的情况。\\n', '  \\n', '\\n', '出现服务启动超时情况，建议对以下两种情况进行排查调整：\\n', '\\n', '容器编排层定期清理不需要的容器，尤其是exited的容器。\\n', '结合解决方案的性能要求场景，调整编排层的清理周期和docker服务的启动时间。\\n', '关联组件journald\\n', '重启systemd-journald后需要重启docker daemon。journald通过pipe获取docker daemon的日志，如果journald服务重启，会导致该pipe被关闭，docker的日志写入操作便会触发SIGPIPE信号，该错误信号会导致docker daemon crash。由于忽略该信号影响严重，可能导致后续docker daemon的日志无法记录，因此建议用户在重启journald服务或者journald 异常后主动去重启docker daemon，保证docker日志能够被正常记录，避免daemon crash导致的状态异常。\\n', '\\n', '关联组件firewalld\\n', '需要在重启或拉起firewalld之后重启docker服务，保证docker服务在firewalld之后启动。\\n', '\\n', 'firewalld服务启动会清空当前系统的iptables规则，所以在启动docker daemon过程中，重启firewalld可能会导致docker服务插入iptables规则失败，从而导致docker服务启动失败。\\n', 'docker服务启动后重启firewalld服务，或者状态发生了变化（从启动到停止，或者从停止到启动），会导致docker的iptables规则被删除，创建带端口映射的容器失败。\\n', '关联组件iptables\\n', 'docker使用–icc=false选项时，可以限制容器之间互通，但若os自带某些规则，可以造成限制容器之间互通失效，例如：\\n', '\\n', 'Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) \\n', '... \\n', '0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0 \\n', '... \\n', '0     0 DROP       all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0\\n', '...\\n', '在Chain FORWARD中，DROP上面多出了一条ACCEPT icmp的规则，造成加了–icc=false后，容器之间也能ping通，但容器之间如果使用udp/tcp协议，对端仍然是不可达的。\\n', '\\n', '因此，在容器os中使用docker，如果需要使用–icc=false选项时，建议先在host上清理一下iptables相关的规则。\\n', '\\n', '关联组件audit\\n', 'docker支持配置audit，但不是强制的。例如：\\n', '\\n', '-w /var/lib/docker -k docker \\n', '-w /etc/docker -k docker \\n', '-w /usr/lib/systemd/system/docker.service -k docker \\n', '-w /usr/lib/systemd/system/docker.socket -k docker \\n', '-w /etc/sysconfig/docker -k docker \\n', '-w /usr/bin/docker-containerd -k docker \\n', '-w /usr/bin/docker-runc -k docker \\n', '-w /etc/docker/daemon.json -k docker\\n', '配置docker的audit，好处在于可以记录更多信息便于审计，但从安全角度来看，它对防攻击并没有实质性的作用。另一方面，audit配置会导致严重的效率问题，可能导致系统卡顿，生产环境中请谨慎使用。\\n', '\\n', '下面以“-w /var/lib/docker -k docker”为例，演示docker audit的配置：\\n', '\\n', '[root@localhost signal]# cat /etc/audit/rules.d/audit.rules | grep docker -w /var/lib/docker/  -k docker \\n', '[root@localhost signal]# auditctl -R /etc/audit/rules.d/audit.rules | grep docker \\n', '[root@localhost signal]# auditctl -l | grep docker -w /var/lib/docker/ -p rwxa -k docker\\n', ' 说明：\\n', '-p [r|w|x|a] 和-w一起使用，观察用户对这个目录的读、写、执行或者属性变化（如时间戳变化）。这样的话，在/var/lib/docker目录下的任何文件、目录操作，都会打印日志到audit.log中，从而会有太多的日志往audit.log中记录，会严重地影响auditd， 比如内存、cpu占用等，进而影响os的运行。例如：每次执行\"ls /var/lib/docker/containers\"都会有类似如下日志记录到/var/log/audit/audit.log中。\\n', '\\n', 'type=SYSCALL msg=audit(1517656451.457:8097): arch=c000003e syscall=257 success=yes exit=3 a0=ffffffffffffff9c a1=1b955b0 a2=90800 a3=0 items=1 ppid=17821 pid=1925 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts6 ses=4 comm=\"ls\" exe=\"/usr/bin/ls\" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=\"docker\"type=CWD msg=audit(1517656451.457:8097):  cwd=\"/root\"type=PATH msg=audit(1517656451.457:8097): item=0 name=\"/var/lib/docker/containers\" inode=1049112 dev=fd:00 mode=040700 ouid=0 ogid=0 rdev=00:00 obj=unconfined_u:object_r:container_var_lib_t:s0 objtype=NORMAL \\n', '  \\n', '\\n', '安全配置seccomp\\n', '在做容器网络性能测试时发现，Docker相对于原生内核namespace性能有所下降，经分析开启seccomp后，系统调用（如：sendto）不会通过system_call_fastpath进行，而是调用tracesys，这会带来性能大幅下降。因此，建议在有高性能要求的业务的容器场景下关闭seccomp，示例如下：\\n', '\\n', 'docker run -itd --security-opt seccomp=unconfined busybox:latest\\n', '禁止修改docker-daemon的私有目录\\n', '不允许对Docker用的根目录（默认/var/lib/docker）和运行时目录（默认/run/docker）以及其文件作任何修改，包括在该目录下删除文件，添加文件，对目录或者文件做软/硬链接，修改文件的属性/权限，修改文件的内容等，如果确实需要做修改，后果自负。\\n', '\\n', '普通用户大量部署容器场景下的配置注意事项\\n', '普通用户在OS主机上能创建的进程数的上限，例如：可以在系统中创建配置文件“/etc/security/limits.d/20-nproc.conf”限制；类似的，普通用户在容器里也能创建的进程数的上限，由容器镜像中“/etc/security/limits.d/20-nproc.conf”文件对应的值决定，如下所示：\\n', '\\n', 'cat /etc/security/limits.conf \\n', '*       soft    nproc   4096\\n', '当普通用户大量部署容器，导致容器内进程过多资源不够出现报错时，需要把容器镜像“/etc/security/limits.d/20-nproc.conf”文件中如上所示的4096配置值加大。\\n', '\\n', '可配置的最大值请参考内核的最大能力，如下：\\n', '\\n', '[root@localhost ~]# sysctl -a | grep pid_max \\n', 'kernel.pid_max = 32768\\n', '存储驱动配置\\n', '本发行版docker支持overlay2和devicemapper两种存储驱动。由于overlay2较devicemapper而言，拥有更好的性能，建议用户在生产环境中优先考虑。\\n', '\\n', '配置overlay2存储驱动\\n', '配置方法\\n', 'docker默认为使用overlay2存储驱动，也可以通过如下两种方式显示指定。\\n', '\\n', '编辑/etc/docker/daemon.json，通过storage-driver字段显示指定。\\n', '\\n', 'cat /etc/docker/daemon.json\\n', '{\\n', '    \"storage-driver\": \"overlay2\"\\n', '}\\n', '编辑/etc/sysconfig/docker-storage，通过docker deamon启动参数显示指定。\\n', '\\n', 'cat /etc/sysconfig/docker-storage \\n', 'DOCKER_STORAGE_OPTIONS=\"--storage-driver=overlay2\"\\n', '注意事项\\n', '部分容器生命周期管理的操作会报找不到相应的rootfs或者相关的可执行文件。\\n', '\\n', '如果容器的健康检查配置的是执行容器内的可执行文件，也会报错，导致容器的健康检查失败。\\n', '\\n', '如果将overlay2作为graphdriver，在容器中第一次修改镜像中的文件时，若该文件的大小大于系统剩余的空间，修改将会失败。因为即使修改很小，也要把这个文件完整的拷贝到上层，剩余空间不足导致失败。\\n', '\\n', 'overlay2文件系统相比普通文件系统天然存在一些行为差异，归纳如下：\\n', '\\n', '内核版本\\n', '\\n', 'overlay2只兼容原生4.0以上内核，建议配合使用ext4文件系统。\\n', '\\n', 'Copy-UP性能问题\\n', '\\n', '修改lower层文件会触发文件复制到upper层，其中数据块复制和fsync比较耗时。\\n', '\\n', 'rename目录问题\\n', '\\n', '只有源路径和目标路径都在merged层时，才允许rename系统调用，否则rename系统调用会报错-EXDEV。\\n', '\\n', '内核4.10引入了redirect dir特性来修复rename问题，对应内核选项为CONFIG_OVERLAY_FS_REDIRECT_DIR。\\n', '\\n', '在使用overlay2场景下，对文件系统目录进行重命名时，如果系统配置文件/sys/module/overlay/parameters/redirect_dir中配置的特性开关为关闭状态，则会导致使用失败；如果用户要使用相关特性，需要用户手动设置/sys/module/overlay/parameters/redirect_dir为“Y”。\\n', '\\n', 'Hard link break问题\\n', '\\n', '当lower层目录中有多个硬链接，在merged层写入数据会触发Copy-UP，导致硬链接断开。\\n', '内核4.13引入了index feature来修复这个问题，对应内核选项为 CONFIG_OVERLAY_FS_INDEX。注意这个选项没有前向兼容性，不支持热升级。\\n', 'st_dev和st_ino变化\\n', '\\n', '触发Copy-UP之后，用户只能看到merged层中的新文件，inode会变化。虽然attr和xattr可以复制，但st_dev和st_ino具有唯一性，不可复制。这会导致stat和ls查看 到相应的变化。\\n', '\\n', 'fd变化\\n', '\\n', 'Copy-UP之前，以只读模式打开文件得到描述符fd1，Copy-UP之后，打开同名文件得到文件描述符fd2， 二者实际指向不同的文件。向fd2写入的数据不会在fd1中体现。\\n', '\\n', '异常场景\\n', '容器使用配置了overlay2存储驱动的过程中，可能出现挂载点被覆盖的异常情况。例如\\n', '\\n', '  \\n', '\\n', '异常场景-挂载点被覆盖\\n', '挂载关系：在问题容器的挂载点的下面，存在一个/var/lib/docker/overlay2的挂载点：\\n', '\\n', '[root@localhost ~]# mount -l | grep overlay \\n', 'overlay on /var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/merged type overlay (rw,relatime,seclabel,lowerdir=/var/lib/docker/overlay2/l/JL5PZQLNDCIBU3ZOG3LPPDBHIJ:/var/lib/docker/overlay2/l/ELRPYU4JJG4FDPRLZJCZZE4UO6,upperdir=/var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/diff,workdir=/var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/work) \\n', '/dev/mapper/dm-root on /var/lib/docker/overlay2 type ext4 (rw,relatime,seclabel,data=ordered)\\n', '执行部分docker命令会遇到错误，比如：\\n', '\\n', '[root@localhost ~]# docker rm 1348136d32\\n', 'docker rm: Error response from daemon: driver \"overlay2\" failed to remove root filesystem for 1348136d32: error while removing /var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785: invalid argument\\n', '此时，在主机侧可以发现对应容器的rootfs找不到，但这并不意味着rootfs丢失，只是被/var/lib/docker/overlay2挂载点覆盖，业务仍然可以正常运行，不受影响。修复方案可以参考如下：\\n', '\\n', '修复方案一\\n', '\\n', '确定当前docker所使用graphdriver：\\n', '\\n', 'docker info | grep \"Storage Driver\"\\n', '  \\n', '\\n', '查询当前的挂载点：\\n', '\\n', 'Devicemapper: mount -l | grep devicemapper \\n', 'Overlay2: mount -l | grep overlay2\\n', '输出格式为： A on B type C (D)\\n', '\\n', 'A：块设备名称或overlay\\n', 'B：挂载点\\n', 'C：文件系统类型\\n', 'D：挂载属性\\n', '从下往上逐一umount这些挂载点B。\\n', '\\n', '然后全部docker restart这些容器，或者删除所有容器。\\n', '\\n', '重启docker。\\n', '\\n', 'systemctl restart docker\\n', '修复方案二\\n', '\\n', '业务迁移\\n', '节点重启\\n', '配置devicemapper存储驱动\\n', '用户如果需要使用devicemapper存储驱动，可以通过如下两种方式显示指定。\\n', '\\n', '编辑/etc/docker/daemon.json，通过storage-driver字段显示指定。\\n', '\\n', 'cat /etc/docker/daemon.json\\n', '{\\n', '    \"storage-driver\": \"devicemapper\"\\n', '}\\n', '编辑/etc/sysconfig/docker-storage，通过docker deamon启动参数显示指定。\\n', '\\n', 'cat /etc/sysconfig/docker-storage \\n', 'DOCKER_STORAGE_OPTIONS=\"--storage-driver=devicemapper\"\\n', '注意事项\\n', '使用devicemapper必须使用devicemapper+direct-lvm的方式，配置的方法可以参考 https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production 。\\n', '\\n', '配置devicemapper时，如果系统上没有足够的空间给thinpool做自动扩容，请禁止自动扩容功能。\\n', '\\n', '禁止把/etc/lvm/profile/docker-thinpool.profile中如下两个值都改成100。\\n', '\\n', 'activation {   \\n', '  thin_pool_autoextend_threshold=80   \\n', '  thin_pool_autoextend_percent=20 \\n', '}\\n', '使用devicemapper时推荐加上–storage-opt dm.use_deferred_deletion=true –storage-opt dm.use_deferred_removal=true。\\n', '\\n', '使用devicemapper时，容器文件系统推荐使用ext4，需要在docker daemon的配置参数中加 上–storage-opt dm.fs=ext4。\\n', '\\n', '当graphdriver为devicemapper时，如果metadata文件损坏且不可恢复，需要人工介入恢复。禁止直接操作或篡改daemon存储devicemapper的元数据。\\n', '\\n', '使用devicemapper lvm时，异常掉电导致的devicemapper thinpool损坏，无法保证thinpool损坏后可以修复，也不能保证数据的完整性，需重建thinpool。\\n', '\\n', 'docker daemon开启了user namespace特性，切换devicemapper存储池时的注意事项\\n', '\\n', '一般启动容器时，deviceset-metadata文件为：/var/lib/docker/devicemapper/metadata/deviceset-metadata。\\n', '使用了user namespace场景下，deviceset-metadata文件使用的是：/var/lib/docker/{userNSUID.GID}/devicemapper/metadata/deviceset-metadata。\\n', '使用devicemapper存储驱动，容器在user namespace场景和普通场景之间切换时，需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空；针对thinpool扩容或者重建的场景下，也同样的需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空，否则docker服务会重启失败。\\n', '信号量残留\\n', '使用devicemapper作为graphdriver时，强制退出强制退出可能导致信号量残留。docker在操作dm的过程中会创建信号量，如果在释放信号量前，daemon被强制退出，可能导致该信号量无法释放，一次强制退出最多泄露一个信号量，泄露概率低。而linux系统有信号量上限限制，当信号量泄露次数达到上线值时将无法创建新的信号量，进而导致docker daemon启动失败。排查方法如下：\\n', '\\n', '首先查看系统上残留的信号量\\n', '\\n', '$ ipcs \\n', '------ Message Queues -------- \\n', 'key        msqid      owner      perms      used-bytes   messages \\n', '------ Shared Memory Segments -------- \\n', 'key        shmid      owner      perms      bytes      nattch     status \\n', '------ Semaphore Arrays -------- \\n', 'key        semid      owner      perms      nsems \\n', '0x0d4d3358 238977024  root       600        1 \\n', '0x0d4d0ec9 270172161  root       600        1 \\n', '0x0d4dc02e 281640962  root       600        1\\n', '接着用dmsetup查看devicemapper创建的信号量，该信号量集合是上一步中查看到的系统信号量的子集\\n', '\\n', '$ dmsetup udevcookies \\n', '最后查看内核信号量设置上限，第四个值就是当前系统的信号量使用上限\\n', '\\n', '$ cat /proc/sys/kernel/sem \\n', '250     32000   32      128\\n', '如果步骤1中残留的信号量数量与步骤3中看到的信号量上限相等，则是达到上限，此时docker daemon无法正常启动。可以使用下述命令增加信号量使用上限值来让docker恢复启动\\n', '\\n', '$ echo 250 32000  32  1024 > /proc/sys/kernel/sem\\n', '也可以手动清理devicemapper残留的信号量（下面是清理一分钟以前申请的dm相关信号量）\\n', '\\n', '$ dmsetup udevcomplete_all 1 \\n', 'This operation will destroy all semaphores older than 1 minutes with keys that have a prefix 3405 (0xd4d). \\n', 'Do you really want to continue? [y/n]: y \\n', '0 semaphores with keys prefixed by 3405 (0xd4d) destroyed. 0 skipped.\\n', '网卡残留\\n', '使用bridge模式启动容器的过程中，强制退出daemon可能导致网卡残留。使用bridge网络模式，当docker创建容器时，会先在host上创建一对veth，然后再把该网卡信息存到数据库中，如果在创建完成，存到docker的数据库之前，daemon被强制退出，那么该网卡无法被docker关联，下次启动也无法删除（docker本身会清理自己数据库中不用的网卡），从而造成网卡残留。\\n', '\\n', '重启容器失败\\n', '容器hook耗时较长，且启动阶段遇到containerd被强制退出，再次执行容器start操作可能失败。容器启动阶段遇到containerd被强制退出，docker start操作直接返回错误；containerd被重新拉起后，上次启动可能仍处于runc create执行阶段（执行用户自定义hook，可能耗时较长），此时再次下发docker start命令启动该容器，可能提示以下错误：\\n', '\\n', 'Error response from daemon: oci runtime error: container with id exists: xxxxxx\\n', '该错误是由runc create一个已经存在（创建中）的容器导致，等第一次start对应的runc操作结束后再次执行docker start便可以成功。\\n', '\\n', '由于hook的执行不受docker控制，这种场景下尝试回收该容器有可能导致containerd进程启动卡死（执行未知hook程序），且问题的风险可控（短期影响当前容器的创建）：\\n', '\\n', '问题出现后等待第一次操作结束可以再次成功启动该容器。\\n', '一般是在容器启动失败后创建新的容器，不复用已经失败的容器。\\n', '综上，该问题暂时作为场景约束。\\n', '\\n', '服务无法正常重启\\n', '短时间内频繁重启docker服务导致该服务无法正常重启。docker系统服务由systemd负责监控，如果docker服务在10s内重启次数超过5次，systemd服务就会监控到该异常行为，因此会禁止docker服务启动。只有等到下一个10s周期开始后，docker服务才能响应重启命令正常重启。\\n', '\\n', '系统掉电影响\\n', '主机意外掉电或系统panic等场景下，由于docker daemon的状态无法及时刷新到磁盘，导致重启后docker daemon状态不正常，可能出现的问题有（包括但不限于）：\\n', '\\n', '掉电前创建的容器，重启后docker ps -a看不到，该问题是因为该容器的状态文件没有刷新到磁盘，从而导致重启后daemon无法获取到该容器的状态（镜像、卷、网络等也可能会有类似问题）。\\n', '掉电前某个文件正处于写入状态，尚未完全写入，重启后daemon重新加载该文件发现文件格式不正常或内容不完整，导致重启加载出错。\\n', '针对掉电时会破坏docker DB的情况，在重启节点时会清理data-root下面的db文件。因此重启前创建的如下信息在重启后会被删除：\\n', 'network，用docker network创建的资源会在重启后清除。\\n', '\\n', 'volume，用 docker volume创建的资源会在重启后删除。\\n', '\\n', '构建缓存，构建缓存信息会在重启后删除。\\n', '\\n', 'containerd保存的元数据，由于启动容器会重建containerd元数据，重启节点会清理containerd中保存的元数据。\\n', '\\n', ' 说明：\\n', '用户若选择采用手动清理恢复环境的方式，可通过配置环境变量“DISABLE_CRASH_FILES_DELETE=true”屏蔽daemon掉电重启时db文件清理功能。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_Docker容器_容器管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-3.html", "text_entry": "['容器管理\\n', '容器管理\\n', '创建容器\\n', '创建容器使用hook-spec\\n', '创建容器配置健康检查\\n', '停止与删除容器\\n', '容器信息查询\\n', '修改操作\\n', '创建容器\\n', '下载镜像\\n', '运行docker命令需要root权限，当你使用普通用户登录时，需要用sudo权限执行docker命令。\\n', '\\n', '[root@localhost ~]# docker pull busybox\\n', '该命令行将在docker官方的镜像库中下载busybox:latest（命令行中没指定TAG，所以使用默认的TAG名latest），镜像在下载过程中将检测所依赖的层本地是否存在，如果存在就跳过。从私有镜像库下载镜像时，请带上registry描述，例如：假如建立了一个私有镜像库，地址为192.168.1.110:5000，里面有一些常用镜像。使用下面命令行从私有镜像库中下载镜像。\\n', '\\n', '[root@localhost ~]# docker pull 192.168.1.110:5000/busybox\\n', '从私有镜像库中下载下来的image名字带有镜像库地址的信息名字比较长，可以用docker tag命令生成一个名字简单点的image。\\n', '\\n', '[root@localhost ~]# docker tag 192.168.1.110:5000/busybox busybox\\n', '可以通过docker images命令查看本地镜像列表。\\n', '\\n', '运行一个简单的应用\\n', '[root@localhost ~]# docker run busybox /bin/echo \"Hello world\"\\n', 'Hello world\\n', '该命令行使用busybox:latest（命令行中没有指定tag，所以使用默认的tag名latest）镜像创建了一个容器，在容器内执行了echo “Hello world”。使用下面命令行可以查看刚才创建的这个容器。\\n', '\\n', '[root@localhost ~]# docker ps -l\\n', 'CONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS                     PORTS               NAMES\\n', 'd8c0a3315bc0        busybox \"/bin/echo \\'Hello wo…\"   5 seconds ago       Exited (0) 3 seconds ago                       practical_franklin\\n', '创建一个交互式的容器\\n', '[root@localhost ~]# docker run -it busybox /bin/bash\\n', 'root@bf22919af2cf:/# ls \\n', 'bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var \\n', 'root@bf22919af2cf:/# pwd \\n', '/\\n', '-ti选项分配一个伪终端给容器并可以使用STDIN进行交互，可以看到这时可以在容器内执行一些命令。这时的容器看起来完全是一个独立的linux虚拟机。使用exit命令退出容器。\\n', '\\n', '后台运行容器\\n', '执行下面命令行，-d指示这个容器在后台运行，--name=container1 指定容器的名字为container1。\\n', '\\n', '[root@localhost ~]# docker run -d --name=container1 busybox /bin/sh -c \"while true;do echo hello world;sleep 1;done\"\\n', '7804d3e16d69b41aac5f9bf20d5f263e2da081b1de50044105b1e3f536b6db1c\\n', '命令行的执行结果是返回了这个容器的ID，没有返回命令的执行结果hello world，此时容器在后台运行，可以用docker ps命令查看正在运行的容器:\\n', '\\n', '[root@localhost ~]# docker ps\\n', 'CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\\n', '7804d3e16d69        busybox \"/bin/sh -c \\'while tr\"   11 seconds ago      Up 10 seconds                           container1\\n', '用docker logs查看容器运行的输出：\\n', '\\n', '[root@localhost ~]# docker logs container1\\n', 'hello world\\n', 'hello world\\n', 'hello world\\n', '...\\n', '容器网络连接\\n', '默认情况下，容器可以访问外部网络，而外部网络访问容器时需要通过端口映射，下面以在docker中运行私有镜像库服务registry为例。下面的命令行中-P使registry镜像中开放的端口暴露给主机。\\n', '\\n', '[root@localhost ~]# docker run --name=container_registry -d -P registry \\n', 'cb883f6216c2b08a8c439b3957fb396c847a99079448ca741cc90724de4e4731 \\n', 'container_registry这个容器已经启动了，但是并不知道容器中的服务映射到主机的哪个端口，通过docker port查看端口映射。\\n', '\\n', '[root@localhost ~]# docker port container_registry \\n', '5000/tcp -> 0.0.0.0:49155 \\n', '从输出可以看出，容器内的5000端口映射到了主机的49155端口。通过主机IP:49155就可以访问registry服务了，在浏览器中输入http://localhost:49155就可以返回registry的版本信息。\\n', '\\n', '在运行registry镜像的时候还可以直接指定端口映射如：\\n', '\\n', 'docker run --name=container_registry -d -p 5000:5000 registry \\n', '通过-p 5000:5000指定容器的5000端口映射到主机的5000端口。\\n', '\\n', '注意事项\\n', '启动容器不能单独加-a stdin\\n', '\\n', '启动容器时，不能单独加-a stdin，必须要同时加上-a stdout或者-a stderr，否则会导致终端即使在容器退出后也会卡住。\\n', '\\n', '避免使用已有容器的长id、短id作为新容器的name\\n', '\\n', '创建容器时，避免使用已有容器A的长id或短id作为新容器B的name。若使用容器A的长id作为容器B的name，当使用容器B的name作为指定容器进行操作时，docker匹配到的是容器A。若使用容器A的短id作为容器B的name，当使用容器A的短id作为指定容器进行相关操作时，docker匹配到的是容器B。这是因为，docker在匹配容器时，先精确匹配所有容器的长id。若未匹配成功，再根据container_name进行精确匹配；若还未匹配成功，直接对容器id进行模糊匹配。\\n', '\\n', '使用sh/bash等依赖标准输入输出的容器应该使用`-ti`参数，避免出现异常\\n', '\\n', '正常情况：不用`-ti`参数启动sh/bash等进程容器，容器会马上退出。\\n', '\\n', '出现这种问题的原因在于，docker会先创建一个匹配用于容器内业务的stdin，在不设置-ti等交互式参数时，docker会在容器启动后关闭该pipe，而业务容器进程sh/bash在检测到stdin被关闭后会直接退出。\\n', '\\n', '异常情况：如果在上述过程中的特定阶段（关闭该pipe之前）强制杀死docker daemon，会导致该pipe的daemon端没有被及时关闭，这样即使不带`-ti`的sh/bash进程也不会退出，导致异常场景，这种容器就需要手动清理。\\n', '\\n', 'Daemon重启后会接管原有的容器stream，而不带`-ti`参数的容器可能就无法处理（因为正常情况下这些容器不存在stream需要接管）；真实业务下几乎不存在这种使用方式(不带 `-ti`的sh/bash没有任何作用)，为了避免这类问题发生，限制交互类容器应该使用 `-ti`参数。\\n', '\\n', '容器存储卷\\n', '\\n', '启动容器时如果通过`-v`参数将主机上的文件挂载到容器中，在主机或容器中使用vi或sed命令修改文件可能会使文件inode发生改变，从而导致主机和容器内的文件不同步。容器中挂载文件时应该尽量避免使用这种文件挂载的方式（或不与vi和sed同时使用），也可以通过挂载文件上层目录来避免该问题。在docker挂载卷时“nocopy”选项可以避免将容器内挂载点目录下原有的文件拷贝到主机源目录下，但是这个选项只能在挂载匿名卷时使用，不能在bind mount的场景下使用。\\n', '\\n', '避免使用可能会对host造成影响的选项\\n', '\\n', '--privileged 选项会让容器获得所有权限，容器可以做挂载操作和修改/proc、/sys等目录，可能会对host造成影响，普通容器需要避免使用该选项。\\n', '\\n', '共享host的namespace，比如--pid host/--ipc host/--net host等选项可以让容器跟host共享命名空间，同样会导致容器影响host的结果，需要避免使用。\\n', '\\n', 'kernel memory cgroup不稳定，禁止使用\\n', '\\n', 'kernel memory cgroup在小于4.0版本的Linux内核上仍属于实验阶段，运行起来不稳定，虽然Docker的Warning说是小于4.0就可以，但是我们评估认为，kmemcg在高版本内核仍然不稳定，所以不管是低版本还是高版本，均禁止使用。\\n', '\\n', '当docker run --kernel-memory时，会产生如下告警：\\n', '\\n', \"WARNING: You specified a kernel memory limit on a kernel older than 4.0. Kernel memory limits are experimental on older kernels, it won't work as expected as expected and can cause your system to be unstable.\\n\", 'blkio-weight参数在支持blkio精确控制的内核下不可用\\n', '\\n', '--blkio-weight-device 可以实现容器内更为精确的blkio控制，该控制需要指定磁盘设备，可以通过docker --blkio-weight-device参数实现。同时在这种内核下docker不再提供--blkio-weight方式限制容器blkio，使用该参数创建容器将会报错:\\n', '\\n', 'docker: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused \"process_linux.go:398: container init caused \\\\\"process_linux.go:369: setting cgroup config for ready process caused \\\\\\\\\\\\\"blkio.weight not supported, use weight_device instead\\\\\\\\\\\\\"\\\\\"\"\\n', '使用--blkio-weight-device需要磁盘支持CFQ调度策略\\n', '\\n', '--blkio-weight-device参数需要磁盘工作于完全公平队列调度（CFQ：Completely Fair Queuing）的策略时才能工作。\\n', '\\n', '通过查看磁盘scheduler文件（/sys/block/<磁盘>/queue/scheduler）可以获知磁盘支持的策略以及当前所采用的策略，如查看sda：\\n', '\\n', '# cat /sys/block/sda/queue/scheduler noop [deadline] cfq \\n', '当前sda支持三种调度策略：noop, deadline, cfq，并且正在使用deadline策略。通过echo修改策略为cfq：\\n', '\\n', '# echo cfq > /sys/block/sda/queue/scheduler\\n', '容器基础镜像中systemd使用限制\\n', '\\n', '通过基础镜像创建的容器在使用过程中，容器基础镜像中的systemd仅用于系统容器，普通容器不支持使用。\\n', '\\n', '并发性能\\n', 'docker内部的消息缓冲有一个上限，超过这个上限就会将消息丢弃，因此在并发执行命令时建议不要超过1000条命令，否则有可能会造成docker内部消息丢失，从而造成容器无法启动等严重问题。\\n', '并发创建容器并对容器执行restart时会偶现“oci runtime error: container init still running”报错，这是因为containerd对事件等待队列进行了性能优化，容器stop过程中执行runc delete，尝试在1s内kill掉容器的init进程，如果1s内init进程还没有被kill掉的话runc会返回该错误。由于containerd的GC（垃圾回收机制）每隔10s会回收之前runc delete的残留资源， 所以并不影响下次对容器的操作，一般出现上述报错的话等待4~5s之后再次启动容器即可。\\n', '安全特性解读\\n', 'docker默认的权能配置分析\\n', '\\n', '原生的docker默认配置如下，默认进程携带的Cap如下:\\n', '\\n', '\"CAP_CHOWN\", \\n', '\"CAP_DAC_OVERRIDE\", \\n', '\"CAP_FSETID\", \\n', '\"CAP_FOWNER\", \\n', '\"CAP_MKNOD\", \\n', '\"CAP_NET_RAW\", \\n', '\"CAP_SETGID\", \\n', '\"CAP_SETUID\", \\n', '\"CAP_SETFCAP\", \\n', '\"CAP_SETPCAP\", \\n', '\"CAP_NET_BIND_SERVICE\", \\n', '\"CAP_SYS_CHROOT\", \\n', '\"CAP_KILL\", \\n', '\"CAP_AUDIT_WRITE\",\\n', '默认的seccomp配置是白名单，不在白名单的syscall默认会返回SCMP_ACT_ERRNO，根据给docker不同的Cap开放不同的系统调用，不在上面的权限，默认docker都不会给到容器。\\n', '\\n', 'CAP_SYS_MODULE\\n', '\\n', 'CAP_SYS_MODULE这个Cap是让容器可以插入ko，增加该Cap可以让容器逃逸，甚至破坏内核。因为容器最大的隔离是Namespace，在ko中只要把他的Namespace指向init_nsproxy即可。\\n', '\\n', 'CAP_SYS_ADMIN\\n', '\\n', 'sys_admin权限给容器带来的能力有：\\n', '\\n', '文件系统（mount，umount，quotactl）\\n', 'namespace设置相关的（setns，unshare，clone new namespace）\\n', 'driver ioctl\\n', '对pci的控制，pciconfig_read, pciconfig_write, pciconfig_iobase\\n', 'sethostname\\n', 'CAP_NET_ADMIN\\n', '\\n', '容器中有访问网络接口的和sniff网络流量的权限，容器可以获取到所有容器包括host的网络流量，对网络隔离破坏极大。\\n', '\\n', 'CAP_DAC_READ_SEARCH\\n', '\\n', '该权限开放了，两个系统调用open_by_handle_at，name_to_handle_at，如果host上没有selinux保护，容器中可通过暴力搜索file_handle结构的inode号，进而可以打开host上的任意文件，影响文件系统的隔离性。\\n', '\\n', 'CAP_SYS_RAWIO\\n', '\\n', '容器中可对host写入io端口，可造成host内核崩溃。\\n', '\\n', 'CAP_SYS_PTRACE\\n', '\\n', '容器中有ptrace权限，可对容器的进程进行ptrace调试。现runc已经修补该漏洞，但有些工具比如nsenter和docker-enter并没有改保护，容器中可对这些工具执行的进程进行调试，获取这些工具带入的资源信息（Namespace、fd等），另外， ptrace可以绕过seccomp，极大增加内核攻击面。\\n', '\\n', 'Docker Cap接口 --cap-add all\\n', '\\n', '–cap-add all表示赋予容器所有的权能，包括本节提到的比较危险的权能，使得容器可以逃逸。\\n', '\\n', '不要禁用docker的seccomp特性\\n', '\\n', \"默认的docker有一个seccomp的配置，配置中使用的是白名单，不在配置的sys_call会被seccomp禁掉，使用接口–security-opt 'seccomp:unconfined'可以禁止使用seccomp特性。如果禁用seccomp或使用自定义seccomp配置但过滤名单不全，都会增加容器对内核的攻击面。\\n\", '\\n', '不要配置/sys和/proc目录可写\\n', '\\n', '/sys和/proc目录包含了linux维护内核参数、设备管理的接口，容器中配置该目录可写可能会导致容器逃逸。\\n', '\\n', 'Docker开放Cap --CAP_AUDIT_CONTROL\\n', '\\n', '容器可以通过控制系统audit系统，并且通过AUDIT_TTY_GET/AUDIT_TTY_SET等命令可以获取审计系统中记录的tty执行输入记录，包括root密码。\\n', '\\n', 'CAP_BLOCK_SUSPEND和CAP_WAKE_ALARM\\n', '\\n', '容器可拥有阻塞系统挂起(epoll)的能力。\\n', '\\n', 'CAP_IPC_LOCK\\n', '\\n', '容器拥有该权限后，可以突破ulimit中的max locked memory限制，任意mlock超大内存块，造成一定意义的DoS攻击。\\n', '\\n', 'CAP_SYS_LOG\\n', '\\n', '容器拥有该权限后，可以dmesg读取系统内核日志，突破内核kaslr防护。\\n', '\\n', 'CAP_SYS_NICE\\n', '\\n', '容器拥有该权限后，可以改变进程的调度策略和优先级，造成一定意义的DoS攻击。\\n', '\\n', 'CAP_SYS_RESOURCE\\n', '\\n', '容器可以绕过对其的一些资源限制，比如磁盘空间资源限制、keymaps数量限制、pipe-size-max限制等，造成一定意义的DoS攻击。\\n', '\\n', 'CAP_SYS_TIME\\n', '\\n', '容器可以改变host上的时间。\\n', '\\n', 'Docker默认Cap风险分析\\n', '\\n', 'Docker默认的Cap，包含了CAP_SETUID和CAP_FSETID，如host和容器共享目录，容器可对共享目录的二进制文件进行+s设置，host上的普通用户可使用其进行提权CAP_AUDIT_WRITE，容器可以对host写入，容器可以对host写入日志，host需配置日志防爆措施。\\n', '\\n', 'Docker和host共享namespace参数，比如 --pid，--ipc, --uts\\n', '\\n', '该参数为容器和host共享namespace空间，容器和host的namespace隔离没有了，容器可对host进行攻击。比如，使用--pid 和host共享pid namespace，容器中可以看到host上的进程pid号，可以随意杀死host的进程。\\n', '\\n', '--device 把host的敏感目录或者设备，映射到容器中\\n', '\\n', 'Docker管理面有接口可以把host上的目录或者设备映射到容器中，比如--device，-v等参数，不要把host上的敏感目录或者设备映射到容器中。\\n', '\\n', '创建容器使用hook-spec\\n', '原理及使用场景\\n', 'docker支持hook的扩展特性，hook应用与底层runc的执行过程中，遵循OCI标准：https://github.com/opencontainers/runtime-spec/blob/master/config.html#hooks 。\\n', '\\n', 'hook主要有三种类型：prestart，poststart，poststop。分别作用于容器内用户应用程序启动之前，容器应用程序启动之后，容器应用程序停止之后。\\n', '\\n', '接口参考\\n', '当前为docker run和create命令增加了参数“–hook-spec”，后面接spec文件的绝对路径，可以指定容器启动时的需要添加的hook，这些hook会自动附加在docker自己动态创建的hook后面（当前docker只有一个libnetwork的prestart hook），随容器的启动/销毁过程执行用户指定的程序。\\n', '\\n', 'spec的结构体定义为：\\n', '\\n', '// Hook specifies a command that is run at a particular event in the lifecycle of a container\\n', 'type Hook struct{       \\n', '               Path    string   `json:\"path\"`    \\n', '               Args    []string `json:\"args,omitempty\"`    \\n', '               Env     []string `json:\"env,omitempty\"`      \\n', '               Timeout *int     `json:\"timeout,omitempty\"`\\n', '}\\n', '// Hooks for container setup and teardown\\n', 'type  Hooks struct{\\n', '               // Prestart is a list of hooks to be run before the container process is executed.\\n', '               // On Linux, they are run after the container namespaces are created.         \\n', '               Prestart []Hook `json:\"prestart,omitempty\"`\\n', '               // Poststart is a list of hooks to be run after the container process is started.         \\n', '               Poststart []Hook `json:\"poststart,omitempty\"`\\n', '               // Poststop is a list of hooks to be run after the container process exits.         \\n', '               Poststop []Hook `json:\"poststop,omitempty\"`\\n', '}\\n', 'Spec文件的path、args、env 都是必填信息；\\n', 'Timeout选填(建议配置)，参数类型为int，不接受浮点数，范围为[1, 120]。\\n', 'Spec内容应该是json格式的，格式不对会报错，示例参考前面。\\n', '使用的时候既可以`docker run --hook-spec /tmp/hookspec.json xxx`, 也可以 `docker create --hook-spec /tmp/hookspec.json xxx && docker start xxx`。\\n', '为容器定制特有的hook\\n', '以启动过程中添加一个网卡的过程来说明。下面是相应的hook spec文件内容：\\n', '\\n', '{\\n', '    \"prestart\": [\\n', '         {\\n', '             \"path\": \"/var/lib/docker/hooks/network-hook\",             \\n', '             \"args\": [\"network-hook\", \"tap0\", \"myTap\"],             \\n', '             \"env\": [],\\n', '             \"timeout\": 5\\n', '         }\\n', '     ],\\n', '     \"poststart\":[],     \\n', '     \"poststop\":[]\\n', '}\\n', '指定prestart hook增加一个网络hook的执行。路径是/var/lib/docker/hooks/network-hook，args代表程序的参数，第一个参数一般是程序名字，第二个是程序接受的参数。对于network-hook这个hook程序，需要两个参数，第一个是主机上的网卡名字，第二个是在容器内的网卡重命名。\\n', '\\n', '  \\n', '\\n', '注意事项\\n', '\\n', 'hook path必须为docker的graph目录（--graph）下的hooks文件夹下，默认一般为 /var/lib/docker/hooks，可以通过docker info命令查看root路径。\\n', '\\n', '[root@localhost ~]# docker info \\n', '... \\n', 'Docker Root Dir: /var/lib/docker \\n', '...\\n', '这个路径可能会跟随用户手动配置，以及user namespace的使用（daemon –userns-remap）而变化。 path进行软链接解析后，必须以Docker Root Dir/hooks开头（如本例中使用 /var/lib/docker/hooks开头），否则会直接报错。\\n', '\\n', 'hooks path必须指定绝对路径，因为这个是由daemon处理，相对路径对daemon无意义。同时绝对路径也更满足安全要求。\\n', '\\n', 'hook程序打印到stderr的输出会打印给客户端并对容器的声明周期产生影响（比如启动失败），而输出到stdout的打印信息会被直接忽略。\\n', '\\n', '严禁在hook里反向调用docker的指令。\\n', '\\n', '配置的hook执行文件必须要有可执行权限，否则hook执行会报错。\\n', '\\n', '使用hook时，执行时间应尽量短。如果hook中的prestart时间过长（超过2分钟），则会导致容器启动超时失败，如果hook中的poststop时间过长（超过2分钟），也会导致容器异常。\\n', '\\n', '目前已知的异常如下：执行docker stop命令停止容器时，2分钟超时执行清理时，由于hook还没执行结束，因此会等待hook执行结束（该过程持有锁），从而导致和该容器相关的操作都会卡住，需要等到hook执行结束才能恢复。另外，由于docker stop命令的2分钟超时处理是异步的过程，因此即使docker stop命令返回了成功，容器的状态也依然是up状态，需要等到hook执行完后状态才会修改为exited。\\n', '\\n', '使用建议\\n', '\\n', '建议配置hook的Timeout超时时间阈值，超时时间最好在5s以内。\\n', '建议不要配置过多hook，每个容器建议prestart、poststart、poststop这三个hook都只配置一个，过多hook会导致启动时间长。\\n', '建议用户识别多个hook之间的依赖关系，如果存在依赖关系，在组合hook配置文件时要根据依赖关系灵活调整顺序，hook的执行顺序是按照配置的spec文件上的先后顺序。\\n', '多个hook-spec\\n', '当有多个hook配置文件，要运行多个hook时，用户必须自己手工将多个hook配置文件组合成一个配置文件，使用--hook-spec参数指定此合并后的配置文件，方可生效所有的hook；如果配置多个--hook-spec参数，则只有最后一个生效。\\n', '\\n', '配置举例：\\n', '\\n', 'hook1.json内容如下：\\n', '\\n', '# cat /var/lib/docker/hooks/hookspec.json \\n', '{\\n', '    \"prestart\": [\\n', '        {\\n', '            \"path\": \"/var/lib/docker/hooks/lxcfs-hook\",             \\n', '            \"args\": [\"lxcfs-hook\", \"--log\", \"/var/log/lxcfs-hook.log\"],             \\n', '            \"env\": []\\n', '        }\\n', '     ],     \\n', '     \"poststart\":[],     \\n', '     \"poststop\":[]\\n', '}\\n', 'hook2.json内容如下：\\n', '\\n', '# cat /etc/isulad-tools/hookspec.json \\n', '{\\n', '      \"prestart\": [\\n', '         {\\n', '               \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '               \"args\": [\"docker-hooks\", \"--state\", \"prestart\"],             \\n', '               \"env\": []\\n', '         }\\n', '       ],     \\n', '       \"poststart\":[],     \\n', '       \"poststop\":[\\n', '          {\\n', '               \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '               \"args\": [\"docker-hooks\", \"--state\", \"poststop\"],             \\n', '               \"env\": []\\n', '          }\\n', '        ]\\n', '}\\n', '手工合并后的json内容如下：\\n', '\\n', '{\\n', '       \"prestart\":[\\n', '          {\\n', '                \"path\": \"/var/lib/docker/hooks/lxcfs-hook\",             \\n', '                \"args\": [\"lxcfs-hook\", \"--log\", \"/var/log/lxcfs-hook.log\"],             \\n', '                \"env\": []\\n', '           },         \\n', '           {\\n', '                \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '                \"args\": [\"docker-hooks\", \"--state\", \"prestart\"],             \\n', '                \"env\": []\\n', '           }\\n', '        ],     \\n', '        \"poststart\":[],     \\n', '        \"poststop\":[\\n', '            {\\n', '                \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '                \"args\": [\"docker-hooks\", \"--state\", \"poststop\"],             \\n', '                \"env\": []\\n', '            }\\n', '         ]\\n', '}\\n', '需要注意的是，docker daemon会按照数组顺序依次读取hook配置文件中prestart等action中的hook二进制，进行执行动作。用户需要识别多个hook之间的依赖关系，如果有依赖关系，在组合hook配置文件时要根据依赖关系灵活调整顺序。\\n', '\\n', '为所有容器定制默认的hook\\n', 'Docker daemon同样可以接收–hook-spec的参数，–hook-spec的语义与docker create/run的–hook-spec参数相同，这里不再复述。也可以在/etc/docker/daemon.json里添加hook配置：\\n', '\\n', '{\\n', '     \"hook-spec\": \"/tmp/hookspec.json\"\\n', '}\\n', '容器在运行时，会首先执行daemon定义的–hook-spec中指定的hooks，然后再执行每个容器单独定制的hooks。\\n', '\\n', '创建容器配置健康检查\\n', 'Docker提供了用户定义的对容器进行健康检查的功能。在Dockerfile中配置HEALTHCHECK CMD选项，或在容器创建时配置--health-cmd选项，在容器内部周期性地执行命令，通过命令的返回值来监测容器的健康状态。\\n', '\\n', '配置方法\\n', '在Dockerfile中添加配置，如：\\n', '\\n', 'HEALTHCHECK --interval=5m --timeout=3s --health-exit-on-unhealthy=true \\\\\\n', '   CMD curl -f http://localhost/ || exit 1\\n', '可配置的选项：\\n', '\\n', '–interval=DURATION，默认 30s，相邻两次命令执行的间隔时间。另外，容器启动后，经过interval时间进行第一次检查。\\n', '\\n', '–timeout=DURATION，默认 30s，单次检查命令执行的时间上限，超时则任务命令执行失败。\\n', '\\n', '–start-period=DURATION，默认 0s，容器初始化时间。初始化期间也会执行健康检查，健康检查失败不会计入最大重试次数。但是，如果在初始化期间运行状况检查成功，则认为容器已启动。之后所有连续的检查失败都将计入最大重试次数。\\n', '\\n', '–retries=N，默认 3，健康检查失败最大的重试次数。\\n', '\\n', '–health-exit-on-unhealthy=BOOLEAN，默认false，检测到容器非健康时是否杀死容器\\n', '\\n', 'CMD，必选，在容器内执行的命令。返回值为0表示成功，非0表示失败。\\n', '\\n', '在配置了HEALTHCHECK后创建镜像，HEALTHCHECK相关配置会被写入镜像的配置中。通过docker inspect可以看到。如：\\n', '\\n', '\"Healthcheck\": {\\n', '    \"Test\": [\\n', '        \"CMD-SHELL\",\\n', '        \"/test.sh\"\\n', '    ]\\n', '},\\n', '在容器创建时的配置：\\n', '\\n', 'docker run -itd --health-cmd \"curl -f http://localhost/ || exit 1\" --health-interval 5m --health-timeout 3s --health-exit-on-unhealthy centos bash\\n', '可配置的选项：\\n', '\\n', '--health-cmd，必选，在容器内执行的命令。返回值为0表示成功，非0表示失败。\\n', '\\n', '--health-interval，默认 30s，最大为int64上限（纳秒）相邻两次命令执行的间隔时间。\\n', '\\n', '--health-timeout，默认 30s，最大为int64上限（纳秒），单次检查命令执行的时间上限，超时则任务命令执行失败。\\n', '\\n', '--health-start-period，默认 0s，最大为int64上限（纳秒），容器初始化时间。\\n', '\\n', '--health-retries，默认 3，最大为int32上限，健康检查失败最大的重试次数。\\n', '\\n', '--health-exit-on-unhealthy，默认false，检测到容器非健康时是否杀死容器。\\n', '\\n', '容器启动后，HEALTHCHECK相关配置会被写入容器的配置中。通过docker inspect可以看到。如：\\n', '\\n', '\"Healthcheck\": {\\n', '    \"Test\": [\\n', '        \"CMD-SHELL\",\\n', '        \"/test.sh\"\\n', '    ]\\n', '},\\n', '检查规则\\n', '容器启动后，容器状态中显示health:starting。\\n', '经过start-period时间后开始，以interval为间隔周期性在容器中执行CMD。即：当一次命令执行完毕后，经过interval时间，执行下一次命令。\\n', '若CMD命令在timeout限制的时间内执行完毕，并且返回值为0，则视为一次检查成功，否则视为一次检查失败。检查成功后，容器状态变为health:healthy。\\n', '若CMD命令连续retries次检查失败，则容器状态变为health:unhealthy。失败后容器也会继续进行健康检查。\\n', '容器状态为health:unhealthy时，任意一次检查成功会使得容器状态变为health:healthy。\\n', '设置–health-exit-on-unhealthy的情况下，如果容器因为非被杀死退出（退出返回值137）后，健康检查只有容器在重新启动后才会继续生效。\\n', 'CMD执行完毕或超时时，docker daemon会将这次检查的起始时间、返回值和标准输出记录到容器的配置文件中。最多记录最新的5条数据。此外，容器的配置文件中还存储着健康检查的相关参数。\\n', '通过docker ps可以看到容器状态。\\n', '\\n', '[root@bac shm]# docker ps\\n', 'CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                         PORTS               NAMES\\n', '7de2228674a2        testimg             \"bash\"              About an hour ago   Up About an hour (unhealthy)                       cocky_davinci\\n', '运行中的容器的健康检查状态也会被写入容器配置中。通过docker inspect可以看到。\\n', '\\n', '\"Health\": {\\n', '    \"Status\": \"healthy\",\\n', '    \"FailingStreak\": 0,\\n', '    \"Log\": [\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:15.481414707-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:15.556908311-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:18.557297462-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:18.63035891-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        ......\\n', '}\\n', ' 说明：\\n', '\\n', '容器内健康检查的状态信息最多保存5条。会保存最后得到的5条记录。\\n', '容器内健康检查相关配置同时最多只能有一条生效。Dockerfile中配置的靠后的条目会覆盖靠前的；容器创建时的配置会覆盖镜像中的。\\n', '在Dockerfile中可以通过 HEALTHCHECK NONE来取消引用的镜像中的健康检查配置。在容器运行时可以通过配置–no-healthcheck来取消镜像中的健康检查配置。不允许在启动时同时配置健康检查相关选项与–no-healthcheck选项。\\n', '带有健康检查配置的容器启动后，若docker daemon退出，则健康检查不会执行，一直等待。docker daemon再次启动后，容器健康状态会变为starting。之后检查规则同上。\\n', '构建容器镜像时若健康检查相关参数配置为空，则按照默认值处理。\\n', '容器启动时若健康检查相关参数配置为0，则按照默认值处理。\\n', '停止与删除容器\\n', '用docker stop停止名为container1的容器：\\n', '\\n', '[root@localhost ~]# docker stop container1\\n', '也可以用docker kill来杀死容器达到停止容器的目的：\\n', '\\n', '[root@localhost ~]# docker kill container1\\n', '当容器停止之后，可以使用docker rm删除容器：\\n', '\\n', '[root@localhost ~]# docker rm container1\\n', '当然，使用docker rm -f 强制删除容器也是可以的：\\n', '\\n', '[root@localhost ~]# docker rm -f container1\\n', '注意事项\\n', '禁止使用docker rm -f XXX 删除容器。如果使用强制删除，docker rm会忽略过程中的错误，可能导致容器相关元数据残留。如果使用普通删除，如果删除过程出错，则会删除失败，不会导致元数据残留。\\n', '避免使用docker kill命令。docker kill命令发送相关信号给容器内业务进程，依赖于容器内业务进程对信号的处理策略，可能导致业务进程的信号处理行为与指令的预期不符合的情况。\\n', 'docker stop处于restarting状态的容器可能容器不会马上停止。如果一个容器使用了重启规则，当容器处于restarting状态时，docker stop这个容器时有很低的概率会立即返回，容器仍然会在重启规则的作用下再次启动。\\n', '不能用docker restart重启加了–rm参数的容器。加了–rm参数的容器在退出时，容器会主动删除，如果重启一个加了–rm的参数的容器， 可能会导致一些异常情况，比如启动容器时，同时加了–rm与-ti参数，对容器执行restart操作，可能会概率性卡住无法退出。\\n', 'docker stop/restart 指定t参数且t<0时，请确保自己容器的应用会处理stop信号\\n', 'Stop的原理：（Restart会调用Stop流程）\\n', '\\n', 'Stop会首先给容器发送Stop 信号（15）\\n', '然后等待一定的时间（这个时间就是用户输入的 t）\\n', '过了一定时间，如果容器还活着，那么就发送kill信号（9）使容器强制退出\\n', '输入参数t（单位s）的含义：\\n', '\\n', 't<0 : 表示死等，不管多久都等待程序优雅退出，既然用户这么输入了，表示对自己的应用比较放心，认为自己的程序有合理的stop信号的处理机制\\n', 't=0 ： 表示不等，立即发送kill -9 到容器\\n', 't>0 ： 表示等一定的时间，如果容器还未退出，就发送kill -9 到容器\\n', '所以如果用户使用t<0 (比如t=-1)，请确保自己容器的应用会正确处理signal 15，如果容器忽略了该信号，会导致docker stop一直卡住。\\n', '\\n', '如果容器处于Dead状态，可能底层文件系统处于busy状态，需要手动删除\\n', 'Docker在执行容器删除时，先停止容器的相关进程，之后将容器状态更改为Dead，最后执行容器rootfs的删除操作。当文件系统或者device mapper处于忙碌状态时，最后一步rootfs的删除会失败。docker ps -a查看会发现容器处于Dead状态。Dead状态的容器不能再次启动，需要等待文件系统不繁忙时，手动再次执行docker rm进行删除。\\n', '\\n', '共享pid namespace容器，子容器处于pause状态会使得父容器stop卡住，并影响docker run命令执行\\n', '使用–pid参数创建共享pid namespace的父子容器，在执行docker stop父容器时，如果子容器中有进程无法退出（比如处于D状态、pause状态），会产生父容器docker stop命令等待的情况，需要手动恢复这些进程，才能正常执行命令。\\n', '\\n', '遇到该问题的时候，请对pause状态的容器使用docker inspect 命令查询 PidMode对应的父容器是否为需要docker stop的容器。如果是该容器，请使用docker unpause将子容器解除pause状态，指令即可继续执行。\\n', '\\n', '一般来说，导致该类问题的可能原因是容器对应的pid namespace由于进程残留导致无法被销毁。如果上述方法无法解决问题，可以通过借助linux工具，获取容器内残留进程，确定pid namespace中进程无法退出的原因，解决后容器就可以退出：\\n', '\\n', '获取容器pid namespace id\\n', '\\n', 'docker inspect --format={{.State.Pid}} CONTAINERID | awk \\'{print  \"/proc/\"$1\"/ns/pid\"}\\' |xargs readlink\\n', '获取该namespace下的线程\\n', '\\n', \" ls -l /proc/*/task/*/ns/pid |grep -F PIDNAMESPACE_ID |awk '{print $9}' |awk -F  \\\\/ '{print $5}'\\n\", '容器信息查询\\n', '在任何情况下，容器的状态都不应该以docker命令执行是否成功返回为判断标准。如想查看容器状态，建议使用：\\n', '\\n', 'docker inspect <NAME|ID>\\n', '修改操作\\n', 'docker exec进入容器启动多个进程的注意事项\\n', 'docker exec进入容器执行的第一个命令为 bash 命令时，当退出 exec 时，要保证在这次exec启动的进程都退出了，再执行exit退出，否则会导致exit退出时终端卡主的情况。如果要在exit退出时，exec中启动的进程仍然在后台保持运行，要在启动进程时加上nohup。\\n', '\\n', 'docker rename和docker stats <container_name>的使用冲突\\n', '如果使用docker stats <container_name> 实时监控容器，当使用docker rename重命名容器之后，docker stats中显示的名字将还是原来的名字，不是rename后的名字。\\n', '\\n', 'docker rename操作restarting状态的容器可能会失败\\n', '对一个处于restarting状态的容器执行rename操作的时候，docker会同步修改容器网络的相关配置。由于restarting状态的容器可能还未真正启动起来，网络是不存在的，导致rename操作报错sandbox不存在。建议rename只操作非restarting的稳定状态的容器。\\n', '\\n', 'docker cp\\n', '使用docker cp向容器中拷贝文件时，docker ps以及所有对这个容器的操作都将等待docker cp结束之后才能进行。\\n', '容器以非root用户运行，当使用docker cp命令复制主机上的一个非root权限的文件到容器时，文件在容器中的权限角色会变成root。docker cp与cp命令不同，docker cp会修改复制到容器中文件的uid和gid为root。\\n', 'docker login\\n', '执行docker login后，会将usrer/passwd经 aes（256位）加密后保存在/root/.docker/config.json，同时生成 root.docker/aeskey(权限0600)，用来解密/root/.docker/config.json中的 usrer/passwd。目前不能定时更新aeskey，只能由用户手动删除aeskey来更新。aeskey更新后，不管是否重启过docker daemon，都需要重新login，才可以push。例如：\\n', '\\n', 'root@hello:~/workspace/dockerfile# docker login \\n', \"Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. \\n\", 'Username: example Password: \\n', 'Login Succeeded \\n', 'root@hello:~/workspace/dockerfile# docker push example/empty \\n', 'The push refers to a repository [docker.io/example/empty] \\n', '547b6288eb33: Layer already exists \\n', 'latest: digest: sha256:99d4fb4ce6c6f850f3b39f54f8eca0bbd9e92bd326761a61f106a10454b8900b size: 524 \\n', 'root@hello:~/workspace/dockerfile# rm /root/.docker/aeskey \\n', 'root@hello:~/workspace/dockerfile# docker push example/empty \\n', 'WARNING: Error loading config file:/root/.docker/config.json - illegal base64 data at input byte 0 \\n', 'The push refers to a repository [docker.io/example/empty] \\n', '547b6288eb33: Layer already exists \\n', 'errors: \\n', 'denied: requested access to the resource is denied \\n', 'unauthorized: authentication required \\n', 'root@hello:~/workspace/dockerfile# docker login \\n', \"Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. \\n\", 'Username: example \\n', 'Password: \\n', 'Login Succeeded \\n', 'root@hello:~/workspace/dockerfile# docker push example/empty \\n', 'The push refers to a repository [docker.io/example/empty] \\n', '547b6288eb33: Layer already exists \\n', 'latest: digest: sha256:99d4fb4ce6c6f850f3b39f54f8eca0bbd9e92bd326761a61f106a10454b8900b size: 524']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_Docker容器_镜像管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86-3.html", "text_entry": "['镜像管理\\n', '镜像管理\\n', '创建镜像\\n', '查看镜像\\n', '删除镜像\\n', '创建镜像\\n', 'docker pull、docker build、docker commit、docker import、docker load都可以创建一个新的镜像，关于这些命令的使用详见命令行参考镜像管理。\\n', '\\n', '注意事项\\n', '避免并发docker load和docker rmi操作。 如果同时满足如下两个条件，可能导致并发性问题：\\n', '\\n', '某个镜像存在于系统中。\\n', '同时对该镜像进行docker rmi和docker load操作。\\n', '所以使用时应该避免这种场景（注：所有的镜像创建操作如tag，build，load和rmi并发都有可能会导致类似的错误，应该尽量避免这类操作与rmi的并发）。\\n', '\\n', '如果Docker操作镜像时系统掉电，可能导致镜像损坏，需要手动恢复。\\n', '\\n', '由于Docker在操作镜像（pull/load/rmi/build/combine/commit/import等）时,镜像数据的操作是异步的、镜像元数据是同步的。所以如果在镜像数据未全部刷到磁盘时掉电，可能导致镜像数据和元数据不一致。对用户的表现是镜像可以看到(有可能是none 镜像)，但是无法启动容器，或者启动后的容器有异常。这种情况下应该先使用docker rmi删除该镜像，然后重新进行之前的操作，系统可以恢复。\\n', '\\n', '生产环境节点应避免存留超大数量镜像，请及时清理不使用的镜像。\\n', '\\n', '镜像数目过多会导致docker image等命令执行过慢，从而导致docker build/docker commit等相关命令执行失败，并可能导致内存堆积。在生产环境中，请及时清理不再使用的镜像和中间过程镜像。\\n', '\\n', '使用--no-parent参数build镜像时，如果有多个build操作同时进行，并且Dockerfile里 FROM的镜像相同，则可能会残留镜像，分为以下两种情况：\\n', '\\n', 'FROM的镜像不是完整镜像，则有可能会残留FROM的镜像运行时生成的镜像。残留的镜像名类似base_v1.0.0-app_v2.0.0，或者残留<none>镜像。\\n', '如果Dockerfile里的前几条指令相同，则有可能会残留<none>镜像。\\n', '可能会产生none镜像场景\\n', 'none镜像是指没有tag的最顶层镜像，比如ubuntu的imageID，只有一个tag是ubuntu，如果这个tag没了，但是imageID还在，那么这个imageID就变成了none镜像。\\n', 'Save镜像的过程中因为要把镜像的数据导出来，所以对image进行保护，但是如果这个时候来一个删除操作，可能会untag成功，删除镜像ID失败，造成该镜像变成none镜像。\\n', '执行docker pull时掉电，或者系统panic，可能出现none镜像，为保证镜像完整性，此时可通过docker rmi 删除镜像后重新拉取。\\n', '执行docker save保存镜像时，如果指定的名字为镜像ID，则load后的镜像也没有tag，其镜像名为none。\\n', 'build镜像的同时删除该镜像，有极低概率导致镜像build失败\\n', '目前的build镜像的过程是通过引用计数来保护的，当build完一个镜像后，紧接着就给该镜像的引用计数加1（holdon操作），一旦holdon操作成功，该镜像就不会被删除了，但是在holdon之前，有极低的概率，还是可以删除成功，导致build镜像失败。\\n', '\\n', '查看镜像\\n', '查看本地镜像列表：\\n', '\\n', 'docker images\\n', '删除镜像\\n', '注意事项\\n', '禁止使用docker rmi –f XXX删除镜像。如果使用强制删除，docker rmi会忽略过程中的错误，可能导致容器或者镜像关元数据残留。如果使用普通删除，如果删除过程出错，则会删除失败，不会导致元数据残留。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_CRI接口.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/CRI%E6%8E%A5%E5%8F%A3.html", "text_entry": "['CRI接口\\n', 'CRI接口\\n', '描述\\n', '接口\\n', 'Runtime服务\\n', 'RunPodSandbox\\n', 'StopPodSandbox\\n', 'RemovePodSandbox\\n', 'PodSandboxStatus\\n', 'ListPodSandbox\\n', 'CreateContainer\\n', 'StartContainer\\n', 'StopContainer\\n', 'RemoveContainer\\n', 'ListContainers\\n', 'ContainerStatus\\n', 'UpdateContainerResources\\n', 'ExecSync\\n', 'Exec\\n', 'Attach\\n', 'ContainerStats\\n', 'ListContainerStats\\n', 'UpdateRuntimeConfig\\n', 'Status\\n', 'Image服务\\n', 'ListImages\\n', 'ImageStatus\\n', 'PullImage\\n', 'RemoveImage\\n', 'ImageFsInfo\\n', '约束\\n', '描述\\n', 'CRI API 接口是由kubernetes 推出的容器运行时接口，CRI定义了容器和镜像的服务接口。ISulad使用CRI接口，实现和kubernetes 的对接。\\n', '\\n', '因为容器运行时与镜像的生命周期是彼此隔离的，因此需要定义两个服务。该接口使用Protocol Buffer定义，基于gRPC。\\n', '\\n', '当前实现CRI版本为v1alpha1版本，官方API描述文件如下：\\n', '\\n', 'https://github.com/kubernetes/kubernetes/blob/release-1.14/pkg/kubelet/apis/cri/runtime/v1alpha2/api.proto，\\n', '\\n', 'ISulad使用的为pass使用的1.14版本API描述文件，与官方API略有出入，以本文档描述的接口为准。\\n', '\\n', ' 说明：\\n', 'CRI接口websocket流式服务，服务端侦听地址为127.0.0.1，端口为10350，端口可通过命令行–websocket-server-listening-port参数接口或者daemon.json配置文件进行配置。\\n', '\\n', '接口\\n', '各接口中可能用到的参数清单如下，部分参数暂不支持配置，已在配置中标出。\\n', '\\n', '接口参数列表\\n', 'DNSConfig\\n', '\\n', '配置sandbox的DNS服务器和搜索域\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'repeated string servers\\n', '\\n', '集群的DNS服务器列表\\n', '\\n', 'repeated string searches\\n', '\\n', '集群的DNS搜索域列表\\n', '\\n', 'repeated string options\\n', '\\n', 'DNS可选项列表，参考https://linux.die.net/man/5/resolv.conf\\n', '\\n', 'Protocol\\n', '\\n', '协议的enum值列表\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'TCP = 0\\n', '\\n', 'TCP协议\\n', '\\n', 'UDP = 1\\n', '\\n', 'UDP协议\\n', '\\n', 'PortMapping\\n', '\\n', '指定sandbox的端口映射配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'Protocol protocol\\n', '\\n', '端口映射使用的协议\\n', '\\n', 'int32 container_port\\n', '\\n', '容器内的端口号\\n', '\\n', 'int32 host_port\\n', '\\n', '主机上的端口号\\n', '\\n', 'string host_ip\\n', '\\n', '主机IP地址\\n', '\\n', 'MountPropagation\\n', '\\n', '挂载传播属性的enum列表\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PROPAGATION_PRIVATE = 0\\n', '\\n', '无挂载传播属性，即linux中的private\\n', '\\n', 'PROPAGATION_HOST_TO_CONTAINER = 1\\n', '\\n', '挂载属性能从host传播到容器中，即linux中的rslave\\n', '\\n', 'PROPAGATION_BIDIRECTIONAL = 2\\n', '\\n', '挂载属性能在host和容器中双向传播，即linux中的rshared\\n', '\\n', 'Mount\\n', '\\n', 'Mount指定host上的一个挂载卷挂载到容器中（只支持文件和文件夹)\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_path\\n', '\\n', '容器中的路径\\n', '\\n', 'string host_path\\n', '\\n', '主机上的路径\\n', '\\n', 'bool readonly\\n', '\\n', '是否配置在容器中是只读的， 默认值： false\\n', '\\n', 'bool selinux_relabel\\n', '\\n', '是否设置SELinux标签（不支持配置）\\n', '\\n', 'MountPropagation propagation\\n', '\\n', '挂载传播属性配置（取值0/1/2，分别对应private/rslave/rshared传播属性） 默认值：0\\n', '\\n', 'NamespaceOption\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'bool host_network\\n', '\\n', '是否使用host的网络命名空间\\n', '\\n', 'bool host_pid\\n', '\\n', '是否使用host的PID命名空间\\n', '\\n', 'bool host_ipc\\n', '\\n', '是否使用host的IPC命名空间\\n', '\\n', 'Capability\\n', '\\n', '包含待添加与待删除的权能信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'repeated string add_capabilities\\n', '\\n', '待新增的权能\\n', '\\n', 'repeated string drop_capabilities\\n', '\\n', '待删除的权能\\n', '\\n', 'Int64Value\\n', '\\n', 'int64类型的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 value\\n', '\\n', '实际的int64值\\n', '\\n', 'UInt64Value\\n', '\\n', 'uint64类型的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'uint64 value\\n', '\\n', '实际的uint64值\\n', '\\n', 'LinuxSandboxSecurityContext\\n', '\\n', '配置sandbox的linux安全选项。\\n', '\\n', '注意，这些安全选项不会应用到sandbox中的容器中，也可能不适用于没有任何running进程的sandbox\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'NamespaceOption namespace_options\\n', '\\n', '配置sandbox的命名空间选项\\n', '\\n', 'SELinuxOption selinux_options\\n', '\\n', '配置SELinux选项（不支持）\\n', '\\n', 'Int64Value run_as_user\\n', '\\n', '配置sandbox中进程的uid\\n', '\\n', 'bool readonly_rootfs\\n', '\\n', '配置sandbox的根文件系统是否只读\\n', '\\n', 'repeated int64 supplemental_groups\\n', '\\n', '配置除主GID之外的sandbox的1号进程用户组信息\\n', '\\n', 'bool privileged\\n', '\\n', '配置sandbox是否为特权容器\\n', '\\n', 'string seccomp_profile_path\\n', '\\n', 'seccomp配置文件路径，有效值为：\\n', '\\n', '// unconfined: 不配置seccomp\\n', '\\n', '// localhost/<配置文件的全路径>： 安装在系统上的配置文件路径\\n', '\\n', '// <配置文件的全路径>： 配置文件全路径\\n', '\\n', '// 默认不配置，即unconfined。\\n', '\\n', 'LinuxPodSandboxConfig\\n', '\\n', '设定和Linux主机及容器相关的一些配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string cgroup_parent\\n', '\\n', 'sandbox的cgroup父路径，runtime可根据实际情况使用cgroupfs或systemd的语法。（不支持配置）\\n', '\\n', 'LinuxSandboxSecurityContext security_context\\n', '\\n', 'sandbox的安全属性\\n', '\\n', 'map<string, string> sysctls\\n', '\\n', 'sandbox的linux sysctls配置\\n', '\\n', 'PodSandboxMetadata\\n', '\\n', 'Sandbox元数据包含构建sandbox名称的所有信息，鼓励容器运行时在用户界面中公开这些元数据以获得更好的用户体验，例如，运行时可以根据元数据生成sandbox的唯一命名。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string name\\n', '\\n', 'sandbox的名称\\n', '\\n', 'string uid\\n', '\\n', 'sandbox的UID\\n', '\\n', 'string namespace\\n', '\\n', 'sandbox的命名空间\\n', '\\n', 'uint32 attempt\\n', '\\n', '尝试创建sandbox的次数，默认为0\\n', '\\n', 'PodSandboxConfig\\n', '\\n', '包含创建sandbox的所有必选和可选配置信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxMetadata metadata\\n', '\\n', 'sandbox的元数据，这项信息唯一标识一个sandbox，runtime必须利用此信息确保操作正确，runtime也可以根据此信息来改善用户体验，例如构建可读的sandbox名称。\\n', '\\n', 'string hostname\\n', '\\n', 'sandbox的hostname\\n', '\\n', 'string log_directory\\n', '\\n', '配置sandbox内的容器的日志文件所存储的文件夹\\n', '\\n', 'DNSConfig dns_config\\n', '\\n', 'sandbox的DNS配置\\n', '\\n', 'repeated PortMapping port_mappings\\n', '\\n', 'sandbox的端口映射\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列sandbox的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可更改的，且能够利用PodSandboxStatus接口查询\\n', '\\n', 'LinuxPodSandboxConfig linux\\n', '\\n', '与linux主机相关的可选项\\n', '\\n', 'PodSandboxNetworkStatus\\n', '\\n', '描述sandbox的网络状态\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string ip\\n', '\\n', 'sandbox的ip地址\\n', '\\n', 'string name\\n', '\\n', 'sandbox内的网络接口名\\n', '\\n', 'string network\\n', '\\n', '附加网络的名称\\n', '\\n', 'Namespace\\n', '\\n', '命名空间选项\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'NamespaceOption options\\n', '\\n', 'Linux 命名空间选项\\n', '\\n', 'LinuxPodSandboxStatus\\n', '\\n', '描述Linux sandbox的状态\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'Namespace namespaces\\n', '\\n', 'sandbox命名空间\\n', '\\n', 'PodSandboxState\\n', '\\n', 'sandbox状态值的enum数据\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'SANDBOX_READY = 0\\n', '\\n', 'sandbox处于ready状态\\n', '\\n', 'SANDBOX_NOTREADY = 1\\n', '\\n', 'sandbox处于非ready状态\\n', '\\n', 'PodSandboxStatus\\n', '\\n', '描述Podsandbox的状态信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'PodSandboxMetadata metadata\\n', '\\n', 'sandbox的元数据\\n', '\\n', 'PodSandboxState state\\n', '\\n', 'sandbox的状态值\\n', '\\n', 'int64 created_at\\n', '\\n', 'sandbox的创建时间戳，单位纳秒\\n', '\\n', 'repeated PodSandboxNetworkStatus networks\\n', '\\n', 'sandbox的多平面网络状态\\n', '\\n', 'LinuxPodSandboxStatus linux\\n', '\\n', 'Linux规范的sandbox状态\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列sandbox的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'PodSandboxStateValue\\n', '\\n', '对PodSandboxState的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxState state\\n', '\\n', 'sandbox的状态值\\n', '\\n', 'PodSandboxFilter\\n', '\\n', '用于列出sandbox时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'PodSandboxStateValue state\\n', '\\n', 'sandbox的状态\\n', '\\n', 'map<string, string> label_selector\\n', '\\n', 'sandbox的labels，label只支持完全匹配，不支持正则匹配\\n', '\\n', 'PodSandbox\\n', '\\n', '包含最小化描述一个sandbox的数据\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'PodSandboxMetadata metadata\\n', '\\n', 'sandbox的元数据\\n', '\\n', 'PodSandboxState state\\n', '\\n', 'sandbox的状态值\\n', '\\n', 'int64 created_at\\n', '\\n', 'sandbox的创建时间戳，单位纳秒\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列sandbox的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'KeyValue\\n', '\\n', '键值对的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string key\\n', '\\n', '键\\n', '\\n', 'string value\\n', '\\n', '值\\n', '\\n', 'SELinuxOption\\n', '\\n', '应用于容器的SELinux标签\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string user\\n', '\\n', '用户\\n', '\\n', 'string role\\n', '\\n', '角色\\n', '\\n', 'string type\\n', '\\n', '类型\\n', '\\n', 'string level\\n', '\\n', '级别\\n', '\\n', 'ContainerMetadata\\n', '\\n', 'Container元数据包含构建container名称的所有信息，鼓励容器运行时在用户界面中公开这些元数据以获得更好的用户体验，例如，运行时可以根据元数据生成container的唯一命名。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string name\\n', '\\n', 'container的名称\\n', '\\n', 'uint32 attempt\\n', '\\n', '尝试创建container的次数，默认为0\\n', '\\n', 'ContainerState\\n', '\\n', '容器状态值的enum列表\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'CONTAINER_CREATED = 0\\n', '\\n', 'container创建完成\\n', '\\n', 'CONTAINER_RUNNING = 1\\n', '\\n', 'container处于运行状态\\n', '\\n', 'CONTAINER_EXITED = 2\\n', '\\n', 'container处于退出状态\\n', '\\n', 'CONTAINER_UNKNOWN = 3\\n', '\\n', '未知的容器状态\\n', '\\n', 'ContainerStateValue\\n', '\\n', '封装ContainerState的数据结构\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerState state\\n', '\\n', '容器状态值\\n', '\\n', 'ContainerFilter\\n', '\\n', '用于列出container时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'PodSandboxStateValue state\\n', '\\n', 'container的状态\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'map<string, string> label_selector\\n', '\\n', 'container的labels，label只支持完全匹配，不支持正则匹配\\n', '\\n', 'LinuxContainerSecurityContext\\n', '\\n', '指定应用于容器的安全配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'Capability capabilities\\n', '\\n', '新增或去除的权能\\n', '\\n', 'bool privileged\\n', '\\n', '指定容器是否未特权模式， 默认值：false\\n', '\\n', 'NamespaceOption namespace_options\\n', '\\n', '指定容器的namespace选项\\n', '\\n', 'SELinuxOption selinux_options\\n', '\\n', 'SELinux context(可选配置项) 暂不支持\\n', '\\n', 'Int64Value run_as_user\\n', '\\n', '运行容器进程的UID。 一次只能指定run_as_user与run_as_username其中之一，run_as_username优先生效\\n', '\\n', 'string run_as_username\\n', '\\n', '运行容器进程的用户名。 如果指定，用户必须存在于容器映像中（即在映像内的/etc/passwd中），并由运行时在那里解析; 否则，运行时必须出错\\n', '\\n', 'bool readonly_rootfs\\n', '\\n', '设置容器中根文件系统是否为只读 默认值由config.json配置\\n', '\\n', 'repeated int64 supplemental_groups\\n', '\\n', '容器运行的除主GID外首进程组的列表\\n', '\\n', 'string apparmor_profile\\n', '\\n', '容器的AppArmor配置文件 暂不支持\\n', '\\n', 'string seccomp_profile_path\\n', '\\n', '容器的seccomp配置文件路径\\n', '\\n', 'bool no_new_privs\\n', '\\n', '是否在容器上设置no_new_privs的标志\\n', '\\n', 'LinuxContainerResources\\n', '\\n', '指定Linux容器资源的特定配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 cpu_period\\n', '\\n', 'CPU CFS（完全公平调度程序）周期。 默认值：0\\n', '\\n', 'int64 cpu_quota\\n', '\\n', 'CPU CFS（完全公平调度程序）配额。 默认值：0\\n', '\\n', 'int64 cpu_shares\\n', '\\n', '所占CPU份额（相对于其他容器的相对权重）。 默认值：0\\n', '\\n', 'int64 memory_limit_in_bytes\\n', '\\n', '内存限制（字节）。 默认值：0\\n', '\\n', 'int64 oom_score_adj\\n', '\\n', 'OOMScoreAdj用于调整oom-killer。 默认值：0\\n', '\\n', 'string cpuset_cpus\\n', '\\n', '指定容器使用的CPU核心。 默认值：“”\\n', '\\n', 'string cpuset_mems\\n', '\\n', '指定容器使用的内存节点。 默认值：“”\\n', '\\n', 'Image\\n', '\\n', 'Image信息描述一个镜像的基本数据。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', '镜像ID\\n', '\\n', 'repeated string repo_tags\\n', '\\n', '镜像tag 名称 repo_tags\\n', '\\n', 'repeated string repo_digests\\n', '\\n', '镜像digest信息\\n', '\\n', 'uint64 size\\n', '\\n', '镜像大小\\n', '\\n', 'Int64Value uid\\n', '\\n', '镜像默认用户UID\\n', '\\n', 'string username\\n', '\\n', '镜像默认用户名称\\n', '\\n', 'ImageSpec\\n', '\\n', '表示镜像的内部数据结构，当前，ImageSpec只封装容器镜像名称\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string image\\n', '\\n', '容器镜像名\\n', '\\n', 'StorageIdentifier\\n', '\\n', '唯一定义storage的标识\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string uuid\\n', '\\n', '设备的UUID\\n', '\\n', 'FilesystemUsage\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '收集文件系统信息时的时间戳\\n', '\\n', 'StorageIdentifier storage_id\\n', '\\n', '存储镜像的文件系统UUID\\n', '\\n', 'UInt64Value used_bytes\\n', '\\n', '存储镜像元数据的大小\\n', '\\n', 'UInt64Value inodes_used\\n', '\\n', '存储镜像元数据的inodes个数\\n', '\\n', 'AuthConfig\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string username\\n', '\\n', '下载镜像使用的用户名\\n', '\\n', 'string password\\n', '\\n', '下载镜像使用的密码\\n', '\\n', 'string auth\\n', '\\n', '下载镜像时使用的认证信息，base64编码\\n', '\\n', 'string server_address\\n', '\\n', '下载镜像的服务器地址，暂不支持\\n', '\\n', 'string identity_token\\n', '\\n', '用于与镜像仓库鉴权的令牌信息，暂不支持\\n', '\\n', 'string registry_token\\n', '\\n', '用于与镜像仓库交互的令牌信息，暂不支持\\n', '\\n', 'Container\\n', '\\n', '用于描述容器信息，例如ID, 状态等。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', '该容器所属的sandbox的ID\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', 'container的元数据\\n', '\\n', 'ImageSpec image\\n', '\\n', '镜像规格\\n', '\\n', 'string image_ref\\n', '\\n', '代表容器使用的镜像，对大多数runtime来产，这是一个image ID值\\n', '\\n', 'ContainerState state\\n', '\\n', 'container的状态\\n', '\\n', 'int64 created_at\\n', '\\n', 'container的创建时间戳，单位为纳秒\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列container的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'ContainerStatus\\n', '\\n', '用于描述容器状态信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', 'container的元数据\\n', '\\n', 'ContainerState state\\n', '\\n', 'container的状态\\n', '\\n', 'int64 created_at\\n', '\\n', 'container的创建时间戳，单位为纳秒\\n', '\\n', 'int64 started_at\\n', '\\n', 'container启动时的时间戳，单位为纳秒\\n', '\\n', 'int64 finished_at\\n', '\\n', 'container退出时的时间戳，单位为纳秒\\n', '\\n', 'int32 exit_code\\n', '\\n', '容器退出码\\n', '\\n', 'ImageSpec image\\n', '\\n', '镜像规格\\n', '\\n', 'string image_ref\\n', '\\n', '代表容器使用的镜像，对大多数runtime来产，这是一个image ID值\\n', '\\n', 'string reason\\n', '\\n', '简要描述为什么容器处于当前状态\\n', '\\n', 'string message\\n', '\\n', '易于人工阅读的信息，用于表述容器处于当前状态的原因\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列container的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'repeated Mount mounts\\n', '\\n', '容器的挂载点信息\\n', '\\n', 'string log_path\\n', '\\n', '容器日志文件路径，该文件位于PodSandboxConfig中配置的log_directory文件夹下\\n', '\\n', 'ContainerStatsFilter\\n', '\\n', '用于列出container stats时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'map<string, string> label_selector\\n', '\\n', 'container的labels，label只支持完全匹配，不支持正则匹配\\n', '\\n', 'ContainerStats\\n', '\\n', '用于列出container stats时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerAttributes attributes\\n', '\\n', '容器的信息\\n', '\\n', 'CpuUsage cpu\\n', '\\n', 'CPU使用情况\\n', '\\n', 'MemoryUsage memory\\n', '\\n', '内存使用情况\\n', '\\n', 'FilesystemUsage writable_layer\\n', '\\n', '可写层使用情况\\n', '\\n', 'ContainerAttributes\\n', '\\n', '列出container的基本信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', '容器的ID\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', '容器的metadata\\n', '\\n', 'map<string,string> labels\\n', '\\n', '可用于标识单个或一系列container的键值对\\n', '\\n', 'map<string,string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'CpuUsage\\n', '\\n', '列出container的CPU使用信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '时间戳\\n', '\\n', 'UInt64Value usage_core_nano_seconds\\n', '\\n', 'CPU的使用值，单位/纳秒\\n', '\\n', 'MemoryUsage\\n', '\\n', '列出container的内存使用信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '时间戳\\n', '\\n', 'UInt64Value working_set_bytes\\n', '\\n', '内存的使用值\\n', '\\n', 'FilesystemUsage\\n', '\\n', '列出container的读写层信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '时间戳\\n', '\\n', 'StorageIdentifier storage_id\\n', '\\n', '可写层目录\\n', '\\n', 'UInt64Value used_bytes\\n', '\\n', '镜像在可写层的占用字节\\n', '\\n', 'UInt64Value inodes_used\\n', '\\n', '镜像在可写层的占用inode数\\n', '\\n', 'Device\\n', '\\n', '指定待挂载至容器的主机卷\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_path\\n', '\\n', '容器内的挂载路径\\n', '\\n', 'string host_path\\n', '\\n', '主机上的挂载路径\\n', '\\n', 'string permissions\\n', '\\n', '设备的Cgroup权限，（r允许容器从指定的设备读取; w允许容器从指定的设备写入; m允许容器创建尚不存在的设备文件)\\n', '\\n', 'LinuxContainerConfig\\n', '\\n', '包含特定于Linux平台的配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'LinuxContainerResources resources\\n', '\\n', '容器的资源规范\\n', '\\n', 'LinuxContainerSecurityContext security_context\\n', '\\n', '容器的Linux容器安全配置\\n', '\\n', 'ContainerConfig\\n', '\\n', '包含用于创建容器的所有必需和可选字段\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', '容器的元数据。 此信息将唯一标识容器，运行时应利用此信息来确保正确操作。 运行时也可以使用此信息来提升UX（用户体检设计），例如通过构造可读名称。(必选)\\n', '\\n', 'ImageSpec image\\n', '\\n', '容器使用的镜像 (必选)\\n', '\\n', 'repeated string command\\n', '\\n', '待执行的命令 默认值： \"/bin/sh\"\\n', '\\n', 'repeated string args\\n', '\\n', '待执行命令的参数\\n', '\\n', 'string working_dir\\n', '\\n', '命令执行的当前工作路径\\n', '\\n', 'repeated KeyValue envs\\n', '\\n', '在容器中配置的环境变量\\n', '\\n', 'repeated Mount mounts\\n', '\\n', '待在容器中挂载的挂载点信息\\n', '\\n', 'repeated Device devices\\n', '\\n', '待在容器中映射的设备信息\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于索引和选择单个资源的键值对。\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '可用于存储和检索任意元数据的非结构化键值映射。\\n', '\\n', 'string log_path\\n', '\\n', '相对于PodSandboxConfig.LogDirectory的路径，用于存储容器主机上的日志（STDOUT和STDERR）。\\n', '\\n', 'bool stdin\\n', '\\n', '是否打开容器的stdin\\n', '\\n', 'bool stdin_once\\n', '\\n', '当某次连接stdin的数据流断开时，是否立即断开其他与stdin连接的数据流（暂不支持）\\n', '\\n', 'bool tty\\n', '\\n', '是否使用伪终端连接容器的stdio\\n', '\\n', 'LinuxContainerConfig linux\\n', '\\n', 'linux系统上容器的特定配置信息\\n', '\\n', 'NetworkConfig\\n', '\\n', 'Runtime的网络配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_cidr\\n', '\\n', 'Pod IP 地址使用的CIDR\\n', '\\n', 'RuntimeConfig\\n', '\\n', 'Runtime的网络配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'NetworkConfig network_config\\n', '\\n', 'Runtime的网络配置\\n', '\\n', 'RuntimeCondition\\n', '\\n', '描述runtime的状态信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string type\\n', '\\n', 'Runtime状态的类型\\n', '\\n', 'bool status\\n', '\\n', 'Runtime状态\\n', '\\n', 'string reason\\n', '\\n', '简要描述runtime状态变化的原因\\n', '\\n', 'string message\\n', '\\n', '具备可阅读性的信息表明runtime状态变化的原因\\n', '\\n', 'RuntimeStatus\\n', '\\n', 'Runtime的状态\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'repeated RuntimeCondition conditions\\n', '\\n', '描述当前runtime状态的列表\\n', '\\n', 'Runtime服务\\n', 'Runtime服务中包含操作pod和容器的接口，以及查询runtime自身配置和状态信息的接口。\\n', '\\n', 'runpodsandbox\\n', '接口原型\\n', 'rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) {}\\n', '接口描述\\n', '创建和启动一个pod sandbox，若运行成功，sandbox处于ready状态。\\n', '\\n', '注意事项\\n', '启动sandbox的默认镜像为rnd-dockerhub.huawei.com/library/pause-${machine}:3.0， 其中${machine}为架构，在x86_64上，machine的值为amd64，在arm64上，machine的值为aarch64，当前rnd-dockerhub仓库上只有amd64和aarch64镜像可供下载，若机器上无此镜像，请确保机器能从rnd-dockerhub下载，若要使用其它镜像，请参考“iSulad部署配置”中的pod-sandbox-image指定镜像。\\n', '由于容器命名以PodSandboxMetadata中的字段为来源，且以下划线\"_“为分割字符，因此限制metadata中的数据不能包含下划线，否则会出现sandbox运行成功，但无法使用ListPodSandbox接口查询的现象。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxConfig config\\n', '\\n', 'sandbox的配置\\n', '\\n', 'string runtime_handler\\n', '\\n', '指定创建sandbox的runtime运行时，当前支持lcr、kata-runtime运行时类型。\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', '成功，返回response数据\\n', '\\n', 'StopPodSandbox\\n', '接口原型\\n', 'rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) {}\\n', '接口描述\\n', '停止pod sandbox，停止sandbox容器，回收分配给sandbox的网络资源（比如IP地址）。如果有任何running的容器属于该sandbox，则必须被强制停止。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', '无\\n', '\\n', '无\\n', '\\n', 'RemovePodSandbox\\n', '接口原型\\n', 'rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) {}\\n', '接口描述\\n', '删除sandbox，如果有任何running的容器属于该sandbox，则必须被强制停止和删除，如果sandbox已经被删除，不能返回错误。\\n', '\\n', '注意事项\\n', '删除sandbox时，不会删除sandbox的网络资源，在删除pod前必须先调用StopPodSandbox才能清理网络资源，调用者应当保证在删除sandbox之前至少调用一次StopPodSandbox。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', '无\\n', '\\n', '无\\n', '\\n', 'PodSandboxStatus\\n', '接口原型\\n', 'rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) {}\\n', '接口描述\\n', '查询sandbox的状态，如果sandbox不存在，返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的id\\n', '\\n', 'bool verbose\\n', '\\n', '标识是否显示sandbox的一些额外信息。（暂不支持配置）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'PodSandboxStatus status\\n', '\\n', 'sandbox的状态信息\\n', '\\n', 'map<string, string> info\\n', '\\n', 'sandbox的额外信息，key是任意string，value是json格式的字符串，这些信息可以是任意调试内容。当verbose为true时info不能为空。（暂不支持配置）\\n', '\\n', 'ListPodSandbox\\n', '接口原型\\n', 'rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) {}\\n', '接口描述\\n', '返回sandbox信息的列表，支持条件过滤。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxFilter filter\\n', '\\n', '条件过滤参数\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated PodSandbox items\\n', '\\n', 'sandbox信息的列表\\n', '\\n', 'CreateContainer\\n', 'grpc::Status CreateContainer(grpc::ServerContext *context, const runtime::CreateContainerRequest *request, runtime::CreateContainerResponse *reply) {}\\n', '接口描述\\n', '在PodSandbox内创建一个容器。\\n', '\\n', '注意事项\\n', '请求CreateContainerRequest 中的sandbox_config与传递给RunPodSandboxRequest以创建PodSandbox的配置相同。 它再次传递，只是为了方便参考。 PodSandboxConfig是不可变的，在pod的整个生命周期内保持不变。\\n', '由于容器命名以ContainerMetadata中的字段为来源，且以下划线”_“为分割字符，因此限制metadata中的数据不能包含下划线，否则会出现sandbox运行成功，但无法使用ListContainers接口查询的现象。\\n', 'CreateContainerRequest中无runtime_handler字段，创建container时的runtime类型和其对应的sandbox的runtime相同。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', '待在其中创建容器的PodSandbox的ID。\\n', '\\n', 'ContainerConfig config\\n', '\\n', '容器的配置信息\\n', '\\n', 'PodSandboxConfig sandbox_config\\n', '\\n', 'PodSandbox的配置信息\\n', '\\n', '补充\\n', '可用于存储和检索任意元数据的非结构化键值映射。有一些字段由于cri接口没有提供特定的参数，可通过该字段将参数传入\\n', '\\n', '自定义\\n', '\\n', '\\n', '自定义 key:value\\n', '\\n', '描述\\n', '\\n', 'cgroup.pids.max:int64_t\\n', '\\n', '用于限制容器内的进/线程数（set -1 for unlimited）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '创建完成的容器ID\\n', '\\n', 'StartContainer\\n', '接口原型\\n', 'rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) {}\\n', '接口描述\\n', '启动一个容器。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', '无\\n', '\\n', '无\\n', '\\n', 'StopContainer\\n', '接口原型\\n', 'rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) {}\\n', '接口描述\\n', '停止一个running的容器，支持配置优雅停止时间timeout，如果容器已经停止，不能返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', 'int64 timeout\\n', '\\n', '强制停止容器前的等待时间，默认值为0，即强制停止容器。\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'RemoveContainer\\n', '接口原型\\n', 'rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) {}\\n', '接口描述\\n', '删除一个容器，如果容器正在运行，必须强制停止，如果容器已经被删除，不能返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'ListContainers\\n', '接口原型\\n', 'rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) {}\\n', '接口描述\\n', '返回container信息的列表，支持条件过滤。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerFilter filter\\n', '\\n', '条件过滤参数\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated Container containers\\n', '\\n', '容器信息的列表\\n', '\\n', 'ContainerStatus\\n', '接口原型\\n', 'rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) {}\\n', '接口描述\\n', '返回容器状态信息，如果容器不存在，则返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', 'bool verbose\\n', '\\n', '标识是否显示sandbox的一些额外信息。（暂不支持配置）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'ContainerStatus status\\n', '\\n', '容器的状态信息\\n', '\\n', 'map<string, string> info\\n', '\\n', 'sandbox的额外信息，key是任意string，value是json格式的字符串，这些信息可以是任意调试内容。当verbose为true时info不能为空。（暂不支持配置）\\n', '\\n', 'UpdateContainerResources\\n', '接口原型\\n', 'rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) {}\\n', '接口描述\\n', '该接口用于更新容器资源配置。\\n', '\\n', '注意事项\\n', '该接口仅用于更新容器的资源配置，不能用于更新Pod的资源配置。\\n', '当前不支持更新容器oom_score_adj配置。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', 'LinuxContainerResources linux\\n', '\\n', 'linux资源配置信息\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'ExecSync\\n', '接口原型\\n', 'rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) {}\\n', '接口描述\\n', '以同步的方式在容器中执行命令，采用的gRPC通讯方式。\\n', '\\n', '注意事项\\n', '执行执行一条单独的命令，不能打开终端与容器交互。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器ID\\n', '\\n', 'repeated string cmd\\n', '\\n', '待执行命令\\n', '\\n', 'int64 timeout\\n', '\\n', '停止命令的超时时间（秒）。 默认值：0（无超时限制）。 暂不支持\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'bytes stdout\\n', '\\n', '捕获命令标准输出\\n', '\\n', 'bytes stderr\\n', '\\n', '捕获命令标准错误输出\\n', '\\n', 'int32 exit_code\\n', '\\n', '退出代码命令完成。 默认值：0（成功）。\\n', '\\n', 'Exec\\n', '接口原型\\n', 'rpc Exec(ExecRequest) returns (ExecResponse) {}\\n', '接口描述\\n', '在容器中执行命令，采用的gRPC通讯方式从CRI服务端获取url，再通过获得的url与websocket服务端建立长连接，实现与容器的交互。\\n', '\\n', '注意事项\\n', '执行执行一条单独的命令，也能打开终端与容器交互。stdin/stdout/stderr之一必须是真的。如果tty为真，stderr必须是假的。 不支持多路复用, 在这种情况下, stdout和stderr的输出将合并为单流。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器ID\\n', '\\n', 'repeated string cmd\\n', '\\n', '待执行的命令\\n', '\\n', 'bool tty\\n', '\\n', '是否在TTY中执行命令\\n', '\\n', 'bool stdin\\n', '\\n', '是否流式标准输入\\n', '\\n', 'bool stdout\\n', '\\n', '是否流式标准输出\\n', '\\n', 'bool stderr\\n', '\\n', '是否流式输出标准错误\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string url\\n', '\\n', 'exec流服务器的完全限定URL\\n', '\\n', 'Attach\\n', '用法：docker attach [OPTIONS] CONTAINER\\n', '\\n', '功能：附加到一个运行着的容器\\n', '\\n', '选项：\\n', '\\n', '–no-stdin=false 不附加STDIN\\n', '\\n', '–sig-proxy=true 代理所有到容器内部的信号，不代理SIGCHLD, SIGKILL, SIGSTOP\\n', '\\n', '示例：\\n', '\\n', '$ sudo docker attach attach_test\\n', 'root@2988b8658669:/# ls bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\\n', 'ContainerStats\\n', '接口原型\\n', 'rpc ContainerStats(ContainerStatsRequest) returns (ContainerStatsResponse) {}\\n', '接口描述\\n', '返回单个容器占用资源信息，仅支持runtime类型为lcr的容器。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'ContainerStats stats\\n', '\\n', '容器信息。注：disk和inodes只支持oci格式镜像起的容器查询\\n', '\\n', 'ListContainerStats\\n', '接口原型\\n', 'rpc ListContainerStats(ListContainerStatsRequest) returns (ListContainerStatsResponse) {}\\n', '接口描述\\n', '返回多个容器占用资源信息，支持条件过滤\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerStatsFilter filter\\n', '\\n', '条件过滤参数\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated ContainerStats stats\\n', '\\n', '容器信息的列表。注：disk和inodes只支持oci格式镜像启动的容器查询\\n', '\\n', 'UpdateRuntimeConfig\\n', '接口原型\\n', 'rpc UpdateRuntimeConfig(UpdateRuntimeConfigRequest) returns (UpdateRuntimeConfigResponse);\\n', '接口描述\\n', '提供标准的CRI接口，目的为了更新网络插件的Pod CIDR，当前CNI网络插件无需更新Pod CIDR，因此该接口只会记录访问日志。\\n', '\\n', '注意事项\\n', '接口操作不会对系统管理信息修改，只是记录一条日志。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'RuntimeConfig runtime_config\\n', '\\n', '包含Runtime要配置的信息\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'Status\\n', '接口原型\\n', 'rpc Status(StatusRequest) returns (StatusResponse) {};\\n', '接口描述\\n', '获取runtime和pod的网络状态，在获取网络状态时，会触发网络配置的刷新。仅支持runtime类型为lcr的容器。\\n', '\\n', '注意事项\\n', '如果网络配置刷新失败，不会影响原有配置；只有刷新成功时，才会覆盖原有配置。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'bool verbose\\n', '\\n', '是否显示关于Runtime额外的信息（暂不支持）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'RuntimeStatus status\\n', '\\n', 'Runtime的状态\\n', '\\n', 'map<string, string> info\\n', '\\n', 'Runtime额外的信息，info的key为任意值，value为json格式，可包含任何debug信息；只有Verbose为true是才应该被赋值\\n', '\\n', 'Image服务\\n', '提供了从镜像仓库拉取、查看、和移除镜像的gRPC API。\\n', '\\n', 'ListImages\\n', '接口原型\\n', 'rpc ListImages(ListImagesRequest) returns (ListImagesResponse) {}\\n', '接口描述\\n', '列出当前已存在的镜像信息。\\n', '\\n', '注意事项\\n', '为统一接口，对于embedded格式镜像，可以通过cri images查询到。但是因embedded镜像不是标准OCI镜像，因此查询得到的结果有以下限制：\\n', '\\n', '因embedded镜像无镜像ID，显示的镜像ID为镜像的config digest。\\n', '因embedded镜像本身无digest仅有config的digest，且格式不符合OCI镜像规范，因此无法显示digest。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec filter\\n', '\\n', '筛选的镜像名称\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated Image images\\n', '\\n', '镜像信息列表\\n', '\\n', 'ImageStatus\\n', '接口原型\\n', 'rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) {}\\n', '接口描述\\n', '查询指定镜像信息。\\n', '\\n', '注意事项\\n', '查询指定镜像信息，若镜像不存在，则返回ImageStatusResponse，其中Image设置为nil。\\n', '为统一接口，对于embedded格式镜像，因不符合OCI格式镜像，缺少字段，无法通过本接口进行查询。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec image\\n', '\\n', '镜像名称\\n', '\\n', 'bool verbose\\n', '\\n', '查询额外信息，暂不支持，无额外信息返回\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'Image image\\n', '\\n', '镜像信息\\n', '\\n', 'map<string, string> info\\n', '\\n', '镜像额外信息，暂不支持，无额外信息返回\\n', '\\n', 'PullImage\\n', '接口原型\\n', ' rpc PullImage(PullImageRequest) returns (PullImageResponse) {}\\n', '接口描述\\n', '下载镜像。\\n', '\\n', '注意事项\\n', '当前支持下载public镜像，使用用户名、密码、auth信息下载私有镜像，不支持authconfig中的server_address、identity_token、registry_token字段。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec image\\n', '\\n', '要下载的镜像名称\\n', '\\n', 'AuthConfig auth\\n', '\\n', '下载私有镜像时的验证信息\\n', '\\n', 'PodSandboxConfig sandbox_config\\n', '\\n', '在Pod上下文中下载镜像（暂不支持）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string image_ref\\n', '\\n', '返回已下载镜像信息\\n', '\\n', 'RemoveImage\\n', '接口原型\\n', 'rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) {}\\n', '接口描述\\n', '删除指定镜像。\\n', '\\n', '注意事项\\n', '为统一接口，对于embedded格式镜像，因不符合OCI格式镜像，缺少字段，无法通过本接口使用image id进行删除。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec image\\n', '\\n', '要删除的镜像名称或者ID\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'ImageFsInfo\\n', '接口原型\\n', 'rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) {}\\n', '接口描述\\n', '查询存储镜像的文件系统信息。\\n', '\\n', '注意事项\\n', '查询到的为镜像元数据下的文件系统信息。\\n', '\\n', '参数\\n', '无\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated FilesystemUsage image_filesystems\\n', '\\n', '镜像存储文件系统信息\\n', '\\n', '约束\\n', '如果创建sandbox时，PodSandboxConfig参数中配置了log_directory，则所有属于该sandbox的container在创建时必须在ContainerConfig中指定log_path，否则可能导致容器无法使用CRI接口启动，甚至无法使用CRI接口删除。\\n', '\\n', '容器的真实LOGPATH=log_directory/log_path，如果log_path不配置，那么最终的LOGPATH会变为LOGPATH=log_directory。\\n', '\\n', '如果该路径不存在，isulad在启动容器时会创建一个软链接，指向最终的容器日志真实路径，此时log_directory变成一个软链接，此时有两种情况：\\n', '\\n', '第一种情况，如果该sandbox里其它容器也没配置log_path，在启动其它容器时，log_directory会被删除，然后重新指向新启动容器的log_path，导致之前启动的容器日志指向后面启动容器的日志。\\n', '第二种情况，如果该sandbox里其它容器配置了log_path，则该容器的LOGPATH=log_directory/log_path，由于log_directory实际是个软链接，使用log_directory/log_path为软链接指向容器真实日志路径时，创建会失败。\\n', '如果该路径存在，isulad在启动容器时首先会尝试删除该路径（非递归），如果该路径是个文件夹，且里面有内容，删除会失败，从而导致创建软链接失败，容器启动失败，删除该容器时，也会出现同样的现象，导致删除失败。\\n', '\\n', '如果创建sandbox时，PodSandboxConfig参数中配置了log_directory，且container创建时在ContainerConfig中指定log_path，那么最终的LOGPATH=log_directory/log_path，isulad不会递归的创建LOGPATH，因而用户必须保证dirname(LOGPATH)存在，即最终的日志文件的上一级路径存在。\\n', '\\n', '如果创建sandbox时，PodSandboxConfig参数中配置了log_directory，如果有两个或多个container创建时在ContainerConfig中指定了同一个log_path，或者不同的sandbox内的容器最终指向的LOGPATH是同一路径，若容器启动成功，则后启动的容器日志路径会覆盖掉之前启动的容器日志路径。\\n', '\\n', '如果远程镜像仓库中镜像内容发生变化，调用CRI Pull image接口重新下载该镜像时，若本地原来存储有原镜像，则原镜像的镜像名称、TAG会变更为“none”\\n', '\\n', '举例如下：\\n', '\\n', '本地已存储镜像：\\n', '\\n', 'IMAGE                                        TAG                 IMAGE ID            SIZE\\n', 'rnd-dockerhub.huawei.com/pproxyisulad/test   latest              99e59f495ffaa       753kB\\n', '远程仓库中rnd-dockerhub.huawei.com/pproxyisulad/test:latest 镜像更新后，重新下载后：\\n', '\\n', 'IMAGE                                        TAG                 IMAGE ID            SIZE\\n', '<none>                                       <none>              99e59f495ffaa       753kB\\n', 'rnd-dockerhub.huawei.com/pproxyisulad/test   latest              d8233ab899d41       1.42MB\\n', '使用isula images 命令行查询，REF显示为”-\"：\\n', '\\n', 'REF                                               IMAGE ID               CREATED              SIZE       \\n', 'rnd-dockerhub.huawei.com/pproxyisulad/test:latest d8233ab899d41          2019-02-14 19:19:37  1.42MB     \\n', '-                                                 99e59f495ffaa          2016-05-04 02:26:41  753kB\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_iSula对接shim v2安全容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/iSula-shim-v2%E5%AF%B9%E6%8E%A5stratovirt.html", "text_entry": "['iSula对接shim v2安全容器\\n', '概述\\n', 'shim v2 是新一代 shim 架构方案，相比于 shim v1, 具有调用链更短、架构清晰的优势，在多业务容器场景，具备明显的低内存开销优势。iSula 运行安全容器可以通过 isulad-shim 或者 containerd-shim-kata-v2 来实现，其中 isulad-shim 组件是 shim v1 方案的具体实现，containerd-shim-kata-v2 组件是 shim v2 方案在安全容器场景的一种具体实现，本文介绍iSula 与 containerd-shim-kata-v2 的对接。\\n', '\\n', '对接 containerd-shim-v2-kata\\n', '前提条件\\n', 'iSula 对接 containerd-shim-v2-kata 前，需要满足如下前提：\\n', '\\n', '已安装 iSulad、lib-shim-v2 和 kata-containers\\n', 'StratoVirt 仅支持 devicemapper 存储驱动，因此需要配置 devicemapper 环境并确保 iSulad 使用的 devicemapper 存储驱动正常工作\\n', '环境准备\\n', '此处给出安装 iSulad 和 kata-containers 并进行相应配置的参考方法。\\n', '\\n', '安装依赖软件\\n', '按照所使用的OS版本自行配置相应的 yum 源，使用 root 权限安装 iSulad、lib-shim-v2和kata-containers ：\\n', '\\n', '# yum install iSulad\\n', '# yum install kata-containers\\n', '# yum install lib-shim-v2\\n', '制作并配置存储 Storage\\n', '需要用户准备一个磁盘， 如 /dev/sdx ， 该磁盘会被格式化，本章使用块设备 /dev/sda 进行演示。\\n', '\\n', '一、创建devicemapper\\n', '\\n', '创建 PV\\n', '\\n', '$ pvcreate /dev/sda\\n', '  Physical volume \"/dev/loop0\" successfully created.\\n', '创建 VG\\n', '\\n', '$ vgcreate isula /dev/sda\\n', '  Volume group \"isula\" successfully created\\n', '创建 thinpool 以及 thinpoolmeta 逻辑卷\\n', '\\n', '$ lvcreate --wipesignatures y -n thinpool isula -l 95%VG\\n', '  Logical volume \"thinpool\" created.\\n', '\\n', '$ lvcreate --wipesignatures y -n thinpoolmeta isula -l 1%VG\\n', '  Logical volume \"thinpoolmeta\" created.\\n', '将上面创建的逻辑卷转换为 thinpool\\n', '\\n', '$ lvconvert -y --zero n -c 64K \\\\\\n', '--thinpool isula/thinpool \\\\\\n', '--poolmetadata isula/thinpoolmeta\\n', '  Thin pool volume with chunk size 512.00 KiB can address at most 126.50 TiB of data.\\n', \"  WARNING: Converting isula/thinpool and isula/thinpoolmeta to thin pool's data and metadata volumes with metadata wiping.\\n\", '  THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.)\\n', '  Converted isula/thinpool and isula/thinpoolmeta to thin pool.\\n', '设置 lvm thinpool 自动扩展功能\\n', '\\n', '$ touch /etc/lvm/profile/isula-thinpool.profile\\n', '$ cat << EOF > /etc/lvm/profile/isula-thinpool.profile\\n', 'activation {\\n', '  thin_pool_autoextend_threshold=80\\n', '  thin_pool_autoextend_percent=20\\n', '}\\n', 'EOF\\n', '$ lvchange --metadataprofile isula-thinpool isula/thinpool\\n', 'Logical volume isula/thinpool changed.\\n', '二、修改 iSulad 存储驱动类型并设置默认runtime\\n', '\\n', '更改配置文件 /etc/isulad/daemon.json, 将 default-runtime 设置为 io.containerd.kata.v2 , 将默认存储驱动类型 overlay 配置成 devicemapper，修改后如下所示：\\n', '\\n', ' {\\n', '    \"default-runtime\": \"io.containerd.kata.v2\",\\n', '    \"storage-driver\": \"devicemapper\",\\n', '    \"storage-opts\": [\\n', '        \"dm.thinpooldev=/dev/mapper/isula-thinpool\",\\n', '        \"dm.fs=ext4\",\\n', '        \"dm.min_free_space=10%\"\\n', '    ],\\n', '}\\n', '三、使能配置\\n', '\\n', '重启 isulad使得配置生效 ：\\n', '\\n', '# systemctl daemon-reload\\n', '# systemctl restart isulad\\n', '确认 iSula 存储驱动是否配置成功：\\n', '\\n', '# isula info\\n', '若回显有如下信息，说明配置成功。\\n', '\\n', 'Storage Driver: devicemapper\\n', '对接指导\\n', '本章给出 iSula 对接 containerd-shim-kata-v2 的操作指导。\\n', '\\n', 'containerd-shim-kata-v2 默认使用 QEMU 虚拟化组件，本章分别介绍使用 QEMU 和 StratoVirt 两种虚拟化组件时的配置方法。\\n', '\\n', '使用 QEMU\\n', 'containerd-shim-kata-v2 使用的虚拟化组件为 QEMU 时，iSula 对接 containerd-shim-kata-v2 的操作如下：\\n', '\\n', '修改 kata 配置文件，路径为 /usr/share/defaults/kata-containers/configuration.toml\\n', '\\n', 'sandbox_cgroup_with_emulator 需要设置为 false， 目前 shimv2 不支该改功能， 其他参数与 shim v1 中 kata 配置参数保持一致或者保持默认值。\\n', '\\n', 'sandbox_cgroup_with_emulator = false\\n', '使用 busybox 镜像运行安全容器并检查使用的 runtime 为 io.containerd.kata.v2\\n', '\\n', '$ id=`isula run -tid busybox /bin/sh`\\n', \"$ isula inspect -f '{{ json .HostConfig.Runtime }}' $id\\n\", '\"io.containerd.kata.v2\"\\n', '确认 qemu 虚拟机进程被拉起，说明 qemu 和 shim v2 安全容器的对接成功\\n', '\\n', '$ ps -ef | grep qemu\\n', '使用 StratoVirt\\n', 'containerd-shim-kata-v2 使用的虚拟化组件为 StratoVirt 时，iSula 对接 containerd-shim-kata-v2 的操作如下：\\n', '\\n', '在任一目录（例如 /home 目录）新建脚本文件 stratovirt.sh 并使用 root 权限给文件添加执行权限：\\n', '\\n', '# touch /home/stratovirt.sh\\n', '# chmod +x /home/stratovirt.sh\\n', 'stratovirt.sh 内容如下，用于指定 StratoVirt 路径：\\n', '\\n', '#!/bin/bash\\n', 'export STRATOVIRT_LOG_LEVEL=info  # set log level which includes trace, debug, info, warn and error.\\n', '/usr/bin/stratovirt $@\\n', '修改 kata 配置文件 ，将安全容器的 hypervisor 类型配置为 stratovirt，kernel 配置 StratoVirt 的 kernel 镜像绝对路径，initrd 配置为 kata-containers 的 initrd 镜像文件（使用 yum 安装 kata-containers 时，默认会下载这个文件并存放在 /var/lib/kata/ 目录），StratoVirt 仅支持 devicemapper 存储模式，需提前准备好环境并将 iSulad 设置为 devicemapper 模式。\\n', '\\n', '配置参考如下：\\n', '\\n', '[hypervisor.stratovirt]\\n', 'path = \"/home/stratovirt.sh\"\\n', 'kernel = \"/var/lib/kata/vmlinux.bin\"\\n', 'initrd = \"/var/lib/kata/kata-containers-initrd.img\"\\n', 'block_device_driver = \"virtio-mmio\"\\n', 'use_vsock = true\\n', 'enable_netmon = true\\n', 'internetworking_model=\"tcfilter\"\\n', 'sandbox_cgroup_with_emulator = false\\n', 'disable_new_netns = false\\n', 'disable_block_device_use = false\\n', 'disable_vhost_net = true\\n', 'StratoVirt 中使用 vsock 功能， 需要开启 vhost_vsock 内核模块并确认是否开启成功\\n', '\\n', '$ modprobe vhost_vsock\\n', '$ lsmod |grep vhost_vsock\\n', '下载对应版本和架构的 kernel 并放到 /var/lib/kata/ 路径下, 如下载 openEuler 22.03 LTS 版本 x86 架构的内核 openeuler repo：\\n', '\\n', '$ cd /var/lib/kata\\n', '$ wget https://repo.openeuler.org/openEuler-22.03-LTS/stratovirt_img/x86_64/vmlinux.bin\\n', '使用 busybox 镜像运行安全容器并检查使用的 runtime 为 io.containerd.kata.v2\\n', '\\n', '$ id=`isula run -tid busybox sh`\\n', \"$ isula inspect -f '{{ json .HostConfig.Runtime }}' $id\\n\", '\"io.containerd.kata.v2\"\\n', '确认 stratovirt 虚拟机进程被拉起，说明 StratoVirt 和 shim v2 安全容器的对接成功\\n', '\\n', '$ ps -ef | grep stratovirt\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_安全特性.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7.html", "text_entry": "['安全特性\\n', '安全特性\\n', 'seccomp安全配置场景\\n', 'capabilities安全配置场景\\n', 'SELinux安全配置场景\\n', 'seccomp安全配置场景\\n', '场景说明\\n', 'seccomp（secure computing mode）是linux kernel从2.6.23版本开始引入的一种简洁的sandboxing机制。在一些特定场景下，用户需要在容器中执行一些“特权”操作，但又不想启动特权容器，用户经常会在run时添加–cap-add来获得一些“小范围”的权限。对于安全要求比较严格的容器实例，上述的CAP粒度不一定能够满足安全需要，可使用一些办法精细化控制权限范围。\\n', '\\n', '举例\\n', '\\n', '普通容器场景中，用户使用-v将宿主机某目录（包含某普通用户无法执行的二进制），映射到容器中。\\n', '\\n', '在容器中，可以将二进制修改权限chmod 4777加入S标志位。这样在宿主机上，原先不能运行二进制的普通用户（或者运行此二进制受限），可以在S标志位的添加动作后，在运行此二进制的时候，获取到二进制自身的权限（比如root），从而提权运行或者访问其他文件。\\n', '\\n', '这个场景，如果在严格安全要求下，需要使用seccomp裁剪chmod、fchmod、fchmodat系统调用。\\n', '\\n', '使用限制\\n', 'seccomp可能会影响性能，设置seccomp之前需要对场景进行评估，确定必要时加入seccomp配置。\\n', '使用指导\\n', '通过–security-opt将配置文件传给要过滤系统调用的容器。\\n', '\\n', 'isula run -itd --security-opt seccomp=/path/to/seccomp/profile.json rnd-dockerhub.huawei.com/official/busybox\\n', ' 说明：\\n', '\\n', '创建容器时通过–security-opt将配置文件传给容器时，采用默认配置文件（/etc/isulad/seccomp_default.json）。\\n', '创建容器时–security-opt设置为unconfined时，对容器不过滤系统调用。\\n', '“/path/to/seccomp/profile.json”需要是绝对路径。\\n', '获取普通容器的默认seccomp配置\\n', '启动一个普通容器（或者是带–cap-add的容器），并查看默认权限配置：\\n', '\\n', 'cat /etc/isulad/seccomp_default.json | python -m json.tool > profile.json\\n', '可以看到\"seccomp\"字段中，有很多的\"syscalls\"，在此基础上，仅提取syscalls的部分，参考定制seccomp配置文件，进行定制化操作。\\n', '\\n', '\"defaultAction\": \"SCMP_ACT_ERRNO\",\\n', '\"syscalls\": [\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"accept\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"accept4\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"access\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"alarm\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"bind\"\\n', '},\\n', ']...\\n', '查看转换为lxc可识别的seccomp配置\\n', '\\n', 'cat /var/lib/isulad/engines/lcr/74353e38021c29314188e29ba8c1830a4677ffe5c4decda77a1e0853ec8197cd/seccomp\\n', '...\\n', 'waitpid allow\\n', 'write allow\\n', 'writev allow\\n', 'ptrace allow\\n', 'personality allow [0,0,SCMP_CMP_EQ,0]\\n', 'personality allow [0,8,SCMP_CMP_EQ,0]\\n', 'personality allow [0,131072,SCMP_CMP_EQ,0]\\n', 'personality allow [0,131080,SCMP_CMP_EQ,0]\\n', 'personality allow [0,4294967295,SCMP_CMP_EQ,0]\\n', '...\\n', '定制seccomp配置文件\\n', '在启动容器的时候使用–security-opt引入seccomp配置文件，容器实例会按照配置文件规则进行限制系统API的运行。首先获取普通容器的默认seccomp，得到完整模板，然后按照本节定制配置文件，启动容器：\\n', '\\n', 'isula run --rm -it --security-opt seccomp:/path/to/seccomp/profile.json rnd-dockerhub.huawei.com/official/busybox\\n', '配置文件模板：\\n', '\\n', '{\\n', '\"defaultAction\": \"SCMP_ACT_ALLOW\",\\n', '\"syscalls\": [\\n', '{\\n', '\"name\": \"syscall-name\",\\n', '\"action\": \"SCMP_ACT_ERRNO\",\\n', '\"args\": null\\n', '}\\n', ']\\n', '}\\n', ' 须知：\\n', '\\n', 'defaultAction、syscalls：对应的action的类型是一样的，但其值是不能一样的，目的就是让所有的syscal都有一个默认的action，并且如果syscalls数组中有明确的定义，就以syscalls中的为准，由于defaultAction、action的值不一样，就能保证action不会有冲突。当前支持的action有：\\n', '“SCMP_ACT_ERRNO”：禁止，并打印错误信息。\\n', '“SCMP_ACT_ALLOW”：允许。\\n', 'syscalls： 数组，可以只有一个syscall，也可以有多个，可以带args，也可以不带。\\n', 'name：要过滤的syscall。\\n', 'args：数组，里面的每个object的定义如下：\\n', 'type Arg struct {  \\n', 'Index    uint     `json:\"index\"`     //参数的序号，如open(fd, buf, len),fd 对应的就是0，buf为1  \\n', 'Value    uint64   `json:\"value\"`     //跟参数进行比较的值  \\n', 'ValueTwo uint64   `json:\"value_two\"` //仅当Op=MaskEqualTo时起作用，用户传入值跟Value按位与操作后，跟ValueTwo进行比较，若相等则执行action。  \\n', 'Op       Operator `json:\"op\"`  \\n', '}  \\n', 'args中的Op，其取值可以下页面的任意一种：\\n', '“SCMP_CMP_NE”: NotEqualTo\\n', '“SCMP_CMP_LT”: LessThan\\n', '“SCMP_CMP_LE”: LessThanOrEqualTo\\n', '“SCMP_CMP_EQ”: EqualTo\\n', '“SCMP_CMP_GE”: GreaterThanOrEqualTo\\n', '“SCMP_CMP_GT”: GreaterThan\\n', '“SCMP_CMP_MASKED_EQ”: MaskEqualTo\\n', '\\n', 'capabilities安全配置场景\\n', '场景说明\\n', \"capabilities机制是linux kernel 2.2之后引入的安全特性，用更小的粒度控制超级管理员权限,可以避免使用 root 权限，将root用户的权限细分为不同的领域，可以分别启用或禁用。capabilities详细信息可通过Linux Programmer's Manual进行查看（capabilities(7) - Linux man page）：\\n\", '\\n', 'man capabilities\\n', '使用限制\\n', 'isulad默认Capabilities（白名单）配置如下，普通容器进程将默认携带：\\n', '\\n', '\"CAP_CHOWN\",\\n', '\"CAP_DAC_OVERRIDE\",\\n', '\"CAP_FSETID\",\\n', '\"CAP_FOWNER\",\\n', '\"CAP_MKNOD\",\\n', '\"CAP_NET_RAW\",\\n', '\"CAP_SETGID\",\\n', '\"CAP_SETUID\",\\n', '\"CAP_SETFCAP\",\\n', '\"CAP_SETPCAP\",\\n', '\"CAP_NET_BIND_SERVICE\",\\n', '\"CAP_SYS_CHROOT\",\\n', '\"CAP_KILL\",\\n', '\"CAP_AUDIT_WRITE\"\\n', '默认的权能配置，包含了CAP_SETUID和CAP_FSETID，如host和容器共享目录，容器可对共享目录的二进制文件进行文件权限设置，host上的普通用户可能使用该特性进行提权攻击。CAP_AUDIT_WRITE，容器可以对host写入，存在一定的风险，如果使用场景不需要，推荐在启动容器的时候使用–cap-drop将其删除。\\n', '\\n', '增加Capabilities意味着容器进程具备更大的能力，同时也会开放更多的系统调用接口。\\n', '\\n', '使用指导\\n', 'iSulad使用–cap-add/–cap-drop给容器增加/删去特定的权限，在非必要情况下，不要给容器增加额外的权限，推荐将容器默认但非必要的权限也去掉。\\n', '\\n', 'isula run --rm -it --cap-add all --cap-drop SYS_ADMIN rnd-dockerhub.huawei.com/official/busybox\\n', 'SELinux安全配置场景\\n', '场景说明\\n', 'SELinux(Security-Enhanced Linux)是一个Linux内核的安全模块，提供了访问控制安全策略机制，iSulad将采用MCS（多级分类安全）实现对容器内进程打上标签限制容器访问资源的方式，减少提权攻击的风险，防止造成更为重要的危害。\\n', '\\n', '使用限制\\n', '确保宿主机已使能SELinux，且daemon端已打开SELinux使能开发（/etc/isulad/daemon.json中“selinux-enabled”字段为true, 或者命令行参数添加–selinux-enabled）\\n', '确保宿主机上已配置合适的selinux策略，推荐使用container-selinux进行配置\\n', '引入SELinux会影响性能，设置SELinux之前需要对场景进行评估，确定必要时打开daemon端SELinux开关并设置容器SELinux配置\\n', '对挂载卷进行标签配置时，源目录不允许为/、/usr、/etc、/tmp、/home、/run、/var、/root以及/usr的子目录。\\n', ' 说明：\\n', '\\n', '目前iSulad不支持对容器的文件系统打标签，确保容器文件系统及配置目录打上容器可访问标签，需使用chcon命令对其打上标签。\\n', '若iSulad启用SELinux访问控制，建议daemon启动前对/var/lib/isulad目录打上标签，容器容器创建时目录下生产的文件及文件夹将默认继承其标签，例如：\\n', 'chcon -R system_u:object_r:container_file_t:s0 /var/lib/isulad  \\n', '使用指导\\n', 'daemon端使能selinux：\\n', '\\n', 'isulad --selinux-enabled\\n', '  \\n', '\\n', '启动容器时配置selinux标签安全上下文\\n', '\\n', '–security-opt=“label=user:USER” 配置安全上下文用户\\n', '\\n', '–security-opt=“label=role:ROLE” 配置安全上下文角色\\n', '\\n', '–security-opt=“label=type:TYPE” 配置安全上下文类型\\n', '\\n', '–security-opt=“label=level:LEVEL” 配置安全上下文域\\n', '\\n', '–security-opt=“label=disable” 容器禁用SELinux配置\\n', '\\n', '$ isula run -itd --security-opt label=type:container_t --security-opt label=level:s0:c1,c2 rnd-dockerhub.huawei.com/official/centos\\n', '9be82878a67e36c826b67f5c7261c881ff926a352f92998b654bc8e1c6eec370\\n', '  \\n', '\\n', \"为挂载卷打selinux标签('z'为共享模式)\\n\", '\\n', '$ isula run -itd -v /test:/test:z rnd-dockerhub.huawei.com/official/centos\\n', '9be82878a67e36c826b67f5c7261c881ff926a352f92998b654bc8e1c6eec370\\n', '\\n', '$ls -Z /test\\n', 'system_u:object_r:container_file_t:s0 file\\n', '  \\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_容器健康状态检查.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5.html", "text_entry": "['容器健康状态检查\\n', '容器健康状态检查\\n', '场景说明\\n', '配置方法\\n', '检查规则\\n', '使用限制\\n', '场景说明\\n', '在实际的生产环境中，开发者提供的应用程序或者平台提供的服务难免存在bug，因此，一套管理系统对运行的应用程序进行周期性的健康检查和修复就是不可或缺的。容器健康检查机制便添加了用户定义的对容器进行健康检查的功能。在容器创建时配置--health-cmd选项，在容器内部周期性地执行命令，通过命令的返回值来监测容器的健康状态。\\n', '\\n', '配置方法\\n', '在容器启动时的配置：\\n', '\\n', 'isula run -itd --health-cmd \"echo iSulad >> /tmp/health_check_file || exit 1\" --health-interval 5m --health-timeout 3s --health-exit-on-unhealthy  busybox bash\\n', '可配置的选项：\\n', '\\n', '--health-cmd，必选，在容器内执行的命令。返回值为0表示成功，非0表示失败。\\n', '--health-interval，默认 30s，最大为int64上限（纳秒），自定义配置最小值1s，相邻两次命令执行的间隔时间（注：入参0s时视为default）。\\n', '--health-timeout，默认 30s，最大为int64上限（纳秒），自定义配置最小值1s，单次检查命令执行的时间上限，超时则任务命令执行失败（注：入参0s时视为default），仅支持runtime类型为lcr的容器。\\n', '--health-start-period，默认 0s，最大为int64上限（纳秒），自定义配置最小值1s，容器初始化时间。\\n', '--health-retries，默认 3，最大为int32上限，健康检查失败最大的重试次数。\\n', '--health-exit-on-unhealthy，默认false，检测到容器非健康时是否杀死容器。\\n', '检查规则\\n', '容器启动后，容器状态中显示health:starting。\\n', '经过start-period时间后开始，以interval为间隔周期性在容器中执行CMD。即：当一次命令执行完毕后，经过interval时间，执行下一次命令。\\n', '若CMD命令在timeout限制的时间内执行完毕，并且返回值为0，则视为一次检查成功。否则视为一次检查失败。检查成功后，容器状态变为health:healthy。\\n', '若CMD命令连续retries次检查失败，则容器状态变为health:unhealthy。失败后容器也会继续进行健康检查。\\n', '容器状态为health:unhealthy时，任意一次检查成功会使得容器状态变为health:healthy。\\n', '设置--exit-on-unhealthy的情况下，如果容器因为非被杀死退出（退出返回值137）后，健康检查只有容器在重新启动后才会继续生效。\\n', 'CMD执行完毕或超时时，docker daemon会将这次检查的起始时间、返回值和标准输出记录到容器的配置文件中。最多记录5条。此外，容器的配置文件中还存储着健康检查的相关参数。\\n', '运行中的容器的健康检查状态也会被写入容器配置中。通过isula inspect可以看到。\\n', '\"Health\": {\\n', '    \"Status\": \"healthy\",\\n', '    \"FailingStreak\": 0,\\n', '    \"Log\": [\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:15.481414707-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:15.556908311-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:18.557297462-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:18.63035891-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        ......\\n', '}\\n', '使用限制\\n', '容器内健康检查的状态信息最多保存5条。会保存最后得到的5条记录。\\n', '容器启动时若健康检查相关参数配置为0，则按照默认值处理。\\n', '带有健康检查配置的容器启动后，若iSulad daemon退出，则健康检查不会执行。iSulad daemon再次启动后，正在运行且带有健康检查配置的容器其健康状态会变为starting。之后检查规则同上。\\n', '如果健康检查从第一次开始便一直失败，其状态保持与之前一致（starting）,直到达到指定失败次数（–health-retries）后变为unhealthy，或者检查成功后变为healthy。\\n', '对于OCI类型的runtime的容器，健康检查功能待完善。目前仅完整支持lcr类型的容器。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_容器管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86.html", "text_entry": "['容器管理\\n', '容器管理\\n', '创建容器\\n', '启动容器\\n', '运行容器\\n', '停止容器\\n', '强制停止容器\\n', '删除容器\\n', '接入容器\\n', '重命名容器\\n', '在容器中执行新命令\\n', '查询单个容器信息\\n', '查询所有容器信息\\n', '重启容器\\n', '等待容器退出\\n', '查看容器中进程信息\\n', '查看容器使用的资源\\n', '获取容器日志\\n', '容器与主机之间数据拷贝\\n', '暂停容器\\n', '恢复容器\\n', '从服务端实时获取事件消息\\n', '创建容器\\n', '描述\\n', 'isula create 命令用于创建一个新的容器。容器引擎会使用指定的容器镜像创建容器读写层，或者使用指定的本地rootfs作为容器的运行环境。创建完成后，会将容器的ID输出到标准输出，后续可以使用isula start 命令启动该容器。新创建的容器状态为inited状态\\n', '\\n', '用法\\n', 'isula create [OPTIONS] IMAGE [COMMAND] [ARG...]\\n', '参数\\n', 'create命令支持参数参考下表。\\n', '\\n', '表 1 create命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'create\\n', '\\n', '  \\n', '\\n', '--annotation\\n', '\\n', '设置容器的annotations。例如支持native.umask选项：\\n', '\\n', '--annotation native.umask=normal # 启动的容器umask值为0022\\n', '--annotation native.umask=secure # 启动的容器umask值为0027\\n', '注意如果没有配置该参数，则使用isulad中的umask配置。\\n', '\\n', '--cap-drop\\n', '\\n', '删除Linux 权限功能\\n', '\\n', '--cgroup-parent\\n', '\\n', '指定容器cgroup父路径\\n', '\\n', '--cpuset-cpus\\n', '\\n', '允许执行的CPU（e.g. 0-3，0，1）\\n', '\\n', '--cpu-shares\\n', '\\n', 'CPU份额（相对权重）\\n', '\\n', '--cpu-quota\\n', '\\n', '限制CPU CFS（完全公平调度器）的配额\\n', '\\n', '--device=[]\\n', '\\n', '为容器添加一个主机设备\\n', '\\n', '--dns\\n', '\\n', '添加DNS服务器\\n', '\\n', '--dns-opt\\n', '\\n', '添加DNS选项\\n', '\\n', '--dns-search\\n', '\\n', '设定容器的搜索域\\n', '\\n', '-e, --env\\n', '\\n', '设置环境变量\\n', '\\n', '--env-file\\n', '\\n', '通过文件配置环境变量\\n', '\\n', '--entrypoint\\n', '\\n', '启动容器时要运行的入口点\\n', '\\n', '--external-rootfs=PATH\\n', '\\n', '指定一个不由iSulad管理的rootfs(可以为文件夹或块设备)给容器\\n', '\\n', '--files-limit\\n', '\\n', '调整容器内能够打开的文件句柄数（-1表示不限制）\\n', '\\n', '--group-add=[]\\n', '\\n', '指定额外的用户组添加到容器\\n', '\\n', '--help\\n', '\\n', '打印帮助信息\\n', '\\n', '--health-cmd\\n', '\\n', '在容器内执行的命令\\n', '\\n', '--health-exit-on-unhealthy\\n', '\\n', '检测到容器非健康时是否杀死容器\\n', '\\n', '--health-interval\\n', '\\n', '相邻两次命令执行的间隔时间\\n', '\\n', '--health-retries\\n', '\\n', '健康检查失败最大的重试次数\\n', '\\n', '--health-start-period\\n', '\\n', '容器初始化时间\\n', '\\n', '--health-timeout\\n', '\\n', '单次检查命令执行的时间上限\\n', '\\n', '--hook-spec\\n', '\\n', '钩子配置文件\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-h, --hostname\\n', '\\n', '容器主机名称\\n', '\\n', '-i, --interactive\\n', '\\n', '即使没有连接到容器的标准输入，也要保持容器的标准输入打开\\n', '\\n', '--hugetlb-limit=[]\\n', '\\n', '大页文件限制，例如：--hugetlb-limit 2MB:32MB\\n', '\\n', '--log-opt=[]\\n', '\\n', '日志驱动程序选项，默认禁用记录容器串口日志功能，可以通过\"--log-opt disable-log=false\"来开启。\\n', '\\n', '-l，--label\\n', '\\n', '为容器设置标签\\n', '\\n', '--lablel-file\\n', '\\n', '通过文件设置容器标签\\n', '\\n', '-m, --memory\\n', '\\n', '内存限制\\n', '\\n', '--memory-reservation\\n', '\\n', '设置容器内存限制，默认与--memory一致。可认为--memory是硬限制，--memory-reservation是软限制；当使用内存超过预设值时，会动态调整（系统回收内存时尝试将使用内存降低到预设值以下），但不确保一定不超过预设值。一般可以和--memory一起使用，数值小于--memory的预设值，最小设置为4MB。\\n', '\\n', '--memory-swap\\n', '\\n', '正整数，内存 + 交换空间，-1 表示不限制\\n', '\\n', '--memory-swappiness\\n', '\\n', '正整数，swappiness参数值可设置范围在0到100之间。 此参数值越低，就会让Linux系统尽量少用swap分区，多用内存；参数值越高就是反过来，使内核更多的去使用swap空间，默认值为-1，表示使用系统默认值。\\n', '\\n', '--mount\\n', '\\n', '挂载主机目录/卷/文件系统到容器中\\n', '\\n', '--no-healthcheck\\n', '\\n', '禁用健康检查配置\\n', '\\n', '--name=NAME\\n', '\\n', '容器名\\n', '\\n', '--net=none\\n', '\\n', '容器连接到网络\\n', '\\n', '--pids-limit\\n', '\\n', '调整容器内能够执行的进程数（-1表示不限制）\\n', '\\n', '--privileged\\n', '\\n', '给予容器扩展的特权\\n', '\\n', '-R, --runtime\\n', '\\n', '容器运行时，参数支持\"lcr\"，忽略大小写，因此\"LCR\"和\"lcr\"是等价的\\n', '\\n', '--read-only\\n', '\\n', '设置容器的根文件系统为只读\\n', '\\n', '--restart\\n', '\\n', '当容器退出时重启策略\\n', '\\n', '系统容器支持--restart on-reboot\\n', '\\n', '--storage-opt\\n', '\\n', '配置容器的存储驱动选项\\n', '\\n', '-t, --tty\\n', '\\n', '分配伪终端\\n', '\\n', '--ulimit\\n', '\\n', '为容器设置ulimit限制\\n', '\\n', '-u, --user\\n', '\\n', '用户名或UID，格式[<name|uid>][:<group|gid>]\\n', '\\n', '-v, --volume=[]\\n', '\\n', '挂载一个卷\\n', '\\n', '--volumes-from=[]\\n', '\\n', '使用指定的容器的挂载配置\\n', '\\n', '约束限制\\n', '使用–user或–group-add参数，在容器启动阶段校验user或group时，容器如果使用的是OCI镜像，是从镜像的真实rootfs的etc/passwd和etc/group文件中校验，如果使用的是rootfs文件夹或块设备作为容器的rootfs，则校验的是host中的etc/passwd和etc/group文件；查找时使用的rootfs会忽略-v 和–mount等挂载参数，意味着使用这些参数尝试覆盖etc/passwd和etc/group两个文件时，在查找阶段不生效，只在容器真正启动时生效。生成的配置保存在\"iSulad根目录/engine/容器ID/start_generate_config.json\"，文件格式如下：\\n', '\\n', '{\\n', '    \"uid\": 0,\\n', '    \"gid\": 8,\\n', '    \"additionalGids\": [\\n', '        1234,\\n', '        8\\n', '    ]\\n', '}\\n', '示例\\n', '创建一个新容器\\n', '\\n', '# isula create busybox\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '# isula ps -a\\n', 'STATUS PID IMAGE   COMMAND EXIT_CODE RESTART_COUNT STARTAT FINISHAT RUNTIME ID           NAMES                                                            inited -   busybox \"sh\"    0         0             -       -        lcr     fd7376591a9c fd7376591a9c4521...\\n', '启动容器\\n', '描述\\n', 'isula start命令用于启动一个或多个容器。\\n', '\\n', '用法\\n', 'isula start [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'start命令支持参数参考下表。\\n', '\\n', '表 1 start命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'start\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-R, --runtime\\n', '\\n', '容器运行时，参数支持\"lcr\"，忽略大小写，因此\"LCR\"和\"lcr\"是等价的\\n', '\\n', '示例\\n', '启动一个新容器\\n', '\\n', '# isula start fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '运行容器\\n', '描述\\n', 'isula run命令命令用于创建一个新的容器。会使用指定的容器镜像创建容器读写层，并且为运行指定的命令做好准备。创建完成后，使用指定的命令启动该容器。run命令相当于create然后start容器。\\n', '\\n', '用法\\n', 'isula run [OPTIONS] ROOTFS|IMAGE [COMMAND] [ARG...]\\n', '参数\\n', 'run命令支持参数参考下表。\\n', '\\n', '表 1 run命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'run\\n', '\\n', '--annotation\\n', '\\n', '设置容器的annotations。例如支持native.umask选项：\\n', '\\n', '--annotation native.umask=normal # 启动的容器umask值为0022\\n', '--annotation native.umask=secure # 启动的容器umask值为0027\\n', '注意如果没有配置该参数，则使用isulad中的umask配置。\\n', '\\n', '--cap-add\\n', '\\n', '添加Linux功能\\n', '\\n', '--cap-drop\\n', '\\n', '删除Linux功能\\n', '\\n', '--cgroup-parent\\n', '\\n', '指定容器cgroup父路径\\n', '\\n', '--cpuset-cpus\\n', '\\n', '允许执行的CPU（e.g. 0-3，0，1）\\n', '\\n', '--cpu-shares\\n', '\\n', 'CPU份额（相对权重）\\n', '\\n', '--cpu-quota\\n', '\\n', '限制CPU CFS（完全公平调度器）的配额\\n', '\\n', '-d, --detach\\n', '\\n', '后台运行容器并打印容器ID\\n', '\\n', '--device=[]\\n', '\\n', '为容器添加一个主机设备\\n', '\\n', '--dns\\n', '\\n', '添加DNS服务器\\n', '\\n', '--dns-opt\\n', '\\n', '添加DNS选项\\n', '\\n', '--dns-search\\n', '\\n', '设定容器的搜索域\\n', '\\n', '-e, --env\\n', '\\n', '设置环境变量\\n', '\\n', '--env-file\\n', '\\n', '通过文件配置环境变量\\n', '\\n', '--entrypoint\\n', '\\n', '启动容器时要运行的入口点\\n', '\\n', '--external-rootfs=PATH\\n', '\\n', '指定一个不由iSulad管理的rootfs(可以为文件夹或块设备)给容器\\n', '\\n', '--files-limit\\n', '\\n', '调整容器内能够打开的文件句柄数（-1表示不限制）\\n', '\\n', '--group-add=[]\\n', '\\n', '指定额外的用户组添加到容器\\n', '\\n', '--help\\n', '\\n', '打印帮助信息\\n', '\\n', '--health-cmd\\n', '\\n', '在容器内执行的命令\\n', '\\n', '--health-exit-on-unhealthy\\n', '\\n', '检测到容器非健康时是否杀死容器\\n', '\\n', '--health-interval\\n', '\\n', '相邻两次命令执行的间隔时间\\n', '\\n', '--health-retries\\n', '\\n', '健康检查失败最大的重试次数\\n', '\\n', '--health-start-period\\n', '\\n', '容器初始化时间\\n', '\\n', '--health-timeout\\n', '\\n', '单次检查命令执行的时间上限\\n', '\\n', '--hook-spec\\n', '\\n', '钩子配置文件\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-h, --hostname\\n', '\\n', '容器主机名称\\n', '\\n', '--hugetlb-limit=[]\\n', '\\n', '大页文件限制，例如：--hugetlb-limit 2MB:32MB\\n', '\\n', '-i, --interactive\\n', '\\n', '即使没有连接到容器的标准输入，也要保持容器的标准输入打开\\n', '\\n', '--log-driver\\n', '\\n', '设置日志驱动，支持syslog和json-file。\\n', '\\n', '--log-opt=[]\\n', '\\n', '日志驱动程序选项，默认禁用记录容器串口日志功能，可以通过\"--log-opt disable-log=false\"来开启。\\n', '\\n', '-m, --memory\\n', '\\n', '内存限制\\n', '\\n', '--memory-reservation\\n', '\\n', '设置容器内存限制，默认与--memory一致。可认为--memory是硬限制，--memory-reservation是软限制；当使用内存超过预设值时，会动态调整（系统回收内存时尝试将使用内存降低到预设值以下），但不确保一定不超过预设值。一般可以和--memory一起使用，数值小于--memory的预设值，最小设置为4MB。\\n', '\\n', '--memory-swap\\n', '\\n', '正整数，内存 + 交换空间，-1 表示不限制\\n', '\\n', '--memory-swappiness\\n', '\\n', '正整数，swappiness参数值可设置范围在0到100之间。 此参数值越低，就会让Linux系统尽量少用swap分区，多用内存；参数值越高就是反过来，使内核更多的去使用swap空间，默认值为-1，表示使用系统默认值。\\n', '\\n', '--mount\\n', '\\n', '挂载主机目录到容器中\\n', '\\n', '--no-healthcheck\\n', '\\n', '禁用健康检查配置\\n', '\\n', '--name=NAME\\n', '\\n', '容器名\\n', '\\n', '--net=none\\n', '\\n', '容器连接到网络\\n', '\\n', '--pids-limit\\n', '\\n', '调整容器内能够执行的进程数（-1表示不限制）\\n', '\\n', '--privileged\\n', '\\n', '给予容器扩展的特权\\n', '\\n', '-R, --runtime\\n', '\\n', '容器运行时，参数支持\"lcr\"，忽略大小写，因此\"LCR\"和\"lcr\"是等价的\\n', '\\n', '--read-only\\n', '\\n', '设置容器的根文件系统为只读\\n', '\\n', '--restart\\n', '\\n', '当容器退出时重启策略\\n', '\\n', '系统容器支持--restart on-reboot\\n', '\\n', '--rm\\n', '\\n', '当容器退出时自动清理容器\\n', '\\n', '--storage-opt\\n', '\\n', '配置容器的存储驱动选项\\n', '\\n', '-t, --tty\\n', '\\n', '分配伪终端\\n', '\\n', '--ulimit\\n', '\\n', '为容器设置ulimit限制\\n', '\\n', '-u, --user\\n', '\\n', '用户名或UID，格式[<name|uid>][:<group|gid>]\\n', '\\n', '-v, --volume=[]\\n', '\\n', '挂载一个卷\\n', '\\n', '约束限制\\n', '容器父进程进程退出时，则对应的容器也自动退出。\\n', '\\n', '创建普通容器时父进程不能为init，因为普通容器的权限不够，导致容器可以创建成功，但是attach进去的时候会卡住。\\n', '\\n', '运行容器时，不指定–net，默认hostname为localhost。\\n', '\\n', '使用–files-limit参数传入一个很小的值，如1时，启动容器时，iSulad创建cgroup子组后先设置files.limit值，再将容器进程的PID写入该子组的cgroup.procs文件，此时容器进程已经打开超过1个句柄，因而写入报错导致启动失败启动容器会失败。\\n', '\\n', '–mount参数和–volume参数同时存在时，如果目的路径有冲突，则–mount会在–volume之后挂载(即将–volume中的挂载点覆盖掉)。\\n', '\\n', '备注：轻量级容器的参数中type支持bind或squashfs，当type=squashfs时，src是镜像的路径；原生docker的参数type支持bind、volume、tmpfs。\\n', '\\n', 'restart重启策略不支持unless-stopped。\\n', '\\n', '以下三种情况与docker 返回值不一致，docker返回127,轻量级容器返回125\\n', '\\n', '–device参数指定主机设备为不存在的设备\\n', '\\n', '–hook-spec参数指定不存在的hook json文件\\n', '\\n', '–entrypoint 参数指定不存在的入口参数\\n', '\\n', '使用–volume参数时，由于容器启动时会对/dev/ptmx设备进行删除重建，因此请勿将/dev目录挂载至容器/dev目录，应使用–device对/dev下的设备在容器中进行挂载\\n', '\\n', '禁止使用echo的方式向run命令的stdin输入数据，会导致客户端卡死。应该直接将echo的值作为命令行参数传给容器\\n', '\\n', '# echo ls | isula run -i busybox /bin/sh\\n', '\\n', '\\n', '^C\\n', '#\\n', '上述命令出现客户端卡死现象，这是由于上述命令相当于往stdin输入ls，随后EOF被读取，客户端不再发送数据，等待服务端退出，但是服务端无法区分客户端是否需要继续发送数据，因而服务端卡在read数据上，最终导致双方均卡死。\\n', '\\n', '正确的执行方式为：\\n', '\\n', '# isula run -i busybox ls\\n', 'bin\\n', 'dev\\n', 'etc\\n', 'home\\n', 'proc\\n', 'root\\n', 'sys\\n', 'tmp\\n', 'usr\\n', 'var\\n', '#\\n', '使用host的根目录（/）作为容器的文件系统，那么在挂载路径时，如果有如下情况\\n', '\\n', '表 2 挂载情况\\n', '\\n', '\\n', 'Host 路径（source）\\n', '\\n', '容器路径（dest）\\n', '\\n', '/home/test1\\n', '\\n', '/mnt/\\n', '\\n', '/home/test2\\n', '\\n', '/mnt/abc\\n', '\\n', ' 须知：\\n', '第一种情况，先挂载/home/test1，然后挂载/home/test2，这种情况会导致/home/test1的内容覆盖掉原来/mnt下面的内容，这样可能导致/mnt下面不存在abc目录，这样会导致挂载/home/test2到/mnt/abc失败。\\n', '第二种情况，先挂载/home/test2，然后挂载/home/test1。这种情况，第二次的挂载会把/mnt的内容替换为/home/test1的内容，这样第一次挂载的/home/test2到/mnt/abc的内容就看不到了。\\n', '因此，不支持第一种使用方式；第二种使用用户需要了解这种数据无法访问的风险\\n', '\\n', ' 须知：\\n', '\\n', '高并发场景（并发启动200容器）下，glibc的内存管理机制会导致内存空洞以及虚拟内存较大（例如10GB）的问题。该问题是高并发场景下glibc内存管理机制的限制，而不是内存泄露，不会导致内存消耗无限增大。可以通过设置MALLOC_ARENA_MAX环境变量来减少虚拟内存的问题，而且可以增大减少物理内存的概率。但是这个环境变量会导致iSulad的并发性能下降，需要用户根据实际情况做配置。\\n', '参考实践情况，平衡性能和内存，可以设置MALLOC_ARENA_MAX为4。（在arm64服务器上面对iSulad的性能影响在10%以内）  \\n', '配置方法：  \\n', '1. 手动启动iSulad的场景，可以直接export MALLOC_ARENA_MAX=4，然后再启动iSulad即可。  \\n', '2. systemd管理iSulad的场景，可以修改/etc/sysconfig/iSulad，增加一条MALLOC_ARENA_MAX=4即可。  \\n', '示例\\n', '运行一个新容器\\n', '\\n', '# isula run -itd busybox\\n', '9c2c13b6c35f132f49fb7ffad24f9e673a07b7fe9918f97c0591f0d7014c713b\\n', '停止容器\\n', '描述\\n', 'isula stop命令用于停止一个或多个运行中的容器。首先向容器中的首进程会发送SIGTERM信号，在指定时间（默认为10s）内容器未停止时，会发送SIGKILL。\\n', '\\n', '用法\\n', 'isula stop [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'stop命令支持参数参考下表。\\n', '\\n', '表 1 stop命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'stop\\n', '\\n', '-f, --force\\n', '\\n', '强制停止正在运行的容器\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-t, --time\\n', '\\n', '先优雅停止，超过这个时间，则强行终止\\n', '\\n', '约束限制\\n', '指定t参数且t<0时，请确保自己容器的应用会处理stop信号。\\n', '\\n', 'Stop的原理：Stop会首先给容器发送Stop 信号（SIGTERM），然后等待一定的时间（这个时间就是用户输入的 t），过了指定时间如果容器还仍处于运行状态，那么就发送kill信号（SIGKILL）使容器强制退出。\\n', '\\n', '输入参数t的含义：\\n', '\\n', 't<0 : 表示一直等待，不管多久都等待程序优雅退出，既然用户这么输入了，表示对自己的应用比较放心，认为自己的程序有 合理的stop信号的处理机制。\\n', '\\n', 't=0 ： 表示不等，立即发送kill -9 到容器。\\n', '\\n', 't>0 ： 表示等一定的时间，如果容器还未退出，就发送kill -9 到容器。\\n', '\\n', '所以如果用户使用t<0 （比如t=-1），请确保自己容器的应用会正确处理SIGTERM. 如果容器忽略了该信号，会导致isula stop一直卡住。\\n', '\\n', '示例\\n', '停止一个容器\\n', '\\n', '# isula stop fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '强制停止容器\\n', '描述\\n', 'isula kill命令用于强制停止一个或多个运行中的容器。\\n', '\\n', '用法\\n', 'isula kill [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'kill命令支持参数参考下表。\\n', '\\n', '表 1 kill命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'kill\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-s, --signal\\n', '\\n', '发送给容器的信号\\n', '\\n', '示例\\n', '杀掉一个容器\\n', '\\n', '# isula kill fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '删除容器\\n', '描述\\n', 'isula rm命令用于删除一个或多个容器。\\n', '\\n', '用法\\n', 'isula rm [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'rm命令支持参数参考下表。\\n', '\\n', '表 1 rm命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'rm\\n', '\\n', '-f, --force\\n', '\\n', '强制移除正在运行的容器\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-v, --volume\\n', '\\n', '移除挂载在容器上的卷（备注：目前iSulad尚不使用此功能）\\n', '\\n', '约束限制\\n', '在IO正常情况，空环境（只有1个容器）删除一个running容器的时间为T1，200个容器的环境（容器无大量IO操作，host IO正常）删除一个running容器所需时间为T2。T2的规格为：T2 = max { T1 * 3, 5 } 秒钟。\\n', '示例\\n', '删除一个停止状态的容器\\n', '\\n', '# isula rm fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '接入容器\\n', '描述\\n', 'isula attach命令用于将当前终端的标准输入、标准输出和标准错误连接到正在运行的容器。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula attach [OPTIONS] CONTAINER\\n', '参数\\n', 'attach命令支持参数参考下表。\\n', '\\n', '表 1 attach命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'attach\\n', '\\n', '--help\\n', '\\n', '打印帮助信息\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-D, --debug\\n', '\\n', '开启debug模式\\n', '\\n', '约束限制\\n', '原生docker attach容器会直接进入容器，而isulad attach容器后需要敲一个回车才进入。\\n', '示例\\n', '接入一个运行状态的容器\\n', '\\n', '# isula attach fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '/ #\\n', '/ #\\n', '重命名容器\\n', '描述\\n', 'isula rename命令用于重命名容器。\\n', '\\n', '用法\\n', 'isula rename [OPTIONS] OLD_NAME NEW_NAME\\n', '参数\\n', 'rename命令支持参数参考下表。\\n', '\\n', '表 1 rename 命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'rename\\n', '\\n', '-H, --host\\n', '\\n', '重命名容器\\n', '\\n', '示例\\n', '重命名一个容器\\n', '\\n', '# isula rename my_container my_new_container\\n', '在容器中执行新命令\\n', '描述\\n', 'isula exec命令用于正在运行的容器中运行一个新命令。新执行的命令将在容器的默认目录中运行。如果基础镜像指定了自定义目录，则将使用该目录。\\n', '\\n', '用法\\n', 'isula exec [OPTIONS] CONTAINER COMMAND [ARG...]\\n', '参数\\n', 'exec命令支持参数参考下表。\\n', '\\n', '表 1 exec命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'exec\\n', '\\n', '  \\n', '\\n', '-d, --detach\\n', '\\n', '后台运行命令\\n', '\\n', '-e, --env\\n', '\\n', '设置环境变量（备注：目前iSulad尚不使用此功能）\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-i, --interactive\\n', '\\n', '没有连接，也要保持标准输入打开（备注：目前iSulad尚不使用此功能）\\n', '\\n', '-t, --tty\\n', '\\n', '分配伪终端（备注：目前iSulad尚不使用此功能）\\n', '\\n', '-u, --user\\n', '\\n', '指定用户登录容器执行命令\\n', '\\n', '约束限制\\n', 'isula exec 不指定任何参数时，会默认使用-it参数， 表示分配一个伪终端，以交互式的方式进入容器\\n', '\\n', '当使用isula exec 执行脚本，在脚本中执行后台进程时，需使用nohup标志忽略SIGHUP信号。\\n', '\\n', '使用isula exec运行脚本,在脚本中运行后台进程需使用nohup标志。否则内核会在exec执行的进程（session首进程）退出时，向后台执行的进程发送SIGHUP信号，导致后台进程退出，出现僵尸进程。\\n', '\\n', 'isula exec 进入容器进程后，不能执行后台程序，否则会出现卡死现象。\\n', '\\n', 'isula exec执行后台进程的方式如下：\\n', '\\n', '使用isula exec进入容器终端，isula exec container_name bash\\n', '进入容器后，执行 script &\\n', '执行exit，导致终端卡死\\n', 'isula exec 进入容器后，执行后台程序卡住的原因为isula exec进入容器运行后台while1程序，当bash退出时，while1程序并不会退出，变为孤儿进程由1号\\n', '进程接管，while1程序是由容器的初始bash进程fork &exec执行的，while1进程复制了bash进程的文件句柄，导致bash退出时，句柄并未完全关闭，导致\\n', 'console进程收不到句柄关闭事件，epoll_wait卡住，进程不退出。\\n', 'isula exec 不能用后台方式执行，否则可能会出现卡死现象。\\n', '\\n', 'isula exec后台执行的方式如下：\\n', '\\n', '使用**isula exec 脚本 & **的方式后台执行exec，如：isula exec container_name script & ，isula exec 后台执行，执行的脚本中不断cat某一文件，正常时在当前终端有输出，如果在当前终端执行回车操作，客户端会因读IO失败而退出读stdout的动作，使终端不再输出，服务端由于进程仍然在cat文件，会继续往fifo的buffer里写入数据，当缓存写满时，容器内进程会卡死在write动作上。\\n', '\\n', '轻量级容器使用exec执行带有管道操作的命令时，建议使用/bin/bash -c 方式执行该命令。\\n', '\\n', '典型应用场景：\\n', '\\n', '使用isula exec container_name -it ls /test | grep “xx” | wc -l,用于统计test目录下xx的文件个数，因exec执行的为\"ls /test\",其输出通过管道进行grep、wc 处理。exec执行的为\"ls /test\"的输出会换行，再针对该输出进行处理时，结果有误。\\n', '\\n', '原因：使用exec 执行ls /test,输出带有换行，针对该输出进行“| grep “xx” | wc -l“，处理结果为2（两行）\\n', '\\n', '# isula exec  -it container ls /test\\n', 'xx    xx10  xx12  xx14  xx3   xx5   xx7   xx9\\n', 'xx1   xx11  xx13  xx2   xx4   xx6   xx8\\n', '#\\n', '建议处理方式：使用run/exec执行带有管道操作的命令时，使用/bin/bash -c 执行命令，在容器中执行管道操作。\\n', '\\n', '# isula exec  -it container  /bin/sh -c \"ls /test | grep \"xx\" | wc -l\"\\n', '15\\n', '#\\n', '禁止使用echo的方式向exec命令的stdin输入数据，会导致客户端卡死。应该直接将echo的值作为命令行参数传给容器\\n', '\\n', '# echo ls | isula exec 38 /bin/sh\\n', '\\n', '\\n', '^C\\n', '#\\n', '上述命令可能出现客户端卡死现象，这是由于上述命令相当于往stdin输入ls，随后EOF被读取，客户端不再发送数据，等待服务端退出，但是服务端无法区分客户端是否需要继续发送数据，因而服务端卡在read数据上，最终导致双方均卡死。\\n', '\\n', '正确的执行方式为：\\n', '\\n', '# isula exec 38 ls\\n', 'bin   dev   etc   home  proc  root  sys   tmp   usr   var\\n', '示例\\n', '在运行中的容器中，执行echo命令\\n', '\\n', '# isula exec c75284634bee echo \"hello,world\"\\n', 'hello,world\\n', '查询单个容器信息\\n', '描述\\n', 'isula inspect提供了容器的详细信息。\\n', '\\n', '用法\\n', 'isula inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]\\n', '参数\\n', 'inspect命令支持参数参考下表。\\n', '\\n', '表 1 inspect命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'inspect\\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-f, --format\\n', '\\n', '使用模板格式化输出\\n', '\\n', '-t, --time\\n', '\\n', '超时时间的秒数，若在该时间内inspect查询容器信息未执行成功，则停止等待并立即报错，默认为120秒，当配置小于等于0的值，表示不启用timeout机制inspect查询容器信息会一直等待，直到获取容器信息成功后返回。\\n', '\\n', '约束限制\\n', '轻量级容器不支持format为“{ {.State} }”的格式化输出，支持“{ {json .State} }”的json格式化输出。当inspect镜像时，不支持-f参数。\\n', '示例\\n', '查询容器信息\\n', '\\n', '# isula inspect c75284634bee\\n', '[\\n', '    {\\n', '        \"Id\": \"c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\",\\n', '        \"Created\": \"2019-08-01T22:48:13.993304927-04:00\",\\n', '        \"Path\": \"sh\",\\n', '        \"Args\": [],\\n', '        \"State\": {\\n', '            \"Status\": \"running\",\\n', '            \"Running\": true,\\n', '            \"Paused\": false,\\n', '            \"Restarting\": false,\\n', '            \"Pid\": 21164,\\n', '            \"ExitCode\": 0,\\n', '            \"Error\": \"\",\\n', '            \"StartedAt\": \"2019-08-02T06:09:25.535049168-04:00\",\\n', '            \"FinishedAt\": \"2019-08-02T04:28:09.479766839-04:00\",\\n', '            \"Health\": {\\n', '                \"Status\": \"\",\\n', '                \"FailingStreak\": 0,\\n', '                \"Log\": []\\n', '            }\\n', '        },\\n', '        \"Image\": \"busybox\",\\n', '        \"ResolvConfPath\": \"\",\\n', '        \"HostnamePath\": \"\",\\n', '        \"HostsPath\": \"\",\\n', '        \"LogPath\": \"none\",\\n', '        \"Name\": \"c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\",\\n', '        \"RestartCount\": 0,\\n', '        \"HostConfig\": {\\n', '            \"Binds\": [],\\n', '            \"NetworkMode\": \"\",\\n', '            \"GroupAdd\": [],\\n', '            \"IpcMode\": \"\",\\n', '            \"PidMode\": \"\",\\n', '            \"Privileged\": false,\\n', '            \"SystemContainer\": false,\\n', '            \"NsChangeFiles\": [],\\n', '            \"UserRemap\": \"\",\\n', '            \"ShmSize\": 67108864,\\n', '            \"AutoRemove\": false,\\n', '            \"AutoRemoveBak\": false,\\n', '            \"ReadonlyRootfs\": false,\\n', '            \"UTSMode\": \"\",\\n', '            \"UsernsMode\": \"\",\\n', '            \"Sysctls\": {},\\n', '            \"Runtime\": \"lcr\",\\n', '            \"RestartPolicy\": {\\n', '                \"Name\": \"no\",\\n', '                \"MaximumRetryCount\": 0\\n', '            },\\n', '            \"CapAdd\": [],\\n', '            \"CapDrop\": [],\\n', '            \"Dns\": [],\\n', '            \"DnsOptions\": [],\\n', '            \"DnsSearch\": [],\\n', '            \"ExtraHosts\": [],\\n', '            \"HookSpec\": \"\",\\n', '            \"CPUShares\": 0,\\n', '            \"Memory\": 0,\\n', '            \"OomScoreAdj\": 0,\\n', '            \"BlkioWeight\": 0,\\n', '            \"BlkioWeightDevice\": [],\\n', '            \"CPUPeriod\": 0,\\n', '            \"CPUQuota\": 0,\\n', '            \"CPURealtimePeriod\": 0,\\n', '            \"CPURealtimeRuntime\": 0,\\n', '            \"CpusetCpus\": \"\",\\n', '            \"CpusetMems\": \"\",\\n', '            \"SecurityOpt\": [],\\n', '            \"StorageOpt\": {},\\n', '            \"KernelMemory\": 0,\\n', '            \"MemoryReservation\": 0,\\n', '            \"MemorySwap\": 0,\\n', '            \"OomKillDisable\": false,\\n', '            \"PidsLimit\": 0,\\n', '            \"FilesLimit\": 0,\\n', '            \"Ulimits\": [],\\n', '            \"Hugetlbs\": [],\\n', '            \"HostChannel\": {\\n', '                \"PathOnHost\": \"\",\\n', '                \"PathInContainer\": \"\",\\n', '                \"Permissions\": \"\",\\n', '                \"Size\": 0\\n', '            },\\n', '            \"EnvTargetFile\": \"\",\\n', '            \"ExternalRootfs\": \"\"\\n', '        },\\n', '        \"Mounts\": [],\\n', '        \"Config\": {\\n', '            \"Hostname\": \"localhost\",\\n', '            \"User\": \"\",\\n', '            \"Env\": [\\n', '                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\\n', '                \"TERM=xterm\",\\n', '                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\\n', '            ],\\n', '            \"Tty\": true,\\n', '            \"Cmd\": [\\n', '                \"sh\"\\n', '            ],\\n', '            \"Entrypoint\": [],\\n', '            \"Labels\": {},\\n', '            \"Annotations\": {\\n', '                \"log.console.file\": \"none\",\\n', '                \"log.console.filerotate\": \"7\",\\n', '                \"log.console.filesize\": \"1MB\",\\n', '                \"rootfs.mount\": \"/var/lib/isulad/mnt/rootfs\",\\n', '                \"native.umask\": \"secure\"\\n', '            },\\n', '            \"HealthCheck\": {\\n', '                \"Test\": [],\\n', '                \"Interval\": 0,\\n', '                \"Timeout\": 0,\\n', '                \"StartPeriod\": 0,\\n', '                \"Retries\": 0,\\n', '                \"ExitOnUnhealthy\": false\\n', '            }\\n', '        },\\n', '        \"NetworkSettings\": {\\n', '            \"IPAddress\": \"\"\\n', '        }\\n', '    }\\n', ']\\n', '查询所有容器信息\\n', '描述\\n', 'isula ps 用于查询所有容器的信息。\\n', '\\n', '用法\\n', 'isula ps [OPTIONS]\\n', '参数\\n', 'ps命令支持参数参考下表。\\n', '\\n', '表 1 ps命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'ps\\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '-a, --all\\n', '\\n', '显示所有的容器\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-q, --quiet\\n', '\\n', '只显示容器名字\\n', '\\n', '-f, --filter\\n', '\\n', '增加筛选过滤条件\\n', '\\n', '--format\\n', '\\n', '按照模板声明的方式输出数据\\n', '\\n', '--no-trunc\\n', '\\n', '不对容器ID进行截断打印\\n', '\\n', '示例\\n', '查询所有容器信息\\n', '\\n', '# isula ps -a\\n', '\\n', 'ID           IMAGE                                     STATUS  PID    COMMAND EXIT_CODE RESTART_COUNT STARTAT        FINISHAT    RUNTIME NAMES\\n', 'e84660aa059c rnd-dockerhub.huawei.com/official/busybox running 304765 \"sh\"    0         0             13 minutes ago -           lcr     e84660aa059cafb0a77a4002e65cc9186949132b8e57b7f4d76aa22f28fde016\\n', '# isula ps -a --format \"table {{.ID}} {{.Image}}\" --no-trunc\\n', 'ID                                                               IMAGE\\n', 'e84660aa059cafb0a77a4002e65cc9186949132b8e57b7f4d76aa22f28fde016 rnd-dockerhub.huawei.com/official/busybox\\n', '\\n', '重启容器\\n', '描述\\n', 'isula restart 用于重启一个或者多个容器。\\n', '\\n', '用法\\n', 'isula restart [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'restart命令支持参数参考下表。\\n', '\\n', '表 1 restart 命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'restart\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-t, --time\\n', '\\n', '先优雅停止，超过这个时间，则强行终止\\n', '\\n', '约束限制\\n', '指定t参数且t<0时，请确保自己容器的应用会处理stop信号。\\n', '\\n', 'restart会首先调用stop停止容器。stop会首先给容器发送stop信号（SIGTERM），然后等待一定的时间（这个时间就是用户输入的 t），过了一定时间如果容器仍处于运行状态，那么就发送kill信号（SIGKILL）使容器强制退出。\\n', '\\n', '输入参数t的含义：\\n', '\\n', 't<0 : 表示一直等待，不管多久都等待程序优雅退出，既然用户这么输入了，表示对自己的应用比较放心，认为自己的程序有合理的stop信号的处理机制。\\n', '\\n', 't=0 ： 表示不等，立即发送kill -9 到容器。\\n', '\\n', 't>0 ： 表示等一定的时间，如果容器还未退出，就发送kill -9 到容器。\\n', '\\n', '所以如果用户使用t<0（比如t=-1），请确保自己容器的应用会正确处理SIGTERM. 如果容器忽略了该信号，会导致isula restart一直卡住。\\n', '\\n', '示例\\n', '重启单个容器\\n', '\\n', '# isula restart c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\\n', ' c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a \\n', '等待容器退出\\n', '描述\\n', 'isula wait用于等待一个或者多个容器退出。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula wait [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'wait命令支持参数参考下表。\\n', '\\n', '表 1 wait命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'wait\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '/\\n', '\\n', '阻塞，直到容器停止，然后打印退出代码\\n', '\\n', '示例\\n', '等待单个容器退出\\n', '\\n', '# isula wait c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\\n', ' 137 \\n', '查看容器中进程信息\\n', '描述\\n', 'isula top用于查看容器中的进程信息。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula top [OPTIONS] container [ps options]\\n', '参数\\n', 'top命令支持参数参考下表。\\n', '\\n', '表 1 top命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'top\\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '/\\n', '\\n', '查询运行容器的进程信息\\n', '\\n', '示例\\n', '查询容器中进程信息\\n', '\\n', '# isula top 21fac8bb9ea8e0be4313c8acea765c8b4798b7d06e043bbab99fc20efa72629c\\n', 'UID        PID  PPID  C STIME TTY          TIME CMD\\n', 'root     22166 22163  0 23:04 pts/1    00:00:00 sh\\n', '查看容器使用的资源\\n', '描述\\n', 'isula stats用于实时显示资源使用的统计信息。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula stats [OPTIONS] [CONTAINER...]\\n', '参数\\n', 'stats命令支持参数参考下表。\\n', '\\n', '表 1 stats命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'stats\\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-a, --all\\n', '\\n', '显示所有容器（默认只显示运行中的容器）\\n', '\\n', '--no-stream\\n', '\\n', '非流式方式的stats，只打印第一次结果\\n', '\\n', '示例\\n', '显示资源使用的统计信息\\n', '\\n', '# isula stats --no-stream 21fac8bb9ea8e0be4313c8acea765c8b4798b7d06e043bbab99fc20efa72629c                                                                                 CONTAINER        CPU %      MEM USAGE / LIMIT          MEM %      BLOCK I / O                PIDS      \\n', '21fac8bb9ea8     0.00       56.00 KiB / 7.45 GiB       0.00       0.00 B / 0.00 B            1  \\n', '获取容器日志\\n', '描述\\n', 'isula logs用于获取容器的日志。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula logs [OPTIONS] [CONTAINER...]\\n', '参数\\n', 'logs命令支持参数参考下表。\\n', '\\n', '表 1 logs命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'logs\\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-f, --follow\\n', '\\n', '跟踪日志输出\\n', '\\n', '--tail\\n', '\\n', '显示日志行数\\n', '\\n', '约束限制\\n', '容器串口logs日志记录功能，默认为开启状态，需要关闭可以通过 isula create –log-opt disable-log=true 或 isula run –log-opt disable-log=true 关闭。\\n', '示例\\n', '获取容器日志\\n', '\\n', '# isula logs 6a144695f5dae81e22700a8a78fac28b19f8bf40e8827568b3329c7d4f742406\\n', 'hello, world\\n', 'hello, world\\n', 'hello, world\\n', '容器与主机之间数据拷贝\\n', '描述\\n', 'isula cp 用于容器与主机之间的数据拷贝，仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH\\n', 'isula cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH\\n', '参数\\n', 'cp命令支持参数参考下表。\\n', '\\n', '表 1 cp命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'cp\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '约束限制\\n', 'iSulad在执行拷贝时，不会挂载/etc/hostname， /etc/resolv.conf，/etc/hosts三个文件，也不会对–volume和–mount参数传入的参数挂载到host，所以对这些文件的拷贝使用的是镜像中的原始文件，而不是真实容器中的文件。\\n', '\\n', '# isula cp b330e9be717a:/etc/hostname /tmp/hostname\\n', '# cat /tmp/hostname\\n', '# \\n', 'iSulad在解压文件时，不会对文件系统中即将被覆盖的文件或文件夹做类型判断，而是直接覆盖，所以在拷贝时，如果源为文件夹，同名的文件会被强制覆盖为文件夹；如果源为文件，同名的文件夹会被强制覆盖为文件。\\n', '\\n', '# rm -rf /tmp/test_file_to_dir && mkdir /tmp/test_file_to_dir\\n', '# isula exec b330e9be717a /bin/sh -c \"rm -rf /tmp/test_file_to_dir && touch /tmp/test_file_to_dir\"\\n', '# isula cp b330e9be717a:/tmp/test_file_to_dir /tmp\\n', '# ls -al /tmp | grep test_file_to_dir\\n', '-rw-r-----    1 root     root             0 Apr 26 09:59 test_file_to_dir\\n', 'iSulad 在cp拷贝过程中，会将容器freeze住，在拷贝完成后，恢复容器运行。\\n', '\\n', '示例\\n', '将主机/test/host目录拷贝到容器21fac8bb9ea8的/test目录下。\\n', '\\n', 'isula cp /test/host 21fac8bb9ea8:/test\\n', '将容器21fac8bb9ea8的/www目录拷贝到主机的/tmp目录中。\\n', '\\n', 'isula cp 21fac8bb9ea8:/www /tmp/\\n', '暂停容器\\n', '描述\\n', 'isula pause用于暂停容器中所有的进程，仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula pause CONTAINER [CONTAINER...]\\n', '参数\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'pause\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '约束限制\\n', '只有状态为running的容器可以被执行pause操作\\n', '当容器被pause后，无法执行其他生命周期管理操作（如restart/exec/attach/kill/stop/rm等）\\n', '当带有健康检查配置的容器被pause后，容器状态最终变为unhealthy状态\\n', '示例\\n', '暂停一个正在运行的容器，命令示例如下：\\n', '\\n', '# isula pause 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac\\n', ' 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac \\n', '恢复容器\\n', '描述\\n', 'isula unpause用于恢复容器中所有的进程, 为isula pause的逆过程，仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula unpause CONTAINER [CONTAINER...]\\n', '参数\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'pause\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '约束限制\\n', '只有状态为paused的容器可以被执行unpause操作\\n', '示例\\n', '恢复一个被暂停的容器，命令示例如下：\\n', '\\n', '# isula unpause 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac\\n', ' 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac \\n', '从服务端实时获取事件消息\\n', '描述\\n', 'isula events用于从服务端实时获取容器镜像生命周期、运行等事件消息, 仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula events [OPTIONS]\\n', '参数\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'events\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-n, --name\\n', '\\n', '获取指定容器的事件消息\\n', '\\n', '-S, --since\\n', '\\n', '获取指定时间以来的事件消息\\n', '\\n', '示例\\n', '从服务端实时获取事件消息，命令示例如下：\\n', '\\n', '# isula events\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_支持CNI网络.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%94%AF%E6%8C%81CNI%E7%BD%91%E7%BB%9C.html", "text_entry": "['支持CNI网络\\n', '支持CNI网络\\n', '描述\\n', '接口\\n', 'CNI网络配置说明\\n', '加入CNI网络列表\\n', '退出CNI网络列表\\n', '使用限制\\n', '描述\\n', '实现CRI接口对接CNI网络的能力，包括CNI网络配置文件的解析、CNI网络的加入和退出。Pod需要支持网络时，例如通过canal等容器网络插件提供网络能力，那么需要CRI接口能够和canal实现对接，并且调用canal的接口，为Pod提供网络能力。\\n', '\\n', 'CNI配置文件相关行为描述：\\n', '\\n', '对–cni-conf-dir目录下的合法配置文件名进行字典排序，取第一个合法配置作为default网络平面的配置；\\n', '每隔5s对配置目录进行扫描，重新加载更新CNI配置；\\n', 'CRI Status接口不更新CNI的网络配置；\\n', '接口\\n', 'CNI对用户可见的接口，主要涉及CNI网络配置和Pod配置中CNI网络相关的项。\\n', '\\n', 'CNI网络配置相关的接口，主要是isulad指定CNI网络配置文件所在路径、CNI网络插件二进制文件所在的路径以及使用的网络模式。详情请参见表1 CNI网络配置接口。\\n', 'Pod配置中CNI网络相关的项，主要是设置Pod加入的附加CNI网络列表，默认情况Pod只会加入到default CNI网络平面中，可以通过该配置把Pod加入到多个CNI网络平面中。\\n', '表 1 CNI网络配置接口\\n', '\\n', '\\n', '  \\n', '\\n', '命令行\\n', '\\n', '配置文件\\n', '\\n', '说明\\n', '\\n', '设置CNI网络插件二进制文件所在路径\\n', '\\n', '--cni-bin-dir\\n', '\\n', '\"cni-bin-dir\": \"\",\\n', '\\n', '默认为/opt/cni/bin\\n', '\\n', '设置CNI网络配置文件所在路径\\n', '\\n', '--cni-conf-dir\\n', '\\n', '\"cni-conf-dir\": \"\",\\n', '\\n', '系统会遍历目录下面所有后缀名为\".conf\"、\".conflist\"和 \".json\"的文件。默认为/etc/cni/net.d\\n', '\\n', '指定网络模式\\n', '\\n', '--network-plugin\\n', '\\n', '\"network-plugin\": \"\",\\n', '\\n', '指定网络插件，默认为空字符，表示无网络配置，创建的sandbox只有loop网卡。支持cni和空字符，其他非法值会导致isulad启动失败。\\n', '\\n', '附加CNI网络配置方式：\\n', '\\n', '在Pod的配置文件的\"annotations\"中，增加一项\"network.alpha.kubernetes.io/network\": “网络平面配置”；\\n', '\\n', '网络平面配置为json格式，包含两项：\\n', '\\n', 'name：指定CNI网络平面的名字\\n', 'interface：指定网络接口的名字\\n', '附件CNI网络配置方式示例如下：\\n', '\\n', '\"annotations\" : {\\n', '        \"network.alpha.kubernetes.io/network\": \"{\\\\\"name\\\\\": \\\\\"mynet\\\\\", \\\\\"interface\\\\\": \\\\\"eth1\\\\\"}\"\\n', ' }\\n', '  \\n', '\\n', 'CNI网络配置说明\\n', 'CNI网络配置包含两种类型，文件格式都为json：\\n', '\\n', '单网络平面配置，以.conf和.json为后缀的文件：具体的配置项请参见\"附录 > CNI配置参数\" 章节的 “表 CNI单网络配置参数”。\\n', '多网络平面配置，以.conflist为后缀的文件：具体的配置项请参见\"附录 > CNI配置参数\" 章节的 “表3 CNI多网络配置参数”。\\n', '加入CNI网络列表\\n', '如果iSulad配置了–network-plugin=cni，而且设置了default网络平面配置，那么在启动Pod的时候，会自动把Pod加入到default网络平面。如果在Pod的配置中配置了附加网络配置，那么启动Pod的时候也会把Pod加入到这些附加网络平面中。\\n', '\\n', 'Pod配置中和网络相关的还有port_mappings项，用于设置Pod的端口映射关系。配置方式如下：\\n', '\\n', '\"port_mappings\":[\\n', '     { \\n', '         \"protocol\": 1,\\n', '         \"container_port\": 80,\\n', '         \"host_port\": 8080\\n', '      }\\n', ']\\n', 'protocol：表示映射使用的协议，支持tcp（用0标识）、udp（用1标识）；\\n', 'container_port：表示容器映射出去的port；\\n', 'host_port：表示映射到主机的port。\\n', '退出CNI网络列表\\n', 'StopPodSandbox的时候，会调用退出CNI网络的接口，清理网络相关的资源。\\n', '\\n', ' 说明：\\n', '\\n', '在调用RemovePodSandbox接口之前，至少要调用一次StopPodSandbox接口\\n', 'StopPodSandbox调用CNI接口失败，可能导致的网络资源残留。\\n', '使用限制\\n', 'cniVersion的版本，当前只支持0.3.0和0.3.1。由于后期可能需要支持0.1.0和0.2.0，错误日志打印时，保留了0.1.0和0.2.0的提示信息。\\n', \"name：必须是小写字符、数字、'-'以及'.'组成； '.'和'-'不能作为首字符和尾字符； 而且长度不超过200个字符。\\n\", '配置文件个数不超过200个，单个配置文件大小不超过1MB。\\n', '扩展之后的参数，需要根据实际网络需求来配置，不需要使用的可选参数可以不写入到netconf.json文件中。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_支持OCI hooks.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%94%AF%E6%8C%81OCI-hooks.html", "text_entry": "['支持OCI hooks\\n', '描述\\n', '支持在容器的生命周期中，运行OCI标准hooks。包括三种类型的hooks：\\n', '\\n', 'prestart hook：在执行isula start命令之后，而在容器的1号进程启动之前，被执行。\\n', 'poststart hook：在容器1号进程启动之后，而在isula start命令返回之前，被执行。\\n', 'poststop hook：在容器被停止之后，但是在停止命令返回之前，被执行。\\n', 'OCI hooks的配置格式规范如下：\\n', '\\n', 'path：格式是字符串，必须项，必须为绝对路径，指定的文件必须有可执行权限。\\n', 'args：格式是字符串数组，可选项，语义和execv的args一致。\\n', 'env：格式是字符串数组，可选项，语义和环境变量一致，内容为键值对，如：“PATH=/usr/bin”。\\n', 'timeout：格式是整数，可选项，必须大于0，表示钩子执行的超时时间。如果钩子进程运行时间超过配置的时间，那么钩子进程会被杀死。\\n', 'hook的配置为json格式，一般存放在json结尾的文件中，示例如下：\\n', '\\n', '{\\n', '        \"prestart\": [\\n', '            {\\n', '                \"path\": \"/usr/bin/echo\",\\n', '                \"args\": [\"arg1\", \"arg2\"],\\n', '                \"env\":  [ \"key1=value1\"],\\n', '                \"timeout\": 30\\n', '            },\\n', '            {\\n', '                \"path\": \"/usr/bin/ls\",\\n', '                \"args\": [\"/tmp\"]\\n', '            }\\n', '        ],\\n', '        \"poststart\": [\\n', '            {\\n', '                \"path\": \"/usr/bin/ls\",\\n', '                \"args\": [\"/tmp\"],\\n', '                \"timeout\": 5\\n', '            }\\n', '        ],\\n', '        \"poststop\": [\\n', '            {\\n', '                \"path\": \"/tmp/cleanup.sh\",\\n', '                \"args\": [\"cleanup.sh\", \"-f\"]\\n', '            }\\n', '        ]\\n', '}\\n', '接口\\n', 'isulad和isula都提供了hook的接口，isulad提供了默认的hook配置，会作用于所有容器；而isula提供的hook接口，只会作用于当前创建的容器。\\n', '\\n', 'isulad提供的默认OCI hooks配置：\\n', '\\n', '通过/etc/isulad/daemon.json配置文件的hook-spec配置项设置hook配置的文件路径：“hook-spec”: “/etc/default/isulad/hooks/default.json”。\\n', '通过isulad –hook-spec参数设置hook配置的文件路径。\\n', 'isula提供的OCI hooks配置：\\n', '\\n', 'isula create –hook-spec：指定hook配置的json文件的路径。\\n', 'isula run –hook-spec：指定hook配置的json文件的路径。\\n', 'run的配置其实也是在create阶段生效了。\\n', '\\n', '使用限制\\n', 'hook-spec指定的路径必须是绝对路径。\\n', '\\n', 'hook-spec指定的文件必须存在。\\n', '\\n', 'hook-spec指定的路径对应的必须是普通文本文件，格式为json。\\n', '\\n', 'hook-spec指定的文件大小不能超过10MB。\\n', '\\n', 'hooks配置的path字段必须为绝对路径。\\n', '\\n', 'hooks配置的path字段指定文件必须存在。\\n', '\\n', 'hooks配置的path字段指定文件必须有可执行权限。\\n', '\\n', 'hooks配置的path字段指定文件的owner必须是root。\\n', '\\n', 'hooks配置的path字段指定文件必须只有root有写权限。\\n', '\\n', 'hooks配置的timeout必须大于0。\\n', '\\n', '  \\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_本地卷管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%9C%AC%E5%9C%B0%E5%8D%B7%E7%AE%A1%E7%90%86.html", "text_entry": "['本地卷管理\\n', '本地卷管理\\n', '概述\\n', '注意事项\\n', '使用方法\\n', '使用-v参数挂载数据\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '使用–mount参数挂载数据\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '复用其他容器中的挂载配置\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '使用镜像中的匿名卷\\n', '卷的查询\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '卷的删除\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '注意事项\\n', '冲突合并规则\\n', 'iSula和Docker的差异\\n', '概述\\n', 'iSula 管理的容器销毁后，容器内自身所有的数据都会被销毁。如果用户希望容器销毁后依然保留数据，则需要有一种持久化数据的机制。iSula 允许将主机上的文件、目录或卷在容器运行时挂载到容器内。用户可以将需要持久化的数据写入容器内的挂载点。则容器销毁后，主机上的文件、目录、卷依然保留。如果用户需要销毁主机上的文件、目录、卷，可以手动删除文件、目录或者执行 iSula 的相关命令删除卷。对于卷的管理目前 iSula 只支持本地卷，本地卷又分为有名卷和匿名卷。由用户指定名称生产的卷叫有名卷，用户没有指定卷名称，由 iSula 自动生成卷名（一个64位的随机数）的卷为匿名卷。\\n', '\\n', '本章介绍通过 iSula 管理本地卷的使用方法。\\n', '\\n', '注意事项\\n', '卷名称长度2-64个字符，符合正则表达式：^[a-zA-Z0-9][a-zA-Z0-9_.-]{1,63}$，即卷名称首字符必须为字母或者数字，从第二个字符开始可以为字母、数字或者\"_\"、\".\"、\"-“这几个字符。\\n', '创建容器时，如果卷对应的容器内的挂载点存在数据，则默认会拷贝到卷里。如果拷贝过程中出现了 iSula 崩溃重启或者系统掉电之类的异常，则卷内的数据可能是不完整的，这时需要手动删除卷或者卷内数据，确保数据的正确完整。\\n', '使用方法\\n', '使用-v参数挂载数据\\n', '命令格式\\n', 'isula run -v [SRC:]DST[:MODE,MODE...] IMAGE\\n', '功能描述\\n', '使用 create / run 创建并运行容器时，使用 -v/–volume 参数将主机上的文件、目录或者卷挂载到容器内用于数据持久化。\\n', '\\n', '参数说明\\n', 'SRC: 用于挂载的文件、目录或者卷在主机上的路径，当值为绝对路径时，表示挂载主机上的文件或者文件夹。当值为卷名时，表示挂载卷。当省略该项时，表示挂载匿名卷。当文件夹或者卷不存在时，iSula会先创建一个新的文件夹/卷，再进行挂载操作。\\n', 'DST: 容器内的挂载路径，必须为绝对路径。\\n', 'MODE: 当挂载的源是目录或者文件时，合法的参数是ro/rw/z/Z/private/rprivate/slave/rslave/shared/rshared。同类型的参数只能配置一个。当挂载的源是卷时，合法的参数是ro/rw/z/Z/nocopy，同类型的参数只能配置一个。多个属性之间使用”,“连接。参数含义如下：\\n', '参数\\t参数含义\\n', 'ro\\t容器内挂载点挂载为只读属性\\n', 'rw\\t容器内挂载点挂载为读写属性\\n', 'z\\t如果开启了SELinux，则挂载时添加SELinux共享标签\\n', 'Z\\t如果开启了SELinux，则挂载时添加SELinux私有标签\\n', 'private\\t容器内挂载点挂载为私有传播属性\\n', 'rprivate\\t容器内挂载点递归挂载为私有传播属性\\n', 'slave\\t容器内挂载点挂载为从属传播属性\\n', 'rslave\\t容器内挂载点递归挂载为从属传播属性\\n', 'shared\\t容器内挂载点挂载为共享传播属性\\n', 'rshared\\t容器内挂载点递归挂载为共享传播属性\\n', 'nocopy\\t不拷贝挂载点内的数据，该参数不进行配置时默认会拷贝数据。另外，如果卷里已经有数据了，也不会进行拷贝\\n', '示例\\n', '基于 busybox 运行容器并创建/挂载名称为 vol 的卷到容器的 /vol 目录，同时配置挂载点为只读，并且如果容器中对应挂载点有数据也不进行拷贝。\\n', '\\n', 'isula run -v vol:/vol:ro,nocopy busybox\\n', '使用–mount参数挂载数据\\n', '命令格式\\n', 'isula run --mount [type=TYPE,][src=SRC,]dst=DST[,KEY=VALUE] busybox\\n', '功能描述\\n', '使用 create / run 创建并运行容器时，使用 –mount 参数将主机上的文件、目录、卷或者文件系统挂载到容器内用于数据持久化。\\n', '\\n', '参数说明\\n', 'type: 挂载到容器中的数据的类型，类型可以是 bind、volume、squashfs, 省略该项时默认为volume类型。\\n', 'src: 用于挂载的文件、目录或者卷在主机上的路径。当值为绝对路径时，表示挂载主机上的文件或者目录。当值为卷名时，表示挂载卷。当省略该项时，表示匿名卷。当文件夹或者卷不存在时，iSula会先创建一个新的文件/卷，再进行挂载操作。该项的关键字 src 也可以写成 source。\\n', 'dst: 容器内的挂载路径，必须为绝对路径。该项的关键字 dst 也可以写成 destination 或者 target。\\n', 'KEY=VALUE: 表示 –mount 的参数，可以取如下值：\\n', 'KEY 值\\tVALUE\\n', 'selinux-opts/bind-selinux-opts\\tz或者Z。z表示如果开启了SElinux，则挂载时添加SElinux共享标签；Z表示如果开启了SElinux，则挂载时添加SElinux私有标签\\n', 'ro/readonly\\t0/false 表示挂载成读写属性，1/true 表示挂载成只读属性。该项的值可以省略表示挂载成只读。该项只在 type=bind 时支持配置该参数\\n', 'volume-nocopy\\t不拷贝挂载点内的数据，该参数不进行配置时默认会拷贝数据。另外，如果卷里已经有数据了，也不会进行拷贝。只在 type=volume 时支持该参数\\n', '示例\\n', '基于 busybox 运行容器并创建/挂载名称为 vol 的卷到容器的 /vol 目录，同时配置挂载点为只读，并且如果容器中对应挂载点有数据也不进行拷贝。\\n', '\\n', 'isula run --mount type=volume,src=vol,dst=/vol,ro=true,volume-nocopy=true busybox\\n', '复用其他容器中的挂载配置\\n', '命令格式\\n', 'isula run --volumes-from CON1[:MODE] busybox\\n', '功能描述\\n', '使用 create / run 创建并运行容器时，使用 –volumes-from 参数表示挂载点配置包括CON1容器的挂载点配置。可以配置多个 –volumes-from 参数。\\n', '\\n', '参数说明\\n', 'CON1: 被复用挂载点的容器的名称或者ID。\\n', 'MODE: 值为ro表示复用的挂载点挂载为只读属性，值为rw表示复用的挂载点挂载为读写属性。\\n', '示例\\n', '假设已经有名称为 container1 的容器配置了卷 vol1 到容器目录 /vol1，名称为 container2 的容器配置了卷 vol2 到容器目录 /vol2。现在运行一个新的容器复用 container1 和 container2 的挂载配置，即卷 vol1 挂载到容器的 /vol1 目录，vol2 挂载到容器的 /vol2 目录。\\n', '\\n', 'isula run --volumes-from container1 --volumes-from container2 busbyox\\n', '使用镜像中的匿名卷\\n', '使用镜像中的匿名卷不需要用户做任何配置。如果镜像中配置了匿名卷，则在运行容器时 iSula 会自动创建一个匿名卷并挂载到镜像中指定的路径供用户使用。用户可以往容器中的匿名卷挂载点写入数据进行数据持久化。\\n', '\\n', '卷的查询\\n', '命令格式\\n', 'isula volume ls [OPTIONS]\\n', '功能描述\\n', '查询 iSula 管理的所有卷。\\n', '\\n', '参数说明\\n', 'OPTIONS 可选参数：\\n', '\\n', '-q,–quit: 如果不加这个参数，默认只会查询到卷的驱动信息和卷的名称，添加该参数表示只查询卷的名称。\\n', '示例\\n', '查询 iSula 管理的所有卷，只返回卷名称。\\n', '\\n', 'isula volume ls -q\\n', '卷的删除\\n', '命令格式\\n', 'isula volume rm [OPTIONS] VOLUME [VOLUME...]\\n', 'isula volume prune [OPTIONS]\\n', '功能描述\\n', 'rm 命令：删除指定的卷，如果卷被容器使用了，则会删除失败。\\n', 'prune 命令：删除所有未被容器使用的卷。\\n', '参数说明\\n', 'prune 命令的 OPTIONS 可选参数:\\n', '\\n', '-f,–force: 表示不弹出“确认是否要删除”的提示，默认会有风险提示，需要输入 y 才能继续执行。\\n', '示例\\n', '删除卷 vol1 和卷 vol2\\n', '\\n', 'isula volume rm vol1 vol2\\n', '删除所有未被使用的卷，不弹出风险提示，格式如下：\\n', '\\n', 'isula volume prune -f\\n', '注意事项\\n', '冲突合并规则\\n', '如果卷的挂载点有冲突，则按照如下规则处理：\\n', '\\n', '-v 和 –mount 的配置冲突，则返回失败。\\n', '–volumes-from 里获取的配置，如果和 -v/–mount 配置有冲突，则丢弃。\\n', '镜像中的匿名卷配置，如果和 -v/–mount/–volumes-from 配置有冲突，则丢弃。\\n', 'iSula和Docker的差异\\n', 'iSula行为\\tDocker行为\\n', '卷名称最长64个字符\\t卷名称长度没有限制\\n', '–mount 参数，如果挂载的源不存在，则会创建\\t–mount 参数，如果挂载的源不存在，则会报错\\n', '–mount 参数，支持 bind-selinux-opts 和 selinux-opts 参数配置 z/Z\\t–mount 参数，不支持 bind-selinux-opts 和 selinux-opts 参数\\n', '挂载点冲突合并规则，不做特殊处理\\t挂载点冲突合并规则，将 -v 指定的匿名卷当成镜像中的匿名卷一样处理\\n', 'volume prune 命令，提示回收了多少空间\\tvolume prune 命令，不会提示回收了多少空间\\n', '-v/–mount/–volumes-from 配置在 hostconfig 中，匿名卷配置在 config 中\\t-v 配置的匿名卷放在 config 配置中，其他配置在 hostconfig 中\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_查询信息.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%9F%A5%E8%AF%A2%E4%BF%A1%E6%81%AF.html", "text_entry": "['查询信息\\n', '查询信息\\n', '查询服务版本信息\\n', '查询系统级信息\\n', '查询信息\\n', '查询服务版本信息\\n', '描述\\n', 'isula version 命令用于查询iSulad服务的版本信息。\\n', '\\n', '用法\\n', 'isula version\\n', '实例\\n', '查询版本信息\\n', '\\n', 'isula version\\n', '如果isulad服务正常运行，则可以查看到客户端、服务端以及OCI config的版本等信息。\\n', '\\n', 'Client:\\n', '  Version:      1.0.31\\n', '  Git commit:   fa7f9902738e8b3d7f2eb22768b9a1372ddd1199\\n', '  Built:        2019-07-30T04:21:48.521198248-04:00\\n', '\\n', 'Server:\\n', '  Version:      1.0.31\\n', '  Git commit:   fa7f9902738e8b3d7f2eb22768b9a1372ddd1199\\n', '  Built:        2019-07-30T04:21:48.521198248-04:00\\n', '\\n', 'OCI config:\\n', '  Version:      1.0.0-rc5-dev\\n', '  Default file: /etc/default/isulad/config.json\\n', '若isulad服务未运行，则仅仅查询到客户端的信息，并提示无法连接到服务端。\\n', '\\n', 'Client:\\n', '  Version:      1.0.31\\n', '  Git commit:   fa7f9902738e8b3d7f2eb22768b9a1372ddd1199\\n', '  Built:        2019-07-30T04:21:48.521198248-04:00\\n', '\\n', 'Can not connect with server.Is the iSulad daemon running on the host?\\n', '因此，isula version命令也常常用来检验isulad是否正常运行。\\n', '\\n', '查询系统级信息\\n', '描述\\n', 'isula info命令用于对系统级信息，以及容器和镜像数目等信息的查询。\\n', '\\n', '用法\\n', 'isula info\\n', '示例\\n', '查询系统级信息，可以展示容器数目，镜像数目，内核版本、操作系统等信息\\n', '\\n', '# isula info\\n', 'Containers: 2\\n', ' Running: 0\\n', ' Paused: 0\\n', ' Stopped: 2\\n', 'Images: 8\\n', 'Server Version: 1.0.31\\n', 'Logging Driver: json-file\\n', 'Cgroup Driverr: cgroupfs\\n', 'Hugetlb Pagesize: 2MB\\n', 'Kernel Version: 4.19\\n', 'Operating System: Fedora 29 (Twenty Nine)\\n', 'OSType: Linux\\n', 'Architecture: x86_64\\n', 'CPUs: 8\\n', 'Total Memory: 7 GB\\n', 'Name: localhost.localdomain\\n', 'iSulad Root Dir: /var/lib/isulad\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_特权容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%89%B9%E6%9D%83%E5%AE%B9%E5%99%A8.html", "text_entry": "['特权容器\\n', '特权容器\\n', '场景说明\\n', '使用限制\\n', '使用指导\\n', '场景说明\\n', 'iSulad默认启动的是普通容器，普通容器适合启动普通进程，其权限非常受限，仅具备/etc/default/isulad/config.json中capabilities所定义的默认权限。当需要特权操作时（比如操作/sys下的设备），需要特权容器完成这些操作，使用该特性，容器内的root将拥有宿主机的root权限， 否则，容器内的root在只是宿主机的普通用户权限。\\n', '\\n', '使用限制\\n', '特权容器为容器提供了所有功能，还解除了设备cgroup控制器强制执行的所有限制，具备以下特性：\\n', '\\n', 'Secomp不block任何系统调用\\n', '\\n', '/sys、/proc路径可写\\n', '\\n', '容器内能访问主机上所有设备\\n', '\\n', '系统的权能将全部打开\\n', '\\n', '普通容器默认权能为：\\n', '\\n', '\\n', 'Capability Key\\n', '\\n', 'Capability Description\\n', '\\n', 'SETPCAP\\n', '\\n', '修改进程权能\\n', '\\n', 'MKNOD\\n', '\\n', '允许使用mknod()系统调用创建特殊文件\\n', '\\n', 'AUDIT_WRITE\\n', '\\n', '向内核审计日志写记录\\n', '\\n', 'CHOWN\\n', '\\n', '对文件的 UIDs 和 GIDs 做任意的修改(参考 chown(2))\\n', '\\n', 'NET_RAW\\n', '\\n', '使用 RAW 和 PACKET sockets；为透明代理绑定任何地址\\n', '\\n', 'DAC_OVERRIDE\\n', '\\n', '忽略文件的DAC访问限制\\n', '\\n', 'FOWNER\\n', '\\n', '忽略文件属主ID必须和进程用户ID相匹配的限制\\n', '\\n', 'FSETID\\n', '\\n', '允许设置文件的setuid位\\n', '\\n', 'KILL\\n', '\\n', '允许对不属于自己的进程发送信号\\n', '\\n', 'SETGID\\n', '\\n', '允许改变进程的组ID\\n', '\\n', 'SETUID\\n', '\\n', '允许改变进程的用户ID\\n', '\\n', 'NET_BIND_SERVICE\\n', '\\n', '允许绑定到小于1024的端口\\n', '\\n', 'SYS_CHROOT\\n', '\\n', '允许使用chroot()系统调用\\n', '\\n', 'SETFCAP\\n', '\\n', '允许向其他进程转移能力以及删除其他进程的能力\\n', '\\n', '当容器为特权模式时，将添加以下权能\\n', '\\n', '\\n', 'Capability Key\\n', '\\n', 'Capability Description\\n', '\\n', 'SYS_MODULE\\n', '\\n', '加载和卸载内核模块\\n', '\\n', 'SYS_RAWIO\\n', '\\n', '允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备\\n', '\\n', 'SYS_PACCT\\n', '\\n', '允许执行进程的BSD式审计\\n', '\\n', 'SYS_ADMIN\\n', '\\n', '允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等\\n', '\\n', 'SYS_NICE\\n', '\\n', '允许提升优先级及设置其他进程的优先级\\n', '\\n', 'SYS_RESOURCE\\n', '\\n', '忽略资源限制\\n', '\\n', 'SYS_TIME\\n', '\\n', '允许改变系统时钟\\n', '\\n', 'SYS_TTY_CONFIG\\n', '\\n', '允许配置TTY设备\\n', '\\n', 'AUDIT_CONTROL\\n', '\\n', '启用和禁用内核审计；修改审计过滤器规则；提取审计状态和过滤规则\\n', '\\n', 'MAC_ADMIN\\n', '\\n', '覆盖强制访问控制 (Mandatory Access Control (MAC))，为Smack Linux安全模块(Linux Security Module (LSM)) 而实现\\n', '\\n', 'MAC_OVERRIDE\\n', '\\n', '允许 MAC 配置或状态改变。为 Smack LSM 而实现\\n', '\\n', 'NET_ADMIN\\n', '\\n', '允许执行网络管理任务\\n', '\\n', 'SYSLOG\\n', '\\n', '执行特权 syslog(2) 操作\\n', '\\n', 'DAC_READ_SEARCH\\n', '\\n', '忽略文件读及目录搜索的DAC访问限制\\n', '\\n', 'LINUX_IMMUTABLE\\n', '\\n', '允许修改文件的IMMUTABLE和APPEND属性标志\\n', '\\n', 'NET_BROADCAST\\n', '\\n', '允许网络广播和多播访问\\n', '\\n', 'IPC_LOCK\\n', '\\n', '允许锁定共享内存片段\\n', '\\n', 'IPC_OWNER\\n', '\\n', '忽略IPC所有权检查\\n', '\\n', 'SYS_PTRACE\\n', '\\n', '允许跟踪任何进程\\n', '\\n', 'SYS_BOOT\\n', '\\n', '允许重新启动系统\\n', '\\n', 'LEASE\\n', '\\n', '允许修改文件锁的FL_LEASE标志\\n', '\\n', 'WAKE_ALARM\\n', '\\n', '触发将唤醒系统的功能，如设置 CLOCK_REALTIME_ALARM 和 CLOCK_BOOTTIME_ALARM 定时器\\n', '\\n', 'BLOCK_SUSPEND\\n', '\\n', '可以阻塞系统挂起的特性\\n', '\\n', '使用指导\\n', 'iSulad使用–privileged给容器添加特权模式，在非必要情况下，不要给容器添加特权，遵循最小特权原则，减少存在的安全风险。\\n', '\\n', 'isula run --rm -it --privileged busybox\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_镜像管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86.html", "text_entry": "['镜像管理\\n', '镜像管理\\n', 'docker镜像管理\\n', '登录到镜像仓库\\n', '从镜像仓库退出登录\\n', '从镜像仓库拉取镜像\\n', '删除镜像\\n', '加载镜像\\n', '列出镜像\\n', '检视镜像\\n', '双向认证\\n', 'embedded镜像管理\\n', '加载镜像\\n', '列出镜像\\n', '检视镜像\\n', '删除镜像\\n', 'docker镜像管理\\n', '登录到镜像仓库\\n', '描述\\n', 'isula login命令用于登录到镜像仓库。登录成功后可以使用isula pull命令从该镜像仓库拉取镜像。如果镜像仓库不需要密码，则拉取镜像前不需要执行该命令。\\n', '\\n', '用法\\n', 'isula login [OPTIONS] SERVER\\n', '参数\\n', 'login命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表1 表1-20 login命令参数列表” 。\\n', '\\n', '示例\\n', '$ isula login -u abc my.csp-edge.com:5000\\n', '\\n', 'Login Succeeded\\n', '从镜像仓库退出登录\\n', '描述\\n', 'isula logout命令用于从镜像仓库退出登录。退出登录成功后再执行isula pull命令从该镜像仓库拉取镜像会因为未认证而拉取失败。\\n', '\\n', '用法\\n', 'isula logout SERVER\\n', '参数\\n', 'logout命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表2 logout命令参数列表”。\\n', '\\n', '示例\\n', '$ isula logout my.csp-edge.com:5000\\n', 'Logout Succeeded\\n', '从镜像仓库拉取镜像\\n', '描述\\n', '从镜像仓库拉取镜像到本地。\\n', '\\n', '用法\\n', 'isula pull [OPTIONS] NAME[:TAG|@DIGEST]\\n', '参数\\n', 'login命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表3 pull命令参数列表”。\\n', '\\n', '示例\\n', '$ isula pull localhost:5000/official/busybox\\n', 'Image \"localhost:5000/official/busybox\" pulling\\n', 'Image \"localhost:5000/official/busybox@sha256:bf510723d2cd2d4e3f5ce7e93bf1e52c8fd76831995ac3bd3f90ecc866643aff\" pulled\\n', '删除镜像\\n', '描述\\n', '删除一个或多个镜像。\\n', '\\n', '用法\\n', 'isula rmi [OPTIONS] IMAGE [IMAGE...]\\n', '参数\\n', 'rmi命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表4 rmi命令参数列表”。\\n', '\\n', '示例\\n', '$ isula rmi rnd-dockerhub.huawei.com/official/busybox\\n', 'Image \"rnd-dockerhub.huawei.com/official/busybox\" removed\\n', '加载镜像\\n', '描述\\n', '从一个tar包加载镜像。该tar包必须是使用docker save命令导出的tar包或格式一致的tar包。\\n', '\\n', '用法\\n', 'isula load [OPTIONS]\\n', '参数\\n', 'load命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表5 load命令参数列表”。\\n', '\\n', '示例\\n', '$ isula load -i busybox.tar\\n', 'Load image from \"/root/busybox.tar\" success\\n', '列出镜像\\n', '描述\\n', '列出当前环境中所有镜像。\\n', '\\n', '用法\\n', 'isula images\\n', '参数\\n', 'images命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表6 images命令参数列表”。\\n', '\\n', '示例\\n', '$ isula images\\n', 'REF                                              IMAGE ID             CREATED              SIZE\\n', 'rnd-dockerhub.huawei.com/official/busybox:latest e4db68de4ff2         2019-06-15 08:19:54  1.376 MB\\n', '检视镜像\\n', '描述\\n', '返回该镜像的配置信息。可以使用-f参数过滤出需要的信息。\\n', '\\n', '用法\\n', 'isula inspect [options] CONTAINER|IMAGE [CONTAINER|IMAGE...]\\n', '参数\\n', 'inspect命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表7 inspect命令参数列表”。\\n', '\\n', '示例\\n', '$ isula inspect -f \"{{json .image.id}}\" rnd-dockerhub.huawei.com/official/busybox\\n', '\"e4db68de4ff27c2adfea0c54bbb73a61a42f5b667c326de4d7d5b19ab71c6a3b\"\\n', '双向认证\\n', '描述\\n', '开启该功能后isulad和镜像仓库之间的通信采用https通信，isulad和镜像仓库都会验证对方的合法性。\\n', '\\n', '用法\\n', '要支持该功能，需要镜像仓库支持该功能，同时isulad也需要做相应的配置：\\n', '\\n', '修改isulad的配置(默认路径/etc/isulad/daemon.json)，将配置里的use-decrypted-key项配置为false。\\n', '\\n', '需要将相关的证书放置到/etc/isulad/certs.d目录下对应的镜像仓库命名的文件夹下，证书具体的生成方法见docker的官方链接：\\n', '\\n', 'https://docs.docker.com/engine/security/certificates/\\n', 'https://docs.docker.com/engine/security/https/\\n', '执行systemctl restart isulad重启isulad。\\n', '\\n', '参数\\n', '可以在/etc/isulad/daemon.json中配置参数，也可以在启动isulad时携带参数：\\n', '\\n', 'isulad --use-decrypted-key=false\\n', '示例\\n', '配置use-decrypted-key参数为false\\n', '\\n', '$ cat /etc/isulad/daemon.json\\n', '{\\n', '    \"group\": \"isulad\",\\n', '    \"graph\": \"/var/lib/isulad\",\\n', '    \"state\": \"/var/run/isulad\",\\n', '    \"engine\": \"lcr\",\\n', '    \"log-level\": \"ERROR\",\\n', '    \"pidfile\": \"/var/run/isulad.pid\",\\n', '    \"log-opts\": {\\n', '        \"log-file-mode\": \"0600\",\\n', '        \"log-path\": \"/var/lib/isulad\",\\n', '        \"max-file\": \"1\",\\n', '        \"max-size\": \"30KB\"\\n', '    },\\n', '    \"log-driver\": \"stdout\",\\n', '    \"hook-spec\": \"/etc/default/isulad/hooks/default.json\",\\n', '    \"start-timeout\": \"2m\",\\n', '    \"storage-driver\": \"overlay2\",\\n', '    \"storage-opts\": [\\n', '        \"overlay2.override_kernel_check=true\"\\n', '    ],\\n', '    \"registry-mirrors\": [\\n', '        \"docker.io\"\\n', '    ],\\n', '    \"insecure-registries\": [\\n', '        \"rnd-dockerhub.huawei.com\"\\n', '    ],\\n', '    \"pod-sandbox-image\": \"\",\\n', '    \"image-opt-timeout\": \"5m\",\\n', '    \"native.umask\": \"secure\",\\n', '    \"network-plugin\": \"\",\\n', '    \"cni-bin-dir\": \"\",\\n', '    \"cni-conf-dir\": \"\",\\n', '    \"image-layer-check\": false,\\n', '    \"use-decrypted-key\": false,\\n', '    \"insecure-skip-verify-enforce\": false\\n', '}\\n', '将证书放到对应的目录下\\n', '\\n', '$ pwd\\n', '/etc/isulad/certs.d/my.csp-edge.com:5000\\n', '$ ls\\n', 'ca.crt  tls.cert  tls.key\\n', '重启isulad\\n', '\\n', '$ systemctl restart isulad\\n', '执行pull命令从仓库下载镜像\\n', '\\n', '$ isula pull my.csp-edge.com:5000/busybox\\n', 'Image \"my.csp-edge.com:5000/busybox\" pulling\\n', 'Image \"my.csp-edge.com:5000/busybox@sha256:f1bdc62115dbfe8f54e52e19795ee34b4473babdeb9bc4f83045d85c7b2ad5c0\" pulled\\n', 'embedded镜像管理\\n', '加载镜像\\n', '描述\\n', '根据embedded镜像的manifest加载镜像。注意–type的值必须填写embedded。\\n', '\\n', '用法\\n', 'isula load [OPTIONS] --input=FILE --type=TYPE\\n', '参数\\n', 'load命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表5 load命令参数列表”。\\n', '\\n', '示例\\n', '$ isula load -i test.manifest --type embedded\\n', 'Load image from \"/root/work/bugfix/tmp/ci_testcase_data/embedded/img/test.manifest\" success\\n', '列出镜像\\n', '描述\\n', '列出当前环境中所有镜像。\\n', '\\n', '用法\\n', 'isula images [OPTIONS]\\n', '参数\\n', 'images命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表6 images命令参数列表”。\\n', '\\n', '示例\\n', '$ isula images\\n', 'REF                            IMAGE ID             CREATED              SIZE\\n', 'test:v1                        9319da1f5233         2018-03-01 10:55:44  1.273 MB\\n', '检视镜像\\n', '描述\\n', '返回该镜像的配置信息。可以使用-f参数过滤出需要的信息。\\n', '\\n', '用法\\n', 'isula inspect [options] CONTAINER|IMAGE [CONTAINER|IMAGE...]\\n', '参数\\n', 'inspect命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表7 inspect命令参数列表”。\\n', '\\n', '示例\\n', '$ isula inspect -f \"{{json .created}}\" test:v1\\n', '\"2018-03-01T15:55:44.322987811Z\"\\n', '删除镜像\\n', '描述\\n', '删除一个或多个镜像。\\n', '\\n', '用法\\n', 'isula rmi [OPTIONS] IMAGE [IMAGE...]\\n', '参数\\n', 'rmi命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表4 rmi命令参数列表”。\\n', '\\n', '示例\\n', '$ isula rmi test:v1\\n', 'Image \"test:v1\" removed\\n', '添加名称\\n', '描述\\n', '给镜像添加一个名称。\\n', '\\n', '用法\\n', 'isula tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]\\n', '参数\\n', 'tag命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表8 tag命令参数列表”。\\n', '\\n', '示例\\n', '$ isula tag test:v1 test:v2\\n', '导入镜像\\n', '描述\\n', '将tar格式的rootfs导入生成一个新的镜像，该tar包必须是通过export命令导出的tar包。\\n', '\\n', '用法\\n', 'isula export [command options] [ID|NAME]\\n', '参数\\n', 'export命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表9 export命令参数列表”。\\n', '\\n', '示例\\n', '$ isula export -o test.tar containername\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_安装、升级与卸载_升级.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%8D%87%E7%BA%A7.html", "text_entry": "['升级\\n', '若为相同大版本之间的升级，例如从2.x.x版本升级到2.x.x版本，请执行如下命令：\\n', '\\n', '# sudo yum update -y iSulad\\n', '若为不同大版本之间的升级，例如从1.x.x版本升级到2.x.x版本，请先保存当前的配置文件/etc/isulad/daemon.json，并卸载已安装的iSulad软件包，然后安装待升级的iSulad软件包，随后恢复配置文件。\\n', '\\n', ' 说明：\\n', '\\n', '可通过** sudo rpm -qa |grep iSulad** 或 **isula version** 命令确认当前iSulad的版本号。\\n', '相同大版本之间，如果希望手动升级，请下载iSulad及其所有依赖库的RPM包进行升级，参考命令如下：\\n', '# sudo rpm -Uhv iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm  \\n', '若升级失败，可通过–force选项进行强制升级，参考命令如下：\\n', '\\n', '# sudo rpm -Uhv --force iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm  \\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_安装、升级与卸载_卸载.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%8D%B8%E8%BD%BD.html", "text_entry": "['卸载\\n', '卸载iSulad的操作步骤如下：\\n', '\\n', '卸载iSulad及其依赖软件包\\n', '\\n', '若使用yum方式安装，卸载的参考命令如下：\\n', '\\n', '# yum remove iSulad\\n', '若使用rpm方式安装，需卸载iSulad及其依赖包，卸载单个RPM包的参考命令如下：\\n', '\\n', '# rpm -e iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm\\n', '镜像、容器、volumes以及相关配置文件不会自动删除，需要手动删除。参考命令如下：\\n', '\\n', '# rm -rf /var/lib/iSulad\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_安装、升级与卸载_安装与配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html", "text_entry": "['安装与配置\\n', '本章介绍iSulad的安装、安装后配置，以及升级和卸载的方法。\\n', '\\n', ' 说明： iSulad的安装、升级、卸载均需要使用root权限。\\n', '\\n', '安装与配置\\n', '安装方法\\n', '配置方法\\n', '安装方法\\n', 'iSulad可以通过yum或rpm命令两种方式安装，由于yum会自动安装依赖，而rpm命令需要手动安装所有依赖，所以推荐使用yum安装。\\n', '\\n', '这里给出两种安装方式的操作方法。\\n', '\\n', '（推荐）使用yum安装iSulad，参考命令如下：\\n', '\\n', '# sudo yum install -y iSulad\\n', '使用rpm安装iSulad，需要下载iSulad及其所有依赖库的RPM包，然后手动安装。安装单个iSulad的RPM包（依赖包安装方式相同），参考命令如下：\\n', '\\n', '# sudo rpm -ihv iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm\\n', '# isulad -l DEBUG\\n', '配置方法\\n', 'iSulad 安装完成后，可以根据需要进行相关配置。\\n', '\\n', '配置方式\\n', '轻量级容器引擎（iSulad）服务端daemon为isulad，isulad可以通过配置文件进行配置，也可以通过命令行的方式进行配置，例如：isulad –xxx，优先级从高到低是：命令行方式>配置文件>代码中默认配置。\\n', '\\n', ' 说明：\\n', '如果采用systemd管理iSulad进程，修改/etc/sysconfig/iSulad文件中的OPTIONS字段，等同于命令行方式进行配置。\\n', '\\n', '命令行方式\\n', '\\n', '在启动服务的时候，直接通过命令行进行配置。其配置选项可通过以下命令查阅：\\n', '\\n', '# isulad --help\\n', 'lightweight container runtime daemon\\n', '\\n', 'Usage:  isulad [global options]\\n', '\\n', 'GLOBAL OPTIONS:\\n', '\\n', '      --authorization-plugin            Use authorization plugin\\n', '      --cgroup-parent                   Set parent cgroup for all containers\\n', '      --cni-bin-dir                     The full path of the directory in which to search for CNI plugin binaries. Default: /opt/cni/bin\\n', '      --cni-conf-dir                    The full path of the directory in which to search for CNI config files. Default: /etc/cni/net.d\\n', '      --default-ulimit                  Default ulimits for containers (default [])\\n', '  -e, --engine                          Select backend engine\\n', '  -g, --graph                           Root directory of the iSulad runtime\\n', '  -G, --group                           Group for the unix socket(default is isulad)\\n', '      --help                            Show help\\n', '      --hook-spec                       Default hook spec file applied to all containers\\n', '  -H, --host                            The socket name used to create gRPC server\\n', '      --image-layer-check               Check layer intergrity when needed\\n', '      --image-opt-timeout               Max timeout(default 5m) for image operation\\n', '      --insecure-registry               Disable TLS verification for the given registry\\n', '      --insecure-skip-verify-enforce    Force to skip the insecure verify(default false)\\n', '      --log-driver                      Set daemon log driver, such as: file\\n', '  -l, --log-level                       Set log level, the levels can be: FATAL ALERT CRIT ERROR WARN NOTICE INFO DEBUG TRACE\\n', '      --log-opt                         Set daemon log driver options, such as: log-path=/tmp/logs/ to set directory where to store daemon logs\\n', '      --native.umask                    Default file mode creation mask (umask) for containers\\n', '      --network-plugin                  Set network plugin, default is null, suppport null and cni\\n', '  -p, --pidfile                         Save pid into this file\\n', '      --pod-sandbox-image               The image whose network/ipc namespaces containers in each pod will use. (default \"rnd-dockerhub.huawei.com/library/pause-${machine}:3.0\")\\n', '      --registry-mirrors                Registry to be prepended when pulling unqualified images, can be specified multiple times\\n', '      --start-timeout                   timeout duration for waiting on a container to start before it is killed\\n', '  -S, --state                           Root directory for execution state files\\n', '      --storage-driver                  Storage driver to use(default overlay2)\\n', '  -s, --storage-opt                     Storage driver options\\n', '      --tls                             Use TLS; implied by --tlsverify\\n', '      --tlscacert                       Trust certs signed only by this CA (default \"/root/.iSulad/ca.pem\")\\n', '      --tlscert                         Path to TLS certificate file (default \"/root/.iSulad/cert.pem\")\\n', '      --tlskey                          Path to TLS key file (default \"/root/.iSulad/key.pem\")\\n', '      --tlsverify                       Use TLS and verify the remote\\n', '      --use-decrypted-key               Use decrypted private key by default(default true)\\n', '  -V, --version                         Print the version\\n', '   --websocket-server-listening-port    CRI websocket streaming service listening port (default 10350)\\n', '示例： 启动isulad，并将日志级别调整成DEBUG\\n', '\\n', '# isulad -l DEBUG\\n', '配置文件方式\\n', '\\n', 'isulad配置文件为/etc/isulad/daemon.json，各配置字段说明如下：\\n', '\\n', '\\n', '配置参数\\n', '\\n', '配置文件示例\\n', '\\n', '参数解释\\n', '\\n', '备注\\n', '\\n', '-e, --engine\\n', '\\n', '\"engine\": \"lcr\"\\n', '\\n', 'iSulad的运行时，默认是lcr\\n', '\\n', '无\\n', '\\n', '-G, --group\\n', '\\n', '\"group\": \"isulad\"\\n', '\\n', 'socket所属组\\n', '\\n', '无\\n', '\\n', '--hook-spec\\n', '\\n', '\"hook-spec\": \"/etc/default/isulad/hooks/default.json\"\\n', '\\n', '针对所有容器的默认钩子配置文件\\n', '\\n', '无\\n', '\\n', '-H, --host\\n', '\\n', '\"hosts\": \"unix:///var/run/isulad.sock\"\\n', '\\n', '通信方式\\n', '\\n', '除本地socket外，还支持tcp://ip:port方式，port范围（0-65535，排除被占用端口）\\n', '\\n', '--log-driver\\n', '\\n', '\"log-driver\": \"file\"\\n', '\\n', '日志驱动配置\\n', '\\n', '无\\n', '\\n', '-l, --log-level\\n', '\\n', '\"log-level\": \"ERROR\"\\n', '\\n', '设置日志输出级别\\n', '\\n', '无\\n', '\\n', '--log-opt\\n', '\\n', '\"log-opts\": {\\n', '\\n', '\"log-file-mode\": \"0600\",\\n', '\\n', '\"log-path\": \"/var/lib/isulad\",\\n', '\\n', '\"max-file\": \"1\",\\n', '\\n', '\"max-size\": \"30KB\"\\n', '\\n', '}\\n', '\\n', '日志相关的配置\\n', '\\n', '可以指定max-file，max-size，log-path。max-file指日志文件个数；max-size指日志触发防爆的阈值，若max-file为1，max-size失效；log-path指定日志文件存储路径；log-file-mode用于设置日志文件的读写权限，格式要求必须为八进制格式，如0666。\\n', '\\n', '--start-timeout\\n', '\\n', '\"start-timeout\": \"2m\"\\n', '\\n', '启动容器的耗时\\n', '\\n', '无\\n', '\\n', '--runtime\\n', '\\n', '\"default-runtime\": \"lcr\"\\n', '\\n', '创建容器时的runtime运行时，默认是lcr\\n', '\\n', '当命令行和配置文件均未指定时，默认为lcr，runtime的三种指定方式优先级：命令行>配置文件>默认lcr，当前支持lcr、kata-runtime。\\n', '\\n', '无\\n', '\\n', '\"runtimes\":  {\\n', '    \"kata-runtime\": {\\n', '      \"path\": \"/usr/bin/kata-runtime\",\\n', '      \"runtime-args\": [\\n', '        \"--kata-config\",\\n', '        \"/usr/share/defaults/kata-containers/configuration.toml\"\\n', '      ]\\n', '    }\\n', '}\\n', '启动容器时，通过此字段指定多runtimes配置，在此集合中的元素均为有效的启动容器的runtime运行时。\\n', '\\n', '容器的runtime白名单，在此集合中的自定义runtime才是有效的。示例为以kata-runtime为例的配置。\\n', '\\n', '-p, --pidfile\\n', '\\n', '\"pidfile\": \"/var/run/isulad.pid\"\\n', '\\n', '保存pid的文件\\n', '\\n', '当启动一个容器引擎的时候不需要配置，当需要启动两个以上的容器引擎时才需要配置。\\n', '\\n', '-g, --graph\\n', '\\n', '\"graph\": \"/var/lib/isulad\"\\n', '\\n', 'iSulad运行时的根目录\\n', '\\n', '-S, --state\\n', '\\n', '\"state\": \"/var/run/isulad\"\\n', '\\n', '执行文件的根目录\\n', '\\n', '--storage-driver\\n', '\\n', '\"storage-driver\": \"overlay2\"\\n', '\\n', '镜像存储驱动，默认为overlay2\\n', '\\n', '当前只支持overlay2\\n', '\\n', '-s, --storage-opt\\n', '\\n', '\"storage-opts\": [ \"overlay2.override_kernel_check=true\" ]\\n', '\\n', '镜像存储驱动配置选项\\n', '\\n', '可使用的选项为：\\n', '\\n', 'overlay2.override_kernel_check=true # 忽略内核版本检查\\n', 'overlay2.size=${size} # 设置rootfs quota限额为${size}大小\\n', 'overlay2.basesize=${size} #等价于overlay2.size\\n', '--image-opt-timeout\\n', '\\n', '\"image-opt-timeout\": \"5m\"\\n', '\\n', '镜像操作超时时间，默认为5m\\n', '\\n', '值为-1表示不限制超时。\\n', '\\n', '--registry-mirrors\\n', '\\n', '\"registry-mirrors\": [ \"docker.io\" ]\\n', '\\n', '镜像仓库地址\\n', '\\n', '无\\n', '\\n', '--insecure-registry\\n', '\\n', '\"insecure-registries\": [ ]\\n', '\\n', '不使用TLS校验的镜像仓库\\n', '\\n', '无\\n', '\\n', '--native.umask\\n', '\\n', '\"native.umask\": \"secure\"\\n', '\\n', '容器umask策略，默认\"secure\"，normal为不安全配置\\n', '\\n', '设置容器umask值。\\n', '\\n', '支持配置空字符（使用默认值0027）、\"normal\"、\"secure\"：\\n', '\\n', 'normal    # 启动的容器umask值为0022\\n', 'secure    # 启动的容器umask值为0027（默认值）\\n', '--pod-sandbox-image\\n', '\\n', '\"pod-sandbox-image\": \"rnd-dockerhub.huawei.com/library/pause-aarch64:3.0\"\\n', '\\n', 'pod默认使用镜像，默认为\"rnd-dockerhub.huawei.com/library/pause-${machine}:3.0\"\\n', '\\n', '无\\n', '\\n', '--network-plugin\\n', '\\n', '\"network-plugin\": \"\"\\n', '\\n', '指定网络插件，默认为空字符，表示无网络配置，创建的sandbox只有loop网卡。\\n', '\\n', '支持cni和空字符，其他非法值会导致isulad启动失败。\\n', '\\n', '--cni-bin-dir\\n', '\\n', '\"cni-bin-dir\": \"\"\\n', '\\n', '指定cni插件依赖的二进制的存储位置\\n', '\\n', '默认为/opt/cni/bin\\n', '\\n', '--cni-conf-dir\\n', '\\n', '\"cni-conf-dir\": \"\"\\n', '\\n', '指定cni网络配置文件的存储位置\\n', '\\n', '默认为/etc/cni/net.d\\n', '\\n', '--image-layer-check=false\\n', '\\n', '\"image-layer-check\": false\\n', '\\n', '开启镜像层完整性检查功能，设置为true；关闭该功能，设置为false。默认为关闭。\\n', '\\n', 'isulad启动时会检查镜像层的完整性，如果镜像层被破坏，则相关的镜像不可用。isulad进行镜像完整性校验时，无法校验内容为空的文件和目录，以及链接文件。因此若镜像因掉电导致上述类型文件丢失，isulad的镜像数据完整性校验可能无法识别。isulad版本变更时需要检查是否支持该参数，如果不支持，需要从配置文件中删除。\\n', '\\n', '--insecure-skip-verify-enforce=false\\n', '\\n', '\"insecure-skip-verify-enforce\": false\\n', '\\n', 'Bool类型，是否强制跳过证书的主机名/域名验证，默认为false。当设置为true时，为不安全配置，会跳过证书的主机名/域名验证\\n', '\\n', '默认为false（不跳过），注意：因isulad使用的yajl json 解析库限制，若在/etc/isulad/daemon.json配置文件中配置非Bool类型的其他符合json格式的值时，isulad将使用默认值false。\\n', '\\n', '--use-decrypted-key=true\\n', '\\n', '\"use-decrypted-key\": true\\n', '\\n', 'Bool类型，指定是否使用不加密的私钥。指定为true，表示使用不加密的私钥；指定为false，表示使用的为加密后的私钥，即需要进行双向认证。\\n', '\\n', '默认配置为true(使用不加密的私钥)，注意：因isulad使用的yajl json 解析库限制，若在/etc/isulad/daemon.json配置文件中配置非Bool类型的其他符合json格式的值时，isulad将使用默认值true。\\n', '\\n', '--tls\\n', '\\n', '\"tls\":false\\n', '\\n', 'Bool类型，是否使用TLS\\n', '\\n', '默认值为false， 仅用于-H tcp://IP:PORT方式\\n', '\\n', '--tlsverify\\n', '\\n', '\"tlsverify\":false\\n', '\\n', 'Bool类型，是否使用TLS，并验证远程访问\\n', '\\n', '仅用于-H tcp://IP:PORT方式\\n', '\\n', '--tlscacert\\n', '\\n', '--tlscert\\n', '\\n', '--tlskey\\n', '\\n', '\"tls-config\": {\\n', '\\n', '\"CAFile\": \"/root/.iSulad/ca.pem\",\\n', '\\n', '\"CertFile\": \"/root/.iSulad/server-cert.pem\",\\n', '\\n', '\"KeyFile\":\"/root/.iSulad/server-key.pem\"\\n', '\\n', '}\\n', '\\n', 'TLS证书相关的配置\\n', '\\n', '仅用于-H tcp://IP:PORT方式\\n', '\\n', '--authorization-plugin\\n', '\\n', '\"authorization-plugin\": \"authz-broker\"\\n', '\\n', '用户权限认证插件\\n', '\\n', '当前只支持authz-broker\\n', '\\n', '--cgroup-parent\\n', '\\n', '\"cgroup-parent\": \"lxc/mycgroup\"\\n', '\\n', '字符串类型，容器默认cgroup父路径\\n', '\\n', '指定daemon端容器默认的cgroup父路径，如果客户端指定了--cgroup-parent，以客户端参数为准。\\n', '\\n', '注意：如果启了一个容器A，然后启一个容器B，容器B的cgroup父路径指定为容器A的cgroup路径，在删除容器的时候需要先删除容器B再删除容器A，否则会导致cgroup资源残留。\\n', '\\n', '--default-ulimits\\n', '\\n', '\"default-ulimits\": {\\n', '\\n', '\"nofile\": {\\n', '\\n', '\"Name\": \"nofile\",\\n', '\\n', '\"Hard\": 6400,\\n', '\\n', '\"Soft\": 3200\\n', '\\n', '}\\n', '\\n', '}\\n', '\\n', 'ulimit指定限制的类型，soft值及hard值\\n', '\\n', \"指定限制的资源类型，如“nofile”。两个字段名字必须相同，即都为nofile，否则会报错。Hard指定的值需要大于等于Soft'。如果Hard字段或者Soft字段未设置，则默认该字段默认为0。\\n\", '\\n', '--websocket-server-listening-port\\n', '\\n', '\"websocket-server-listening-port\": 10350\\n', '\\n', '设置CRI websocket流式服务侦听端口，默认端口号10350\\n', '\\n', '指定CRI websocket流式服务侦听端，如果客户端指定了\\n', '\\n', '--websocket-server-listening-port，以客户端参数为准。端口范围1024-49151\\n', '\\n', '示例：\\n', '\\n', '# cat /etc/isulad/daemon.json\\n', '{\\n', '    \"group\": \"isulad\",\\n', '    \"default-runtime\": \"lcr\",\\n', '    \"graph\": \"/var/lib/isulad\",\\n', '    \"state\": \"/var/run/isulad\",\\n', '    \"engine\": \"lcr\",\\n', '    \"log-level\": \"ERROR\",\\n', '    \"pidfile\": \"/var/run/isulad.pid\",\\n', '    \"log-opts\": {\\n', '        \"log-file-mode\": \"0600\",\\n', '        \"log-path\": \"/var/lib/isulad\",\\n', '        \"max-file\": \"1\",\\n', '        \"max-size\": \"30KB\"\\n', '    },\\n', '    \"log-driver\": \"stdout\",\\n', '    \"hook-spec\": \"/etc/default/isulad/hooks/default.json\",\\n', '    \"start-timeout\": \"2m\",\\n', '    \"storage-driver\": \"overlay2\",\\n', '    \"storage-opts\": [\\n', '        \"overlay2.override_kernel_check=true\"\\n', '    ],\\n', '    \"registry-mirrors\": [\\n', '        \"docker.io\"\\n', '    ],\\n', '    \"insecure-registries\": [\\n', '        \"rnd-dockerhub.huawei.com\"\\n', '    ],\\n', '    \"pod-sandbox-image\": \"\",\\n', '    \"image-opt-timeout\": \"5m\",\\n', '    \"native.umask\": \"secure\",\\n', '    \"network-plugin\": \"\",\\n', '    \"cni-bin-dir\": \"\",\\n', '    \"cni-conf-dir\": \"\",\\n', '    \"image-layer-check\": false,\\n', '    \"use-decrypted-key\": true,\\n', '    \"insecure-skip-verify-enforce\": false\\n', '}\\n', ' 须知：\\n', '默认配置文件/etc/isulad/daemon.json仅供参考，请根据实际需要进行配置\\n', '\\n', '存储说明\\n', '\\n', '文件名\\n', '\\n', '文件路径\\n', '\\n', '内容\\n', '\\n', '\\\\*\\n', '\\n', '/etc/default/isulad/\\n', '\\n', '存放isulad的OCI配置文件和钩子模板文件，文件夹下的配置文件权限设置为0640，sysmonitor检查脚本权限为0550\\n', '\\n', '\\\\*\\n', '\\n', '/etc/isulad/\\n', '\\n', 'isulad的默认配置文件和seccomp的默认配置文件\\n', '\\n', 'isulad.sock\\n', '\\n', '/var/run/\\n', '\\n', '管道通信文件，客户端和isulad的通信使用的socket文件\\n', '\\n', 'isulad.pid\\n', '\\n', '/var/run/\\n', '\\n', '存放isulad的PID，同时也是一个文件锁防止启动多个isulad实例\\n', '\\n', '\\\\*\\n', '\\n', '/run/lxc/\\n', '\\n', '文件锁文件，isula运行过程创建的文件\\n', '\\n', '\\\\*\\n', '\\n', '/var/run/isulad/\\n', '\\n', '实时通讯缓存文件，isulad运行过程创建的文件\\n', '\\n', '\\\\*\\n', '\\n', '/var/run/isula/\\n', '\\n', '实时通讯缓存文件，isula运行过程创建的文件\\n', '\\n', '\\\\*\\n', '\\n', '/var/lib/lcr/\\n', '\\n', 'LCR 组件临时目录\\n', '\\n', '\\\\*\\n', '\\n', '/var/lib/isulad/\\n', '\\n', 'isulad运行的根目录，存放创建的容器配置、日志的默认路径、数据库文件、mount点等\\n', '\\n', '/var/lib/isulad/mnt/ ：容器rootfs的mount点\\n', '\\n', '/var/lib/isulad/engines/lcr/ ：存放lcr容器配置目录，每个容器一个目录（以容器名命名）\\n', '\\n', '约束限制\\n', '高并发场景（并发启动200容器）下，glibc的内存管理机制会导致内存空洞以及虚拟内存较大（例如10GB）的问题。该问题是高并发场景下glibc内存管理机制的限制，而不是内存泄露，不会导致内存消耗无限增大。可以通过设置MALLOC_ARENA_MAX环境变量来减少虚拟内存的问题，而且可以增大减少物理内存的概率。但是这个环境变量会导致iSulad的并发性能下降，需要用户根据实际情况做配置。\\n', '\\n', '参考实践情况，平衡性能和内存，可以设置MALLOC_ARENA_MAX为4。（在arm64服务器上面对iSulad的性能影响在10%以内）\\n', '\\n', '配置方法：\\n', '1. 手动启动iSulad的场景，可以直接export MALLOC_ARENA_MAX=4，然后再启动iSulad即可。\\n', '2. systemd管理iSulad的场景，可以修改/etc/sysconfig/iSulad，增加一条MALLOC_ARENA_MAX=4即可。\\n', '为daemon指定各种运行目录时的注意事项\\n', '\\n', '以–root为例，当使用/new/path/作为daemon新的Root Dir时，如果/new/path/下已经存在文件，且目录或文件名与isulad需要使用的目录或文件名冲突（例如：engines、mnt等目录）时，isulad可能会更新原有目录或文件的属性，包括属主、权限等为自己的属主和权限。\\n', '\\n', '所以，用户需要明白重新指定各种运行目录和文件，会对冲突目录、文件属性的影响。建议用户指定的新目录或文件为isulad专用，避免冲突导致的文件属性变化以及带来的安全问题。\\n', '\\n', '日志文件管理：\\n', '\\n', ' 须知：\\n', '日志功能对接： iSulad由systemd管理，日志也由systemd管理，然后传输给rsyslogd。rsyslog默认会对写日志速度有限制，可以通过修改/etc/rsyslog.conf文件，增加\"$imjournalRatelimitInterval 0\"配置项，然后重启rsyslogd的服务即可。\\n', '\\n', '命令行参数解析限制\\n', '\\n', \"使用iSulad命令行接口时，其参数解析方式与docker略有不同，对于命令行中带参数的flag，不管使用长flag还是短flag，只会将该flag后第一个空格或与flag直接相连接的'='后的字符串作为flag的参数，具体如下：\\n\", '\\n', '使用短flag时，与“-”连接的字符串中的每个字符都被当作短flag（当有=号时，=号后的字符串当成=号前的短flag的参数）。\\n', '\\n', 'isula run -du=root busybox 等价于 isula run -du root busybox 或 isula run -d -u=root busybox 或 isula run -d -u root busybox ，当使用isula run -du:root时，由于-:不是有效的短flag，因此会报错。前述的命令行也等价于isula run -ud root busybox，但不推荐这种使用方式，可能带来语义困扰。\\n', '\\n', '使用长flag时，与“–”连接的字符串作为一个整体当成长flag，若包含=号，则=号前的字符串为长flag，=号后的为参数。\\n', '\\n', 'isula run --user=root busybox\\n', '等价于\\n', '\\n', 'isula run --user root busybox\\n', '启动一个isulad容器，不能够以非root用户进行isula run -i/-t/-ti以及isula attach/exec操作。\\n', '\\n', 'iSulad对接OCI容器时，仅支持kata-runtime启动OCI容器。\\n', '\\n', 'DAEMON多端口的绑定\\n', '描述\\n', 'daemon端可以绑定多个unix socket或者tcp端口，并在这些端口上侦听，客户端可以通过这些端口和daemon端进行交互。\\n', '\\n', '接口\\n', '用户可以在/etc/isulad/daemon.json文件的hosts字段配置一个或者多个端口。当然用户也可以不指定hosts。\\n', '\\n', '{\\n', '    \"hosts\": [\\n', '        \"unix:///var/run/isulad.sock\",\\n', '        \"tcp://localhost:5678\",\\n', '        \"tcp://127.0.0.1:6789\"\\n', '    ]\\n', '}\\n', '用户也可以在/etc/sysconfig/iSulad中通过-H或者–host配置端口。用户同样可以不指定hosts。\\n', '\\n', \"OPTIONS='-H unix:///var/run/isulad.sock --host tcp://127.0.0.1:6789'\\n\", '如果用户在daemon.json文件及iSulad中均未指定hosts，则daemon在启动之后将默认侦听unix:///var/run/isulad.sock。\\n', '\\n', '限制\\n', '用户不可以在/etc/isulad/daemon.json和/etc/sysconfig/iSuald两个文件中同时指定hosts，如果这样做将会出现错误，isulad无法正常启动；\\n', '\\n', 'unable to configure the isulad with file /etc/isulad/daemon.json: the following directives are specified both as a flag and in the configuration file: hosts: (from flag: [unix:///var/run/isulad.sock tcp://127.0.0.1:6789], from file: [unix:///var/run/isulad.sock tcp://localhost:5678 tcp://127.0.0.1:6789])\\n', '若指定的host是unix socket，则必须是合法的unix socket，需要以\"unix://“开头，后跟合法的socket绝对路径；\\n', '\\n', '若指定的host是tcp端口，则必须是合法的tcp端口，需要以\"tcp://“开头，后跟合法的IP地址和端口，IP地址可以为localhost；\\n', '\\n', '可以指定至多10个有效的端口，超过10个则会出现错误，isulad无法正常启动。\\n', '\\n', '配置TLS认证与开启远程访问\\n', '描述\\n', 'iSulad采用C/S模式进行设计，在默认情况，iSulad守护进程isulad只侦听本地/var/run/isulad.sock，因此只能在本地通过客户端isula执行相关命令操作容器。为了能使isula可以远程访问容器，isulad守护进程需要通过tcp:ip的方式侦听远程访问的端口。然而，仅通过简单配置tcp ip:port进行侦听，这样会导致所有的ip都可以通过调用isula -H tcp://<remote server ip>:port与isulad通信，容易导致安全问题，因此推荐使用较安全版本的TLS(Transport Layer Security - 安全传输层协议）方式进行远程访问。\\n', '\\n', '生成TLS证书\\n', '明文私钥和证书生成方法示例\\n', '\\n', '#!/bin/bash\\n', 'set -e\\n', 'echo -n \"Enter pass phrase:\"\\n', 'read password\\n', 'echo -n \"Enter public network ip:\"\\n', 'read publicip\\n', 'echo -n \"Enter host:\"\\n', 'read HOST\\n', '\\n', 'echo \" => Using hostname: $publicip, You MUST connect to iSulad using this host!\"\\n', '\\n', 'mkdir -p $HOME/.iSulad\\n', 'cd $HOME/.iSulad\\n', 'rm -rf $HOME/.iSulad/*\\n', '\\n', 'echo \" => Generating CA key\"\\n', 'openssl genrsa -passout pass:$password -aes256 -out ca-key.pem 4096\\n', 'echo \" => Generating CA certificate\"\\n', 'openssl req -passin pass:$password -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem -subj \"/C=CN/ST=zhejiang/L=hangzhou/O=Huawei/OU=iSulad/CN=iSulad@huawei.com\"\\n', 'echo \" => Generating server key\"\\n', 'openssl genrsa -passout pass:$password -out server-key.pem 4096\\n', 'echo \" => Generating server CSR\"\\n', 'openssl req -passin pass:$password -subj /CN=$HOST -sha256 -new -key server-key.pem -out server.csr\\n', 'echo subjectAltName = DNS:$HOST,IP:$publicip,IP:127.0.0.1 >> extfile.cnf\\n', 'echo extendedKeyUsage = serverAuth >> extfile.cnf\\n', 'echo \" => Signing server CSR with CA\"\\n', 'openssl x509 -req -passin pass:$password -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf\\n', 'echo \" => Generating client key\"\\n', 'openssl genrsa -passout pass:$password -out key.pem 4096\\n', 'echo \" => Generating client CSR\"\\n', \"openssl req -passin pass:$password -subj '/CN=client' -new -key key.pem -out client.csr\\n\", 'echo \" => Creating extended key usage\"\\n', 'echo extendedKeyUsage = clientAuth > extfile-client.cnf\\n', 'echo \" => Signing client CSR with CA\"\\n', 'openssl x509 -req -passin pass:$password -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnf\\n', 'rm -v client.csr server.csr extfile.cnf extfile-client.cnf\\n', 'chmod -v 0400 ca-key.pem key.pem server-key.pem\\n', 'chmod -v 0444 ca.pem server-cert.pem cert.pem\\n', '加密私钥和证书请求文件生成方法示例\\n', '\\n', '#!/bin/bash\\n', '\\n', 'echo -n \"Enter public network ip:\"\\n', 'read publicip\\n', 'echo -n \"Enter pass phrase:\"\\n', 'read password\\n', '\\n', '# remove certificates from previous execution.\\n', 'rm -f *.pem *.srl *.csr *.cnf\\n', '\\n', '\\n', '# generate CA private and public keys\\n', 'echo 01 > ca.srl\\n', 'openssl genrsa -aes256 -out ca-key.pem -passout pass:$password 2048\\n', \"openssl req -subj '/C=CN/ST=zhejiang/L=hangzhou/O=Huawei/OU=iSulad/CN=iSulad@huawei.com' -new -x509 -days $DAYS -passin pass:$password -key ca-key.pem -out ca.pem\\n\", '\\n', '# create a server key and certificate signing request (CSR)\\n', 'openssl genrsa -aes256 -out server-key.pem -passout pass:$PASS 2048\\n', \"openssl req -new -key server-key.pem -out server.csr -passin pass:$password -subj '/CN=iSulad'\\n\", '\\n', 'echo subjectAltName = DNS:iSulad,IP:${publicip},IP:127.0.0.1 > extfile.cnf\\n', 'echo extendedKeyUsage = serverAuth >> extfile.cnf\\n', '# sign the server key with our CA\\n', 'openssl x509 -req -days $DAYS -passin pass:$password -in server.csr -CA ca.pem -CAkey ca-key.pem -out server-cert.pem -extfile extfile.cnf\\n', '\\n', '# create a client key and certificate signing request (CSR)\\n', 'openssl genrsa -aes256 -out key.pem -passout pass:$password 2048\\n', \"openssl req -subj '/CN=client' -new -key key.pem -out client.csr -passin pass:$password\\n\", '\\n', '# create an extensions config file and sign\\n', 'echo extendedKeyUsage = clientAuth > extfile.cnf\\n', 'openssl x509 -req -days 365 -passin pass:$password -in client.csr -CA ca.pem -CAkey ca-key.pem -out cert.pem -extfile extfile.cnf\\n', '\\n', '# remove the passphrase from the client and server key\\n', 'openssl rsa -in server-key.pem -out server-key.pem -passin pass:$password\\n', 'openssl rsa -in key.pem -out key.pem -passin pass:$password\\n', '\\n', '# remove generated files that are no longer required\\n', 'rm -f ca-key.pem ca.srl client.csr extfile.cnf server.csr\\n', '接口\\n', '{\\n', '    \"tls\": true,\\n', '    \"tls-verify\": true,\\n', '    \"tls-config\": {\\n', '\\t\\t\"CAFile\": \"/root/.iSulad/ca.pem\",\\n', '\\t\\t\"CertFile\": \"/root/.iSulad/server-cert.pem\",\\n', '\\t\\t\"KeyFile\":\"/root/.iSulad/server-key.pem\"\\n', '    }\\n', '}\\n', '限制\\n', '服务端支持的模式如下：\\n', '\\n', '模式1（验证客户端）：tlsverify, tlscacert, tlscert, tlskey。\\n', '模式2（不验证客户端）：tls, tlscert, tlskey。\\n', '客户端支持的模式如下:\\n', '\\n', '模式1(使用客户端证书进行身份验证，并根据给定的CA验证服务器)：tlsverify, tlscacert, tlscert, tlskey。\\n', '模式2(验证服务器)：tlsverify, tlscacert。\\n', '如果需要采用双向认证方式进行通讯，则服务端采用模式1，客户端采用模式1；\\n', '\\n', '如果需要采用单向认证方式进行通讯，则服务端采用模式2，客户端采用模式2。\\n', '\\n', ' 须知：\\n', '\\n', '采用RPM安装方式时，服务端配置可通过/etc/isulad/daemon.json以及/etc/sysconfig/iSulad配置修改\\n', '相比非认证或者单向认证方式，双向认证具备更高的安全性，推荐使用双向认证的方式进行通讯\\n', 'GRPC开源组件日志不由iSulad进行接管，如果需要查看GRPC相关日志，请按需设置GRPC_VERBOSITY和GRPC_TRACE环境变量\\n', '  \\n', '示例\\n', '服务端：\\n', '\\n', ' isulad -H=tcp://0.0.0.0:2376 --tlsverify --tlscacert ~/.iSulad/ca.pem --tlscert ~/.iSulad/server-cert.pem --tlskey ~/.iSulad/server-key.pem\\n', '客户端：\\n', '\\n', ' isula version -H=tcp://$HOSTIP:2376 --tlsverify --tlscacert ~/.iSulad/ca.pem --tlscert ~/.iSulad/cert.pem --tlskey ~/.iSulad/key.pem\\n', '配置devicemapper存储驱动\\n', '使用devicemapper存储驱动需要先配置一个thinpool设备，而配置thinpool需要一个独立的块设备，且该设备需要有足够的空闲空间用于创建thinpool，请用户根据实际需求确定。这里假设独立块设备为/dev/xvdf，具体的配置方法如下：\\n', '\\n', '一、配置thinpool\\n', '\\n', '停止isulad服务。\\n', '\\n', '# systemctl stop isulad\\n', '基于块设备创建一个lvm卷。\\n', '\\n', '# pvcreate /dev/xvdf\\n', '使用刚才创建的物理卷创建一个卷组。\\n', '\\n', '# vgcreate isula /dev/xvdf\\n', 'Volume group \"isula\" successfully created：\\n', '创建名为thinpool和thinpoolmeta的两个逻辑卷。\\n', '\\n', '# lvcreate --wipesignatures y -n thinpool isula -l 95%VG\\n', 'Logical volume \"thinpool\" created.\\n', '# lvcreate --wipesignatures y -n thinpoolmeta isula -l 1%VG\\n', 'Logical volume \"thinpoolmeta\" created.\\n', '将新创建的两个逻辑卷转换成thinpool以及thinpool所使用的metadata，这样就完成了thinpool配置。\\n', '\\n', '# lvconvert -y --zero n -c 512K --thinpool isula/thinpool --poolmetadata isula/thinpoolmeta\\n', '\\n', 'WARNING: Converting logical volume isula/thinpool and isula/thinpoolmeta to\\n', \"thin pool's data and metadata volumes with metadata wiping.\\n\", 'THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.)\\n', 'Converted isula/thinpool to thin pool.\\n', '  \\n', '\\n', '二、修改isulad配置文件\\n', '\\n', '如果环境之前运行过isulad，请先备份之前的数据。\\n', '\\n', '# mkdir /var/lib/isulad.bk\\n', '# mv /var/lib/isulad/* /var/lib/isulad.bk\\n', '修改配置文件\\n', '\\n', '这里提供了两种配置方式，用户可根据实际情况的选择合适的方式。\\n', '\\n', '编辑/etc/isulad/daemon.json，配置storage-driver字段值为devicemapper，并配置storage-opts字段的相关参数，支持参数请参见参数说明。配置参考如下所示：\\n', '\\n', '{\\n', '    \"storage-driver\": \"devicemapper\"\\n', '    \"storage-opts\": [\\n', '        \"dm.thinpooldev=/dev/mapper/isula-thinpool\",\\n', '        \"dm.fs=ext4\",\\n', '            \"dm.min_free_space=10%\"\\n', '    ]\\n', '}\\n', '或者也可以通过编辑/etc/sysconfig/iSulad，在isulad启动参数里显式指定，支持参数请参见参数说明。配置参考如下所示：\\n', '\\n', 'OPTIONS=\"--storage-driver=devicemapper --storage-opt dm.thinpooldev=/dev/mapper/isula-thinpool --storage-opt dm.fs=ext4 --storage-opt dm.min_free_space=10%\"\\n', '启动isulad，使配置生效。\\n', '\\n', '# systemctl start isulad\\n', '参数说明\\n', 'storage-opts 支持的参数请参见表1。\\n', '\\n', '表 1 starage-opts字段参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '是否必选\\n', '\\n', '含义\\n', '\\n', 'dm.fs\\n', '\\n', '是\\n', '\\n', '用于指定容器使用的文件系统类型。当前必须配置为ext4，即dm.fs=ext4\\n', '\\n', 'dm.basesize\\n', '\\n', '否\\n', '\\n', '用于指定单个容器的最大存储空间大小，单位为k/m/g/t/p，也可以使用大写字母，例如dm.basesize=50G。该参数只在首次初始化时有效。\\n', '\\n', 'dm.mkfsarg\\n', '\\n', '否\\n', '\\n', '用于在创建基础设备时指定额外的mkfs参数。例如“dm.mkfsarg=-O ^has_journal”\\n', '\\n', 'dm.mountopt\\n', '\\n', '否\\n', '\\n', '用于在挂载容器时指定额外的mount参数。例如dm.mountopt=nodiscard\\n', '\\n', 'dm.thinpooldev\\n', '\\n', '否\\n', '\\n', '用于指定容器/镜像存储时使用的thinpool设备。\\n', '\\n', 'dm.min_free_space\\n', '\\n', '否\\n', '\\n', '用于指定最小的预留空间，用百分比表示。例如dm.min_free_space=10%，表示当剩余存储空间只剩10%左右时，创建容器等和存储相关操作就会失败。\\n', '\\n', '注意事项\\n', '配置devicemapper时，如果系统上没有足够的空间给thinpool做自动扩容，请禁止自动扩容功能。\\n', '\\n', '禁止自动扩容的方法是把/etc/lvm/profile/isula-thinpool.profile中thin_pool_autoextend_threshold和thin_pool_autoextend_percent两个值都改成100，如下所示：\\n', '\\n', 'activation {   \\n', '  thin_pool_autoextend_threshold=100   \\n', '  thin_pool_autoextend_percent=100 \\n', '}\\n', '使用devicemapper时，容器文件系统必须配置为ext4，需要在isulad的配置参数中加上–storage-opt dm.fs=ext4。\\n', '\\n', '当graphdriver为devicemapper时，如果metadata文件损坏且不可恢复，需要人工介入恢复。禁止直接操作或篡改daemon存储devicemapper的元数据。\\n', '\\n', '使用devicemapper lvm时，异常掉电导致的devicemapper thinpool损坏，无法保证thinpool损坏后可以修复，也不能保证数据的完整性，需重建thinpool。\\n', '\\n', 'iSula开启了user namespace特性，切换devicemapper存储池时的注意事项\\n', '\\n', '一般启动容器时，deviceset-metadata文件为：/var/lib/isulad/devicemapper/metadata/deviceset-metadata。\\n', '使用了user namespace场景下，deviceset-metadata文件使用的是：/var/lib/isulad/{userNSUID.GID}/devicemapper/metadata/deviceset-metadata。\\n', '使用devicemapper存储驱动，容器在user namespace场景和普通场景之间切换时，需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空；针对thinpool扩容或者重建的场景下，也同样的需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空，否则isulad服务会重启失败。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_为安全容器配置网络.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E4%B8%BA%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C.html", "text_entry": "['为安全容器配置网络\\n', 'tap设备网络支持\\n', '安全容器技术是基于Qemu VM实现的，对于物理机系统来说，安全容器就相当于是一个VM，所以安全容器可以在Neutron网络中将VM通过TAP技术接入外部网络。我们这里不需要关心TAP设备的创建和网桥对接等问题，只需要将指定的TAP设备（host已经存在）热插进pause容器的VM，并更新网卡信息即可。\\n', '\\n', '相关命令行如下：\\n', '\\n', '为已经启动的容器添加一个tap网卡（interface）\\n', '\\n', '$ cat ./test-iface.json | kata-runtime kata-network add-iface 6ec7a98 -\\n', '其中：6ec7a98是容器ID的截断,test-infs.json是描述网卡信息的文件，举例如下：\\n', '\\n', '{\\n', '    \"device\": \"tap-test\", \\n', '    \"name\": \"eth-test\", \\n', '    \"IPAddresses\": [\\n', '        {\\n', '            \"address\": \"172.16.0.3\", \\n', '            \"mask\": \"16\"\\n', '        }\\n', '    ], \\n', '    \"hwAddr\":\"02:42:20:6f:a3:69\",\\n', '    \"mtu\": 1500,\\n', '    \"vhostUserSocket\":\"/usr/local/var/run/openvswitch/vhost-user1\",\\n', '    \"queues\":5\\n', '}\\n', '上述json文件中各个字段的含义说明如下：\\n', '\\n', '\\n', '字段\\n', '\\n', '是否可选\\n', '\\n', '说明\\n', '\\n', 'device\\n', '\\n', '必选\\n', '\\n', '设置网卡的主机端名字。支持字母、数字、下划线“\\\\_”、“-” 以及“.”字符，必须以字母开头，且长度不超过15。需要确保同一个宿主机上device不能重复。\\n', '\\n', 'name\\n', '\\n', '必选\\n', '\\n', '设置网卡的容器内名称。支持字母、数字、下划线“\\\\_”、“-” 以及“.”字符，必须以字母开头，且长度不超过15。需要确保同一个Sandbox内name不能重复。\\n', '\\n', 'IPAddresses\\n', '\\n', '可选\\n', '\\n', '设置网卡的IP地址。暂时支持一张网卡配置一个IP，如果不配置IP，则不会在容器内部配置IP。\\n', '\\n', 'hwAddr\\n', '\\n', '必选\\n', '\\n', '设置网卡的mac地址值。\\n', '\\n', 'mtu\\n', '\\n', '必选\\n', '\\n', '设置网卡的mtu值。允许范围为[46, 9600]之间\\n', '\\n', 'vhostUserSocket\\n', '\\n', '可选\\n', '\\n', '设置dpdk轮询socket路径。路径最大长度128字节，命名规则支持数字、字母、“-”。必须以字母开头。\\n', '\\n', 'queues\\n', '\\n', '可选\\n', '\\n', '设置网卡多队列的队列数目。如果不配置，默认为0。\\n', '\\n', 'kata-runtime kata-network add-iface添加网卡命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式插入网卡的信息，json格式内容和传入的网卡信息相同。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-iface <container-id> net.json \\n', '{\"device\":\"tap_test\",\"name\":\"eth-test\",\"IPAddresses\":[{\"Family\":2,\"Address\":\"173.85.100.1\",\"Mask\":\"24\"}],\"mtu\":1500,\"hwAddr\":\"02:42:20:6e:03:01\",\"pciAddr\":\"01.0/00\"}\\n', '命令执行失败：从命令的标准输出返回字符串null。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-iface <container-id> netbad.json 2>/dev/null\\n', 'null\\n', ' 说明：\\n', '当网卡添加成功时，如果为其指定了IP地址，则kata会为新添加的网卡添加一条destination为同网段地址的默认路由，如上例中添加网卡之后容器内有如下路由被添加：\\n', '\\n', '[root@6ec7a98 /]# ip route  \\n', '172.16.0.0/16 dev eth-test proto kernel scope link src 172.16.0.3  \\n', '列出已经添加的网卡\\n', '\\n', '$ kata-runtime kata-network list-ifaces 6ec7a98\\n', '[{\"name\":\"eth-test\",\"mac\":\"02:42:20:6f:a3:69\",\"ip\":[\"172.16.0.3/16\"],\"mtu\":1500}]\\n', '可以查询到我们刚才添加的网卡信息。\\n', '\\n', 'kata-runtime kata-network list-ifaces列出已添加网卡命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式的Pod中所有插入网卡的信息。\\n', '\\n', '如果Pod中插入了多个网卡设备，返回的是一个json数组格式的网卡信息\\n', '\\n', '$ kata-runtime kata-network list-ifaces <container-id>\\n', '[{\"name\":\"container_eth\",\"mac\":\"02:42:20:6e:a2:59\",\"ip\":[\"172.17.25.23/8\"],\"mtu\":1500},{\"name\":\"container_eth_2\",\"mac\":\"02:90:50:6b:a2:29\",\"ip\":[\"192.168.0.34/24\"],\"mtu\":1500}]\\n', '如果Pod中没有插入任何网卡设备，从命令的标准输出返回字符串null。\\n', '\\n', '$ kata-runtime kata-network list-ifaces <container-id>\\n', 'null\\n', '命令执行失败：从命令的标准输出返回字符串null，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network list-ifaces <container-id>\\n', 'null\\n', '为指定网卡添加一条路由\\n', '\\n', '$ cat ./test-route.json | kata-runtime kata-network add-route 6ec7a98 -\\n', '[{\"dest\":\"default\",\"gateway\":\"172.16.0.1\",\"device\":\"eth-test\"}]\\n', 'kata-runtime kata-network add-route为指定网卡添加一条路由命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式的添加的路由信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-route <container-id> route.json \\n', '[{\"dest\":\"177.17.0.0/24\",\"gateway\":\"177.17.25.1\",\"device\":\"netport_test_1\"}]\\n', '命令执行失败：从命令的标准输出返回字符串null，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-route <container-id> routebad.json 2>/dev/null\\n', 'null\\n', '字段说明如下：\\n', '\\n', 'dest：设置路由对应的网段。格式为<ip>/<mask>，<ip>必选。分如下3种情况：\\n', '\\n', '配置<ip>/<mask>；\\n', '只配置<ip>，则默认掩码为32；\\n', '若配置了\"dest\":“default”，默认无dest，需传入gateway。\\n', 'gateway：设置路由的下一跳网关。设置\"dest\":“default\"时，gateway必选；其他情况可选。\\n', '\\n', 'device：必选。设置路由对应的网卡名称，最长支持15字符。\\n', '\\n', ' 说明：\\n', '如果为容器内的回环设备lo添加路由时，路由配置文件中的\"device\"字段对应的设备名称为\"lo”。\\n', '\\n', '删除指定路由\\n', '\\n', '$ cat ./test-route.json | kata-runtime kata-network del-route 6ec7a98 -\\n', 'test-route.json字段与添加路由输入json文件的字段相同。\\n', '\\n', 'kata-runtime kata-network del-route删除指定路由命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式的添加的路由信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-route <container-id> route.json \\n', '[{\"dest\":\"177.17.0.0/24\",\"gateway\":\"177.17.25.1\",\"device\":\"netport_test_1\"}]\\n', '命令执行失败：从命令的标准输出返回字符串null，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-route <container-id> routebad.json 2>/dev/null\\n', 'null\\n', ' 说明：\\n', '\\n', '输入字段中dest为必选，device/gateway均为可选。kata根据不同字段进行模糊匹配，删除对应的路由规则。例如指定了dest为某个IP，则所有该IP的规则都会被删除。\\n', '如果删除的是容器内回环设备lo的路由时，路由配置文件中的\"device\"字段对应的设备名称为\"lo\"。\\n', '删除已经添加的网卡\\n', '\\n', '$ cat ./test-iface.json | kata-runtime kata-network del-iface 6ec7a98 -\\n', ' 说明：\\n', '删除网卡时，仅根据网卡容器内名称（name字段）来删除。即便填写其他字段，kata也不会使用。\\n', '\\n', 'kata-runtime kata-network del-iface删除网卡命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令标准输出返回null字符串。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-iface <container-id> net.json\\n', 'null\\n', '命令执行失败：从命令标准输出返回删除失败网卡json格式的信息，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-iface <container-id> net.json\\n', '{\"device\":\"tapname_fun_012\",\"name\":\"netport_test_1\",\"IPAddresses\":[{\"Family\":0,\"Address\":\"177.17.0.1\",\"Mask\":\"8\"}],\"mtu\":1500,\"hwAddr\":\"02:42:20:6e:a2:59\",\"linkType\":\"tap\"}\\n', '以上为常用场景和命令行示例，具体命令行接口“附录 > 接口列表”。\\n', '\\n', 'kata IPVS子系统\\n', '安全容器提供添加ipvs命令的接口，支持对容器设置ipvs规则。功能包含对虚拟服务的添加/编辑/删除、对真实服务器的添加/编辑/删除、查询ipvs服务信息、设置连接超时、清理系统连接缓存，并支持对规则的批量导入。\\n', '\\n', '为容器添加一个虚拟服务地址\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--add-service --tcp-service 172.17.0.7:80 --scheduler rr --persistent 3000\" <container-id>\\n', '修改容器虚拟服务参数\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--edit-service --tcp-service 172.17.0.7:80 --scheduler rr --persistent 5000\" <container-id>\\n', '删除容器虚拟服务地址\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--delete-service --tcp-service 172.17.0.7:80\" <container-id>\\n', '为虚拟服务地址添加一个真实服务器\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--add-server --tcp-service 172.17.0.7:80 --real-server 172.17.0.4:80 --weight 100\" <container-id>\\n', '修改容器真实服务器参数\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--edit-server --tcp-service 172.17.0.7:80 --real-server 172.17.0.4:80 --weight 200\" <container-id>\\n', '删除容器真实服务器\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--delete-server --tcp-service 172.17.0.7:80 --real-server 172.17.0.4:80\" <container-id>\\n', '查询服务信息\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--list\" <container-id>\\n', '逐条导入耗时太久，可将规则写入文件后，批量导入\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --restore -  <  <规则文件路径> <container-id>\\n', ' 说明：\\n', '单条添加时默认使用NAT模式，批量导入时添加真实服务器需手动添加-m参数使用NAT模式。\\n', '规则文件内容示例：\\n', '-A -t 10.10.11.12:100 -s rr -p 3000\\n', '-a -t 10.10.11.12:100 -r 172.16.0.1:80 -m\\n', '-a -t 10.10.11.12:100 -r 172.16.0.1:81 -m\\n', '-a -t 10.10.11.12:100 -r 172.16.0.1:82 -m\\n', '\\n', '清理系统连接缓存\\n', '\\n', 'kata-runtime kata-ipvs cleanup --parameters \"--orig-dst 172.17.0.4 --protonum tcp\" <container-id>\\n', '为tcp/tcpfin/udp连接设置超时\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--set 100 100 200\" <container-id>\\n', ' 说明：\\n', '\\n', '每个容器支持iptables规则数量最大为20000条（5k service，3个server/service），add-service和add-server都算作规则。\\n', '批量导入前需清空已有规则。\\n', '不存在并发测试场景。\\n', '以上为常用命令示例，具体命令行接口请参见“附录 > 接口列表”。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_为安全容器配置资源.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E4%B8%BA%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90.html", "text_entry": "['为安全容器配置资源\\n', '为安全容器配置资源\\n', '资源共享\\n', '限制CPU资源\\n', '限制内存资源\\n', '限制Blkio资源\\n', '限制文件描述符资源\\n', '安全容器运行于虚拟化隔离的轻量级虚拟机内，因此资源的配置应分为两部分：对轻量级虚拟机的资源配置，即Host资源配置；对虚拟机内容器的配置，即Guest容器资源配置。以下资源配置均分为这两部分。\\n', '\\n', '资源共享-27\\n', '由于安全容器运行于虚拟化隔离的轻量虚拟机内，故无法访问Host上某些namespace下的资源，因此启动时不支持–net host，–ipc host，–pid host，–uts host。\\n', '\\n', '当启动一个Pod时，同一个Pod中的所有容器默认共享同一个net namespace和ipc namespace。如果同一个Pod中的容器需要共享pid namespace，则可以通过Kubernetes进行配置，Kubernetes 1.11版本该值为默认关闭。\\n', '\\n', '限制CPU资源\\n', '配置轻量级虚拟机CPU运行资源\\n', '\\n', '对轻量级虚拟机的CPU资源配置即虚拟机运行的vcpu配置，安全容器使用–annotation com.github.containers.virtcontainers.sandbox_cpu配置轻量级虚拟机运行CPU资源，该参数仅可配置在pause容器上：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_cpu=<cpu-nums> <pause-image> <command>\\n', '举例：\\n', '\\n', '# 启动一个pause容器\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_cpu=4 busybox sleep 999999\\n', 'be3255a3f66a35508efe419bc52eccd3b000032b9d8c9c62df611d5bdc115954\\n', '\\n', '# 进入容器查看CPU信息，查看CPU个数是否与com.github.containers.virtcontainers.sandbox_cpu配置的CPU个数相等\\n', 'docker exec be32 lscpu\\n', 'Architecture:        aarch64\\n', 'Byte Order:          Little Endian\\n', 'CPU(s):              4\\n', 'On-line CPU(s) list: 0-3\\n', 'Thread(s) per core:  1\\n', 'Core(s) per socket:  1\\n', 'Socket(s):           4\\n', ' 说明：\\n', 'CPU个数可以设置的最大值为当前OS上可供运行的CPU值（除去隔离核），最小值为0.5个CPU。\\n', '\\n', '配置容器CPU运行资源\\n', '\\n', '配置容器CPU运行资源与开源docker容器配置CPU运行资源的方式相同，可以通过docker run命令中CPU资源限制相关的参数进行配置：\\n', '\\n', '\\n', '参数\\n', '\\n', '含义\\n', '\\n', '--cpu-shares\\n', '\\n', '设置容器能使用的CPU时间比例。\\n', '\\n', '--cpus\\n', '\\n', '设置容器可以使用的 CPU 个数。\\n', '\\n', '--cpu-period\\n', '\\n', '设置容器进程的调度周期。\\n', '\\n', '--cpu-quota\\n', '\\n', '设置每个容器进程调度周期内能够使用的CPU时间。\\n', '\\n', '--cpuset-cpus\\n', '\\n', '设置容器进程可以使用的CPU列表。\\n', '\\n', '说明：\\n', '安全容器使用 --cpuset-cpus 参数绑定CPU时，CPU的编号不能超过安全容器对应的轻量级虚机中CPU的个数减1（轻量级虚机中CPU的编号从0开始）。\\n', '\\n', '--cpuset-mems\\n', '\\n', '设定该容器进程可以访问的内存节点。\\n', '\\n', '说明：\\n', '安全容器不支持多NUMA架构和配置，使用NUMA memory的--cpuset-mems参数只能配置为0。\\n', '\\n', '配置CPU热插拔功能\\n', '\\n', ' 说明：\\n', '安全容器CPU热插拔功能需要虚拟化组件qemu支持CPU热插拔。\\n', '\\n', 'kata-runtime配置文件config.toml中enable_cpu_memory_hotplug选项负责开启和禁用CPU和内存热插拔。默认取值为false，表示禁用CPU和内存热插拔功能；取值为true，表示开启CPU和内存热插拔功能。\\n', '\\n', 'kata-runtime中复用了**–cpus**选项实现了CPU热插拔的功能，通过统计Pod中所有容器的**–cpus**选项的和，然后确定需要热插多少个CPU到轻量级虚机中。\\n', '\\n', '举例：\\n', '\\n', '# 启动一个pause容器，轻量级虚机默认分配了1个vcpu\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox busybox sleep 999999\\n', '77b40fb72f63b11dd3fcab2f6dabfc7768295fced042af8c7ad9c0286b17d24f\\n', '\\n', '# 查看启动完pause容器后轻量级虚机中CPU个数\\n', 'docker exec 77b40fb72f6 lscpu\\n', 'Architecture:          x86_64\\n', 'CPU op-mode(s):        32-bit, 64-bit\\n', 'Byte Order:            Little Endian\\n', 'CPU(s):                1\\n', 'On-line CPU(s) list:   0\\n', 'Thread(s) per core:    1\\n', 'Core(s) per socket:    1\\n', 'Socket(s):             1\\n', '\\n', '# 在同一个Pod中启动新的容器并通过--cpus设置容器需要的CPU数量为4\\n', 'docker run -tid --runtime kata-runtime --network none --cpus 4 --annotation io.kubernetes.docker.type=container --annotation io.kubernetes.sandbox.id=77b40fb72f63b11dd3fcab2f6dabfc7768295fced042af8c7ad9c0286b17d24f busybox sleep 999999\\n', '7234d666851d43cbdc41da356bf62488b89cd826361bb71d585a049b6cedafd3\\n', '\\n', '# 查看当前轻量级虚机中CPU的个数\\n', 'docker exec 7234d6668 lscpu\\n', 'Architecture:          x86_64\\n', 'CPU op-mode(s):        32-bit, 64-bit\\n', 'Byte Order:            Little Endian\\n', 'CPU(s):                4\\n', 'On-line CPU(s) list:   0-3\\n', 'Thread(s) per core:    1\\n', 'Core(s) per socket:    1\\n', 'Socket(s):             4\\n', '\\n', '# 删除热插了CPU的容器后，查看轻量级虚机中CPU的个数\\n', 'docker rm -f 7234d666851d\\n', '7234d666851d\\n', '\\n', 'docker exec 77b40fb72f6  lscpu\\n', 'Architecture:          x86_64\\n', 'CPU op-mode(s):        32-bit, 64-bit\\n', 'Byte Order:            Little Endian\\n', 'CPU(s):                1\\n', 'On-line CPU(s) list:   0\\n', 'Thread(s) per core:    1\\n', 'Core(s) per socket:    1\\n', 'Socket(s):             1\\n', '  \\n', '\\n', '  \\n', '\\n', ' 说明：\\n', '由于pause容器只是一个占位容器没有工作负载，所以轻量级虚机启动时默认分配的1个CPU可以被其它容器共享，因此上面例子中启动的新容器只需要再热插3个CPU到轻量级虚机中即可。\\n', '\\n', '当停止热插了CPU的容器后，启动容器时热插进去的CPU也会被拔出。\\n', '限制内存资源\\n', '配置轻量级虚拟机MEM运行资源\\n', '\\n', '对轻量级虚拟机的MEM资源配置即虚拟机运行的内存进行配置，安全容器使用–annotation com.github.containers.virtcontainers.sandbox_mem配置轻量级虚拟机运行MEM资源，该参数仅可配置在pause容器上：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_mem=<memory-size> <pause-image> <command>\\n', '举例：\\n', '\\n', '# 启动一个pause容器，通过--annotation com.github.containers.virtcontainers.sandbox_mem=4G为轻量级虚机分配4G内存\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_mem=4G busybox sleep 999999\\n', '1532c3e59e7a45cd6b419aa1db07dd0069b0cdd93097f8944177a25e457e4297\\n', '\\n', '# 查看轻量级虚机中内存信息，查看内存大小是否与com.github.containers.virtcontainers.sandbox_mem配置的内存大小相等\\n', 'docker exec 1532c3e free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           3950          20        3874          41          55        3858\\n', 'Swap:             0           0           0\\n', ' 说明：\\n', '\\n', '如果没有通过–annotation com.github.containers.virtcontainers.sandbox_mem显示地设置轻量级虚机的内存大小，则轻量级虚机默认使用的内存大小为1GB。\\n', '安全容器一个Pod的最小内存规格是1GB，支持的最大内存规格是256GB。如果用户分配的内存规格超过256GB，可能会出现未定义的错误，安全容器暂不支持超过256GB的大内存场景。\\n', '配置容器MEM运行资源\\n', '\\n', '配置容器MEM运行资源与开源docker容器配置MEM运行资源的方式相同，可以通过docker run命令中MEM资源限制相关的参数进行配置：\\n', '\\n', '\\n', '参数\\n', '\\n', '含义\\n', '\\n', '-m/--memory\\n', '\\n', '设置容器进程可以使用的内存大小。\\n', '\\n', '说明：\\n', '当内存热插拔开关关闭时，-m的取值要小于等于轻量级虚机启动时分配的内存大小。\\n', '配置MEM热插功能\\n', '\\n', '同配置CPU热插拔功能一样，MEM的热插功能也是由kata-runtime配置文件config.toml中enable_cpu_memory_hotplug选项配置，用法参见3。\\n', '\\n', ' 说明：\\n', '内存资源当前只支持热插，不支持内存热拔。\\n', '\\n', 'kata-runtime中复用了**-m**选项实现了MEM热插的功能，通过统计Pod中所有容器的**-m**选项的和，然后确定需要热插多少内存到轻量级虚机中，例如，\\n', '\\n', '举例：\\n', '\\n', '# 启动一个pause容器，轻量级虚机默认分配了1GB内存\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox busybox sleep 999999\\n', '99b78508ada3fa7dcbac457bb0f6e3784e64e7f7131809344c5496957931119f\\n', '\\n', '# 查看启动完pause容器后轻量级虚机中的内存大小\\n', 'docker exec 99b78508ada free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:            983          18         914          36          50         908\\n', 'Swap:             0           0           0\\n', '\\n', '# 在同一个Pod中启动新的容器并通过-m设置容器需要的内存大小为4G\\n', 'docker run -tid --runtime kata-runtime --network none -m 4G --annotation io.kubernetes.docker.type=container --annotation io.kubernetes.sandbox.id=99b78508ada3fa7dcbac457bb0f6e3784e64e7f7131809344c5496957931119f busybox sleep 999999\\n', 'c49461745a712b2ef3127fdf43b2cbb034b7614e6060b13db12b7a5ff3c830c8\\n', '\\n', '# 查看当前轻量级虚机中内存的大小\\n', 'docker exec c49461745 free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           4055          69        3928          36          57        3891\\n', 'Swap:             0           0           0\\n', '\\n', '# 删除热插了CPU的容器后，查看轻量级虚机中内存的大小\\n', 'docker rm -f c49461745\\n', 'c49461745\\n', '\\n', '# 因为热插的内存暂不支持热拔功能，所以轻量级虚机中在删除热插内存容器之后还是拥有4GB的内存\\n', 'docker exec 99b78508ada free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           4055          69        3934          36          52        3894\\n', 'Swap:             0           0           0\\n', ' 说明：\\n', '由于pause容器只是一个占位容器没有工作负载，所以轻量级虚机启动时分配的内存可以被其它容器共享使用，因此上面例子中启动的新容器只需要再热插3GB的内存到轻量级虚机中即可。\\n', '\\n', '限制Blkio资源\\n', '配置轻量级虚拟机Blkio运行资源\\n', '\\n', '对轻量级虚拟机的BlkIio资源配置，安全容器使用–annotation com.github.containers.virtcontainers.blkio_cgroup配置轻量级虚拟机使用的块设备的blkio资源，该参数仅可配置在pause容器上：\\n', '\\n', 'docker run -tid --runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.blkio_cgroup=<blkio json格式字符串> <pause-image> <command>\\n', '其中–annotation com.github.containers.virtcontainers.blkio_cgroup的取值要符合下面BlkioCgroup结构体的定义：\\n', '\\n', \"// BlkioCgroup for Linux cgroup 'blkio' data exchange\\n\", 'type BlkioCgroup struct {\\n', '\\t// Items specifies per cgroup values\\n', '\\tItems []BlockIOCgroupItem `json:\"blkiocgroup,omitempty\"`\\n', '}\\n', '\\n', 'type BlockIOCgroupItem struct {\\n', '\\t// Path represent path of blkio device\\n', '\\tPath string `json:\"path,omitempty\"`\\n', '\\t// Limits specifies the blkio type and value\\n', '\\tLimits []IOLimit `json:\"limits,omitempty\"`\\n', '}\\n', '\\n', 'type IOLimit struct {\\n', '\\t// Type specifies IO type\\n', '\\tType string `json:\"type,omitempty\"`\\n', '\\t// Value specifies rate or weight value\\n', '\\tValue uint64 `json:\"value,omitempty\"`\\n', '}\\n', 'IOLimit结构体中Type字段取值列表为：\\n', '\\n', '// BlkioThrottleReadBps is the key to fetch throttle_read_bps\\n', 'BlkioThrottleReadBps = \"throttle_read_bps\"\\n', '\\n', '// BlkioThrottleWriteBps is the key to fetch throttle_write_bps\\n', 'BlkioThrottleWriteBps = \"throttle_write_bps\"\\n', '\\n', '// BlkioThrottleReadIOPS is the key to fetch throttle_read_iops\\n', 'BlkioThrottleReadIOPS = \"throttle_read_iops\"\\n', '\\n', '// BlkioThrottleWriteIOPS is the key to fetch throttle_write_iops\\n', 'BlkioThrottleWriteIOPS = \"throttle_write_iops\"\\n', '\\n', '// BlkioWeight is the key to fetch blkio_weight\\n', 'BlkioWeight = \"blkio_weight\"\\n', '\\n', '// BlkioLeafWeight is the key to fetch blkio_leaf_weight\\n', 'BlkioLeafWeight = \"blkio_leaf_weight\"\\n', '举例：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation com.github.containers.virtcontainers.blkio_cgroup=\\'{\"blkiocgroup\":[{\"path\":\"/dev/sda\",\"limits\":[{\"type\":\"throttle_read_bps\",\"value\":400},{\"type\":\"throttle_write_bps\",\"value\":400},{\"type\":\"throttle_read_iops\",\"value\":700},{\"type\":\"throttle_write_iops\",\"value\":699}]},{\"limits\":[{\"type\":\"blkio_weight\",\"value\":78}]}]}\\' busybox sleep 999999\\n', '上面命令表示对启动的安全容器所使用的/dev/sda磁盘进行blkio限流，分别将throttle_read_bps限速为400bps，throttle_write_bps限速为400bps，throttle_read_iops限速为700次/秒，throttle_write_iops限速为699次/秒，以及所在blkio cgroup组的权重值设置为78。\\n', '\\n', '限制文件描述符资源\\n', '为了避免在容器中打开大量9p共享目录中的文件导致主机上文件描述符资源耗尽，使得安全容器无法正常提供服务，安全容器支持自定义配置安全容器qemu进程最多可以打开的文件描述符数量限制。\\n', '\\n', '安全容器通过复用docker run命令中的**–files-limit**选项来设置安全容器qemu进程最多可以打开文件描述符，该参数仅可配置在pause容器上，使用方法如下所示：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --files-limit <max-open-files> <pause-image> bash\\n', ' 说明：\\n', '\\n', '如果**–files-limit**选项的取值小于安全容器默认设置的最小值1024且不为0时，安全容器qemu进程最多可以打开的文件描述符数量会被设置为最小值1024。\\n', '如果**–files-limit**选项的取值为0时，安全容器qemu进程最多可以打开的文件描述符数量为系统可以打开文件描述符的最大值/proc/sys/fs/file-max除以400后得到的默认值。\\n', '如果启动安全容器时没有显示指定**–files-limit**可以打开的文件描述符的上限，安全容器qemu进程可以打开的文件描述符数量的上限和系统默认值保持一致。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_监控安全容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%9B%91%E6%8E%A7%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8.html", "text_entry": "['监控安全容器\\n', '描述\\n', 'kata events命令用于显示指定容器状态。包括但不限于容器内存、CPU、Pid、 Blkio、大页内存、网络等信息。\\n', '\\n', '用法\\n', 'kata-runtime events [command options] <container-id>\\n', '参数\\n', '-- interval value：设置查询周期。如果不使用该参数，默认查询周期为5秒。\\n', '--stats： 显示容器信息并退出查询。\\n', '前置条件\\n', '要查询的容器状态必须为running，否则报错：Container ID (<container_id>) does not exist。\\n', '\\n', '该命令只支持查询监控一个容器的状态\\n', '\\n', '示例\\n', '每隔三秒显示容器状态。\\n', '\\n', '$ kata-runtime events --interval 3s 5779b2366f47\\n', '{\\n', '    \"data\": {\\n', '        \"blkio\": {},\\n', '        \"cpu\": {\\n', '            \"throttling\": {},\\n', '            \"usage\": {\\n', '                \"kernel\": 130000000,\\n', '                \"percpu\": [\\n', '                    214098440\\n', '                ],\\n', '                \"total\": 214098440,\\n', '                \"user\": 10000000\\n', '            }\\n', '        },\\n', '        \"hugetlb\": {},\\n', '        \"intel_rdt\": {},\\n', '        \"interfaces\": [\\n', '            {\\n', '                \"name\": \"lo\",\\n', '                \"rx_bytes\": 0,\\n', '                \"rx_dropped\": 0,\\n', '                \"rx_errors\": 0,\\n', '                \"rx_packets\": 0,\\n', '                \"tx_bytes\": 0,\\n', '                \"tx_dropped\": 0,\\n', '                \"tx_errors\": 0,\\n', '                \"tx_packets\": 0\\n', '            }\\n', '        ],\\n', '        \"memory\": {\\n', '            \"cache\": 827392,\\n', '            \"kernel\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 9223372036854771712,\\n', '                \"max\": 421888,\\n', '                \"usage\": 221184\\n', '            },\\n', '            \"kernelTCP\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 0\\n', '            },\\n', '            \"raw\": {\\n', '                \"active_anon\": 49152,\\n', '                \"active_file\": 40960,\\n', '                \"cache\": 827392,\\n', '                \"dirty\": 0,\\n', '                \"hierarchical_memory_limit\": 9223372036854771712,\\n', '                \"hierarchical_memsw_limit\": 9223372036854771712,\\n', '                \"inactive_anon\": 0,\\n', '                \"inactive_file\": 839680,\\n', '                \"mapped_file\": 540672,\\n', '                \"pgfault\": 6765,\\n', '                \"pgmajfault\": 0,\\n', '                \"pgpgin\": 12012,\\n', '                \"pgpgout\": 11803,\\n', '                \"rss\": 4096,\\n', '                \"rss_huge\": 0,\\n', '                \"shmem\": 32768,\\n', '                \"swap\": 0,\\n', '                \"total_active_anon\": 49152,\\n', '                \"total_active_file\": 40960,\\n', '                \"total_cache\": 827392,\\n', '                \"total_dirty\": 0,\\n', '                \"total_inactive_anon\": 0,\\n', '                \"total_inactive_file\": 839680,\\n', '                \"total_mapped_file\": 540672,\\n', '                \"total_pgfault\": 6765,\\n', '                \"total_pgmajfault\": 0,\\n', '                \"total_pgpgin\": 12012,\\n', '                \"total_pgpgout\": 11803,\\n', '                \"total_rss\": 4096,\\n', '                \"total_rss_huge\": 0,\\n', '                \"total_shmem\": 32768,\\n', '                \"total_swap\": 0,\\n', '                \"total_unevictable\": 0,\\n', '                \"total_writeback\": 0,\\n', '                \"unevictable\": 0,\\n', '                \"writeback\": 0\\n', '            },\\n', '            \"swap\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 9223372036854771712,\\n', '                \"max\": 34201600,\\n', '                \"usage\": 1204224\\n', '            },\\n', '            \"usage\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 9223372036854771712,\\n', '                \"max\": 34201600,\\n', '                \"usage\": 1204224\\n', '            }\\n', '        },\\n', '        \"pids\": {\\n', '            \"current\": 1\\n', '        },\\n', '        \"tcp\": {},\\n', '        \"tcp6\": {},\\n', '        \"udp\": {},\\n', '        \"udp6\": {}\\n', '    },\\n', '    \"id\": \"5779b2366f47cd1468ebb1ba7c52cbdde3c7d3a5f2af3eefadc8356700fc860b\",\\n', '    \"type\": \"stats\"\\n', '}\\n', '显示容器状态并立即返回\\n', '\\n', 'kata-runtime events --stats <container_id>\\n', '该命令返回内容的格式与上一条相同，区别为只显示一次信息后便退出。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_管理安全容器的生命周期.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%AE%A1%E7%90%86%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html", "text_entry": "['管理安全容器的生命周期\\n', '管理安全容器的生命周期\\n', '启动安全容器\\n', '停止安全容器\\n', '删除安全容器\\n', '在容器中执行一条新的命令\\n', '启动安全容器\\n', '用户可以使用docker-engine或者iSulad作为安全容器的容器引擎，两者的调用方式类似，请用户自行选择一种方式启动安全容器。\\n', '\\n', '启动安全容器的操作步骤如下：\\n', '\\n', '确保安全容器组件已经正确安装部署。\\n', '\\n', '准备容器镜像。假设容器镜像为busybox，使用docker-engine和iSula容器引擎下载容器镜像的命令分别如下：\\n', '\\n', 'docker pull busybox\\n', 'isula pull busybox\\n', '启动一个安全容器。使用docker-engine和iSula容器引擎启动安全容器的命令分别如下：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none busybox <command>\\n', 'isula run -tid --runtime kata-runtime --network none busybox <command>\\n', ' 说明：\\n', '安全容器网络使用仅支持CNI网络，不支持CNM网络，不支持使用-p和–expose暴露容器端口，使用安全容器时需指定参数–net=none。\\n', '\\n', '启动一个Pod\\n', '\\n', '启动pause容器并根据回显获取pod的sandbox-id。使用docker-engine和iSula容器引擎启动的命令分别如下：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox <pause-image> <command>\\n', 'isula run -tid --runtime kata-runtime --network none --annotation io.kubernetes.cri.container-type=sandbox <pause-image> <command>\\n', '  \\n', '\\n', '创建业务容器并加入到这个pod中。使用docker-engine和iSula容器引擎创建的命令分别如下：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=container --annotation io.kubernetes.sandbox.id=<sandbox-id> busybox <command>\\n', 'isula run -tid --runtime kata-runtime --network none --annotation io.kubernetes.cri.container-type=container --annotation io.kubernetes.cri.sandbox-id=<sandbox-id> busybox <command>\\n', '–annotation用于容器类型的标注，这里的docker-engine和isula提供该字段，上游社区的开源docker引擎则不提供。\\n', '\\n', '停止安全容器\\n', '停止一个安全容器。\\n', '\\n', 'docker stop <contaienr-id>\\n', '停止一个Pod。\\n', '\\n', 'Pod停止需要注意顺序，pause容器与Pod生命周期相同，因此先停止业务容器后再停止pause容器。\\n', '\\n', '删除安全容器\\n', '删除前请确保容器已经停止：\\n', '\\n', 'docker rm <container-id>\\n', '如果需要强制删除一个正在运行的容器，可以使用**-f**强制删除：\\n', '\\n', 'docker rm -f <container-id>\\n', '在容器中执行一条新的命令\\n', '由于pause容器仅作为占位容器，如果启动一个Pod时，请在业务容器内执行新的命令，pause容器并没有相应的指令；如果只启动一个容器时，则可以直接执行新增命令：\\n', '\\n', 'docker exec -ti <container-id> <command>\\n', ' 说明：\\n', '\\n', '如遇到docker exec -ti进入容器的同时，另一终端执行docker restart或者docker stop命令造成exec界面卡住的情况，可使用Ctrl+P+Q退出docker exec操作界面。\\n', '如果使用-d参数则命令在后台执行，不会打印错误信息，其退出码也不能作为命令执行是否正确的判断依据。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_安装与配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE-2.html", "text_entry": "['安装与配置\\n', '安装与配置\\n', '安装方法\\n', '配置方法\\n', '安装方法\\n', '前提条件\\n', '安全容器的安装需要使用root权限。\\n', '为了获取更好的性能体验，安全容器需要运行在裸金属服务器上，暂不支持安全容器运行在虚拟机内。\\n', '安全容器运行依赖以下组件，请确保环境上已安装所需版本的依赖组件。以下组件来自配套的openEuler版本。如果使用iSula容器引擎，请参考iSula容器引擎的安装方法章节安装iSulad。\\n', 'docker-engine\\n', 'qemu\\n', '安装操作\\n', '安全容器发布组件集成在同一个kata-containers-<version>.rpm包中，使用rpm命令可以直接安装对应的软件，其中version为。\\n', '\\n', 'rpm -ivh kata-containers-<version>.rpm\\n', '配置方法\\n', 'docker-engine容器引擎的配置\\n', '为了让docker-engine容器引擎支持新的容器运行时kata-runtime，需要通过以下步骤对docker-engine容器引擎进行配置：\\n', '\\n', '请保证环境上所有的软件包（docker-engine、kata-containers）都已经安装完毕。\\n', '\\n', '停止docker-engine。\\n', '\\n', 'systemctl stop docker\\n', '修改docker-engine的配置文件/etc/docker/daemon.json，并新增如下配置：\\n', '\\n', '{\\n', '  \"runtimes\": {\\n', '    \"kata-runtime\": {\\n', '      \"path\": \"/usr/bin/kata-runtime\",\\n', '      \"runtimeArgs\": [\\n', '          \"--kata-config\",\\n', '          \"/usr/share/defaults/kata-containers/configuration.toml\"\\n', '        ]\\n', '    }\\n', '  }\\n', '}\\n', '重新启动docker-engine。\\n', '\\n', 'systemctl start docker\\n', 'iSula容器引擎的配置\\n', '与docker-engine容器引擎类似，为了让iSula容器引擎支持新的容器运行时kata-runtime，需要通过以下步骤对iSula容器引擎进行配置：\\n', '\\n', '请保证环境上所有的软件包（iSulad、kata-containers）都已经安装完毕。\\n', '\\n', '停止isulad。\\n', '\\n', 'systemctl stop isulad\\n', '修改iSula容器引擎的配置文件/etc/isulad/daemon.json，并新增如下配置：\\n', '\\n', '{\\n', '  \"runtimes\": {\\n', '    \"kata-runtime\": {\\n', '      \"path\": \"/usr/bin/kata-runtime\",\\n', '      \"runtime-args\": [\\n', '          \"--kata-config\",\\n', '          \"/usr/share/defaults/kata-containers/configuration.toml\"\\n', '        ]\\n', '    }\\n', '  }\\n', '}\\n', '重新启动isulad。\\n', '\\n', 'systemctl start isulad\\n', '安全容器全局配置文件configuration-toml\\n', '安全容器提供全局配置文件configuration.toml进行配置开关，用户也可以定制安全容器配置文件路径与配置选项。\\n', '\\n', '在docker-engine的runtimeArges字段可以利用–kata-config指定私有文件，默认的配置文件路径为/usr/share/defaults/kata-containers/configuration.toml。\\n', '\\n', '常用配置文件字段如下，详细的配置文件选项参见“安全容器 > 附录 > configuration.toml配置说明”。\\n', '\\n', 'hypervisor.qemu\\n', '\\n', 'path ：指定虚拟化qemu执行路径。\\n', 'kernel ：指定guest kernel执行路径。\\n', 'initrd ：指定guest initrd执行路径。\\n', 'machin_type ：指定模拟芯片类型，其中arm为virt，x86架构为pc。\\n', 'kernel_params ：指定guest内核运行参数。\\n', 'proxy.kata\\n', '\\n', 'path ：指定kata-proxy运行路径。\\n', 'enable_debug ：kata-proxy进程debug开关。\\n', 'agent.kata\\n', '\\n', 'enable_blk_mount ：开启block设备guest挂载。\\n', 'enable_debug ：kata-agent进程debug开关。\\n', 'runtime\\n', '\\n', 'enable_cpu_memory_hotplug：CPU和内存热插拔开关。\\n', 'enable_debug：kata-runtime进程debug开关。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_容器镜像构建.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/isula-build%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html", "text_entry": "['容器镜像构建\\n', '概述\\n', '安装\\n', '环境准备\\n', '安装isula-build\\n', '配置与管理服务\\n', '配置服务\\n', '管理服务\\n', '通过 systemd 管理（推荐方式）\\n', '直接运行 isula-build 服务端\\n', '使用指南\\n', '前提条件\\n', '总体说明\\n', 'ctr-img: 容器镜像管理\\n', 'build: 容器镜像构建\\n', 'image: 查看本地持久化构建镜像\\n', 'import: 导入容器基础镜像\\n', 'load: 导入层叠镜像\\n', 'rm: 删除本地持久化镜像\\n', 'save: 导出层叠镜像\\n', 'tag: 给本地持久化镜像打标签\\n', 'pull: 拉取镜像到本地\\n', 'push: 将本地镜像推送到远程仓库\\n', 'info: 查看运行环境与系统信息\\n', 'login: 登录远端镜像仓库\\n', 'logout: 退出远端镜像仓库\\n', 'version: 版本查询\\n', 'manifest: manifest列表管理（实验特性）\\n', 'create: manifest列表创建\\n', 'annotate: manifest列表更新\\n', 'inspect: manifest列表查询\\n', 'push: 将manifest列表推送到远程仓库\\n', '直接集成容器引擎\\n', '与iSulad集成\\n', '与Docker集成\\n', '使用注意事项\\n', '约束和限制\\n', '与“docker build”差异\\n', '附录\\n', '命令行参数说明\\n', '通信矩阵\\n', '文件与权限\\n', '概述\\n', 'isula-build是iSula容器团队推出的容器镜像构建工具，支持通过Dockerfile文件快速构建容器镜像。\\n', '\\n', 'isula-build采用服务端/客户端模式，其中，isula-build为客户端，提供了一组命令行工具，用于镜像构建及管理等；isula-builder为服务端，用于处理客户端管理请求，作为守护进程常驻后台。\\n', '\\n', 'isula-build architecture\\n', '\\n', ' 说明：\\n', '\\n', 'isula-build当前支持OCI镜像格式（OCI Image Format Specification）以及Docker镜像格式（Image Manifest Version 2, Schema 2）。通过命令`export ISULABUILD_CLI_EXPERIMENTAL=enabled开启实验特性以支持OCI镜像格式。不开启实验特性时，isula-build默认采用Docker镜像格式；当开启实验特性后，将默认采用OCI镜像格式。\\n', '安装\\n', '环境准备\\n', '为了确保isula-build成功安装，需满足以下软件硬件要求。\\n', '\\n', '支持的机器架构：x86_64 和 AArch64\\n', '支持的操作系统：openEuler\\n', '用户具有root权限。\\n', '安装isula-build\\n', '使用isula-build构建容器镜像，需要先安装以下软件包。\\n', '\\n', '（推荐）方法一：使用yum安装\\n', '\\n', '配置openEuler yum源。\\n', '\\n', '使用root权限，登录目标服务器，安装isula-build。\\n', '\\n', 'sudo yum install -y isula-build\\n', '方法二：使用rpm包安装\\n', '\\n', '从openEuler yum源中获取isula-build对应安装包isula-build-*.rpm。例如isula-build-0.9.6-4.oe1.x86_64.rpm。\\n', '\\n', '将获取的rpm软件包上传至目标服务器的任一目录，例如 /home/。\\n', '\\n', '使用root权限，登录目标服务器，参考如下命令安装isula-build。\\n', '\\n', 'sudo rpm -ivh /home/isula-build-*.rpm\\n', ' 说明：\\n', '\\n', '安装完成后，需要手工启动isula-build服务。启动请参见\"管理服务\"。\\n', '配置与管理服务\\n', '配置服务\\n', '在安装完 isula-build 软件包之后，systemd 管理服务会以 isula-build 软件包自带的 isula-build 服务端默认配置启动 isula-build 服务。如果 isula-build 服务端的默认配置文件不能满足用户的需求，可以参考如下介绍进行定制化配置。需要注意的是，修改完默认配置之后，需要重启 isula-build 服务端使新配置生效，具体操作可参考下一章节。\\n', '\\n', '目前 isula-build 服务端包含如下配置文件：\\n', '\\n', '/etc/isula-build/configuration.toml：isula-builder 总体配置文件，用于设置 isula-builder 日志级别、持久化目录和运行时目录、OCI runtime等。其中各参数含义如下：\\n', '配置项\\t是否可选\\t配置项含义\\t配置项取值\\n', 'debug\\t可选\\t设置是否打开debug日志\\ttrue：打开debug日志\\n', 'false：关闭debug日志\\n', 'loglevel\\t可选\\t设置日志级别\\tdebug\\n', 'info\\n', 'warn\\n', 'error\\n', 'run_root\\t必选\\t设置运行时数据根目录\\t运行时数据根目录路径，例如/var/run/isula-build/\\n', 'data_root\\t必选\\t设置本地持久化目录\\t本地持久化目录路径，例如/var/lib/isula-build/\\n', 'runtime\\t可选\\t设置runtime种类，目前仅支持runc\\trunc\\n', 'group\\t可选\\t设置本地套接字isula_build.sock文件属组使得加入该组的非特权用户可以操作isula-build\\tisula\\n', 'experimental\\t可选\\t设置是否开启实验特性\\ttrue：开启实验特性；false：关闭实验特性\\n', '/etc/isula-build/storage.toml: 本地持久化存储的配置文件，包含所使用的存储驱动的配置。\\n', '配置项\\t是否可选\\t配置项含义\\n', 'driver\\t可选\\t存储驱动类型，目前支持overlay2\\n', '更多设置可参考 containers-storage.conf.5.md。\\n', '\\n', '/etc/isula-build/registries.toml : 针对各个镜像仓库的配置文件。\\n', '配置项\\t是否可选\\t配置项含义\\n', 'registries.search\\t可选\\t镜像仓库搜索域，在此list的镜像仓库可以被感知，不在此列的不被感知。\\n', 'registries.insecure\\t可选\\t可访问的不安全镜像仓库地址，在此列表中的镜像仓库将不会通过鉴权，不推荐使用。\\n', '更多设置可参考 containers-registries.conf.5.md。\\n', '\\n', '/etc/isula-build/policy.json：镜像pull/push策略文件。注：当前不支持对其进行配置\\n', ' 说明：\\n', '\\n', 'isula-build 支持最大 1MiB 的上述配置文件。\\n', 'isula-build 不支持将持久化工作目录 dataroot 配置在内存盘上，比如 tmpfs。\\n', 'isula-build 目前仅支持使用overlay2为底层 graphdriver。\\n', '在设置–group参数前，需保证本地OS已经创建了对应的用户组，且非特权用户已经加入该组。重启isula-builder之后即可使该非特权用户使用isula-build功能。同时，为了保持权限一致性，isula-build的配置文件目录/etc/isula-build的属组也会被设置为–group指定的组。\\n', '管理服务\\n', '目前 openEuler 采用 systemd 管理软件服务，isula-build 软件包已经自带了 systemd 的服务文件，用户安装完 isula-build 软件包之后可以直接通过 systemd 工具对它进行服务启停等操作。用户同样可以手动启动 isula-build 服务端软件。需要注意的是，同一个节点上不可以同时启动多个 isula-build 服务端软件。\\n', '\\n', ' 说明：\\n', '\\n', '同一个节点上不可以同时启动多个 isula-build 服务端软件。\\n', '通过 systemd 管理（推荐方式）\\n', '用户可以通过如下 systemd 的标准指令控制 isula-build 服务的启动、停止、重启等动作：\\n', '\\n', '启动 isula-build 服务：\\n', '\\n', 'sudo systemctl start isula-build.service\\n', '停止 isula-build 服务：\\n', '\\n', 'sudo systemctl stop isula-build.service\\n', '重启 isula-builder 服务：\\n', '\\n', 'sudo systemctl restart isula-build.service\\n', 'isula-build 软件包安装的 systemd 服务文件保存在 /usr/lib/systemd/system/isula-build.service。如果用户需要修改 isula-build 服务的 systemd 配置，可以修改该文件，执行如下命令使配置生效，之后再根据上面提到的 systemd 管理指令重启 isula-build 服务\\n', '\\n', 'sudo systemctl daemon-reload\\n', '直接运行 isula-build 服务端\\n', '您也可以通过执行 isula-build 服务端命令（ isula-builder）的方式启动服务。其中，服务端启动配置，可通过isula-builder命令支持的 flags 设置。isula-build 服务端目前支持的 flags 如下：\\n', '\\n', '-D, –debug: 是否开启调测模式。\\n', '–log-level: 日志级别，支持 “debug”, “info”, “warn” or “error”，默认为 “info”。\\n', '–dataroot: 本地持久化路径，默认为”/var/lib/isula-build/“。\\n', '–runroot: 运行时路径，默认为”/var/run/isula-build/“。\\n', '–storage-driver：底层存储驱动类型。\\n', '–storage-opt: 底层存储驱动配置。\\n', '–group: 设置本地套接字isula_build.sock文件属组使得加入该组的非特权用户可以操作isula-build，默认为“isula”。\\n', '–experimental: 是否开启实验特性，默认为false。\\n', ' 说明：\\n', '\\n', '当命令行启动参数中传递了与配置文件相同的配置选项时，优先使用命令行参数启动。\\n', '启动 isula-build 服务。例如指定本地持久化路径/var/lib/isula-build，且不开启调试的参考命令如下：\\n', '\\n', 'sudo isula-builder --dataroot \"/var/lib/isula-build\" --debug=false\\n', '使用指南\\n', '前提条件\\n', 'isula-build 构建 Dockerfile 内的 RUN 指令时依赖可执行文件 runc ，需要 isula-build 的运行环境上预装好 runc。安装方式视用户使用场景而定，如果用户不需要使用完整的 docker-engine 工具链，则可以仅安装 docker-runc rpm包：\\n', '\\n', 'sudo yum install -y docker-runc\\n', '如果用户需要使用完整的 docker-engine 工具链，则可以安装 docker-engine rpm包，默认包含可执行文件 runc ：\\n', '\\n', 'sudo yum install -y docker-engine\\n', ' 说明：\\n', '\\n', '用户需保证OCI runtime（runc）可执行文件的安全性，避免被恶意替换。\\n', '总体说明\\n', 'isula-build 客户端提供了一系列命令用于构建和管理容器镜像，当前 isula-build 包含的命令行指令如下：\\n', '\\n', 'ctr-img，容器镜像管理。ctr-img又包含如下子命令：\\n', 'build，根据给定dockerfile构建出容器镜像。\\n', 'images，列出本地容器镜像。\\n', 'import，导入容器基础镜像。\\n', 'load，导入层叠镜像。\\n', 'rm，删除本地容器镜像。\\n', 'save，导出层叠镜像至本地磁盘。\\n', 'tag，给本地容器镜像打tag。\\n', 'pull，拉取镜像到本地。\\n', 'push，推送本地镜像到远程仓库。\\n', 'info，查看isula-build的运行环境和系统信息。\\n', 'login，登录远端容器镜像仓库。\\n', 'logout，退出远端容器镜像仓库。\\n', 'version，查看isula-build和isula-builder的版本号。\\n', 'manifest（实验特性），管理manifest列表。\\n', ' 说明：\\n', '\\n', 'isula-build completion 和 isula-builder completion 命令用于生成bash命令补全脚本。该命令为命令行框架隐式提供，不会显示在help信息中。\\n', 'isula-build客户端不包含配置文件，当用户需要使用isula-build实验特性时，需要在客户端通过命令export ISULABUILD_CLI_EXPERIMENTAL=enabled配置环境变量ISULABUILD_CLI_EXPERIMENTAL来开启实验特性。\\n', '以下按照上述维度依次详细介绍这些命令行指令的使用。\\n', '\\n', 'ctr-img: 容器镜像管理\\n', 'isula-build 将所有容器镜像管理相关命令划分在子命令 ctr-img 下，命令原型为：\\n', '\\n', 'isula-build ctr-img [command]\\n', 'build: 容器镜像构建\\n', 'ctr-img 的子命令 build 用于构建容器镜像，命令原型为：\\n', '\\n', 'isula-build ctr-img build [flags]\\n', '其中 build 包含如下 flags：\\n', '\\n', '–build-arg：string列表，构建过程中需要用到的变量。\\n', '–build-static：KeyValue值，构建二进制一致性。目前包含如下Key值：\\n', 'build-time：string，使用固定时间戳来构建容器镜像；时间戳格式为“YYYY-MM-DD HH-MM-SS”。\\n', '-f, –filename：string，Dockerfile的路径，不指定则是使用当前路径的Dockerfile文件。\\n', '–format： string, 设置构建镜像的镜像格式：oci | docker（需开启实验特性选项）。\\n', '–iidfile：string，输出 image ID 到本地文件。\\n', '-o, –output：string，镜像导出的方式和路径。\\n', '–proxy：布尔值，继承主机侧环境的proxy环境变量（默认为true）。\\n', '–tag：string，设置构建成功的镜像的tag值。\\n', '–cap-add：string列表，构建过程中RUN指令所需要的权限。\\n', '以下为各个 flags 的详解。\\n', '\\n', '--build-arg\\n', '\\n', '从命令行接受参数作为Dockerfile中的参数，用法：\\n', '\\n', '$ echo \"This is bar file\" > bar.txt\\n', '$ cat Dockerfile_arg\\n', 'FROM busybox\\n', 'ARG foo\\n', 'ADD ${foo}.txt .\\n', 'RUN cat ${foo}.txt\\n', '$ sudo isula-build ctr-img build --build-arg foo=bar -f Dockerfile_arg\\n', 'STEP  1: FROM busybox\\n', 'Getting image source signatures\\n', 'Copying blob sha256:8f52abd3da461b2c0c11fda7a1b53413f1a92320eb96525ddf92c0b5cde781ad\\n', 'Copying config sha256:e4db68de4ff27c2adfea0c54bbb73a61a42f5b667c326de4d7d5b19ab71c6a3b\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'STEP  2: ARG foo\\n', 'STEP  3: ADD ${foo}.txt .\\n', 'STEP  4: RUN cat ${foo}.txt\\n', 'This is bar file\\n', 'Getting image source signatures\\n', 'Copying blob sha256:6194458b07fcf01f1483d96cd6c34302ffff7f382bb151a6d023c4e80ba3050a\\n', 'Copying blob sha256:6bb56e4a46f563b20542171b998cb4556af4745efc9516820eabee7a08b7b869\\n', 'Copying config sha256:39b62a3342eed40b41a1bcd9cd455d77466550dfa0f0109af7a708c3e895f9a2\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Build success with image id: 39b62a3342eed40b41a1bcd9cd455d77466550dfa0f0109af7a708c3e895f9a2\\n', '--build-static\\n', '\\n', '指定为静态构建，即使用isula-build构建容器镜像时消除所有时间戳和其他构建因素（例如容器ID、hostname等）的差异。最终构建出满足静态要求的容器镜像。\\n', '\\n', '在使用isula-build进行容器镜像构建时，假如给 build 子命令一个固定的时间戳，并在限定如下条件的时候：\\n', '\\n', '构建环境前后保持一致。\\n', '构建Dockerfile前后保持一致。\\n', '构建产生的中间数据前后保持一致。\\n', '构建命令相同。\\n', '第三方库版本一致。\\n', '对于容器镜像构建，isula-build支持相同的Dockerfile。如果构建环境相同，则多次构建生成的镜像内容和镜像ID相同。\\n', '\\n', '–build-static接受k=v形式的键值对选项，当前支持的选项有：\\n', '\\n', 'build-time：字符串类型。构建静态镜像的固定时间戳，格式为“YYYY-MM-DD HH-MM-SS”。时间戳影响diff层创建修改时间的文件属性。\\n', '\\n', '使用示例如下：\\n', '\\n', \"$ sudo isula-build ctr-img build -f Dockerfile --build-static='build-time=2020-05-23 10:55:33' .\\n\", '以此方式，同一环境多次构建出来的容器镜像和镜像ID均会保持一致。\\n', '\\n', '--format 开始实验特性后该选项可用，默认为OCI镜像格式。可以手动指定镜像格式进行构建，例如，下面分别为构建OCI镜像格式以及Docker镜像格式镜像的命令。\\n', '\\n', '$ export ISULABUILD_CLI_EXPERIMENTAL=enabled; sudo isula-build ctr-img build -f Dockerfile --format oci .\\n', '$ export ISULABUILD_CLI_EXPERIMENTAL=enabled; sudo isula-build ctr-img build -f Dockerfile --format docker .\\n', '--iidfile\\n', '\\n', '将构建的镜像ID输出到文件，用法：\\n', '\\n', 'isula-build ctr-img build --iidfile filename\\n', '例如，将容器镜像ID输出到testfile的参考命令如下：\\n', '\\n', '$ sudo isula-build ctr-img build -f Dockerfile_arg --iidfile testfile\\n', '查看testfile中的容器镜像ID：\\n', '\\n', '$ cat testfile\\n', '76cbeed38a8e716e22b68988a76410eaf83327963c3b29ff648296d5cd15ce7b\\n', '-o, –output\\n', '\\n', '目前 -o, –output 支持如下形式：\\n', '\\n', 'isulad:image:tag：将构建成功的镜像直接推送到 iSulad。比如：-o isulad:busybox:latest。同时需要注意如下约束：\\n', '\\n', 'isula-build 和 iSulad 必须在同一个节点上\\n', 'tag必须配置\\n', 'isula-build client端需要将构建成功的镜像暂存成 /var/tmp/isula-build-tmp-%v.tar 再导入至 iSulad，用户需要保证 /var/tmp/ 目录有足够磁盘空间\\n', 'docker-daemon:image:tag：将构建成功的镜像直接推送到 Docker daemon。比如：-o docker-daemon:busybox:latest。同时需要注意如下约束：\\n', '\\n', 'isula-build 和 docker 必须在同一个节点上\\n', 'tag必须配置\\n', 'docker://registry.example.com/repository:tag：将构建成功的镜像以Docker镜像格式直接推送到远端镜像仓库。比如：-o docker://localhost:5000/library/busybox:latest。\\n', '\\n', 'docker-archive:<path>/<filename>:image:tag：将构建成功的镜像以Docker镜像格式保存至本地。比如：-o docker-archive:/root/image.tar:busybox:latest。\\n', '\\n', '打开实验特性之后，可以启用相应OCI镜像的构建：\\n', '\\n', 'oci://registry.example.com/repository:tag：将构建成功的镜像以OCI镜像格式直接推送到远端镜像仓库（远程镜像仓库须支持OCI镜像格式）。比如：-o oci://localhost:5000/library/busybox:latest。\\n', '\\n', 'oci-archive:<path>/<filename>:image:tag：将构建成功的镜像以OCI镜像的格式保存至本地。比如：-o oci-archive:/root/image.tar:busybox:latest。\\n', '\\n', '除去各个flags之外，build子命令的命令行最后还会接收一个argument，该argument类型是string，意义为context，即该Dockerfile构建环境的上下文。该参数默认值为isula-build被执行的当前路径。该路径会影响 .dockerignore 和 Dockerfile的ADD/COPY指令 所检索的路径。\\n', '\\n', '--proxy\\n', '\\n', '选择构建时RUN指令启动的容器是否从环境上继承proxy相关环境变量”http_proxy”,“https_proxy”,“ftp_proxy”,“no_proxy”,“HTTP_PROXY”,“HTTPS_PROXY”,“FTP_PROXY”,“NO_PROXY”，默认为true。\\n', '\\n', '当用户在Dockerfile配置proxy相关ARG或ENV，将覆盖所继承的环境变量。\\n', '\\n', '注意：若client与daemon不在同一个终端运行，所能继承的环境变量为daemon所在终端的环境变量。\\n', '\\n', '--tag\\n', '\\n', '设置镜像构建成功之后，该镜像在本地磁盘存储时的tag。\\n', '\\n', '--cap-add\\n', '\\n', '添加构建过程中RUN指令所需权限，用法：\\n', '\\n', 'isula-build ctr-img build --cap-add ${CAP}\\n', '使用举例：\\n', '\\n', '$ sudo isula-build ctr-img build --cap-add CAP_SYS_ADMIN --cap-add CAP_SYS_PTRACE -f Dockerfile\\n', ' 说明：\\n', '\\n', 'isula-build最大支持并发构建100个容器镜像。\\n', 'isula-build支持Dockerfile最大为1MiB。\\n', 'isula-build支持 .dockerignore 最大为 1MiB。\\n', '用户需保证Dockerfile文件的权限为仅当前用户可读写，避免别的用户进行篡改。\\n', '构建时，RUN指令会启动容器在容器内进行构建，目前 isula-build 仅支持使用主机网络。\\n', 'isula-build 导出的镜像压缩格式，目前仅支持tar格式。\\n', 'isula-build 在每一个镜像构建stage完成后做一次提交，而不是每执行 Dockerfile的一行就提交一次。\\n', 'isula-build 暂不支持构建缓存。\\n', 'isula-build 仅在构建RUN指令时会启动构建容器。\\n', '目前不支持docker镜像格式的history功能。\\n', 'isula-build 的stage name支持以数字开头。\\n', 'isula-build 的stage name最长可为64个字符。\\n', 'isula-build 暂不支持对单次Dockerfile的构建进行资源限制。如有资源限制需求，可通过对 isula-builder 服务端配置资源限额的方式进行限制。\\n', 'isula-build 目前不支持Dockerfile里的ADD指令提供的数据来源是远端url。\\n', 'isula-build 使用docker-archive以及oci-archive类型导出的本地tar包未经压缩。如有需求，用户可以手动进行压缩。\\n', 'image: 查看本地持久化构建镜像\\n', '可通过images命令查看当前本地持久化存储的镜像：\\n', '\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                   SIZE\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'localhost:5000/library/alpine            latest       a24bb4013296       2022-01-17 10:02:19       5.85 MB\\n', '<none>                                   <none>       39b62a3342ee       2022-01-17 10:01:12       1.45 MB\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', ' 说明：\\n', '\\n', '通过isula-build ctr-img images查看的镜像大小与docker images的显示上有一定差异。这是因为统计镜像大小时，isula-build是直接计算每层tar包大小之和，而docker是通过解压tar遍历diff目录计算文件大小之和，因此存在统计上的差异。\\n', 'import: 导入容器基础镜像\\n', '可以通过ctr-img import指令将rootfs形式的tar文件导入到isula-build中。\\n', '\\n', '命令原型如下：\\n', '\\n', 'isula-build ctr-img import [flags]\\n', '使用举例：\\n', '\\n', '$ sudo isula-build ctr-img import busybox.tar mybusybox:latest\\n', 'Getting image source signatures\\n', 'Copying blob sha256:7b8667757578df68ec57bfc9fb7754801ec87df7de389a24a26a7bf2ebc04d8d\\n', 'Copying config sha256:173b3cf612f8e1dc34e78772fcf190559533a3b04743287a32d549e3c7d1c1d1\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Import success with image id: \"173b3cf612f8e1dc34e78772fcf190559533a3b04743287a32d549e3c7d1c1d1\"\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                   SIZE\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'mybusybox                                latest       173b3cf612f8       2022-01-12 16:02:31       1.47 MB\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', ' 说明：\\n', '\\n', 'isula-build 支持导入最大1GiB的容器基础镜像。\\n', 'load: 导入层叠镜像\\n', '层叠镜像指的是通过 docker save 或 isula-build ctr-img save 等指令，将一个构建完成的镜像保存至本地之后，镜像压缩包内是一层一层 layer.tar 的镜像包。可以通过 ctr-img load 指令将它导入至 isula-build。\\n', '\\n', '命令原型如下：\\n', '\\n', 'isula-build ctr-img load [flags]\\n', '目前支持的 flags 为：\\n', '\\n', '-i, –input：本地tar包的路径\\n', '使用举例如下：\\n', '\\n', '$ sudo isula-build ctr-img load -i ubuntu.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:cf612f747e0fbcc1674f88712b7bc1cd8b91cf0be8f9e9771235169f139d507c\\n', 'Copying blob sha256:f934e33a54a60630267df295a5c232ceb15b2938ebb0476364192b1537449093\\n', 'Copying blob sha256:943edb549a8300092a714190dfe633341c0ffb483784c4fdfe884b9019f6a0b4\\n', 'Copying blob sha256:e7ebc6e16708285bee3917ae12bf8d172ee0d7684a7830751ab9a1c070e7a125\\n', 'Copying blob sha256:bf6751561805be7d07d66f6acb2a33e99cf0cc0a20f5fd5d94a3c7f8ae55c2a1\\n', 'Copying blob sha256:c1bd37d01c89de343d68867518b1155cb297d8e03942066ecb44ae8f46b608a3\\n', 'Copying blob sha256:a84e57b779297b72428fc7308e63d13b4df99140f78565be92fc9dbe03fc6e69\\n', 'Copying blob sha256:14dd68f4c7e23d6a2363c2320747ab88986dfd43ba0489d139eeac3ac75323b2\\n', 'Copying blob sha256:a2092d776649ea2301f60265f378a02405539a2a68093b2612792cc65d00d161\\n', 'Copying blob sha256:879119e879f682c04d0784c9ae7bc6f421e206b95d20b32ce1cb8a49bfdef202\\n', 'Copying blob sha256:e615448af51b848ecec00caeaffd1e30e8bf5cffd464747d159f80e346b7a150\\n', 'Copying blob sha256:f610bd1e9ac6aa9326d61713d552eeefef47d2bd49fc16140aa9bf3db38c30a4\\n', 'Copying blob sha256:bfe0a1336d031bf5ff3ce381e354be7b2bf310574cc0cd1949ad94dda020cd27\\n', 'Copying blob sha256:f0f15db85788c1260c6aa8ad225823f45c89700781c4c793361ac5fa58d204c7\\n', 'Copying config sha256:c07ddb44daa97e9e8d2d68316b296cc9343ab5f3d2babc5e6e03b80cd580478e\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Loaded image as c07ddb44daa97e9e8d2d68316b296cc9343ab5f3d2babc5e6e03b80cd580478e\\n', ' 说明：\\n', '\\n', 'isula-build 支持导入最大50G的容器层叠镜像。\\n', 'isula-build 会自动识别容器层叠镜像的格式并进行导入。\\n', 'rm: 删除本地持久化镜像\\n', '可通过rm命令删除当前本地持久化存储的镜像。命令原型为：\\n', '\\n', 'isula-build ctr-img rm IMAGE [IMAGE...] [FLAGS]\\n', '目前支持的 flags 为：\\n', '\\n', '-a, –all：删除所有本地持久化存储的镜像。\\n', '-p, –prune：删除所有没有tag的本地持久化存储的镜像。\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build ctr-img rm -p\\n', 'Deleted: sha256:78731c1dde25361f539555edaf8f0b24132085b7cab6ecb90de63d72fa00c01d\\n', 'Deleted: sha256:eeba1bfe9fca569a894d525ed291bdaef389d28a88c288914c1a9db7261ad12c\\n', 'save: 导出层叠镜像\\n', '可通过save命令导出层叠镜像到本地磁盘。命令原型如下：\\n', '\\n', 'isula-build ctr-img save [REPOSITORY:TAG]|imageID -o xx.tar\\n', '目前支持的 flags 为：\\n', '\\n', '-f, –format：导出层叠镜像的镜像格式：oci | docker（需开启实验特性选项）\\n', '-o, –output：本地tar包路径\\n', '以下示例通过 image/tag 的形式将镜像进行导出：\\n', '\\n', '$ sudo isula-build ctr-img save busybox:latest -o busybox.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:50644c29ef5a27c9a40c393a73ece2479de78325cae7d762ef3cdc19bf42dd0a\\n', 'Copying blob sha256:824082a6864774d5527bda0d3c7ebd5ddc349daadf2aa8f5f305b7a2e439806f\\n', 'Copying blob sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\\n', 'Copying config sha256:21c3e96ac411242a0e876af269c0cbe9d071626bdfb7cc79bfa2ddb9f7a82db6\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Save success with image: busybox:latest\\n', '以下示例通过 ImageID 的形式将镜像进行导出：\\n', '\\n', '$ sudo isula-build ctr-img save 21c3e96ac411 -o busybox.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:50644c29ef5a27c9a40c393a73ece2479de78325cae7d762ef3cdc19bf42dd0a\\n', 'Copying blob sha256:824082a6864774d5527bda0d3c7ebd5ddc349daadf2aa8f5f305b7a2e439806f\\n', 'Copying blob sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\\n', 'Copying config sha256:21c3e96ac411242a0e876af269c0cbe9d071626bdfb7cc79bfa2ddb9f7a82db6\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Save success with image: 21c3e96ac411\\n', '以下示例导出多个镜像到同一个tar包：\\n', '\\n', '$ sudo isula-build ctr-img save busybox:latest nginx:latest -o all.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:eb78099fbf7fdc70c65f286f4edc6659fcda510b3d1cfe1caa6452cc671427bf\\n', 'Copying blob sha256:29f11c413898c5aad8ed89ad5446e89e439e8cfa217cbb404ef2dbd6e1e8d6a5\\n', 'Copying blob sha256:af5bd3938f60ece203cd76358d8bde91968e56491daf3030f6415f103de26820\\n', 'Copying config sha256:b8efb18f159bd948486f18bd8940b56fd2298b438229f5bd2bcf4cedcf037448\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Getting image source signatures\\n', 'Copying blob sha256:e2d6930974a28887b15367769d9666116027c411b7e6c4025f7c850df1e45038\\n', 'Copying config sha256:a33de3c85292c9e65681c2e19b8298d12087749b71a504a23c576090891eedd6\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Save success with image: [busybox:latest nginx:latest]\\n', ' 说明：\\n', '\\n', 'save 导出的镜像默认格式为未压缩的tar格式，如有需求，用户可以再save之后手动压缩。\\n', '在使用镜像名导出镜像时，需要给出完整的镜像名格式：REPOSITORY:TAG。\\n', 'tag: 给本地持久化镜像打标签\\n', '可使用tag命令给本地持久化的容器镜像打tag。命令原型如下：\\n', '\\n', 'isula-build ctr-img tag <imageID>/<imageName> busybox:latest\\n', '使用举例：\\n', '\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  --------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                     SIZE\\n', '---------------------------------------  -----------  -----------------  --------------------------  ------------\\n', 'alpine                                   latest       a24bb4013296       2020-05-29 21:19:46         5.85 MB\\n', '---------------------------------------  -----------  -----------------  --------------------------  ------------\\n', '$ sudo isula-build ctr-img tag a24bb4013296 alpine:v1\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                   SIZE\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'alpine                                   latest       a24bb4013296       2020-05-29 21:19:46       5.85 MB\\n', 'alpine                                   v1           a24bb4013296       2020-05-29 21:19:46       5.85 MB\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'pull: 拉取镜像到本地\\n', '可通过pull命令拉取远程镜像仓库中的镜像到本地。命令原型如下：\\n', '\\n', 'isula-build ctr-img pull REPOSITORY[:TAG]\\n', '使用示例：\\n', '\\n', '$ sudo isula-build ctr-img pull example-registry/library/alpine:latest\\n', 'Getting image source signatures\\n', 'Copying blob sha256:8f52abd3da461b2c0c11fda7a1b53413f1a92320eb96525ddf92c0b5cde781ad\\n', 'Copying config sha256:e4db68de4ff27c2adfea0c54bbb73a61a42f5b667c326de4d7d5b19ab71c6a3b\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Pull success with image: example-registry/library/alpine:latest\\n', 'push: 将本地镜像推送到远程仓库\\n', '可通过push命令将本地镜像推送到远程仓库。命令原型如下：\\n', '\\n', 'isula-build ctr-img push REPOSITORY[:TAG]\\n', '目前支持的 flags 为：\\n', '\\n', '-f, –format：推送的镜像格式：oci｜docker（需开启实验特性选项）\\n', '使用示例：\\n', '\\n', '$ sudo isula-build ctr-img push example-registry/library/mybusybox:latest\\n', 'Getting image source signatures\\n', 'Copying blob sha256:d2421964bad195c959ba147ad21626ccddc73a4f2638664ad1c07bd9df48a675\\n', 'Copying config sha256:f0b02e9d092d905d0d87a8455a1ae3e9bb47b4aa3dc125125ca5cd10d6441c9f\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Push success with image: example-registry/library/mybusybox:latest\\n', ' 说明：\\n', '\\n', '推送镜像时，需要先登录对应的镜像仓库。\\n', 'info: 查看运行环境与系统信息\\n', '可以通过“isula-build info”指令查看 isula-build 目前的运行环境与系统信息。命令原型如下：\\n', '\\n', ' isula-build info [flags]\\n', '支持如下Flags：\\n', '\\n', '-H, –human-readable 布尔值，以常用内存表示格式打印内存信息，使用1000次幂\\n', '-V, –verbose 布尔值，显示运行时内存占用信息\\n', '使用示例：\\n', '\\n', '$ sudo isula-build info -HV\\n', '   General:\\n', '     MemTotal:     7.63 GB\\n', '     MemFree:      757 MB\\n', '     SwapTotal:    8.3 GB\\n', '     SwapFree:     8.25 GB\\n', '     OCI Runtime:  runc\\n', '     DataRoot:     /var/lib/isula-build/\\n', '     RunRoot:      /var/run/isula-build/\\n', '     Builders:     0\\n', '     Goroutines:   12\\n', '   Store:\\n', '     Storage Driver:     overlay\\n', '     Backing Filesystem: extfs\\n', '   Registry:\\n', '     Search Registries:\\n', '       oepkgs.net\\n', '     Insecure Registries:\\n', '       localhost:5000\\n', '       oepkgs.net\\n', '   Runtime:\\n', '\\t MemSys:           68.4 MB\\n', '     HeapSys:          63.3 MB\\n', '     HeapAlloc:        7.41 MB\\n', '     MemHeapInUse:     8.98 MB\\n', '     MemHeapIdle:      54.4 MB\\n', '     MemHeapReleased:  52.1 MB\\n', 'login: 登录远端镜像仓库\\n', '用户可以运行 login 命令来登录远程镜像仓库。命令原型如下：\\n', '\\n', ' isula-build login SERVER [FLAGS]\\n', '目前支持的flag有：\\n', '\\n', ' Flags:\\n', '   -p, --password-stdin    Read password from stdin\\n', '   -u, --username string   Username to access registry\\n', '通过stdin输入密码。以下示例通过通过管道将creds.txt里的密码传给isula-build的stdin进行输入：\\n', '\\n', ' $ cat creds.txt | sudo isula-build login -u cooper -p mydockerhub.io\\n', ' Login Succeeded\\n', '通过交互式输入密码：\\n', '\\n', ' $ sudo isula-build login mydockerhub.io -u cooper\\n', ' Password:\\n', ' Login Succeeded\\n', 'logout: 退出远端镜像仓库\\n', '用户可以运行 logout 命令来登出远程镜像仓库。命令原型如下：\\n', '\\n', ' isula-build logout [SERVER] [FLAGS]\\n', '目前支持的flag有：\\n', '\\n', ' Flags:\\n', '   -a, --all   Logout all registries\\n', '使用示例如下：\\n', '\\n', ' $ sudo isula-build logout -a\\n', '   Removed authentications\\n', 'version: 版本查询\\n', '可通过version命令查看当前版本信息：\\n', '\\n', '$ sudo isula-build version\\n', 'Client:\\n', '  Version:       0.9.6-4\\n', '  Go Version:    go1.15.7\\n', '  Git Commit:    83274e0\\n', '  Built:         Wed Jan 12 15:32:55 2022\\n', '  OS/Arch:       linux/amd64\\n', '\\n', 'Server:\\n', '  Version:       0.9.6-4\\n', '  Go Version:    go1.15.7\\n', '  Git Commit:    83274e0\\n', '  Built:         Wed Jan 12 15:32:55 2022\\n', '  OS/Arch:       linux/amd64\\n', 'manifest: manifest列表管理\\n', 'manifest列表包含不同系统架构对应的镜像信息，通过使用manifest列表，用户可以在不同的架构中使用相同的manifest（例如openeuler:latest）获取对应架构的镜像，manifest包含create、annotate、inspect和push子命令。\\n', '\\n', ' 说明：\\n', '\\n', 'manifest为实验特性，使用时需开启客户端和服务端的实验选项，方式详见客户端总体说明和配置服务章节。\\n', 'create: manifest列表创建\\n', 'manifest的子命令create用于创建manifest列表，命令原型为：\\n', '\\n', 'isula-build manifest create MANIFEST_LIST MANIFEST [MANIFEST...]\\n', '用户可以指定manifest列表的名称以及需要加入到列表中的远程镜像，若不指定任何远程镜像，则会创建一个空的manifest列表。\\n', '\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest create openeuler localhost:5000/openeuler_x86:latest localhost:5000/openeuler_aarch64:latest\\n', 'annotate: manifest列表更新\\n', 'manifest的子命令annotate用于更新manifest列表，命令原型为：\\n', '\\n', 'isula-build manifest annotate MANIFEST_LIST MANIFEST [flags]\\n', '用户可以指定需要更新的manifest列表以及其中的镜像，通过flags指定需要更新的选项，此命令也可用于添加新的镜像到列表中。\\n', '\\n', '其中annotate包含如下flags：\\n', '\\n', '–arch： string，重写镜像适用架构\\n', '–os： string，重写镜像适用系统\\n', '–os-features： string列表，指定镜像需要的OS特性，很少使用\\n', '–variant： string，指定列表中记录镜像的变量\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest annotate --os linux --arch arm64 openeuler:latest localhost:5000/openeuler_aarch64:latest\\n', 'inspect: manifest列表查询\\n', 'manifest子命令inspect用于查询manifest列表信息，命令原型为：\\n', '\\n', 'isula-build manifest inspect MANIFEST_LIST\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest inspect openeuler:latest\\n', '{\\n', '    \"schemaVersion\": 2,\\n', '    \"mediaType\": \"application/vnd.docker.distribution.manifest.list.v2+json\",\\n', '    \"manifests\": [\\n', '        {\\n', '            \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\\n', '            \"size\": 527,\\n', '            \"digest\": \"sha256:bf510723d2cd2d4e3f5ce7e93bf1e52c8fd76831995ac3bd3f90ecc866643aff\",\\n', '            \"platform\": {\\n', '                \"architecture\": \"amd64\",\\n', '                \"os\": \"linux\"\\n', '            }\\n', '        },\\n', '        {\\n', '            \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\\n', '            \"size\": 527,\\n', '            \"digest\": \"sha256:f814888b4bb6149bd39ba8375a1932fb15071b4dbffc7f76c7b602b06abbb820\",\\n', '            \"platform\": {\\n', '                \"architecture\": \"arm64\",\\n', '                \"os\": \"linux\"\\n', '            }\\n', '        }\\n', '    ]\\n', '}\\n', 'push: 将manifest列表推送到远程仓库\\n', 'manifest子命令push用于将manifest列表推送到远程仓库，命令原型为：\\n', '\\n', 'isula-build manifest push MANIFEST_LIST DESTINATION\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest push openeuler:latest localhost:5000/openeuler:latest\\n', '直接集成容器引擎\\n', 'isula-build可以与iSulad和docker集成，将构建好的容器镜像导入到容器引擎的本地存储中。\\n', '\\n', '与iSulad集成\\n', '支持将构建成功的镜像直接导出到iSulad。\\n', '\\n', '命令行举例：\\n', '\\n', '$ sudo isula-build ctr-img build -f Dockerfile -o isulad:busybox:2.0\\n', '通过在-o参数中指定iSulad，将构建好的容器镜像导出到iSulad，可以通过isula images查询：\\n', '\\n', '$ sudo isula images\\n', 'isula images\\n', 'REPOSITORY                     TAG        IMAGE ID             CREATED              SIZE\\n', 'busybox                        2.0        2d414a5cad6d         2020-08-01 06:41:36  5.577 MB\\n', ' 说明：\\n', '\\n', '要求isula-build和iSulad在同一节点。\\n', '直接导出镜像到iSulad时，isula-build client端需要将构建成功的镜像暂存成 /var/lib/isula-build/tmp/[buildid]/isula-build-tmp-%v.tar 再导入至 iSulad，用户需要保证 /var/lib/isula-build/tmp/ 目录有足够磁盘空间；同时如果在导出过程中 isula-build client进程被KILL或Ctrl+C终止，需要依赖用户手动清理 /var/lib/isula-build/tmp/[buildid]/isula-build-tmp-%v.tar 文件。\\n', '与Docker集成\\n', '支持将构建成功的镜像直接导出到Docker daemon。\\n', '\\n', '命令行举例：\\n', '\\n', '$ sudo isula-build ctr-img build -f Dockerfile -o docker-daemon:busybox:2.0\\n', '通过在-o参数中指定docker-daemon，将构建好的容器镜像导出到docker, 可以通过docker images查询。\\n', '\\n', '$ sudo docker images\\n', 'REPOSITORY                                          TAG                 IMAGE ID            CREATED             SIZE\\n', 'busybox                                             2.0                 2d414a5cad6d        2 months ago        5.22MB\\n', ' 说明：\\n', '\\n', '要求isula-build和Docker在同一节点。\\n', '使用注意事项\\n', '本章节主要介绍在使用isula-build构建镜像时相关的约束和限制，以及与docker build的差异。\\n', '\\n', '约束和限制\\n', '当导出镜像到iSulad时，镜像必须指明tag。\\n', '因为isula-builder运行RUN指令时，需要调用系统中的oci 运行时（如runc），用户需要保证该运行时的安全性，不受篡改。\\n', 'DataRoot不能设置在内存盘上（tmpfs）。\\n', 'Overlay2是目前isula-builder唯一支持的存储驱动。\\n', 'Docker镜像是目前唯一支持的镜像格式，未来即将支持oci格式镜像。\\n', 'Dockerfile文件权限强烈建议设置为0600以防止恶意篡改。\\n', 'RUN命令中目前只支持主机侧网络（host network）。\\n', '当导出镜像到本地tar包时，目前只支持保存为tar格式。\\n', '当使用import功能导入基础镜像时，最大支持1G。\\n', '与“docker build”差异\\n', 'isula-build兼容Docker镜像格式规范，但仍然和docker build存在一些差异：\\n', '\\n', '支持镜像压缩，即对每个stage进行提交而非每一行。\\n', '目前不支持构建缓存。\\n', '只有RUN指令会运行容器进行构建。\\n', '目前不支持查询镜像构建历史。\\n', 'Stage名称可以用数字开头。\\n', 'Stage名称最大长度为64。\\n', 'ADD命令不支持远端URL格式。\\n', '暂不支持对单次构建进行资源限额，可采取对isula-builder配置资源限额的方式进行限制。\\n', '统计镜像大小时，isula-build是直接计算每层tar包大小之和，而docker是通过解压tar遍历diff目录计算文件大小之和，因此通过isula-build ctr-img images查看的镜像大小与docker images的显示上有一定差异。\\n', '操作时的镜像名称需要明确，格式为IMAGE_NAME:IMAGE_TAG。例如 busybox:latest, 其中latest不可省略。\\n', '附录\\n', '命令行参数说明\\n', '表1 ctr-img build 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img build\\t–build-arg\\tstring列表，构建过程中需要用到的变量\\n', '–build-static\\tKV值，构建二进制一致性。目前包含如下K值：- build-time：string，使用固定时间戳来构建容器镜像；时间戳格式为“YYYY-MM-DD HH-MM-SS”\\n', '-f, –filename\\tstring，Dockerfile的路径，不指定则是使用当前路径的Dockerfile文件\\n', '–format\\tstring，设置构建镜像的镜像格式：oci｜docker（需开启实验特性选项）\\n', '–iidfile\\tstring，输出 image ID 到本地文件\\n', '-o, –output\\tstring，镜像导出的方式和路径\\n', '–proxy\\t布尔值，继承主机侧环境的proxy环境变量（默认为true）\\n', '–tag\\tstring，给构建的镜像添加tag\\n', '–cap-add\\tstring列表，构建过程中RUN指令所需要的权限\\n', '表2 ctr-img load 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img load\\t-i, –input\\tstring，需要导入的本地tar包的路径\\n', '表3 ctr-img push 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img push\\t-f, –format\\tstring，推送的镜像格式：oci｜docker（需开启实验特性选项）\\n', '表4 ctr-img rm 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img rm\\t-a, –all\\t布尔值，删除所有本地持久化存储的镜像\\n', '-p, –prune\\t布尔值，删除所有没有tag的本地持久化存储的镜像\\n', '表5 ctr-img save 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img save\\t-o, –output\\tstring，镜像导出后在本地的存储路径\\n', '-f, –format\\tstring，导出层叠镜像的镜像格式：oci｜docker（需开启实验特性选项）\\n', '表6 login 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'login\\t-p, –password-stdin\\t布尔值，是否通过stdin读入密码；或采用交互式界面输入密码\\n', '-u, –username\\tstring，登陆镜像仓库所使用的用户名\\n', '表7 logout 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'logout\\t-a, –all\\t布尔值，是否登出所有已登陆的镜像仓库\\n', '表8 manifest annotate命令参数列表\\n', '\\n', '命令\\t说明\\t参数\\n', 'manifest annotate\\t–arch\\tstring，重写镜像适用架构\\n', '–os\\tstring，重写镜像适用系统\\n', '–os-features\\tstring列表，指定镜像需要的OS特性，很少使用\\n', '–variant\\tstring，指定列表中记录镜像的变量\\n', '通信矩阵\\n', 'isula-build两个组件进程之间通过unix socket套接字文件进行通信，无端口通信。\\n', '\\n', '文件与权限\\n', 'isula-build 所有的操作均需要使用 root 权限。如需使用非特权用户操作，则需要配置–group参数\\n', '\\n', 'isula-build 运行涉及文件权限如下表所示：\\n', '\\n', '文件路径\\t文件/文件夹权限\\t说明\\n', '/usr/bin/isula-build\\t550\\t命令行工具二进制文件。\\n', '/usr/bin/isula-builder\\t550\\t服务端isula-builder进程二进制文件。\\n', '/usr/lib/systemd/system/isula-build.service\\t640\\tsystemd配置文件，用于管理isula-build服务。\\n', '/etc/isula-build\\t650\\tisula-builder 配置文件根目录\\n', '/etc/isula-build/configuration.toml\\t600\\tisula-builder 总配置文件，包含设置 isula-builder 日志级别、持久化目录和运行时目录、OCI runtime等。\\n', '/etc/isula-build/policy.json\\t600\\t签名验证策略文件的语法文件。\\n', '/etc/isula-build/registries.toml\\t600\\t针对各个镜像仓库的配置文件，含可用的镜像仓库列表、镜像仓库黑名单。\\n', '/etc/isula-build/storage.toml\\t600\\t本地持久化存储的配置文件，包含所使用的存储驱动的配置。\\n', '/etc/isula-build/isula-build.pub\\t400\\t非对称加密公钥文件\\n', '/var/run/isula_build.sock\\t660\\t服务端isula-builder的本地套接字。\\n', '/var/lib/isula-build\\t700\\t本地持久化目录。\\n', '/var/run/isula-build\\t700\\t本地运行时目录。\\n', '/var/lib/isula-build/tmp/[buildid]/isula-build-tmp-*.tar\\t644\\t镜像导出至iSulad时的本地暂存目录。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_cgroup路径可配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/cgroup%E8%B7%AF%E5%BE%84%E5%8F%AF%E9%85%8D%E7%BD%AE.html", "text_entry": "['cgroup路径可配置\\n', '功能描述\\n', '系统容器提供在宿主机上进行容器资源隔离和预留的能力。通过--cgroup-parent参数，可以将容器使用的cgroup目录指定到某个特定目录下，从而达到灵活分配宿主机资源的目的。例如可以设置容器a、b、c的cgroup父路径为/lxc/cgroup1，容器d、e、f的cgroup父路径为/lxc/cgroup2，这样通过cgroup路径将容器分为两个group，实现容器cgroup组层面的资源隔离。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--cgroup-parent\\n', '\\n', '字符串变量。\\n', '指定容器cgroup父路径。\\n', '除了通过命令行指定单个系统容器对应的cgroup父路径外，还可通过修改iSulad容器引擎启动配置文件，指定所有容器的cgroup路径。\\n', '\\n', '\\n', '配置文件路径\\n', '\\n', '配置项\\n', '\\n', '配置项说明\\n', '\\n', '/etc/isulad/daemon.json\\n', '\\n', '--cgroup-parent\\n', '\\n', '字符串变量。\\n', '指定容器默认cgroup父路径。\\n', '配置示例：\"cgroup-parent\": \"/lxc/mycgroup\"\\n', '约束限制\\n', '如果daemon端和客户端都设置了cgroup parent参数，最终以客户端指定的--cgroup-parent生效。\\n', '如果已启动容器A，然后启动容器B，容器B的cgroup父路径指定为容器A的cgroup路径，在删除容器的时候需要先删除容器B再删除容器A，否则会导致cgroup资源残留。\\n', '使用示例\\n', '启动系统容器，指定–cgroup-parent参数：\\n', '\\n', '[root@localhost ~]# isula run -tid --cgroup-parent /lxc/cgroup123 --system-container --external-rootfs /root/myrootfs none init\\n', '115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '查看容器init进程的cgroup信息：\\n', '\\n', '[root@localhost ~]# isula inspect -f \"{{json .State.Pid}}\" 11\\n', '22167\\n', '[root@localhost ~]# cat /proc/22167/cgroup\\n', '13:blkio:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '12:perf_event:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '11:cpuset:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '10:pids:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '9:rdma:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '8:devices:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '7:hugetlb:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '6:memory:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '5:net_cls,net_prio:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '4:cpu,cpuacct:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '3:files:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '2:freezer:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '1:name=systemd:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e/init.scope\\n', '0::/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '可以看到容器的cgroup父路径被设置为/sys/fs/cgroup/<controller>/lxc/cgroup123\\n', '\\n', '同时，对于所有容器cgroup父路径的设置可以配置一下容器daemon文件，例如：\\n', '\\n', '{\\n', '         \"cgroup-parent\": \"/lxc/cgroup123\",\\n', '}\\n', '然后重启容器引擎，配置生效。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_namespace化内核参数可写.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/namespace%E5%8C%96%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%8F%AF%E5%86%99.html", "text_entry": "['namespace化内核参数可写\\n', '功能描述\\n', '对于运行在容器内的业务，如数据库，大数据，包括普通应用，有对部分内核参数进行设置和调整的需求，以满足最佳的业务运行性能和可靠性。内核参数要么不允许修改，要么全部允许修改（特权容器）：\\n', '\\n', '在不允许用户在容器内修改时，只提供了–sysctl外部接口，而且容器内不能灵活修改参数值。\\n', '\\n', '在允许用户在容器内修改时，部分内核参数是全局有效的，某个容器修改后，会影响主机上所有的程序，安全性降低。\\n', '\\n', '  \\n', '\\n', '系统容器提供–ns-change-opt参数，可以指定namespace化的内核参数在容器内动态设置，当前仅支持net、ipc。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--ns-change-opt\\n', '\\n', '字符串变量。\\n', '仅支持配置net、ipc：\\n', 'net：支持/proc/sys/net目录下所有namespace化参数。\\n', '\\n', 'ipc：支持的namespace化参数列表如下：\\n', '\\n', '/proc/sys/kernel/msgmax\\n', '\\n', '/proc/sys/kernel/msgmnb\\n', '\\n', '/proc/sys/kernel/msgmni\\n', '\\n', '/proc/sys/kernel/sem\\n', '\\n', '/proc/sys/kernel/shmall\\n', '\\n', '/proc/sys/kernel/shmmax\\n', '\\n', '/proc/sys/kernel/shmmni\\n', '\\n', '/proc/sys/kernel/shm_rmid_forced\\n', '\\n', '/proc/sys/fs/mqueue/msg_default\\n', '\\n', '/proc/sys/fs/mqueue/msg_max\\n', '\\n', '/proc/sys/fs/mqueue/msgsize_default\\n', '\\n', '/proc/sys/fs/mqueue/msgsize_max\\n', '\\n', '/proc/sys/fs/mqueue/queues_max\\n', '\\n', '支持通知指定多个namespce配置，多个配置间通过逗号隔开，例如：--ns-change-opt=net,ipc。\\n', '约束限制\\n', '如果容器启动同时指定了–privileged（特权容器）和–ns-change-opt，则–ns-change-opt不生效。\\n', '使用示例\\n', '启动容器， 指定–ns-change-opt=net：\\n', '\\n', '[root@localhost ~]# isula run -tid --ns-change-opt net --system-container --external-rootfs /root/myrootfs none init\\n', '4bf44a42b4a14fdaf127616c90defa64b4b532b18efd15b62a71cbf99ebc12d2\\n', '[root@localhost ~]# isula exec -it 4b mount | grep /proc/sys\\n', 'proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/net type proc (rw,nosuid,nodev,noexec,relatime)\\n', '可以看到容器内/proc/sys/net挂载点为rw，说明net相关的namespace化的内核参数具有读写权限。\\n', '\\n', '再启动一个容器，指定–ns-change-opt=ipc：\\n', '\\n', '[root@localhost ~]# isula run -tid --ns-change-opt ipc --system-container --external-rootfs /root/myrootfs none init\\n', 'c62e5e5686d390500dab2fa76b6c44f5f8da383a4cbbeac12cfada1b07d6c47f\\n', '[root@localhost ~]# isula exec -it c6 mount | grep /proc/sys\\n', 'proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shmmax type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shmmni type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shmall type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shm_rmid_forced type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/msgmax type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/msgmni type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/msgmnb type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/sem type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/fs/mqueue type proc (rw,nosuid,nodev,noexec,relatime)\\n', '可以看到容器内ipc相关的内核参数挂载点为rw，说明ipc相关的namespace化的内核参数具有读写权限。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_共享内存通道.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E9%81%93.html", "text_entry": "['共享内存通道\\n', '功能描述\\n', '系统容器提供容器与主机进程通过共享内存进行通信的功能，通过在容器创建时配置--host-channel参数，可以在容器与主机之间共享同一tmpfs，从而达到主机与容器间通信的功能。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--host-channel\\n', '\\n', '字符串变量，格式为：\\n', '<host path>:<container path>:<rw/ro>:<size limit>\\n', '参数说明如下：\\n', '<host path>：将在宿主机上挂载tmpfs的路径，必须是绝对路径。\\n', '\\n', '<container path>：将在容器内挂载tmpfs的路径，必须是绝对路径。\\n', '\\n', '<rw/ro>：在容器内挂载的文件系统的使用权限，只能配置为rw（可读写）或ro（只读），默认为rw。\\n', '\\n', '<size limit>：挂载的tmpfs能够使用的最大限制，最小支持1物理页（4KB），最大支持系统总物理内存的1/2 。默认为64MB。\\n', '\\n', '约束限制\\n', '宿主机上挂载的tmpfs的生命周期为从容器启动到容器删除，容器删除并解除对空间的占用后会移除这片空间。\\n', '容器删除时会将宿主机上挂载tmpfs的路径删除，所以不允许使用宿主机上已存在的目录。\\n', '为了宿主机上非root用户运行的进程能够与容器内进行通信，宿主机上tmpfs挂载的权限为1777。\\n', '使用示例\\n', '创建容器时指定--host-channel参数：\\n', '\\n', '[root@localhost ~]# isula run --rm -it --host-channel /testdir:/testdir:rw:32M --system-container --external-rootfs /root/myrootfs none init \\n', 'root@3b947668eb54:/# dd if=/dev/zero of=/testdir/test.file bs=1024 count=64K \\n', \"dd: error writing '/testdir/test.file': No space left on device \\n\", '32769+0 records in \\n', '32768+0 records out \\n', '33554432 bytes (34 MB, 32 MiB) copied, 0.0766899 s, 438 MB/s\\n', ' 说明：\\n', '\\n', '使用–host-channel大小限制时，若在容器内创建共享文件，则会受到容器内的内存配额限制（在容器内存使用达到极限时可能会产生oom）。\\n', '若用户在主机端创建共享文件，则不受容器内的内存配额限制。\\n', '若用户需要在容器内创建共享文件，且业务为内存密集型，可以通过设置容器内存配额为在原本基础上加上–host-channel配置的大小来消除影响。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_动态加载内核模块.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.html", "text_entry": "['动态加载内核模块\\n', '功能描述\\n', '容器内业务可能依赖某些内核模块，可通过设置环境变量的方式，在系统容器启动前动态加载容器中业务需要的内核模块到宿主机，此特性需要配合syscontainer-hooks一起使用，具体使用可参看\"容器资源动态管理（syscontainer-tools）“章节。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '-e KERNEL_MODULES=module_name1,module_name\\n', '\\n', '字符串变量。\\n', '支持配置多个模块，模块名以逗号分隔。\\n', '约束限制\\n', '如果加载的内核模块是未经过验证的，或者跟宿主机已有模块冲突的场景，会导致宿主机出现不可预知问题，在做加载内核模块时需要谨慎操作。\\n', '动态加载内核模块通过将需要加载的内核模块传递给容器，此功能是依靠syscontainer-tools捕获到容器启动的环境变量实现，依赖syscontainer-tools的正确安装部署。\\n', '加载的内核模块需要手动进行删除。\\n', '使用示例\\n', '启动系统容器时，指定-e KERNEL_MODULES参数，待系统容器启动后，可以看到ip_vs模块被成功加载到内核中。\\n', '\\n', '[root@localhost ~]# lsmod | grep ip_vs\\n', '[root@localhost ~]# isula run -tid -e KERNEL_MODULES=ip_vs,ip_vs_wrr --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/myrootfs none init\\n', 'ae18c4281d5755a1e153a7bff6b3b4881f36c8e528b9baba8a3278416a5d0980\\n', '[root@localhost ~]# lsmod | grep ip_vs\\n', 'ip_vs_wrr              16384  0\\n', 'ip_vs                 176128  2 ip_vs_wrr\\n', 'nf_conntrack          172032  7 xt_conntrack,nf_nat,nf_nat_ipv6,ipt_MASQUERADE,nf_nat_ipv4,nf_conntrack_netlink,ip_vs\\n', 'nf_defrag_ipv6         20480  2 nf_conntrack,ip_vs\\n', 'libcrc32c              16384  3 nf_conntrack,nf_nat,ip_vs\\n', ' 说明：\\n', '\\n', '宿主机需要安装syscontainer-tools。\\n', '需要指定–hooks-spec为syscontainer hooks。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_安全性和隔离性.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E6%80%A7.html", "text_entry": "['安全性和隔离性\\n', '安全性和隔离性\\n', 'user namespace多对多\\n', '用户权限控制\\n', 'proc文件系统隔离（lxcfs）\\n', 'user-namespace多对多\\n', '功能描述\\n', 'user namespace是将容器的root映射到主机的普通用户，使得容器中的进程和用户在容器里有特权，但是在主机上就是普通权限，防止容器中的进程逃逸到主机上，进行非法操作。更进一步，使用user namespace技术后，容器和主机使用不同的uid和gid，保证容器内部的用户资源和主机资源进行隔离，例如文件描述符等。\\n', '\\n', '系统容器支持通过–user-remap接口参数将不同容器的user namespace映射到宿主机不同的user namespace，实现容器user namespace隔离。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--user-remap\\n', '\\n', '参数格式为<uid>:<gid>:<offset>，参数说明如下：\\n', '\\n', 'uid、gid为整数型，且必须大于等于0。\\n', 'offset为整数型，且必须大于0，并且小于65536。取值不能太小，否则容器无法启动。\\n', 'uid加上offset的值必须小于等于232-1，gid加上offset的值必须小于等于232-1，否则容器启动会报错。\\n', '约束限制\\n', '如果系统容器指定了–user-remap，那么rootfs目录必须能够被–user-remap指定的uid/gid用户所访问，否则会导致容器user namespace无法访问rootfs，容器启动失败。\\n', '容器内所有的id都应该能映射到主机rootfs，某些目录/文件可能是从主机mount到容器，比如/dev/pts目录下面的设备文件，如果offset值太小可能会导致mount失败。\\n', 'uid、gid和offset的值由上层调度平台控制，容器引擎只做合法性检查。\\n', '–user-remap只适用于系统容器。\\n', '–user-remap和–privileged不能共存，否则容器启动会报错。\\n', '如果uid或gid指定为0，则–user-remap参数不生效。\\n', '使用指导\\n', ' 说明：\\n', '指定–user-remap参数前，请先将rootfs下所有目录和文件的uid和gid做整体偏移，偏移量为–user-remap指定uid和gid的偏移量。\\n', '例如将dev目录的uid和gid整体uid和gid偏移100000的参考命令为：\\n', 'chown 100000:100000 dev\\n', '\\n', '系统容器启动指定–user-remap参数：\\n', '\\n', '[root@localhost ~]# isula run -tid --user-remap 100000:100000:65535 --system-container --external-rootfs /home/root-fs none /sbin/init\\n', 'eb9605b3b56dfae9e0b696a729d5e1805af900af6ce24428fde63f3b0a443f4a\\n', '分别在宿主机和容器内查看/sbin/init进程信息：\\n', '\\n', '[root@localhost ~]# isula exec eb ps aux | grep /sbin/init\\n', 'root         1  0.6  0.0  21624  9624 ?        Ss   15:47   0:00 /sbin/init\\n', '[root@localhost ~]# ps aux | grep /sbin/init\\n', '100000    4861  0.5  0.0  21624  9624 ?        Ss   15:47   0:00 /sbin/init\\n', 'root      4948  0.0  0.0 213032   808 pts/0    S+   15:48   0:00 grep --color=auto /sbin/init\\n', '可以看到/sbin/init进程在容器内的owner是root用户，但是在宿主机的owner是uid=100000这个用户。\\n', '\\n', '在容器内创建一个文件，然后在宿主机上查看文件的owner：\\n', '\\n', '[root@localhost ~]# isula exec -it eb bash\\n', '[root@localhost /]# echo test123 >> /test123\\n', '[root@localhost /]# exit\\n', 'exit\\n', '[root@localhost ~]# ll /home/root-fs/test123\\n', '-rw-------. 1 100000 100000 8 Aug  2 15:52 /home/root-fs/test123\\n', '可以看到，在容器内生成了一个文件，它的owner是root，但是在宿主机上看到的owner是id=100000这个用户。\\n', '\\n', '用户权限控制\\n', '功能描述\\n', '容器引擎支持通过TLS认证方式来认证用户的身份，并依此控制用户的权限，当前容器引擎可以对接authz插件实现权限控制。\\n', '\\n', '接口说明\\n', '通过配置iSulad容器引擎启动参数来指定权限控制插件，daemon配置文件默认为/etc/isulad/daemon.json。\\n', '\\n', '\\n', '配置参数\\n', '\\n', '示例\\n', '\\n', '说明\\n', '\\n', '--authorization-plugin\\n', '\\n', '\"authorization-plugin\": \"authz-broker\"\\n', '\\n', '用户权限认证插件，当前只支持authz-broker。\\n', '\\n', '约束限制\\n', 'authz需要配置用户权限策略，策略文件默认为/var/lib/authz-broker/policy.json，该配置文件支持动态修改，修改完即时生效，不需要重启插件服务。\\n', '由于容器引擎为root用户启动，放开一般用户使用的一些命令可能会导致该用户不当获得过大权限，需谨慎配置。目前container_attach、container_create和container_exec_create动作可能会有风险。\\n', '对于某些复合操作，比如isula exec、isula attach等命令依赖isula inspect是否有权限，如果用户没有inspect权限会直接报错。\\n', '采用SSL/TLS 加密通道在增加安全性的同时也会带来性能损耗，如增加延时，消耗较多的CPU资源，除了数据传输外，加解密需要更大吞吐量，因此在并发场景下，相比非TLS通信，其并发量有一定程度上的下降。经实测，在ARM服务器（Cortex-A72 64核）接近空载情况下，采用TLS并发起容器，其最大并发量在200~250范围内。\\n', '服务端指定–tlsverify时，认证文件默认配置路径为/etc/isulad。且默认文件名分别为ca.pem、cert.pem、key.pem。\\n', '使用示例\\n', '确认宿主机安装了authz插件，如果需要安装，安装并启动authz插件服务命令如下：\\n', '\\n', '[root@localhost ~]# yum install authz\\n', '[root@localhost ~]# systemctl start authz\\n', '要启动该功能，首先需要配置容器引擎和用户的TLS证书。可以使用OPENSSL来生成需要的证书，具体步骤如下：\\n', '\\n', '#SERVERSIDE\\n', '\\n', '# Generate CA key\\n', 'openssl genrsa -aes256 -passout \"pass:$PASSWORD\" -out \"ca-key.pem\" 4096\\n', '# Generate CA\\n', 'openssl req -new -x509 -days $VALIDITY -key \"ca-key.pem\" -sha256 -out \"ca.pem\" -passin \"pass:$PASSWORD\" -subj \"/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL\"\\n', '# Generate Server key\\n', 'openssl genrsa -out \"server-key.pem\" 4096\\n', '\\n', '# Generate Server Certs.\\n', 'openssl req -subj \"/CN=$COMMON_NAME\" -sha256 -new -key \"server-key.pem\" -out server.csr\\n', '\\n', 'echo \"subjectAltName = DNS:localhost,IP:127.0.0.1\" > extfile.cnf\\n', 'echo \"extendedKeyUsage = serverAuth\" >> extfile.cnf\\n', '\\n', 'openssl x509 -req -days $VALIDITY -sha256 -in server.csr -passin \"pass:$PASSWORD\" -CA \"ca.pem\" -CAkey \"ca-key.pem\" -CAcreateserial -out \"server-cert.pem\" -extfile extfile.cnf\\n', '\\n', '#CLIENTSIDE\\n', '\\n', 'openssl genrsa -out \"key.pem\" 4096\\n', 'openssl req -subj \"/CN=$CLIENT_NAME\" -new -key \"key.pem\" -out client.csr\\n', 'echo \"extendedKeyUsage = clientAuth\" > extfile.cnf\\n', 'openssl x509 -req -days $VALIDITY -sha256 -in client.csr -passin \"pass:$PASSWORD\" -CA \"ca.pem\" -CAkey \"ca-key.pem\" -CAcreateserial -out \"cert.pem\" -extfile extfile.cnf\\n', \"若要直接使用以上过程作为脚本，需替换各变量为配置数值。生成CA时使用的参数若为空则写为“''”。PASSWORD、COMMON_NAME、CLIENT_NAME、VALIDITY为必选项。\\n\", '\\n', '容器引擎启动时添加TLS相关参数和认证插件相关参数，并保证认证插件的运行。此外，为了使用TLS认证，容器引擎必须使用TCP侦听的方式启动，不能使用传统的unix socket的方式启动。容器demon端配置如下：\\n', '\\n', '{\\n', '    \"tls\": true,\\n', '    \"tls-verify\": true,\\n', '    \"tls-config\": {\\n', '           \"CAFile\": \"/root/.iSulad/ca.pem\",\\n', '           \"CertFile\": \"/root/.iSulad/server-cert.pem\",\\n', '           \"KeyFile\":\"/root/.iSulad/server-key.pem\"\\n', '    },\\n', '    \"authorization-plugin\": \"authz-broker\"\\n', '}\\n', '然后需要配置策略，对于基本授权流程，所有策略都位于一个配置文件下/var/lib/authz-broker/policy.json。该配置文件支持动态修改，更改时不需要重新启动插件，只需要向authz进程发送SIGHUP信号。文件格式是每行一个策略JSON对象。每行只有一个匹配。具体的策略配置示例如下：\\n', '\\n', '所有用户都可以运行所有iSulad命令：{“name”:“policy_0”,“users”:[\"\"],“actions”:[\"\"]}。\\n', 'Alice可以运行所有iSulad命令：{“name”:“policy_1”,“users”:[“alice”],“actions”:[\"\"]}。\\n', '空用户都可以运行所有iSulad命令： {“name”:“policy_2”,“users”:[\"\"],“actions”:[\"\"]}。\\n', 'Alice和Bob可以创建新的容器：{“name”:“policy_3”,“users”:[“alice”,“bob”],“actions”:[“container_create”]}。\\n', 'service_account可以读取日志并运行docker top：{“name”:“policy_4”,“users”:[“service_account”],“actions”:[“container_logs”,“container_top”]}。\\n', 'Alice可以执行任何container操作：{“name”:“policy_5”,“users”:[“alice”],“actions”:[“container”]}。\\n', 'Alice可以执行任何container操作，但请求的种类只能是get：{“name”:“policy_5”,“users”:[“alice”],“actions”:[“container”], “readonly”:true }。\\n', ' 说明：\\n', '\\n', '配置中匹配action支持正则表达式。\\n', 'users不支持正则表达式。\\n', 'users不能有重复用户，即同一用户不能被多条规则匹配。\\n', '配置并更新完之后，客户端配置TLS参数连接容器引擎，即是以受限的权限访问。\\n', '\\n', '[root@localhost ~]#  isula version --tlsverify --tlscacert=/root/.iSulad/ca.pem --tlscert=/root/.iSulad/cert.pem --tlskey=/root/.iSulad/key.pem  -H=tcp://127.0.0.1:2375\\n', '如果想默认配置TLS认证进行客户端连接，可以将文件移动到~/.iSulad，并设置 ISULAD_HOST和ISULAD_TLS_VERIFY变量（而不是每次调用时传递 -H=tcp://$HOST:2375和–tlsverify）。\\n', '\\n', '[root@localhost ~]# mkdir -pv ~/.iSulad\\n', '[root@localhost ~]# cp -v {ca,cert,key}.pem ~/.iSulad \\n', '[root@localhost ~]# export ISULAD_HOST=localhost:2375 ISULAD_TLS_VERIFY=1\\n', '[root@localhost ~]# isula version\\n', 'proc文件系统隔离（lxcfs）\\n', '场景描述\\n', '容器虚拟化带来轻量高效，快速部署的同时，也因其隔离性不够彻底，给用户带来一定程度的使用不便。由于Linux内核namespace本身还不够完善，因此容器在隔离性方面也存在一些缺陷。例如，在容器内部proc文件系统中可以看到宿主机上的proc信息（如meminfo, cpuinfo，stat， uptime等）。利用lxcfs工具可以将容器内的看到宿主机/proc文件系统的内容，替换成本容器实例的相关/proc内容，以便容器内业务获取正确的资源数值。\\n', '\\n', '接口说明\\n', '系统容器对外提供两个工具包：一个是lxcfs软件，另外一个是配合lxcfs一起使用的lxcfs-tools工具。其中lxcfs作为宿主机daemon进程常驻，lxcfs-tools通过hook机制将宿主机的lxcfs文件系统绑定挂载到容器。\\n', '\\n', 'lxcfs-tools命令行格式如下：\\n', '\\n', 'lxcfs-tools [OPTIONS] COMMAND [COMMAND_OPTIONS]\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '参数\\n', '\\n', 'remount\\n', '\\n', '将lxcfs重新mount到容器中\\n', '\\n', '--all：对所有的容器执行remout lxcfs操作\\n', '\\n', '--container-id：remount lxcfs到特定的容器ID\\n', '\\n', 'umount\\n', '\\n', '将lxcfs从容器中umount掉\\n', '\\n', '--all：对所有的容器执行umout lxcfs操作\\n', '\\n', '--container-id：对特定容器执行umount lxcfs操作\\n', '\\n', 'check-lxcfs\\n', '\\n', '检查lxcfs服务是否运行\\n', '\\n', '无\\n', '\\n', 'prestart\\n', '\\n', '在lxcfs服务启动前将/var/lib/lxcfs目录mount到容器中\\n', '\\n', '无\\n', '\\n', '约束限制\\n', '当前只支持proc文件系统下的cpuinfo, meminfo, stat, diskstats, partitions，swaps和uptime文件，其他的文件和其他内核API文件系统（比如sysfs）未做隔离 。\\n', '安装rpm包后会在/var/lib/isulad/hooks/hookspec.json生成样例json文件，用户如果需要增加日志功能，需要在定制时加入–log配置。\\n', 'diskstats只能显示支持cfq调度的磁盘信息，无法显示分区信息。容器内设备会被显示为/dev目录下的名字。若不存在则为空。此外，容器根目录所在设备会被显示为sda。\\n', '挂载lxcfs时必须使用slave参数。若使用shared参数，可能会导致容器内挂载点泄露到主机，影响主机运行 。\\n', 'lxcfs支持服务优雅降级使用，若lxcfs服务crash或者不可用，容器内查看到的cpuinfo, meminfo, stat, diskstats, partitions, swaps和uptime均为host信息，容器其它业务功能不受影响。\\n', 'lxcfs底层依赖fuse内核模块以及libfuse库，因此需要内核支持fuse。\\n', 'lxcfs当前仅支持容器内运行64位的app，如果容器内运行32位的app可能会导致app读取到的cpuinfo信息不符合预期。\\n', 'lxcfs只是对容器cgroup进行资源视图模拟，对于容器内的系统调用（例如sysconf）获取到的仍然是主机的信息，lxcfs无法做到内核隔离。\\n', 'lxcfs使用隔离后的cpuinfo显示的cpu信息具有如下特征：\\n', 'processor：从0开始依次递增。\\n', 'physical id：从0开始依次递增。\\n', 'sibliing：固定为1。\\n', 'core id：固定为0。\\n', 'cpu cores：固定为1。\\n', '使用示例\\n', '首先需要安装lxcfs和lxcfs-tools这两个包，并启动lxcfs服务。\\n', '\\n', '[root@localhost ~]# yum install lxcfs lxcfs-tools \\n', '[root@localhost ~]# systemctl start lxcfs\\n', '容器启动完成之后查看容器内是否存在lxcfs挂载点。\\n', '\\n', '[root@localhost ~]# isula run -tid -v /var/lib/lxc:/var/lib/lxc --hook-spec /var/lib/isulad/hooks/hookspec.json --system-container --external-rootfs /home/root-fs none init\\n', 'a8acea9fea1337d9fd8270f41c1a3de5bceb77966e03751346576716eefa9782\\n', '[root@localhost ~]# isula exec a8 mount | grep lxcfs\\n', 'lxcfs on /var/lib/lxc/lxcfs type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/cpuinfo type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/diskstats type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/meminfo type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/partitions type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/stat type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/swaps type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/uptime type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', '执行update命令更新容器的cpu和mem资源配置，然后查看容器资源。根据如下回显可知，容器资源视图显示的是容器真实资源数据而不是宿主机的数据。\\n', '\\n', '[root@localhost ~]# isula update --cpuset-cpus 0-1 --memory 1G a8\\n', 'a8\\n', '[root@localhost ~]# isula exec a8 cat /proc/cpuinfo\\n', 'processor       : 0\\n', 'BogoMIPS        : 100.00\\n', 'cpu MHz         : 2400.000\\n', 'Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid\\n', 'CPU implementer : 0x41\\n', 'CPU architecture: 8\\n', 'CPU variant     : 0x0\\n', 'CPU part        : 0xd08\\n', 'CPU revision    : 2\\n', '\\n', 'processor       : 1\\n', 'BogoMIPS        : 100.00\\n', 'cpu MHz         : 2400.000\\n', 'Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid\\n', 'CPU implementer : 0x41\\n', 'CPU architecture: 8\\n', 'CPU variant     : 0x0\\n', 'CPU part        : 0xd08\\n', 'CPU revision    : 2\\n', '\\n', '[root@localhost ~]# isula exec a8 free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           1024          17         997           7           8        1006\\n', 'Swap:          4095           0        4095\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_容器内rebootshutdown.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E5%86%85reboot-shutdown.html", "text_entry": "['容器内reboot/shutdown\\n', '功能描述\\n', '系统容器支持在容器内执行reboot和shutdown命令。执行reboot命令效果同重启容器一致；执行shutdown命令效果同停止容器一致。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--restart\\n', '\\n', '字符串变量。\\n', '可取指定值：\\n', 'on-reboot：表示重启系统容器。\\n', '\\n', '  \\n', '\\n', '约束限制\\n', 'shutdown功能，依赖于不同的OS，以实际容器运行环境对应OS为准。\\n', '执行“shutdown -h now”命令关闭系统时，不能多次占用console。例如“isula run -ti”命令打开一个console，在另一个host bash中isula attach该容器，会打开另一个console，此时执行shutdown会失败。\\n', '使用示例\\n', '容器启动时指定--restart on-reboot参数，示例如下：\\n', '\\n', '[root@localhost ~]# isula run -tid --restart on-reboot --system-container --external-rootfs /root/myrootfs none init\\n', '106faae22a926e22c828a0f2b63cf5c46e5d5986ea8a5b26de81390d0ed9714f\\n', '进入容器执行reboot命令：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 bash\\n', '[root@localhost /]# reboot\\n', '查看容器是否重启：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 ps aux\\n', 'USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\\n', 'root         1  0.1  0.0  21588  9504 ?        Ss   12:11   0:00 init\\n', 'root        14  0.1  0.0  27024  9376 ?        Ss   12:11   0:00 /usr/lib/system\\n', 'root        17  0.0  0.0  18700  5876 ?        Ss   12:11   0:00 /usr/lib/system\\n', 'dbus        22  0.0  0.0   9048  3624 ?        Ss   12:11   0:00 /usr/bin/dbus-d\\n', 'root        26  0.0  0.0   8092  3012 ?        Rs+  12:13   0:00 ps aux\\n', '进入容器执行shutdown命令：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 bash\\n', '[root@localhost /]# shutdown -h now\\n', '[root@localhost /]# [root@localhost ~]#\\n', '检查容器是否停止：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 bash\\n', 'Error response from daemon: Exec container error;Container is not running:106faae22a926e22c828a0f2b63cf5c46e5d5986ea8a5b26de81390d0e']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_容器资源动态管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86.html", "text_entry": "['容器资源动态管理\\n', '普通容器无法支持对容器内的资源进行管理，例如添加一个块设备到容器、插入一块物理/虚拟网卡到容器。系统容器场景下，通过syscontainer-tools工具可以实现动态为容器挂载/卸载块设备，网络设备，路由和卷等资源。\\n', '\\n', '要使用此功能，需要安装syscontainer-tools工具：\\n', '\\n', '[root@localhost ~]# yum install syscontainer-tools\\n', '容器资源动态管理\\n', '设备管理\\n', '网卡管理\\n', '路由管理\\n', '挂卷管理\\n', '设备管理\\n', '功能描述\\n', 'syscontainer-tools支持将宿主机上的块设备（比如磁盘、LVM）或字符设备（比如GPU、binner、fuse）添加到容器中。在容器中使用该设备，例如可以对磁盘进行fdisk格式化，写入fs等操作。在容器不需要设备时，syscontainer-tools可以将设备从容器中删除，归还宿主机。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id> [ARG...]\\n', '其中：\\n', '\\n', 'COMMAND：设备管理相关的命令。\\n', '\\n', 'OPTIONS：设备管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', 'ARG：命令对应的参数。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', '参数说明\\n', '\\n', 'add-device\\n', '\\n', '将宿主机块设备/字符设备添加到容器中。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--blkio-weight-device：设置块设备IO权重（相对权重，10-100之间）。\\n', '--device-read-bps：设置块设备读取速率限制（byte/秒）。\\n', '--device-read-iops：设置块设备读取速率限制（IO/秒）。\\n', '--device-write-bps：设置块设备写入速率限制（byte/秒）。\\n', '--device-write-iops：设置块设备写入速率限制（IO/秒）。\\n', '--follow-partition：如果块设备是基础块设备（主SCSI块磁盘），加入此参数可以添加主磁盘下的所有分区。\\n', '--force：如果容器中已有块设备/字符设备，使用此参数覆盖旧的块设备/字符设备文件。\\n', '--update-config-only：只更新配置文件不实际做添加磁盘动作。\\n', '参数格式为：hostdevice[:containerdevice][:permission] [hostdevice[:containerdevice][:permission] ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：设备在主机上的路径。\\n', '\\n', 'containerdevice：设备在容器中的路径。\\n', '\\n', 'permission：容器内对设备的操作权限。\\n', '\\n', 'remove-device\\n', '\\n', '将块设备/字符设备从容器中删除，还原至宿主机。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--follow-partition：如果块设备是基础块设备（主SCSI块磁盘），加入此参数可以删除容器中主磁盘下的所有分区，还原至宿主机。\\n', '\\n', '参数格式为：hostdevice[:containerdevice] [hostdevice[:containerdevice] ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：设备在主机上的路径。\\n', '\\n', 'containerdevice：设备在容器中的路径。\\n', '\\n', 'list-device\\n', '\\n', '列出容器中所有的块设备/字符设备。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '--sub-partition：如果某磁盘为主磁盘，加入此flag，在显示主磁盘的同时，也显示主磁盘的子分区。\\n', '无\\n', '\\n', 'update-device\\n', '\\n', '更新磁盘Qos。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--device-read-bps：设置块设备读取速率限制（byte/秒），建议设置值大于等于1024。\\n', '--device-read-iops：设置块设备读取速率限制（IO/秒）。\\n', '--device-write-bps：设置块设备写入速率限制（byte/秒），建议设置值大于等于1024。\\n', '--device-write-iops：设置块设备写入速率限制（IO/秒）。\\n', '无\\n', '\\n', '约束限制\\n', '添加/删除设备的时机可以是容器实例非运行状态，完成操作后启动容器，容器内会有体现；也可以在容器运行时（running）动态添加。\\n', '不能在容器内和host上并发进行fdisk对磁盘的格式化写入，会影响容器磁盘使用。\\n', 'add-device将磁盘添加到容器的特定目录时，如果容器内的父目录为多级目录（比如/dev/a/b/c/d/e…）且目录层级不存在，则syscontainer-tools会自动在容器内创建对应目录；当删除时，不会将创建的父目录删除。如果用户下一次add-device到该父目录，则会提示已经存在无法添加成功。\\n', 'add-device添加磁盘、更新磁盘参数时，配置磁盘Qos；当配置磁盘Qos的read/write bps、read/write IOPS值时，不建议配置值过小，当设置过小时，会造成磁盘表现为不可读（实际原因是速度过慢），最终影响业务功能。\\n', '使用–blkio-weight-device来限制指定块设备的权重，如果当前块设备仅支持BFQ模式，可能会报错，提示用户检查当前OS环境是否支持BFQ块设备权重值设置。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', 'eed1096c8c7a0eca6d92b1b3bc3dd59a2a2adf4ce44f18f5372408ced88f8350\\n', '添加一个块设备到容器\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-device ee /dev/sdb:/dev/sdb123\\n', 'Add device (/dev/sdb) to container(ee,/dev/sdb123) done.\\n', '[root@localhost ~]# isula exec ee fdisk -l /dev/sdb123\\n', 'Disk /dev/sdb123: 50 GiB, 53687091200 bytes, 104857600 sectors\\n', 'Units: sectors of 1 * 512 = 512 bytes\\n', 'Sector size (logical/physical): 512 bytes / 512 bytes\\n', 'I/O size (minimum/optimal): 512 bytes / 512 bytes\\n', 'Disklabel type: dos\\n', 'Disk identifier: 0xda58a448\\n', '\\n', 'Device        Boot Start       End   Sectors Size Id Type\\n', '/dev/sdb123p1       2048 104857599 104855552  50G  5 Extended\\n', '/dev/sdb123p5       4096 104857599 104853504  50G 83 Linux\\n', '更新设备信息\\n', '\\n', '[root@localhost ~]# syscontainer-tools update-device --device-read-bps /dev/sdb:10m ee\\n', 'Update read bps for device (/dev/sdb,10485760) done.\\n', '删除设备\\n', '\\n', '[root@localhost ~]# syscontainer-tools remove-device ee /dev/sdb:/dev/sdb123\\n', 'Remove device (/dev/sdb) from container(ee,/dev/sdb123) done.\\n', 'Remove read bps for device (/dev/sdb) done.\\n', '网卡管理\\n', '功能描述\\n', 'syscontainer-tools支持将宿主机上的物理网卡或虚拟网卡插入到容器，在不使用网卡的时候从容器中删除归还给宿主机，并且可以动态修改网卡配置。插入物理网卡即把宿主机上一块网卡直接添加到容器中，插入虚拟网卡则需要先创建一对veth pair，之后将一端插入到容器中。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id>\\n', '其中：\\n', '\\n', 'COMMAND：网卡管理相关的命令。\\n', '\\n', 'OPTIONS：网卡管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', 'add-nic\\n', '\\n', '给容器创建一个网卡。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--type：设置网卡类型，当前只支持eth/veth。\\n', '--name：设置网卡名称，格式为[host:]<container>，host不写是随机名字。\\n', '--ip：设置网卡IP地址。\\n', '--mac：设置网卡mac地址。\\n', '--bridge：设置网卡绑定的网桥。\\n', '--mtu：设置网卡的mtu值，默认1500。\\n', '--update-config-only：如果此flag设置了，只更新配置文件，不会实际做添加网卡的动作。\\n', '--qlen：配置qlen值，默认为1000。\\n', 'remove-nic\\n', '\\n', '从容器中将网卡删除，还原至宿主机。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--type：设置网卡的类型。\\n', '--name：设置网卡的名称，格式为[host:]<container>。\\n', 'list-nic\\n', '\\n', '列出容器中所有的网卡。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '--filter：按照过滤格式输出，比如--filter \\'{\"ip\":\"192.168.3.4/24\", \"Mtu\":1500}\\'。\\n', 'update-nic\\n', '\\n', '更改容器内指定网卡的配置参数。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--name：容器内网卡名（必须项）。\\n', '--ip：设置网卡IP地址。\\n', '--mac：设置网卡mac地址。\\n', '--bridge：设置网卡绑定的网桥。\\n', '--mtu：设置网卡的mtu值。\\n', '--update-config-only：如果此flag设置了，只更新配置文件，不会实际做更新网卡的动作。\\n', '--qlen：配置qlen值。\\n', '约束限制\\n', '支持添加物理网卡（eth）和虚拟网卡（veth）两种类型。\\n', '在添加网卡时可以同时对网卡进行配置，参数包括–ip/–mac/–bridge/–mtu/–qlen。\\n', '支持最多添加8个物理网卡到容器。\\n', '使用syscontainer-tools add-nic向容器添加eth网卡后，如果不加hook，在容器退出前必须手工将nic删除，否则在host上的eth网卡的名字会被更改成容器内的名字。\\n', '对于物理网卡（1822 vf网卡除外），add-nic必须使用原mac地址，update-nic禁止修改mac地址，容器内也不允许修改mac地址。\\n', '使用syscontainer-tools add-nic时，设置mtu值，设置范围跟具体的网卡型号有关。\\n', '使用syscontainer-tools向容器添加网卡和路由时，建议先执行add-nic添加网卡，然后执行add-route添加路由；使用syscontainer-tools从容器删除网卡和路由时，建议先执行remove-route删除路由，然后执行remove-nic删除网卡。\\n', '使用syscontainer-tools添加网卡时，一块网卡只能添加到一个容器中。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本：\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', '2aaca5c1af7c872798dac1a468528a2ccbaf20b39b73fc0201636936a3c32aa8\\n', '添加一个虚拟网卡到容器\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-nic --type \"veth\" --name abc2:bcd2 --ip 172.17.28.5/24 --mac 00:ff:48:13:xx:xx --bridge docker0 2aaca5c1af7c\\n', 'Add network interface to container 2aaca5c1af7c (bcd2,abc2) done  \\n', '添加一个物理网卡到容器\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-nic --type \"eth\" --name eth3:eth1 --ip 172.17.28.6/24  --mtu 1300  --qlen 2100 2aaca5c1af7c\\n', 'Add network interface to container 2aaca5c1af7c (eth3,eth1) done\\n', ' 说明：\\n', '添加虚拟网卡或物理网卡时，请确保网卡处于空闲状态，添加正在使用的网卡会导致系统网络断开。\\n', '\\n', '路由管理\\n', '功能描述\\n', 'syscontainer-tools工具可以对系统容器进行动态添加/删除路由表。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id> [ARG...]\\n', '其中：\\n', '\\n', 'COMMAND：路由管理相关的命令。\\n', '\\n', 'OPTIONS：路由管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', 'ARG：命令对应的参数。\\n', '\\n', '接口说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', '参数说明\\n', '\\n', 'add-route\\n', '\\n', '将网络路由规则添加到容器中。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--update-config-only：添加此参数，只更新配置文件，不做实际的更新路由表的动作。\\n', '\\n', '参数格式：[{rule1}，{rule2}]\\n', '\\n', 'rule样例：\\n', '\\n', '\\'[{\"dest\":\"default\", \"gw\":\"192.168.10.1\"},{\"dest\":\"192.168.0.0/16\",\"dev\":\"eth0\",\"src\":\"192.168.1.2\"}]\\'\\n', '\\n', 'dest：目标网络，如果为空则是默认网关。\\n', 'src：路由源IP。\\n', 'gw：路由网关。\\n', 'dev：网络设备。\\n', 'remove-route\\n', '\\n', '从容器中删除路由。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--update-config-only：设置此参数，只更新配置文件，不做实际从容器中删除路由的动作。\\n', '\\n', '参数格式：[{rule1}，{rule2}]\\n', '\\n', 'rule样例：\\n', '\\n', '\\'[{\"dest\":\"default\", \"gw\":\"192.168.10.1\"},{\"dest\":\"192.168.0.0/16\",\"dev\":\"eth0\",\"src\":\"192.168.1.2\"}]\\'\\n', '\\n', 'dest：目标网络，如果为空则是默认网关。\\n', 'src：路由源IP。\\n', 'gw：路由网关。\\n', 'dev：网络设备。\\n', 'list-route\\n', '\\n', '列出容器中所有的路由规则。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '--filter：按照过滤格式输出，比如--filter \\'{\"ip\":\"192.168.3.4/24\", \"Mtu\":1500}\\'。\\n', '无\\n', '\\n', '约束限制\\n', '使用syscontainer-tools向容器添加网卡和路由时，建议先执行add-nic添加网卡，然后执行add-route添加路由；使用syscontainer-tools从容器删除网卡和路由时，建议先执行remove-route删除路由，然后执行remove-nic删除网卡。\\n', '向容器内添加路由规则时，需确保所添加的路由规则与容器内现有的路由规则不会产生冲突。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本：\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', '0d2d68b45aa0c1b8eaf890c06ab2d008eb8c5d91e78b1f8fe4d37b86fd2c190b\\n', 'syscontainer-tools向系统容器添加一块物理网卡：\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-nic --type \"eth\" --name enp4s0:eth123 --ip 172.17.28.6/24  --mtu 1300  --qlen 2100 0d2d68b45aa0\\n', 'Add network interface (enp4s0) to container (0d2d68b45aa0,eth123) done\\n', \"syscontainer-tools添加一条路由规则到系统容器，注意格式需按照'[{“dest”:“default”, “gw”:“192.168.10.1”},{“dest”:“192.168.0.0/16”,“dev”:“eth0”,“src”:“192.168.1.2”}]'来配置。如果dest为空会自动填成default。\\n\", '\\n', '[root@localhost ~]# syscontainer-tools add-route 0d2d68b45aa0 \\'[{\"dest\":\"172.17.28.0/32\", \"gw\":\"172.17.28.5\",\"dev\":\"eth123\"}]\\'\\n', 'Add route to container 0d2d68b45aa0, route: {dest:172.17.28.0/32,src:,gw:172.17.28.5,dev:eth123} done\\n', '查看容器内是否新增一条路由规则：\\n', '\\n', '[root@localhost ~]# isula exec -it 0d2d68b45aa0 route\\n', 'Kernel IP routing table\\n', 'Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\\n', '172.17.28.0     172.17.28.5     255.255.255.255 UGH   0      0        0 eth123\\n', '172.17.28.0     0.0.0.0         255.255.255.0   U     0      0        0 eth123\\n', '挂卷管理\\n', '功能描述\\n', '普通容器仅支持在创建时指定–volume参数将宿主机的目录/卷挂载到容器实现资源共享，但是无法在容器运行时将挂载到容器中的目录/卷卸载掉，也不支持将宿主机的目录/卷挂载到容器。系统容器可以通过syscontainer-tools工具实现动态将宿主机的目录/卷挂载到容器，以及将容器中的目录/卷进行卸载。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id> [ARG...]\\n', '其中：\\n', '\\n', 'COMMAND：路由管理相关的命令。\\n', '\\n', 'OPTIONS：路由管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', 'ARG：命令对应的参数。\\n', '\\n', '接口说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', '参数说明\\n', '\\n', 'add-path\\n', '\\n', '将宿主机文件/目录添加到容器中。\\n', '\\n', '无\\n', '\\n', '参数格式为：\\n', '\\n', 'hostpath:containerpath:permission [hostpath:containerpath:permission ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：卷在主机上的路径。\\n', '\\n', 'containerdevice：卷在容器中的路径。\\n', '\\n', 'permission：容器内对挂载路径的操作权限。\\n', '\\n', 'remove-path\\n', '\\n', '将容器中的目录/文件删除，还原到宿主机中。\\n', '\\n', '无\\n', '\\n', '参数格式为：hostpath:containerpath [hostpath:containerpath ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：卷在主机上的路径。\\n', '\\n', 'containerdevice：卷在容器中的路径。\\n', '\\n', 'list-path\\n', '\\n', '列出容器中所有的path目录。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '\\n', '无\\n', '\\n', '约束限制\\n', '挂载目录（add-path）的时候必须要指定绝对路径。\\n', '挂载目录（add-path）会在主机上生成/.sharedpath挂载点。\\n', '最多可以向单个容器中添加128个volume，超过128后无法添加成功。\\n', 'add-path不能将主机目录覆盖容器中的根目录目录（/），否则会造成功能影响。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本：\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', 'e45970a522d1ea0e9cfe382c2b868d92e7b6a55be1dd239947dda1ee55f3c7f7\\n', 'syscontainer-tools将宿主机某个目录挂载到容器，实现资源共享：\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-path e45970a522d1 /home/test123:/home/test123\\n', 'Add path (/home/test123) to container(e45970a522d1,/home/test123) done.\\n', '宿主机目录/home/test123创建一个文件，然后在容器内查看文件是否可以访问：\\n', '\\n', '[root@localhost ~]# echo \"hello world\" > /home/test123/helloworld\\n', '[root@localhost ~]# isula exec e45970a522d1 bash\\n', '[root@localhost /]# cat /home/test123/helloworld\\n', 'hello world\\n', 'syscontainer-tools将挂载目录从容器内删除：\\n', '\\n', '[root@localhost ~]# syscontainer-tools remove-path e45970a522d1 /home/test123:/home/test123\\n', 'Remove path (/home/test123) from container(e45970a522d1,/home/test123) done\\n', '[root@localhost ~]# isula exec e45970a522d1 bash\\n', '[root@localhost /]# ls /home/test123/helloworld\\n', \"ls: cannot access '/home/test123/helloworld': No such file or directory\\n\", '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_指定rootfs创建容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%8C%87%E5%AE%9Arootfs%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8.html", "text_entry": "['指定rootfs创建容器\\n', '功能描述\\n', '系统容器不同于普通容器，普通容器需要指定一个容器镜像来启动，而系统容器通过参数 --external-rootfs 指定一个本地的根文件系统rootfs（Root File System）来启动，rootfs包含了容器运行时依赖的操作系统环境。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--external-rootfs\\n', '\\n', '字符串变量。\\n', '容器根文件系统对应的绝对路径，即 rootfs 的路径。\\n', '约束限制\\n', '参数–external-rootfs指定的rootfs目录必须为绝对路径，不能为相对路径。\\n', '参数–external-rootfs指定的rootfs目录必须为一个完整运行的操作系统环境（包含systemd软件包），否则容器会启动失败。\\n', '容器删除时，不会删除–external-rootfs指定的rootfs目录。\\n', '不支持在x86环境上运行基于arm rootfs的容器，也不支持在arm环境上运行基于x86 rootfs的容器。\\n', '同一份rootfs，不建议启动多个容器实例，即同一份rootfs只供一个生命周期内的容器实例使用。\\n', '使用示例\\n', '假设本地rootfs的路径为/root/myrootfs，那么启动一个系统容器的命令如下：\\n', '\\n', '# isula run  -tid --system-container --external-rootfs /root/myrootfs none init\\n', ' 说明：\\n', 'rootfs为自定义的文件系统，请用户自行准备。例如容器镜像的tar包解压后，即为一个rootfs。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_最大句柄数限制.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%9C%80%E5%A4%A7%E5%8F%A5%E6%9F%84%E6%95%B0%E9%99%90%E5%88%B6.html", "text_entry": "['最大句柄数限制\\n', '功能描述\\n', '系统容器支持对容器内使用文件句柄数进行限制，文件句柄包括普通文件句柄和网络套接字，启动容器时，可以通过指定–files-limit参数限制容器内打开的最大句柄数。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--files-limit\\n', '\\n', '  \\n', '\\n', '整数值，不能为负数。\\n', '指定为0表示不受限制，最大值限制由当前内核files cgroup决定。\\n', '约束限制\\n', '如果--files-limit指定的值太小，可能会导致系统容器无法通过exec执行命令，报\"open too many files\"错误，所以files limit的值应该设置大一些。\\n', '文件句柄包括普通文件句柄和网络套接字。\\n', '使用示例\\n', '使用--files-limit限制容器内打开文件句柄数需要内核支持files cgroup，可以执行以下命令查看：\\n', '\\n', '[root@localhost ~]# cat /proc/1/cgroup | grep files\\n', '10:files:/\\n', '结果显示files，说明内核支持files cgroup。\\n', '\\n', '容器启动指定–files-limit参数，并检查files.limit参数是否成功写入：\\n', '\\n', '[root@localhost ~]# isula run  -tid --files-limit 1024 --system-container  --external-rootfs /tmp/root-fs  empty init 01e82fcf97d4937aa1d96eb8067f9f23e4707b92de152328c3fc0ecb5f64e91d \\n', '[root@localhost ~]# isula exec -it 01e82fcf97d4 bash \\n', '[root@localhost ~]# cat /sys/fs/cgroup/files/files.limit \\n', '1024 \\n', '\\n', '可以看出，容器内文件句柄数被成功限制。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_环境变量持久化.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8C%81%E4%B9%85%E5%8C%96.html", "text_entry": "['环境变量持久化\\n', '功能描述\\n', '系统容器支持通过指定–env-target-file接口参数将env变量持久化到容器rootfs目录下的配置文件中。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--env-target-file\\n', '\\n', '字符串变量。\\n', 'env持久化文件必须在rootfs目录下，且配置为绝对路径。\\n', '约束限制\\n', '–env-target-file指定的目标文件如果存在的话，大小不能超过10MB。\\n', '–env-target-file指定的参数为rootfs目录下的绝对路径。\\n', '如果–env和目标文件里面的env出现冲突，以–env指定值的参数为准。\\n', '使用示例\\n', '启动系统容器，指定env环境变量和–env-target-file参数：\\n', '\\n', '[root@localhost ~]# isula run -tid -e abc=123 --env-target-file /etc/environment --system-container --external-rootfs /root/myrootfs none init\\n', 'b75df997a64da74518deb9a01d345e8df13eca6bcc36d6fe40c3e90ea1ee088e\\n', '[root@localhost ~]# isula exec b7 cat /etc/environment\\n', 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\n', 'TERM=xterm\\n', 'abc=123\\n', '可以看到容器的env变量（abc=123）已经持久化到/etc/environment配置文件中。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_通过systemd启动容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E9%80%9A%E8%BF%87systemd%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.html", "text_entry": "['通过systemd启动容器\\n', '功能描述\\n', '系统容器与普通容器最大的差异就在于容器启动的init进程，普通容器无法通过systemd启动系统服务，而系统容器具备这个能力，通过在启动容器时指定--system-container参数可以使能systemd服务。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--system-container\\n', '\\n', '布尔变量，取值为true、false，未指定值时表示true。\\n', '指定某个容器类型是否属于系统容器，必须使能。\\n', '约束限制\\n', 'systemd服务需要调用一些特殊系统调用，包括mount、umount2、unshare、reboot以及name_to_handle_at，所以在不开启特权容器标签的情况下，系统容器打开了调用上述接口的权限。\\n', '系统容器都是init启动，init进程不响应表示正常退出的SIGTERM信号，stop默认在10s之后才会强制杀死容器。如果需要快速结束，可以手动指定stop的超时时间。\\n', '--system-container必须配合--external-rootfs参数一起使用。\\n', '系统容器内支持运行各类服务，服务的启停通过systemctl来管理，服务之间可能会出现相互依赖关系导致异常情况下某些服务进程出现D/Z状态，使得容器无法正常退出。\\n', '系统容器内的某些服务进程可能会影响其它操作结果，例如容器内若运行了NetworkManager服务，可能会影响向容器添加网卡的行为（网卡添加成功然后被NetworkManger停掉），导致不可预期的结果。\\n', '系统容器和主机暂时无法实现udev事件隔离，所以fstab配置也暂不支持。\\n', 'systemd服务可能和libcgroup提供的cgconfig服务在功能上出现冲突，建议在容器内去掉libcgroup相关的包或者配置cgconfig服务的Delegate值为no。\\n', '使用示例\\n', '指定--system-container和--external-rootfs参数启动系统容器。\\n', '\\n', '[root@localhost ~]# isula run -tid -n systest01 --system-container --external-rootfs /root/myrootfs none init\\n', '执行以上命令后容器成功运行，通过exec进容器查看进程信息，可看到systemd服务已启动。\\n', '\\n', '[root@localhost ~]# isula exec -it systest01 bash\\n', '[root@localhost /]# ps -ef\\n', 'UID        PID  PPID  C STIME TTY          TIME CMD\\n', 'root         1     0  2 06:49 ?        00:00:00 init\\n', 'root        14     1  2 06:49 ?        00:00:00 /usr/lib/systemd/systemd-journal\\n', 'root        16     1  0 06:49 ?        00:00:00 /usr/lib/systemd/systemd-network\\n', 'dbus        23     1  0 06:49 ?        00:00:00 /usr/bin/dbus-daemon --system --\\n', 'root        25     0  0 06:49 ?        00:00:00 bash\\n', 'root        59    25  0 06:49 ?        00:00:00 ps –ef\\n', '容器内执行systemctl命令查看服务状态，可看到服务被systemd管理。\\n', '\\n', '[root@localhost /]# systemctl status dbus\\n', '● dbus.service - D-Bus System Message Bus\\n', '   Loaded: loaded (/usr/lib/systemd/system/dbus.service; static; vendor preset:\\n', 'disabled)\\n', '   Active: active (running) since Mon 2019-07-22 06:49:38 UTC; 2min 5\\n', '8s ago\\n', '     Docs: man:dbus-daemon(1)\\n', ' Main PID: 23 (dbus-daemon)\\n', '   CGroup: /system.slice/dbus.service\\n', '           └─23 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidf\\n', 'ile --systemd-activation --syslog-only\\n', '\\n', 'Jul 22 06:49:38 localhost systemd[1]: Started D-Bus System Message Bus.\\n', '容器内通过systemctl stop/start服务，可看到服务被systemd管理。\\n', '\\n', '[root@localhost /]# systemctl stop dbus\\n', 'Warning: Stopping dbus.service, but it can still be activated by:\\n', '  dbus.socket\\n', '[root@localhost /]# systemctl start dbus']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_安装指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AF%BC.html", "text_entry": "['安装指导\\n', ' 说明：\\n', '系统容器的安装需要使用root权限。\\n', '\\n', '首先需要安装iSulad容器引擎。\\n', '\\n', '# yum install iSulad\\n', '安装系统容器依赖包。\\n', '\\n', '# yum install syscontainer-tools authz lxcfs-tools lxcfs\\n', '查看iSulad是否已经启动。\\n', '\\n', '# systemctl status isulad\\n', '开启lxcfs和authz服务。\\n', '\\n', '# systemctl start lxcfs\\n', '# systemctl start authz\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_FAQ.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/FAQ-54.html", "text_entry": "['FAQ\\n', 'FAQ\\n', '使用systemctl和top命令查询libvirtd服务占用内存不同\\n', '设置RAID0卷，参数stripsize设置为4时出错\\n', '使用rpmbuild编译mariadb失败\\n', '使用默认配置启动SNTP服务失败\\n', '安装时出现软件包冲突、文件冲突或缺少软件包导致安装失败\\n', 'libiscsi降级失败\\n', 'xfsprogs降级失败\\n', 'cpython/Lib发现CVE-2019-9674:Zip炸弹漏洞\\n', '不合理使用glibc正则表达式引起ReDoS攻击\\n', '使用systemctl和top命令查询libvirtd服务占用内存不同\\n', '问题描述\\n', '使用systemctl和systemd-cgtop命令查询libvirtd服务占用内存超1.5G，而使用top命令查询libvirtd服务占用内存仅70M左右。\\n', '\\n', '原因分析\\n', 'systemd管理的服务（包括systemctl和systemd-cgtop）中显示的内存通过查询CGroup对应的memory.usage_in_bytes得到。top是直接统计/proc下内存相关信息计算得出。两者的统计方法不同，不能直接比较。\\n', '\\n', '一般来说，业务进程使用的内存主要有以下几种情况：\\n', '\\n', 'anon_rss：用户空间的匿名映射页（Anonymous pages in User Mode address spaces），比如调用malloc分配的内存，以及使用MAP_ANONYMOUS的mmap。当系统内存不够时，内核可以将这部分内存交换出去。\\n', 'file_rss：用户空间的文件映射页（Mapped pages in User Mode address spaces），包含map file和map tmpfs，前者比如指定文件的mmap，后者比如IPC共享内存。当系统内存不够时，内核可以回收这些页，但回收之前可能需要与文件同步数据。\\n', 'file_cache：文件缓存（page in page cache of disk file），普通读写（read/write）文件时产生的文件缓存。当系统内存不够时，内核可以回收这些页，但回收之前可能需要与文件同步数据。\\n', 'buffer pages：属于page cache，比如读取块设备文件时的相关缓存。\\n', '其中anon_rss和file_rss属于进程的RSS，file_cache和buffer pages属于page cache。简单来说：\\n', '\\n', 'top里的RSS = anon_rss + file_rss，SHR = file_rss。\\n', '\\n', 'CGroup里的memory.usage_in_bytes = cache + RSS + swap。\\n', '\\n', '由上可知，syestemd相关命令和top命令的内存占用率含义不同，所以查询结果不同。\\n', '\\n', '设置RAID0卷，参数stripsize设置为4时出错\\n', '问题现象\\n', '设置RAID0卷，参数stripsize设置为4时出错。\\n', '\\n', '原因分析\\n', '64K页表开启只能支持64K场景。\\n', '\\n', '解决方法\\n', '不需要修改配置文件，openeuler执行lvcreate命令时，条带化规格支持的stripesize最小值为64KB，将参数stripesize设置为64。\\n', '\\n', '使用rpmbuild编译mariadb失败\\n', '问题描述\\n', '如果使用root账号登录系统，并在该账号下使用rpmbuild命令编译mariadb源代码，会出现编译失败现象，提示：\\n', '\\n', \"+ echo 'mysql can'\\\\''t run test as root'\\n\", \"mysql can't run test as root\\n\", '+ exit 1\\n', '原因分析\\n', 'mariadb数据库不允许使用root权限的账号进行测试用例执行，所以会阻止编译过程（编译过程中会自动执行测试用例）。\\n', '\\n', '解决方案\\n', '使用vi等文本编辑工具，修改mariadb.spec文件中runtest变量的值。\\n', '\\n', '修改前：\\n', '\\n', '%global runtest 1\\n', '修改后：\\n', '\\n', '%global runtest 0\\n', '该修改关闭了编译阶段执行测试用例的功能，但不会影响编译和编译后的RPM包内容。\\n', '\\n', '使用默认配置启动SNTP服务失败\\n', '问题现象\\n', '默认配置情况下SNTP服务启动失败。\\n', '\\n', '原因分析\\n', '默认配置中未添加授时服务器域名。\\n', '\\n', '解决方案\\n', '修改/etc/sysconfig/sntp文件 ，在文件中添加中国NTP快速授时服务器域名：0.generic.pool.ntp.org。\\n', '\\n', '安装时出现软件包冲突、文件冲突或缺少软件包导致安装失败\\n', '问题现象\\n', '安装软件包过程中，可能出现软件包冲突、文件冲突或缺少软件包，从而导致升安装被中断，最终安装失败。软件包冲突、文件冲突和缺少软件包的报错信息分别如下所示。\\n', '\\n', '软件包冲突报错信息示例（以 libev-libevent-devel-4.24-11.oe1.aarch64与libevent-devel-2.1.11-2.oe1.aarch64冲突为例）：\\n', '\\n', 'package libev-libevent-devel-4.24-11.oe1.aarch64 conflicts with libevent-devel provided by libevent-devel-2.1.11-2.oe1.aarch64  \\n', ' - cannot install the best candidate for the job  \\n', ' - conflicting requests\\n', '文件冲突报错信息示例（以/usr/bin/containerd文件冲突为例）：\\n', '\\n', 'Error: Transaction test error:  \\n', ' file /usr/bin/containerd from install of containerd-1.2.0-101.oe1.aarch64 conflicts with file from package docker-engine-18.09.0-100.aarch64  \\n', ' file /usr/bin/containerd-shim from install of containerd-1.2.0-101.oe1.aarch64 conflicts with file from package docker-engine-18.09.0-100.aarch64\\n', '缺少软件包的报错信息示例（以缺失blivet-data软件包为例）：\\n', '\\n', 'Error:  \\n', '  Problem: cannot install both blivet-data-1:3.1.1-6.oe1.noarch and blivet-data-1:3.1.1-5.noarch  \\n', '   - package python2-blivet-1:3.1.1-5.noarch requires blivet-data = 1:3.1.1-5, but none of the providers can be installed  \\n', '   - cannot install the best update candidate for package blivet-data-1:3.1.1-5.noarch  \\n', \"   - problem with installed package python2-blivet-1:3.1.1-5.noarch(try to add '--allowerasing' to command line to replace conflicting packages or '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages)\\n\", '原因分析\\n', 'openEuler提供的软件包中，有些软件包虽然名称不同，但功能相同，导致两个软件包无法同时安装。\\n', 'openEuler提供的软件包中，有些软件包虽然名称不同，但功能相同，导致安装时安装后的文件相同，从而产生了文件冲突。\\n', '有些软件包，因在升级安装前被其他软件包所依赖，一旦该软件包升级后，可能导致依赖它的软件包因缺少软件包而不能安装。\\n', '解决方案\\n', '若为软件包冲突，则按如下步骤进行处理（以问题现象中示例的软件包冲突为例）：\\n', '\\n', '根据安装过程中的软件包冲突报错信息，确定与待安装的 libev-libevent-devel-4.24-11.oe1.aarch64软件包冲突的软件包为libevent-devel-2.1.11-2.oe1.aarch64。\\n', '\\n', '执行dnf remove命令将与待安装软件包冲突的软件包单独卸载。\\n', '\\n', '# dnf remove libevent-devel-2.1.11-2.oe1.aarch64\\n', '重新进行安装操作。\\n', '\\n', '若为文件冲突，则按如下步骤进行处理（以问题现象中示例的文件冲突为例）：\\n', '\\n', '根据安装过程中的文件冲突报错信息，确定导致文件冲突的软件包名称为containerd-1.2.0-101.oe1.aarch64和docker-engine-18.09.0-100.aarch64。\\n', '\\n', '将不需要安装的软件包名称记录下来，以不需要安装docker-engine-18.09.0-100.aarch64为例。\\n', '\\n', '执行dnf remove命令将不需要安装的软件包单独卸载。\\n', '\\n', '# dnf remove docker-engine-18.09.0-100.aarch64\\n', '重新进行安装操作。\\n', '\\n', '若为缺少软件包，则按如下步骤进行处理（以问题现象中示例的缺少软件包为例）：\\n', '\\n', '根据升级安装过程中的缺少软件包报错信息，确定待升级的软件包名称blivet-data-1:3.1.1-5.noarch及依赖它的软件包名称python2-blivet-1:3.1.1-5.noarch。\\n', '\\n', '执行dnf remove命令将依赖待升级包才能安装的软件包单独卸载或在升级软件包时加上--allowerasing参数。\\n', '\\n', '执行dnf remove命令将依赖blivet-data-1:3.1.1-5.noarch软件包才能安装的软件包单独卸载。\\n', '\\n', '# dnf remove python2-blivet-1:3.1.1-5.noarch\\n', '升级软件包时加上--allowerasing参数。\\n', '\\n', '# yum update blivet-data-1:3.1.1-5.noarch -y --allowerasing\\n', '重新进行升级操作。\\n', '\\n', '安装冲突实例\\n', '文件冲突\\n', '\\n', 'python3-edk2-devel.noarch 与 build.noarch 因文件名重复存在冲突。\\n', '\\n', '# yum install python3-edk2-devel.noarch build.noarch\\n', '...\\n', 'Error: Transaction test error:\\n', 'file /usr/bin/build conflicts between attempted installs of python3-edk2-devel-202002-3.oe1.noarch and build-20191114-324.4.oe1.noarch\\n', 'libiscsi降级失败\\n', '问题现象\\n', 'libiscsi-1.19.4 版本及以上降级到 libiscsi-1.19.3 及以下版本时失败。\\n', '\\n', 'Error:\\n', 'Problem: problem with installed package libiscsi-utils-1.19.0-4.oe1.x86_64\\n', '- package libiscsi-utils-1.19.0-4.oe1.x86_64 requires libiscsi(x86-64) = 1.19.0-4.oe1, but none of the providers can be installed\\n', '- cannot install both libiscsi-1.19.0-3.oe1.x86_64 and libiscsi-1.19.0-4.oe1.x86_64\\n', '- cannot install both libiscsi-1.19.0-4.oe1.x86_64 and libiscsi-1.19.0-3.oe1.x86_64\\n', '- conflicting requests\\n', \"(try to add '--allowerasing' to command line to replace conflicting packages or '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages)\\n\", '原因分析\\n', 'libiscsi-1.19.3 之前的版本把 iscsi-xxx 等二进制文件打包进了主包 libiscsi，而这些二进制文件引入了不合理的依赖 CUnit, 为了解决这种不合理的依赖，在 libiscsi-1.19.4 版本把这些二进制文件单独拆分出来一个子包 libiscsi-utils，主包弱依赖于子包，产品可以根据自己的需求在做镜像时是否集成该子包；不集成或卸载子包不会影响 libiscsi 主包的功能。 如果系统中安装了 libiscsi-utils 子包，libiscsi-1.19.4 及以上版本降级到 libiscsi-1.19.3 及以下版本时，由于 libiscsi-1.19.3 及以下版本无法提供对应的 libiscsi-utils，因此 libiscsi-utils 不会降级，但 libiscsi-utils 依赖于降级前的 libiscsi 主包，导致依赖问题无法解决，最终导致降级失败。\\n', '\\n', '解决方案\\n', '执行以下命令，卸载 libiscsi-utils 子包，卸载成功后再进行降级操作。\\n', '\\n', 'yum remove libiscsi-utils\\n', 'xfsprogs降级失败\\n', '问题现象\\n', 'xfsprogs-5.6.0-2 及以上版本降级到 xfsprogs-5.6.0-1 及以下版本时失败。\\n', '\\n', 'Error:\\n', 'Problem: problem with installed package xfsprogs-xfs_scrub-5.6.0-2.oe1.x86_64\\n', '- package xfsprogs-xfs_scrub-5.6.0-2.oe1.x86_64 requires xfsprogs = 5.6.0-2.oe1, but none of the providers can be installed\\n', '- cannot install both xfsprogs-5.6.0-1.oe1.x86_64 and xfsprogs-5.6.0-2.oe1.x86_64\\n', '- cannot install both xfsprogs-5.6.0-2.oe1.x86_64 and xfsprogs-5.6.0-1.oe1.x86_64\\n', '- conflicting requests\\n', '原因分析\\n', '在 xfsprogs-5.6.0-2 版本中，为了减少 xfsprogs 主包的不合理依赖，同时将实验性质的命令从主包中分来，我们将 xfs_scrub* 命令拆分到单独的 xfsprogs-xfs_scrub 子包中。而 xfsprogs 主包弱依赖于 xfsprogs-xfs_scrub 子包，所以产品可以根据自己的需求在做镜像时是否集成该子包，或者是否卸载该子包。不集成或卸载该子包不会影响 xfsprogs 主包功能。\\n', '\\n', '如果系统中安装了 xfsprogs-xfs_scrub 子包，从 xfsprogs-5.6.0-2 及以上版本降级到 xfsprogs-5.6.0-1 及以下版本时，由于 xfsprogs-5.6.0-1 及以下版本无法提供对应的 xfsprogs-xfs_scrub，因此 xfsprogs-xfs_scrub 不会降级，但 xfsprogs-xfs_scrub 依赖于降级前的 xfsprogs 主包，导致依赖问题无法解决，最终导致降级失败。\\n', '\\n', '解决方案\\n', '执行以下命令，卸载 xfsprogs-xfs_scrub 子包，卸载成功后再进行降级操作。\\n', '\\n', 'yum remove xfsprogs-xfs_scrub\\n', 'cpython/Lib发现CVE-2019-9674:Zip炸弹漏洞\\n', '问题现象\\n', 'Python 3.7.2 及以下版本中的 Lib/zipfile.py 允许远程攻击者通过 zip 炸弹制造拒绝服务请求，从而导致资源消耗过大。\\n', '\\n', '原因分析\\n', '远程攻击者通过 zip 炸弹导致拒绝服务，影响目标系统业务甚至达到使系统崩溃的结果。zip 炸弹就是一个高压缩比的 zip 文件，它本身可能只有几M或几十M的大小，但是解压缩之后会产生巨大的数据量，产生巨大的资源消耗。\\n', '\\n', '解决方案\\n', '在 zipfile 文档中添加告警信息： https://github.com/python/cpython/blob/3.7/Doc/library/zipfile.rst。\\n', '\\n', '不合理使用glibc正则表达式引起ReDoS攻击\\n', '问题现象\\n', '使用glibc的regcomp/regexec接口编程，或者grep/sed等应用glibc正则表达式的shell命令，不合理的正则表达式或输入会造成ReDoS攻击（CVE-2019-9192/CVE-2018-28796）。 典型正则表达式pattern为“反向引用”（\\\\1表示）与“*”（匹配零次或多次）、“+”（匹配一次或多次）、“{m,n}”（最小匹配m次，最多匹配n次）的组合，或者配合超长字符串输入，示例如下：\\n', '\\n', '# echo D | grep -E \"$(printf \\'(\\\\0|)(\\\\\\\\1\\\\\\\\1)*\\')\"Segmentation fault (core dumped)\\n', '# grep -E \"$(printf \\'(|)(\\\\\\\\1\\\\\\\\1)*\\')\"\\n', 'Segmentation fault (core dumped)\\n', \"# echo A | sed '/\\\\(\\\\)\\\\(\\\\1\\\\1\\\\)*/p'\\n\", 'Segmentation fault (core dumped)\\n', '# time python -c \\'print \"a\"*40000\\' | grep -E \"a{1,32767}\"\\n', 'Segmentation fault (core dumped)\\n', '# time python -c \\'print \"a\"*40900\\' | grep -E \"(a)\\\\\\\\1\"\\n', 'Segmentation fault (core dumped)\\n', '原因分析\\n', '使用正则表达式的进程coredump。具体原因为glibc正则表达式的实现为NFA/DFA混合算法，内部原理是使用贪婪算法进行递归查找，目的是尽可能匹配更多的字符串，贪婪算法在处理递归正则表达式时会导致ReDoS。\\n', '\\n', '解决方案\\n', '需要对用户做严格的权限控制，减少攻击面。\\n', '用户需保证正则表达式的正确性，不输入无效正则表达式，或者超长字符串配合正则的“引用” “*”等容易触发无限递归的组合。\\n', '# ()(\\\\1\\\\1)*\\n', '# \"a\"*400000\\n', '用户程序在检测到进程异常之后，通过重启进程等手段恢复业务，提升程序的可靠性。\\n', '安装卸载httpd-devel和apr-util-devel软件包，其中的依赖包gdbm-devel安装、卸载有报错\\n', '问题现象\\n', 'gdbm-devel-1.18.1-1包安装、卸载有报错；\\n', '问题1修复后，gdbm和gdbm-devel包更新到1.18.1-2版本，但在安装httpd-devel、apr-util-devel等包（依赖关系中有gdbm-devel软件包）时，默认安装的gdbm-devel还是1.18.1-1旧版本，导致问题报错依然存在。\\n', '原因分析\\n', 'gdbm-devel-1.18.1-1包中缺少提供info信息的help软件包，导致单独安装gdbm-devel并不能将help包引入进来，所以出现了如下告警信息。 install-info: 没有那个文件或目录 for /usr/share/info/gdbm.info.gz\\n', '由于系统默认安装的gdbm主包是1.18.1-1版本，而没有安装gdbm-devel包。依赖gdbm-devel包的相关软件包在安装gdbm-devel包的过程中，仍会匹配gdbm的主包版本，故而依然安装了gdbm-devel的旧版本1.18.1-1,导致警告信息依然存在。\\n', '解决方案\\n', '单包升级gdbm，安装使用gdbm-1.18.1-2版本相关软件包后，告警信息消失；\\n', '在单包升级gdbm后，再进行安装依赖的gdbm-devel软件包安装，让其依赖高版本gdbm软件包，告警信息消失。\\n', '系统reboot后，执行yum/dnf 等命令报错，提示rpmdb error\\n', '问题现象\\n', 'reboot系统，重启后，执行rpm相关命令(yum/dnf)提示：\\n', 'error: db5 error(-30973) from dbenv->open: BDB0087 DB_RUNRECOVERY: Fatal error, run database recovery\\n', 'error: cannot open Packages index using db5 - (-30973)\\n', 'error: cannot open Packages database in /var/lib/rpm\\n', 'Error: Error: rpmdb open failed\\n', '原因分析\\n', '执行安装升级动作过程中，会对/var/lib/rpm/__db.00*文件进行读写操作，如果在运行中出现强制下电、磁盘空间满或者 ‘kill -9’ 等异常中断操作，会导致对应_db文件损坏，后续执行rpm相关命令（dnf/yum）会发生报错\\n', '解决方案\\n', '步骤1 使用 ‘kill -9’ 停止所有正在运行的rpm命令。\\n', '步骤2 删除所有的/var/lib/rpm/__db.00*文件。\\n', '步骤3 执行 ‘rpmdb –rebuilddb’ 命令，重建rpm db后即可。\\n', '\\n', '执行 rpmrebuild -d /home/test filesystem对filesystem包rebuild时，rebuild失败\\n', '问题现象\\n', \"执行 rpmrebuild –comment-missing=y –keep-perm -b -d /home/test filesystem-3.16-3.oe1.aarch64对filesystem包rebuild时，rebuild失败. /usr/lib/rpmrebuild/rpmrebuild.sh:Error:(RpmBuild) Package 'filesystem-3.16-3.oe1.aarch64' build failed. /usr/lib/rpmrebuild/rpmrebuild.sh:Error: RpmBuild\\n\", '\\n', '原因分析\\n', '软件包在%pretrans -p阶段创建目录，并在%ghost阶段对该目录进行修饰，如果用户在该目录下创建目录或文件，执行rpmrebuild对该包进行打包，发现创建的目录或文件也会打包到该包中。\\n', '\\n', '上述问题的根本原因是因为filesystem在%pretrans阶段创建了/proc目录，并在%ghost阶段对该目录进行了修饰，但是该目录在系统运行时会动态的创建一些微量进程，这些进程非目录也非文件，在执行rpmrebuild的时无法对这些进程进行打包，所以rebuild失败。\\n', '\\n', '解决方案\\n', '暂时不使用rpmrebuild命令对filesystem进行rebuild。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_使用DNF管理软件包.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8DNF%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85.html", "text_entry": "['使用DNF管理软件包\\n', 'DNF是一款Linux软件包管理工具，用于管理RPM软件包。DNF可以查询软件包信息，从指定软件库获取软件包，自动处理依赖关系以安装或卸载软件包，以及更新系统到最新可用版本。\\n', '\\n', ' 说明：\\n', '\\n', 'DNF与YUM完全兼容，提供了YUM兼容的命令行以及为扩展和插件提供的API。\\n', '使用DNF需要管理员权限，本章所有命令需要在管理员权限下执行。\\n', '使用DNF管理软件包\\n', '配置DNF\\n', 'DNF配置文件\\n', '创建本地软件源仓库\\n', '添加、启用和禁用软件源\\n', '管理软件包\\n', '搜索软件包\\n', '列出软件包清单\\n', '显示RPM包信息\\n', '安装RPM包\\n', '下载软件包\\n', '删除软件包\\n', '管理软件包组\\n', '列出软件包组清单\\n', '显示软件包组信息\\n', '安装软件包组\\n', '删除软件包组\\n', '检查并更新\\n', '检查更新\\n', '升级\\n', '更新所有的包和它们的依赖\\n', '配置DNF\\n', 'DNF配置文件\\n', 'DNF 的主要配置文件是 /etc/dnf/dnf.conf，该文件包含两部分：\\n', '\\n', '“main”部分保存着DNF的全局设置。\\n', '\\n', '“repository”部分保存着软件源的设置，可以有一个或多个“repository”。\\n', '\\n', '另外，在/etc/yum.repos.d 目录中保存着一个或多个repo源相关文件，它们也可以定义不同的“repository”。\\n', '\\n', '所以openEuler软件源的配置一般有两种方式，一种是直接配置/etc/dnf/dnf.conf文件中的“repository”部分，另外一种是在/etc/yum.repos.d目录下增加.repo文件。\\n', '\\n', '配置main部分\\n', '/etc/dnf/dnf.conf 文件包含的“main”部分，配置示例如下：\\n', '\\n', '[main]\\n', 'gpgcheck=1\\n', 'installonly_limit=3\\n', 'clean_requirements_on_remove=True\\n', 'best=True\\n', 'skip_if_unavailable=False\\n', '常用选项说明：\\n', '\\n', '表 1 main参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'cachedir\\n', '\\n', '缓存目录，该目录用于存储RPM包和数据库文件。\\n', '\\n', 'keepcache\\n', '\\n', '可选值是1和0，表示是否要缓存已安装成功的那些RPM包及头文件，默认值为0，即不缓存。\\n', '\\n', 'debuglevel\\n', '\\n', '设置dnf生成的debug信息。取值范围：[0-10]，数值越大会输出越详细的debug信息。默认值为2，设置为0表示不输出debug信息。\\n', '\\n', 'clean_requirements_on_remove\\n', '\\n', '删除在dnf remove期间不再使用的依赖项，如果软件包是通过DNF安装的，而不是通过显式用户请求安装的，则只能通过clean_requirements_on_remove删除软件包，即它是作为依赖项引入的。 默认值为True。\\n', '\\n', 'best\\n', '\\n', '升级包时，总是尝试安装其最高版本，如果最高版本无法安装，则提示无法安装的原因并停止安装。默认值为True。\\n', '\\n', 'obsoletes\\n', '\\n', '可选值1和0，设置是否允许更新陈旧的RPM包。默认值为1，表示允许更新。\\n', '\\n', 'gpgcheck\\n', '\\n', '可选值1和0，设置是否进行gpg校验。默认值为1，表示需要进行校验。\\n', '\\n', 'plugins\\n', '\\n', '可选值1和0，表示启用或禁用dnf插件。默认值为1，表示启用dnf插件。\\n', '\\n', 'installonly_limit\\n', '\\n', '设置可以同时安装“installonlypkgs”指令列出包的数量。默认值为3，不建议降低此值。\\n', '\\n', '配置repository部分\\n', 'repository部分允许您定义定制化的openEuler软件源仓库，各个仓库的名称不能相同，否则会引起冲突。配置repository部分有两种方式，一种是直接配置/etc/dnf/dnf.conf文件中的“repository”部分，另外一种是配置/etc/yum.repos.d目录下的.repo文件。\\n', '\\n', '直接配置/etc/dnf/dnf.conf文件中的“repository”部分\\n', '\\n', '下面是[repository]部分的一个最小配置示例：\\n', '\\n', '[repository]\\n', 'name=repository_name\\n', 'baseurl=repository_url\\n', ' 说明：\\n', 'openEuler提供在线的镜像源，地址：https://repo.openeuler.org/。以 openEuler 21.03的aarch64版本为例，baseurl可配置为https://repo.openeuler.org/openEuler-21.03/OS/aarch64/。\\n', '\\n', '选项说明：\\n', '\\n', '表 2 repository参数说明\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'name=repository_name\\n', '\\n', '软件仓库（repository ）描述的字符串。\\n', '\\n', 'baseurl=repository_url\\n', '\\n', '软件仓库（repository ）的地址。\\n', '\\n', '使用http协议的网络位置：例如 http://path/to/repo\\n', '使用ftp协议的网络位置：例如 ftp://path/to/repo\\n', '本地位置：例如 file:///path/to/local/repo\\n', '配置/etc/yum.repos.d目录下的.repo文件\\n', '\\n', 'openEuler提供了多种repo源供用户在线使用，各repo源含义可参考系统安装。使用root权限添加openEuler repo源，示例如下：\\n', '\\n', '# vi /etc/yum.repos.d/openEuler.repo\\n', '[OS]\\n', 'name=openEuler-$releasever - OS\\n', 'baseurl=https://repo.openeuler.org/openEuler-21.03/OS/$basearch/\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=https://repo.openeuler.org/openEuler-21.03/OS/$basearch/RPM-GPG-KEY-openEuler\\n', ' 说明：\\n', '\\n', 'enabled为是否启用该软件源仓库，可选值为1和0。默认值为1，表示启用该软件源仓库。\\n', 'gpgkey为验证签名用的公钥。\\n', '显示当前配置\\n', '要显示当前的配置信息：\\n', '\\n', 'dnf config-manager --dump\\n', '要显示相应软件源的配置，首先查询repo id：\\n', '\\n', 'dnf repolist\\n', '然后执行如下命令，显示对应id的软件源配置，其中 repository 为查询得到的repo id：\\n', '\\n', 'dnf config-manager --dump repository\\n', '您也可以使用一个全局正则表达式，来显示所有匹配部分的配置：\\n', '\\n', 'dnf config-manager --dump glob_expression\\n', '创建本地软件源仓库\\n', '要建立一个本地软件源仓库，请按照下列步骤操作。\\n', '\\n', '安装createrepo软件包。在root权限下执行如下命令：\\n', '\\n', 'dnf install createrepo\\n', '将需要的软件包复制到一个目录下，如/mnt/local_repo/ 。\\n', '\\n', '创建软件源，执行以下命令：\\n', '\\n', 'createrepo /mnt/local_repo\\n', '添加、启用和禁用软件源\\n', '本节将介绍如何通过“dnf config-manager”命令添加、启用和禁用软件源仓库。\\n', '\\n', '添加软件源\\n', '要定义一个新的软件源仓库，您可以在 /etc/dnf/dnf.conf 文件中添加“repository”部分，或者在/etc/yum.repos.d/目录下添加“.repo”文件进行说明。建议您通过添加“.repo”的方式，每个软件源都有自己对应的“.repo”文件，以下介绍该方式的操作方法。\\n', '\\n', '要在您的系统中添加一个这样的源，请在root权限下执行如下命令，执行完成之后会在/etc/yum.repos.d/目录下生成对应的repo文件。其中 repository_url 为repo源地址，详情请参见表2。\\n', '\\n', 'dnf config-manager --add-repo repository_url\\n', '启用软件源\\n', '要启用软件源，请在root权限下执行如下命令，其中 repository 为新增.repo文件中的repo id（可通过dnf repolist查询）：\\n', '\\n', 'dnf config-manager --set-enable repository\\n', '您也可以使用一个全局正则表达式，来启用所有匹配的软件源。其中 glob_expression 为对应的正则表达式，用于同时匹配多个repo id：\\n', '\\n', 'dnf config-manager --set-enable glob_expression\\n', '禁用软件源\\n', '要禁用软件源，请在root权限下执行如下命令：\\n', '\\n', 'dnf config-manager --set-disable repository\\n', '同样的，您也可以使用一个全局正则表达式来禁用所有匹配的软件源：\\n', '\\n', 'dnf config-manager --set-disable glob_expression\\n', '管理软件包\\n', '使用dnf能够让您方便的进行查询、安装、删除软件包等操作。\\n', '\\n', '搜索软件包\\n', '您可以使用rpm包名称、缩写或者描述搜索需要的RPM包，使用命令如下：\\n', '\\n', 'dnf search term\\n', '示例如下：\\n', '\\n', '$   dnf search httpd\\n', '========================================== N/S matched: httpd ==========================================\\n', 'httpd.aarch64 : Apache HTTP Server\\n', 'httpd-devel.aarch64 : Development interfaces for the Apache HTTP server\\n', 'httpd-manual.noarch : Documentation for the Apache HTTP server\\n', 'httpd-tools.aarch64  : Tools for use with the Apache HTTP Server\\n', 'libmicrohttpd.aarch64  : Lightweight library for embedding a webserver in applications\\n', 'mod_auth_mellon.aarch64  : A SAML 2.0 authentication module for the Apache Httpd Server\\n', 'mod_dav_svn.aarch64  : Apache httpd module for Subversion server\\n', '列出软件包清单\\n', '要列出系统中所有已安装的以及可用的RPM包信息，使用命令如下：\\n', '\\n', 'dnf list all\\n', '要列出系统中特定的RPM包信息，使用命令如下：\\n', '\\n', 'dnf list glob_expression...\\n', '示例如下：\\n', '\\n', '$ dnf list httpd\\n', 'Available Packages\\n', 'httpd.aarch64              2.4.34-8.h5.oe1           Local\\n', '显示RPM包信息\\n', '要显示一个或者多个RPM包信息，使用命令如下：\\n', '\\n', 'dnf info package_name...\\n', '例如搜索，命令如下：\\n', '\\n', '$ dnf info httpd\\n', 'Available Packages\\n', 'Name        : httpd\\n', 'Version     : 2.4.34\\n', 'Release     : 8.h5.oe1\\n', 'Arch        : aarch64\\n', 'Size        : 1.2 M\\n', 'Repo        : Local\\n', 'Summary     : Apache HTTP Server\\n', 'URL         : http://httpd.apache.org/\\n', 'License     : ASL 2.0\\n', 'Description : The Apache HTTP Server is a powerful, efficient, and extensible\\n', '            : web server.\\n', '安装RPM包\\n', '要安装一个软件包及其所有未安装的依赖，请在root权限下执行如下命令：\\n', '\\n', 'dnf install package_name\\n', '您也可以通过添加软件包名字同时安装多个软件包。配置文件/etc/dnf/dnf.conf添加参数strict=False，运行dnf命令参数添加--setopt=strict=0。请在root权限下执行如下命令：\\n', '\\n', 'dnf install package_name package_name... --setopt=strict=0\\n', '示例如下：\\n', '\\n', '# dnf install httpd\\n', ' 说明：\\n', '\\n', '安装RPM包过程中，若出现安装失败，可参考安装时出现软件包冲突、文件冲突或缺少软件包导致安装失败。\\n', '请勿安装install-scipts软件包，该包仅用于imageTailor工具裁剪ISO时使用，若在openEuler系统上安装该软件包会导致系统无法启动。\\n', '下载软件包\\n', '使用dnf下载软件包，请在root权限下输入如下命令：\\n', '\\n', 'dnf download package_name\\n', '如果需要同时下载未安装的依赖，则加上--resolve，使用命令如下：\\n', '\\n', 'dnf download --resolve package_name\\n', '示例如下：\\n', '\\n', '# dnf download --resolve httpd\\n', '删除软件包\\n', '要卸载软件包以及相关的依赖软件包，请在root权限下执行如下命令：\\n', '\\n', 'dnf remove package_name...\\n', '示例如下：\\n', '\\n', '# dnf remove totem\\n', '管理软件包组\\n', '软件包集合是服务于一个共同的目的一组软件包，例如系统工具集等。使用dnf可以对软件包组进行安装/删除等操作，使相关操作更高效。\\n', '\\n', '列出软件包组清单\\n', '使用summary参数，可以列出系统中所有已安装软件包组、可用的组，可用的环境组的数量，命令如下：\\n', '\\n', 'dnf groups summary\\n', '使用示例如下：\\n', '\\n', '# dnf groups summary\\n', 'Last metadata expiration check: 0:11:56 ago on Sat 17 Aug 2019 07:45:14 PM CST.\\n', 'Available Groups: 8\\n', '要列出所有软件包组和它们的组ID ，命令如下：\\n', '\\n', 'dnf group list\\n', '使用示例如下：\\n', '\\n', '# dnf group list\\n', 'Last metadata expiration check: 0:10:32 ago on Sat 17 Aug 2019 07:45:14 PM CST.\\n', 'Available Environment Groups:\\n', '   Minimal Install\\n', '   Custom Operating System\\n', '   Server\\n', 'Available Groups:\\n', '   Development Tools\\n', '   Graphical Administration Tools\\n', '   Headless Management\\n', '   Legacy UNIX Compatibility\\n', '   Network Servers\\n', '   Scientific Support\\n', '   Security Tools\\n', '   System Tools\\n', '\\n', '显示软件包组信息\\n', '要列出包含在一个软件包组中必须安装的包和可选包，使用命令如下：\\n', '\\n', 'dnf group info glob_expression...\\n', '例如显示Development Tools信息，示例如下：\\n', '\\n', '# dnf group info \"Development Tools\"\\n', 'Last metadata expiration check: 0:14:54 ago on Wed 05 Jun 2019 08:38:02 PM CST.\\n', '\\n', 'Group: Development Tools\\n', ' Description: A basic development environment.\\n', ' Mandatory Packages:\\n', '   binutils\\n', '   glibc-devel\\n', '   make\\n', '   pkgconf\\n', '   pkgconf-m4\\n', '   pkgconf-pkg-config\\n', '   rpm-sign\\n', ' Optional Packages:\\n', '   expect\\n', '安装软件包组\\n', '每一个软件包组都有自己的名称以及相应的ID（groupid），您可以使用软件包组名称或它的ID进行安装。\\n', '\\n', '要安装一个软件包组，请在root权限下执行如下命令：\\n', '\\n', 'dnf group install group_name\\n', 'dnf group install groupid\\n', '例如安装Development Tools相应的软件包组，命令如下：\\n', '\\n', '# dnf group install \"Development Tools\"\\n', '# dnf group install development\\n', '删除软件包组\\n', '要卸载软件包组，您可以使用软件包组名称或它的ID，在root权限下执行如下命令：\\n', '\\n', 'dnf group remove group_name\\n', 'dnf group remove groupid\\n', '例如删除Development Tools相应的软件包组，命令如下：\\n', '\\n', '# dnf group remove \"Development Tools\"\\n', '# dnf group remove development\\n', '检查并更新\\n', 'dnf可以检查您的系统中是否有软件包需要更新。您可以通过dnf列出需要更新的软件包，并可以选择一次性全部更新或者只对指定包进行更新。\\n', '\\n', '检查更新\\n', '如果您需要显示当前系统可用的更新，使用命令如下：\\n', '\\n', 'dnf check-update\\n', '使用实例如下：\\n', '\\n', '# dnf check-update\\n', 'Last metadata expiration check: 0:02:10 ago on Sun 01 Sep 2019 11:28:07 PM  CST.\\n', '\\n', 'anaconda-core.aarch64       19.31.123-1.14             updates\\n', 'anaconda-gui.aarch64        19.31.123-1.14             updates\\n', 'anaconda-tui.aarch64        19.31.123-1.14             updates\\n', 'anaconda-user-help.aarch64  19.31.123-1.14             updates\\n', 'anaconda-widgets.aarch64    19.31.123-1.14             updates\\n', 'bind-libs.aarch64           32:9.9.4-29.3              updates\\n', 'bind-libs-lite.aarch64      32:9.9.4-29.3              updates\\n', 'bind-license.noarch         32:9.9.4-29.3              updates\\n', 'bind-utils.aarch64          32:9.9.4-29.3              updates\\n', '...\\n', '升级\\n', '如果您需要升级单个软件包，在root权限下执行如下命令：\\n', '\\n', 'dnf update package_name\\n', '例如升级rpm包，示例如下：\\n', '\\n', '# dnf update anaconda-gui.aarch64\\n', 'Last metadata expiration check: 0:02:10 ago on Sun 01 Sep 2019 11:30:27 PM  CST.\\n', 'Dependencies Resolved\\n', '================================================================================\\n', ' Package                  Arch         Version              Repository     Size\\n', '================================================================================\\n', 'Updating:\\n', ' anaconda-gui             aarch64      19.31.123-1.14       updates       461 k\\n', ' anaconda-core            aarch64      19.31.123-1.14       updates       1.4 M\\n', ' anaconda-tui             aarch64      19.31.123-1.14       updates       274 k\\n', ' anaconda-user-help       aarch64      19.31.123-1.14       updates       315 k\\n', ' anaconda-widgets         aarch64      19.31.123-1.14       updates       748 k\\n', '\\n', 'Transaction Summary\\n', '================================================================================\\n', 'Upgrade  5 Package\\n', '\\n', 'Total download size: 3.1 M\\n', 'Is this ok [y/N]:\\n', '类似的，如果您需要升级软件包组，在root权限下执行如下命令：\\n', '\\n', 'dnf group update group_name\\n', '更新所有的包和它们的依赖\\n', '要更新所有的包和它们的依赖，在root权限下执行如下命令：\\n', '\\n', 'dnf update']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_使用KAE加速引擎.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8KAE%E5%8A%A0%E9%80%9F%E5%BC%95%E6%93%8E.html", "text_entry": "['使用KAE加速引擎\\n', '使用KAE加速引擎\\n', '简介\\n', '应用场景\\n', '安装、升级和卸载\\n', '安装加速器软件包\\n', '升级加速器软件包\\n', '卸载加速器软件包\\n', '日志查询\\n', '加速引擎的应用\\n', 'KAE引擎使用示例代码\\n', '通过OpenSSL配置文件openssl.cnf使用KAE引擎\\n', '故障处理\\n', '初始化失败\\n', '安装完加速器引擎之后，查找不到加速器设备\\n', '升级加速器驱动失败\\n', '简介\\n', 'KAE加速引擎为openEuler的一个软件加速库，搭载在Kunpeng 920处理器上联合提供硬件加速引擎功能，包含了对称加密、非对称加密和数字签名，用于加速SSL/TLS应用，可以显著降低处理器消耗，提高处理器效率。此外，用户通过OpenSSL标准接口可实现业务快速迁移。\\n', '\\n', 'KAE加速引擎支持以下算法：\\n', '\\n', '摘要算法SM3, 支持异步模式。\\n', '\\n', '对称加密算法SM4，支持异步模式，支持CTR/XTS/CBC模式。\\n', '\\n', '对称加密算法AES, 支持异步模式，支持ECB/CTR/XTS/CBC模式。\\n', '\\n', '非对称算法RSA，支持异步模式，支持 Key Sizes 1024/2048/3072/4096。\\n', '\\n', '密钥协商算法DH, 支持异步模式，支持 Key Sizes 768/1024/1536/2048/3072/4096。\\n', '\\n', '应用场景\\n', 'KAE加速引擎主要有以下应用场景，如表1所示。\\n', '\\n', '表 1 应用场景\\n', '\\n', '\\n', '场景\\n', '\\n', '数据\\n', '\\n', '大数据\\n', '\\n', '流数据\\n', '\\n', '数据加密\\n', '\\n', '块数据\\n', '\\n', '智能安防\\n', '\\n', '视频流数据\\n', '\\n', 'Web服务\\n', '\\n', '握手连接\\n', '\\n', '安装、升级和卸载\\n', '安装加速器软件包\\n', '安装前准备\\n', '环境要求\\n', 'TaiShan 200服务器，开启加速引擎功能\\n', ' 说明：\\n', '\\n', '需要导入加速器许可证，具体操作请参考《TaiShan 机架服务器 iBMC (V500及以上) 用户指南》中“许可证管理”章节。\\n', '物理机场景使用加速器需要关闭SMMU，具体操作请参考《TaiShan 200服务器BIOS参数参考》。\\n', 'CPU：Kunpeng 920\\n', '操作系统：openEuler-22.03_LTS-aarch64-dvd.iso\\n', 'KAE加速引擎软件说明\\n', '表 2 加速引擎的rpm软件包\\n', '\\n', '\\n', '软件包名称\\n', '\\n', '软件包说明\\n', '\\n', 'kae_driver-版本号-1.OS类型.aarch64.rpm\\n', '\\n', '加速器驱动，包含内容：uacce.ko、hisi_qm.ko、hisi_sec2.ko、hisi_hpre.ko内核模块\\n', '\\n', '支持：SM3/SM4/AES/RSA/DH算法\\n', '\\n', 'libwd-版本号-1.OS类型.aarch64.rpm\\n', '\\n', '包含内容：libwd.so动态链接库\\n', '\\n', '提供接口给KAE引擎\\n', '\\n', 'libkae-版本号-1.OS类型.aarch64.rpm\\n', '\\n', '依赖：libwd rpm包\\n', '\\n', '包含内容：libkae.so动态库\\n', '\\n', '支持：SM3/SM4/AES/RSA/DH等算法\\n', '\\n', '安装加速器软件包\\n', '前提条件\\n', '已在本地安装远程SSH登录工具\\n', '\\n', '已安装openEuler操作系统\\n', '\\n', 'RPM工具能正常使用。\\n', '\\n', '已安装OpenSSL 1.1.1a或以上版本。\\n', '\\n', '使用如下命令查询OpenSSL的版本号\\n', '\\n', 'openssl version\\n', '安装步骤\\n', '以root帐号登录openEuler OS命令行界面。\\n', '\\n', '新建目录用于存放加速器引擎软件包。\\n', '\\n', '使用SSH远程登录工具，将所有加速引擎软件包拷贝到已建好的目录下。\\n', '\\n', '在存放加速引擎软件包目录下，使用rpm -ivh命令安装加速器引擎软件包。\\n', '\\n', ' 说明：\\n', '由于libkae包的安装依赖libwd包，所以libwd的安装必须先于libkae。\\n', '\\n', 'rpm -ivh uacce*.rpm hisi*.rpm libwd-*.rpm libkae*.rpm\\n', 'Verifying...                          ################################# [100%]\\n', 'Preparing...                          ################################# [100%]\\n', 'checking installed modules\\n', 'uacce modules start to install\\n', 'Updating / installing...\\n', '   1:uacce-1.2.10-4.oe1               ################################# [ 14%]\\n', 'uacce modules installed\\n', '   2:libwd-1.2.10-3.oe1               ################################# [ 29%]\\n', '   3:libkae-1.2.10-3.oe1              ################################# [ 43%]\\n', 'checking installed modules\\n', 'hisi_hpre modules start to install\\n', '   4:hisi_hpre-1.2.10-4.oe1           ################################# [ 57%]\\n', 'hisi_hpre modules installed\\n', 'checking installed modules\\n', 'hisi_rde modules start to install\\n', '   5:hisi_rde-1.2.10-4.oe1            ################################# [ 71%]\\n', 'hisi_rde modules installed\\n', 'checking installed modules\\n', 'hisi_sec2 modules start to install\\n', '   6:hisi_sec2-1.2.10-4.oe1           ################################# [ 86%]\\n', 'hisi_sec2 modules installed\\n', 'checking installed modules\\n', 'hisi_zip modules start to install\\n', '   7:hisi_zip-1.2.10-4.oe1            ################################# [100%]\\n', 'hisi_zip modules installed\\n', '使用rpm -qa命令，查看加速器软件包是否已正常安装到系统内。使用rpm -ql命令 ，查看软件包的文件是否正确。示例如下。\\n', '\\n', 'rpm -qa|grep -E \"hisi|uacce|libwd|libkae\"\\n', 'hisi_rde-1.2.10-4.oe1.aarch64\\n', 'hisi_sec2-1.2.10-4.oe1.aarch64\\n', 'libkae-1.2.10-3.oe1.aarch64\\n', 'hisi_hpre-1.2.10-4.oe1.aarch64\\n', 'uacce-1.2.10-4.oe1.aarch64\\n', 'libwd-1.2.10-3.oe1.aarch64\\n', 'hisi_zip-1.2.10-4.oe1.aarch64\\n', 'rpm -ql uacce hisi* libwd* libkae\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_qm.ko\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/uacce.ko\\n', '/etc/modprobe.d/hisi_hpre.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_hpre.ko\\n', '/etc/modprobe.d/hisi_rde.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_rde.ko\\n', '/etc/modprobe.d/hisi_sec2.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_sec2.ko\\n', '/etc/modprobe.d/hisi_zip.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_zip.ko\\n', '/usr/include/warpdrive/config.h\\n', '/usr/include/warpdrive/include/uacce.h\\n', '/usr/include/warpdrive/smm.h\\n', '/usr/include/warpdrive/wd.h\\n', '/usr/include/warpdrive/wd_bmm.h\\n', '/usr/include/warpdrive/wd_cipher.h\\n', '/usr/include/warpdrive/wd_comp.h\\n', '/usr/include/warpdrive/wd_dh.h\\n', '/usr/include/warpdrive/wd_digest.h\\n', '/usr/include/warpdrive/wd_rsa.h\\n', '/usr/lib64/libwd.so.1.2.10\\n', '/usr/local/lib/engines-1.1/libkae.so.1.2.10\\n', '重启系统或通过命令行手动依次加载加速器引擎驱动到内核，并查看是否加载成功。\\n', '\\n', '# modprobe uacce \\n', '# lsmod | grep uacce \\n', '# modprobe hisi_qm\\n', '# lsmod | grep hisi_qm \\n', '# modprobe hisi_qm\\n', '# modprobe hisi_sec2 #加载hisi_sec2驱动时将根据/etc/modprobe.d/hisi_sec2.conf 下的配置文件加载到内核\\n', '# modprobe hisi_hpre #加载hisi_hpre驱动时将根据/etc/modprobe.d/hisi_hpre.conf 下的配置文件加载到内核\\n', '设置环境变量\\n', '通过以下命令导出环境变量：如果用户指定安装路径，则下面/usr/local应根据实际安装路径进行修改。\\n', '\\n', 'export OPENSSL_ENGINES=/usr/local/lib/engines-1.1\\n', '安装后检查\\n', '执行rpm -qa命令查看加速器引擎软件包是否安装成功。\\n', '\\n', '打印信息中包含“ 软件包名-版本号- ”表示该软件包安装成功。示例如下。\\n', '\\n', 'rpm -qa|grep -E \"hisi|uacce|libwd|libkae\"\\n', 'hisi_rde-1.2.10-4.oe1.aarch64\\n', 'hisi_sec2-1.2.10-4.oe1.aarch64\\n', 'libkae-1.2.10-3.oe1.aarch64\\n', 'hisi_hpre-1.2.10-4.oe1.aarch64\\n', 'uacce-1.2.10-4.oe1.aarch64\\n', 'libwd-1.2.10-3.oe1.aarch64\\n', 'hisi_zip-1.2.10-4.oe1.aarch64\\n', '安装后操作\\n', 'OpenSSL加速器引擎测试\\n', '用户可以通过以下命令测试部分加速器功能。\\n', '\\n', '使用OpenSSL的软件算法测试RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed rsa2048\\n', '...\\n', '                 sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.001384s 0.000035s   724.1  28365.8.\\n', '使用KAE引擎的测试RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -engine kae rsa2048\\n', '....\\n', '                 sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.000355s 0.000022s   2819.0  45478.4\\n', ' 说明：\\n', '使用KAE引擎加速后签名性能从724.1 sign/s提升到2819sign/s。\\n', '\\n', '使用OpenSSL的软件算法测试异步RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -async_jobs 36 rsa2048 \\n', '....\\n', '                  sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.001318s 0.000032s    735.7  28555\\n', '使用KAE引擎的测试异步RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -engine kae -elapsed -async_jobs 36 rsa2048 \\n', '.... \\n', '                  sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.000018s 0.000009s  54384.1 105317.0\\n', ' 说明：\\n', '使用KAE引擎加速后异步RSA签名性能从735.7 sign/s提升到 54384.1sign/s。\\n', '\\n', '使用OpenSSL的软件算法测试SM4 CBC模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp sm4-cbc\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', '....\\n', \"Doing sm4-cbc for 3s on 10240 size blocks: 2196 sm4-cbc's in 3.00s  ....\\n\", 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'sm4-cbc          82312.53k    85196.80k    85284.18k    85000.85k    85284.18k    85261.26k\\n', '使用KAE引擎的测试SM4 CBC模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -engine kae -evp sm4-cbc\\n', 'engine \"kae\" set. \\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', '...\\n', \"Doing sm4-cbc for 3s on 1048576 size blocks: 11409 sm4-cbc's in 3.00s\\n\", '...\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'sm4-cbc         383317.33k   389427.20k   395313.15k   392954.73k   394264.58k   394264.58k\\n', ' 说明：\\n', '使用KAE加速后SM4 CBC模式在输入数据块大小为8M时，从82312.53k/s提升到383317.33k/s。\\n', '\\n', '使用OpenSSL的软件算法测试SM3模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp sm3\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing sm3 for 3s on 102400 size blocks: 1536 sm3's in 3.00s\\n\", '....\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'sm3              50568.53k    52428.80k    52428.80k    52428.80k    52428.80k    52428.80k\\n', '使用KAE引擎测试SM3模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -engine kae -evp sm3\\n', 'engine \"kae\" set.\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing sm3 for 3s on 102400 size blocks: 19540 sm3's in 3.00s\\n\", '....\\n', 'type            51200 bytes  102400 bytes  1048576 bytes 2097152 bytes 4194304 bytes 8388608 bytes\\n', 'sm3             648243.20k   666965.33k   677030.57k   678778.20k   676681.05k   668292.44k\\n', ' 说明：\\n', '使用KAE加速后SM3算法在输入数据块大小为8M时，从52428.80 k/s提升到668292.44k/s。\\n', '\\n', '使用OpenSSL软件算法测试AES算法CBC模式异步性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp aes-128-cbc -async_jobs 4\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing aes-128-cbc for 3s on 51200 size blocks: 65773 aes-128-cbc's in 3.00s\\n\", \"Doing aes-128-cbc for 3s on 102400 size blocks: 32910 aes-128-cbc's in 3.00s\\n\", '....\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'aes-128-cbc    1122525.87k  1123328.00k  1120578.22k  1121277.27k  1119879.17k  1115684.86k\\n', '使用的KEA引擎测试AES算法CBC模式异步性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp aes-128-cbc -async_jobs 4 -engine kae\\n', 'engine \"kae\" set.\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing aes-128-cbc for 3s on 51200 size blocks: 219553 aes-128-cbc's in 3.00s\\n\", \"Doing aes-128-cbc for 3s on 102400 size blocks: 117093 aes-128-cbc's in 3.00s\\n\", '....\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'aes-128-cbc    3747037.87k  3996774.40k  1189085.18k  1196774.74k  1196979.11k  1199570.94k\\n', ' 说明：\\n', '\\n', 'AES仅支持数据长度为256KB及以下场景的异步使用。\\n', '使用KAE加速后AES算法在输入数据块为100K大小时，从1123328.00k/s提升到3996774.40 k/s 。\\n', '升级加速器软件包\\n', '使用场景\\n', '当需要更新加速器软件版本时可以使用rpm -Uvh方式进行升级。\\n', '\\n', '操作步骤\\n', '从openEuler社区下载最新版本的加速引擎软件包。\\n', '\\n', '使用SSH远程登录工具，以root帐号进入Linux操作系统命令行界面。\\n', '\\n', '将下载下来的最新版本的软件包都放在某个路径下。\\n', '\\n', '在存放软件包的路径下使用rpm -Uvh 命令升级加速器驱动包及引擎库包。示例如下。\\n', '\\n', '命令和信息回显如下所示。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '使用rpm -qa 命令查询是否升级成功。确认查询到的版本是最新的升级后版本。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '重启系统或通过命令行手动卸载旧版本驱动，然后加载新版本驱动，并查看是否加载成功\\n', '\\n', '卸载旧驱动\\n', '# lsmod | grep uacce \\n', 'uacce                 262144  3 hisi_hpre,hisi_sec2,hisi_qm \\n', '# \\n', '# rmmod hisi_hpre \\n', '# rmmod hisi_sec2 \\n', '# rmmod hisi_qm \\n', '# rmmod uacce \\n', '# lsmod | grep uacce \\n', '# \\n', '加载新驱动# modprobe uacce \\n', '# modprobe hisi_qm# modprobe hisi_sec2 #加载hisi_sec2驱动时将根据/etc/modprobe.d/hisi_sec2.conf 下的配置文件加载到内核\\n', '# modprobe hisi_hpre  #加载hisi_hpre驱动时将根据/etc/modprobe.d/hisi_hpre.conf 下的配置文件加载到内核\\n', '# lsmod | grep uacce \\n', 'uacce                36864  3 hisi_sec2,hisi_qm,hisi_hpre\\n', '卸载加速器软件包\\n', '使用场景\\n', '用户不再使用加速引擎软件，或进行新版本加速引擎软件的安装。\\n', '\\n', '操作步骤\\n', '使用SSH远程登录工具，以root帐号进入Linux操作系统命令行界面。\\n', '\\n', '重启系统或通过命令行手动将已加载到内核的驱动卸载掉，并查看是否卸载成功。\\n', '\\n', '# lsmod | grep uacce \\n', 'uacce                36864  3 hisi_sec2,hisi_qm,hisi_hpre \\n', '# rmmod hisi_hpre \\n', '# rmmod hisi_sec2  \\n', '# rmmod hisi_qm \\n', '# rmmod uacce \\n', '# lsmod | grep uacce \\n', '#\\n', '通过rpm -e 命令卸载加速引擎软件包。示例如下。\\n', '\\n', ' 说明：\\n', '由于存在依赖关系，卸载libwd前须先卸载libkae引擎软件包。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '使用rpm -qa |grep 软件包名命令查询是否卸载成功。\\n', '\\n', '\\n', '\\n', '日志查询\\n', '加速器引擎涉及日志信息如表3所示。\\n', '\\n', '表 3 日志信息\\n', '\\n', '\\n', '目录\\n', '\\n', '文件名\\n', '\\n', '文件内容说明\\n', '\\n', '/var/log/\\n', '\\n', 'kae.log\\n', '\\n', 'OpenSSL引擎日志默认打印等级为error级别，如需要设置日志级别按照如下操作：\\n', '\\n', 'export KAE_CONF_ENV=/var/log/\\n', '在/var/log/下创建文件kae.cnf\\n', '在kae.cnf 文件中设置如下：\\n', '[LogSection]\\n', '\\n', 'debug_level=error #取值内容none/error/info/warning/debug\\n', '\\n', '说明：\\n', '正常情况下不建议开启info或debug级别日志，否则会导致加速器性能的下降。\\n', '\\n', '/var/log/\\n', '\\n', 'message/syslog\\n', '\\n', '内核日志路径为/var/log/message。\\n', '说明：\\n', '或通过dmesg > /var/log/dmesg.log日志收集内核相关日志，包含驱动及内核态日志。\\n', '\\n', '加速引擎的应用\\n', ' 说明：\\n', '如果用户未购买引擎许可证，建议用户不要通过kae引擎调用相应算法，否则可能会影响openssl加密算法的性能。\\n', '\\n', 'KAE引擎使用示例代码\\n', '#include <stdio.h> \\n', '\\n', '#include <stdlib.h> \\n', '\\n', '/* OpenSSL headers */ \\n', '\\n', '#include <openssl/bio.h> \\n', '\\n', '#include <openssl/ssl.h> \\n', '\\n', '#include <openssl/err.h> \\n', '\\n', '#include <openssl/engine.h> \\n', '\\n', 'int main(int argc, char **argv) \\n', '\\n', '{ \\n', '\\n', '    /* Initializing OpenSSL */ \\n', '\\n', '    SSL_load_error_strings(); \\n', '\\n', '    ERR_load_BIO_strings(); \\n', '\\n', '    OpenSSL_add_all_algorithms(); \\n', '\\n', '    /*You can use ENGINE_by_id Function to get the handle of the Huawei Accelerator Engine*/ \\n', '\\n', '    ENGINE *e = ENGINE_by_id(\"kae\"); \\n', '\\n', '    /*使能加速器异步功能，可选配置，设置为“0”表示不使能，设置为“1”表示使能，默认使能异步功能*/ \\n', '\\n', '    ENGINE_ctrl_cmd_string(e, \"KAE_CMD_ENABLE_ASYNC\", \"1\", 0) \\n', '\\n', '    ENGINE_init(e); \\n', '\\n', '\\n', '    RSA *rsa = RSA_new_method(e);#指定引擎用于RSA加解密 \\n', '\\n', '    /*The user code*/ \\n', '\\n', '    …… \\n', '\\n', '; \\n', '\\n', '    ENGINE_free(e); \\n', '\\n', '; \\n', '\\n', '}\\n', '通过OpenSSL配置文件openssl.cnf使用KAE引擎\\n', '新建openssl.cnf 需要添加如下配置信息\\n', '\\n', 'openssl_conf=openssl_def \\n', '[openssl_def] \\n', 'engines=engine_section \\n', '[engine_section] \\n', 'kae=kae_section \\n', '[kae_section] \\n', 'engine_id=kae \\n', 'dynamic_path=/usr/local/lib/engines-1.1/kae.so \\n', 'KAE_CMD_ENABLE_ASYNC=1    # 0，表示不使能异步功能，1表示使能异步功能，默认使能 \\n', 'default_algorithms=ALL \\n', 'init=1\\n', '导出OPENSSL_CONF环境变量：\\n', '\\n', 'export OPENSSL_CONF=/home/app/openssl.cnf  #该路径为openssl.cnf存放路径\\n', '使用OpenSSL配置文件示例如下：\\n', '\\n', '#include <stdio.h>  \\n', '\\n', '#include <stdlib.h>  \\n', '\\n', '/* OpenSSL headers */  \\n', '\\n', '#include <openssl/bio.h>  \\n', '\\n', '#include <openssl/ssl.h>  \\n', '\\n', '#include <openssl/err.h>  \\n', '\\n', '#include <openssl/engine.h>  \\n', '\\n', 'int main(int argc, char **argv)  \\n', '\\n', '{  \\n', '\\n', '    /* Initializing OpenSSL */  \\n', '\\n', '    SSL_load_error_strings();  \\n', '\\n', '    ERR_load_BIO_strings();  \\n', '\\n', '#Load openssl configure \\n', '\\n', 'OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);    OpenSSL_add_all_algorithms();  \\n', '\\n', '    /*You can use ENGINE_by_id Function to get the handle of the Huawei Accelerator Engine*/  \\n', '\\n', '    ENGINE *e = ENGINE_by_id(\"kae\"); \\n', '\\n', '    /*The user code*/  \\n', '\\n', '    ……  \\n', '\\n', ';  \\n', '\\n', '    ENGINE_free(e);  \\n', '\\n', ';\\n', '}\\n', '故障处理\\n', '初始化失败\\n', '故障现象\\n', '加速器引擎没有完全加载成功。\\n', '\\n', '处理步骤\\n', '检查加速器驱动是否加载成功，运行lsmod 命令查看uacce.ko、qm.ko 、sgl.ko 、hisi_sec2.ko 、hisi_hpre.ko 、hisi_zip.ko、 hisi_rde.ko是否在位。\\n', '\\n', '# lsmod | grep uacce\\n', 'uacce                  262144  2 hisi_hpre,hisi_qm,hisi_sec2,hisi_zip,hisi_rde\\n', '检查/usr/lib64（RPM方式安装时目录）或者/usr/local/lib（源码方式安装时目录）和OpenSSL安装目录是否有加速器引擎库，且建立正确的软连接。\\n', '\\n', ' [root@localhost home]# ll /usr/local/lib/engines-1.1/ |grep kae \\n', '#查询kae是否正确安装并建立软连接，如果有正确安装显示如下内容\\n', '# ll /usr/local/lib/engines-1.1/ |grep kae\\n', 'lrwxrwxrwx. 1 root root     22 Nov 12 02:33 kae.so -> kae.so.1.0.1\\n', 'lrwxrwxrwx. 1 root root     22 Nov 12 02:33 kae.so.0 -> kae.so.1.0.1\\n', '-rwxr-xr-x. 1 root root 112632 May 25  2019 kae.so.1.0.1\\n', '[[root@localhost home]#\\n', ' [root@localhost home]# ll /usr/lib64/ | grep libwd  \\n', ' #查询libwd是否正确安装并建立软连接，如果有正确安装显示如下内容\\n', 'lrwxrwxrwx.  1 root root       14 Nov 12 02:33 libwd.so -> libwd.so.1.0.1\\n', 'lrwxrwxrwx.  1 root root       14 Nov 12 02:33 libwd.so.0 -> libwd.so.1.0.1\\n', '-rwxr-xr-x.  1 root root   137120 May 25  2019 libwd.so.1.0.1\\n', '[root@localhost home]#\\n', '检查OpenSSL引擎库的路径是否能通过export命令进行导出。\\n', '\\n', '# echo $OPENSSL_ENGINES \\n', '# export OPENSSL_ENGINES=/usr/local/lib/engines-1.1\\n', '#  echo $OPENSSL_ENGINES\\n', '/usr/local/lib/engines-1.1\\n', '安装完加速器引擎之后，查找不到加速器设备\\n', '故障现象\\n', '安装完加速器引擎之后，查找不到加速器设备。\\n', '\\n', '解决方法\\n', '检查虚拟文件系统下是否有相应设备。正常情况下有如下相应的加速器设备。\\n', '\\n', '# ls -al /sys/class/uacce/\\n', 'total 0\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 03:45 hisi_hpre-2 -> ../../devices/pci0000:78/0000:78:00.0/0000:79:00.0/uacce/hisi_hpre-2\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 03:45 hisi_hpre-3 -> ../../devices/pci0000:b8/0000:b8:00.0/0000:b9:00.0/uacce/hisi_hpre-3\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_rde-4 -> ../../devices/pci0000:78/0000:78:01.0/uacce/hisi_rde-4\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_rde-5 -> ../../devices/pci0000:b8/0000:b8:01.0/uacce/hisi_rde-5\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 08:39 hisi_sec-0 -> ../../devices/pci0000:74/0000:74:01.0/0000:76:00.0/uacce/hisi_sec-0\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 08:39 hisi_sec-1 -> ../../devices/pci0000:b4/0000:b4:01.0/0000:b6:00.0/uacce/hisi_sec-1\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_zip-6 -> ../../devices/pci0000:74/0000:74:00.0/0000:75:00.0/uacce/hisi_zip-6\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_zip-7 -> ../../devices/pci0000:b4/0000:b4:00.0/0000:b5:00.0/uacce/hisi_zip-7\\n', '若要使用hpre设备但是在1中未查询到，请按初始化失败排查加速器软件是否已正确安装。\\n', '\\n', '若2已确认加速器软件正确安装，请排查通过lspci命令查看物理设备是否存在。\\n', '\\n', '# lspci | grep HPRE\\n', '79:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon HPRE Engine (rev 21)\\n', 'b9:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon HPRE Engine (rev 21)\\n', '## lspci | grep SEC\\n', '76:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon SEC Engine (rev 21)\\n', 'b6:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon SEC Engine (rev 21)\\n', '## lspci | grep RDE\\n', '78:01.0 RAID bus controller: Huawei Technologies Co., Ltd. HiSilicon RDE Engine (rev 21)\\n', 'b8:01.0 RAID bus controller: Huawei Technologies Co., Ltd. HiSilicon RDE Engine (rev 21)\\n', '## lspci | grep ZIP\\n', '75:00.0 Processing accelerators: Huawei Technologies Co., Ltd. HiSilicon ZIP Engine (rev 21)\\n', 'b5:00.0 Processing accelerators: Huawei Technologies Co., Ltd. HiSilicon ZIP Engine (rev 21)\\n', '#\\n', '若3未查询到相应的物理设备，请确认以下，不分先后：\\n', '\\n', '确认是否已导入加速器许可证，若未导入，请请参考《TaiShan 机架服务器 iBMC (V500及以上) 用户指南》中“许可证管理”章节，导入加速器许可证。导入加速器许可证之后，需要掉电重启BMC，使能License。\\n', '确认BMC和BIOS版本是否支持加速器特性。\\n', '升级加速器驱动失败\\n', '故障现象\\n', '升级加速器驱动后，重启系统驱动版本仍为旧版本。\\n', '\\n', '可能原因\\n', '在升级加速器驱动前，系统更新了其他驱动包，这些驱动包可能重新更新了引导文件系统initramfs，将未升级前的加速器驱动一起更新到了initramfs文件系统中。例如系统更新了网卡驱动，或者人为更新了initramfs文件系统，导致系统重启时优先从initramfs文件系统中加载加速器驱动。\\n', '\\n', '处理步骤\\n', '升级加速器驱动版本后，通过执行dracut --force命令重新更新initramfs文件系统。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_使用LVM管理硬盘.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8LVM%E7%AE%A1%E7%90%86%E7%A1%AC%E7%9B%98.html", "text_entry": "['使用LVM管理硬盘\\n', '使用LVM管理硬盘\\n', 'LVM简介\\n', '基本概念\\n', '安装\\n', '管理物理卷\\n', '创建物理卷\\n', '查看物理卷\\n', '修改物理卷属性\\n', '删除物理卷\\n', '管理卷组\\n', '创建卷组\\n', '查看卷组\\n', '修改卷组属性\\n', '扩展卷组\\n', '收缩卷组\\n', '删除卷组\\n', '管理逻辑卷\\n', '创建逻辑卷\\n', '查看逻辑卷\\n', '调整逻辑卷大小\\n', '扩展逻辑卷\\n', '收缩逻辑卷\\n', '删除逻辑卷\\n', '创建并挂载文件系统\\n', '创建文件系统\\n', '手动挂载文件系统\\n', '自动挂载文件系统\\n', 'LVM简介\\n', 'LVM是逻辑卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制。LVM通过在硬盘和文件系统之间添加一个逻辑层，来为文件系统屏蔽下层硬盘分区布局，提高硬盘分区管理的灵活性，\\n', '\\n', '使用LVM管理硬盘的基本过程如下：\\n', '\\n', '将硬盘创建为物理卷\\n', '将多个物理卷组合成卷组\\n', '在卷组中创建逻辑卷\\n', '在逻辑卷之上创建文件系统\\n', '通过LVM管理硬盘之后，文件系统不再受限于硬盘的大小，可以分布在多个硬盘上，也可以动态扩容。\\n', '\\n', '基本概念\\n', '物理存储介质（The physical media）：指系统的物理存储设备，如硬盘，系统中为/dev/hda、/dev/sda等等，是存储系统最低层的存储单元。\\n', '\\n', '物理卷（Physical Volume，PV）：指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块。物理卷包括一个特殊的标签，该标签默认存放在第二个 512 字节扇区，但也可以将标签放在最开始的四个扇区之一。该标签包含物理卷的随机唯一识别符（UUID），记录块设备的大小和LVM元数据在设备中的存储位置。\\n', '\\n', '卷组（Volume Group，VG）：由物理卷组成，屏蔽了底层物理卷细节。可在卷组上创建一个或多个逻辑卷且不用考虑具体的物理卷信息。\\n', '\\n', '逻辑卷（Logical Volume，LV）：卷组不能直接用，需要划分成逻辑卷才能使用。逻辑卷可以格式化成不同的文件系统，挂载后直接使用。\\n', '\\n', '物理块（Physical Extent，PE）：物理卷以大小相等的“块”为单位存储，块的大小与卷组中逻辑卷块的大小相同。\\n', '\\n', '逻辑块（Logical Extent，LE）：逻辑卷以“块”为单位存储，在一卷组中的所有逻辑卷的块大小是相同的。\\n', '\\n', '安装\\n', ' 说明：\\n', 'openEuler操作系统默认已安装LVM。可通过rpm -qa | grep lvm2命令查询，若打印信息中包含“lvm2”信息，则表示已安装LVM，可跳过本章节内；若无任何打印信息，则表示未安装，可参考本章节内容进行安装。\\n', '\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装LVM。\\n', '\\n', '# dnf install lvm2\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep lvm2\\n', '管理物理卷\\n', '创建物理卷\\n', '可在root权限下通过pvcreate命令创建物理卷。\\n', '\\n', 'pvcreate [option] devname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制创建物理卷，不需要用户确认。\\n', '\\n', '-u：指定设备的UUID。\\n', '\\n', '-y：所有的问题都回答“yes”。\\n', '\\n', 'devname：指定要创建的物理卷对应的设备名称，如果需要批量创建，可以填写多个设备名称，中间以空格间隔。\\n', '\\n', '示例1：将/dev/sdb、/dev/sdc创建为物理卷。\\n', '\\n', '# pvcreate /dev/sdb /dev/sdc\\n', '示例2：将/dev/sdb1、/dev/sdb2创建为物理卷。\\n', '\\n', '# pvcreate /dev/sdb1 /dev/sdb2\\n', '查看物理卷\\n', '可在root权限通过pvdisplay命令查看物理卷的信息，包括：物理卷名称、所属的卷组、物理卷大小、PE大小、总PE数、可用PE数、已分配的PE数和UUID。\\n', '\\n', 'pvdisplay [option] devname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-s：以短格式输出。\\n', '-m：显示PE到LE的映射。\\n', 'devname：指定要查看的物理卷对应的设备名称。如果不指定物理卷名称，则显示所有物理卷的信息。\\n', '\\n', '示例：显示物理卷/dev/sdb的基本信息。\\n', '\\n', '# pvdisplay /dev/sdb\\n', '修改物理卷属性\\n', '可在root权限下通过pvchange命令修改物理卷的属性。\\n', '\\n', 'pvchange [option] pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-u：生成新的UUID。\\n', '-x：是否允许分配PE”。\\n', 'pvname：指定要要修改属性的物理卷对应的设备名称，如果需要批量修改，可以填写多个设备名称，中间以空格间隔。\\n', '\\n', '示例：禁止分配/dev/sdb物理卷上的PE。\\n', '\\n', '# pvchange -x n /dev/sdb\\n', '删除物理卷\\n', '可在root权限下通过pvremove命令删除物理卷。\\n', '\\n', 'pvremove [option] pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制删除物理卷，不需要用户确认。\\n', '-y：所有的问题都回答“yes”。\\n', 'pvname：指定要删除的物理卷对应的设备名称，如果需要批量删除，可以填写多个设备名称，中间以空格间隔。\\n', '\\n', '示例：删除物理卷/dev/sdb。\\n', '\\n', '# pvremove /dev/sdb\\n', '管理卷组\\n', '创建卷组\\n', '可在root权限下通过vgcreate命令创建卷组。\\n', '\\n', 'vgcreate [option] vgname pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-l：卷组上允许创建的最大逻辑卷数。\\n', '-p：卷组中允许添加的最大物理卷数。\\n', '-s：卷组上的物理卷的PE大小。\\n', 'vgname：要创建的卷组名称。\\n', '\\n', 'pvname：要加入到卷组中的物理卷名称。\\n', '\\n', '示例：创建卷组 vg1，并且将物理卷/dev/sdb和/dev/sdc添加到卷组中。\\n', '\\n', '# vgcreate vg1 /dev/sdb /dev/sdc  \\n', '查看卷组\\n', '可在root权限下通过vgdisplay命令查看卷组的信息。\\n', '\\n', 'vgdisplay [option] [vgname]\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-s：以短格式输出。\\n', '-A：仅显示活动卷组的属性。\\n', 'vgname：指定要查看的卷组名称。如果不指定卷组名称，则显示所有卷组的信息。\\n', '\\n', '示例：显示卷组vg1的基本信息。\\n', '\\n', '# vgdisplay vg1\\n', '修改卷组属性\\n', '可在root权限下通过vgchange命令修改卷组的属性。\\n', '\\n', 'vgchange [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-a：设置卷组的活动状态。\\n', 'vgname：指定要修改属性的卷组名称。\\n', '\\n', '示例：将卷组vg1状态修改为活动。\\n', '\\n', '# vgchange -ay vg1\\n', '扩展卷组\\n', '可在root权限下通过vgextend命令动态扩展卷组。它通过向卷组中添加物理卷来增加卷组的容量。\\n', '\\n', 'vgextend [option] vgname pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-d：调试模式。\\n', '-t：仅测试。\\n', 'vgname：要扩展容量的卷组名称。\\n', '\\n', 'pvname：要加入到卷组中的物理卷名称。\\n', '\\n', '示例：向卷组vg1中添加物理卷/dev/sdb。\\n', '\\n', '# vgextend vg1 /dev/sdb\\n', '收缩卷组\\n', '可在root权限下通过vgreduce命令删除卷组中的物理卷来减少卷组容量。不能删除卷组中剩余的最后一个物理卷。\\n', '\\n', 'vgreduce [option] vgname pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-a：如果命令行中没有指定要删除的物理卷，则删除所有的空物理卷。\\n', '--removemissing：删除卷组中丢失的物理卷，使卷组恢复正常状态。\\n', 'vgname：要收缩容量的卷组名称。\\n', '\\n', 'pvname：要从卷组中删除的物理卷名称。\\n', '\\n', '示例：从卷组vg1中移除物理卷/dev/sdb2。\\n', '\\n', '# vgreduce vg1 /dev/sdb2\\n', '删除卷组\\n', '可在root权限下通过vgremove命令删除卷组。\\n', '\\n', 'vgremove [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制删除卷组，不需要用户确认。\\n', 'vgname：指定要删除的卷组名称。\\n', '\\n', '示例：删除卷组vg1。\\n', '\\n', '# vgremove vg1\\n', '管理逻辑卷\\n', '创建逻辑卷\\n', '可在root权限下通过lvcreate命令创建逻辑卷。\\n', '\\n', 'lvcreate [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-n：指定要创建的逻辑卷名称。\\n', '-s：创建快照。\\n', 'vgname：要创建逻辑卷的卷组名称。\\n', '\\n', '示例1：在卷组vg1中创建10G大小的逻辑卷。\\n', '\\n', '# lvcreate -L 10G vg1\\n', '示例2：在卷组vg1中创建200M的逻辑卷，并命名为lv1。\\n', '\\n', '# lvcreate -L 200M -n lv1 vg1\\n', '查看逻辑卷\\n', '可在root权限下通过lvdisplay命令查看逻辑卷的信息，包括逻辑卷空间大小、读写状态和快照信息等属性。\\n', '\\n', 'lvdisplay [option] [lvname]\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-v：显示LE到PE的映射\\n', '\\n', 'lvname：指定要显示属性的逻辑卷对应的设备文件。如果省略，则显示所有的逻辑卷属性。\\n', '\\n', ' 说明：\\n', '逻辑卷对应的设备文件保存在卷组目录下，例如：在卷组vg1上创建一个逻辑卷lv1，则此逻辑卷对应的设备文件为/dev/vg1/lv1。\\n', '\\n', '示例：显示逻辑卷lv1的基本信息。\\n', '\\n', '# lvdisplay /dev/vg1/lv1\\n', '调整逻辑卷大小\\n', '可在root权限下通过lvresize命令调整LVM逻辑卷的空间大小，可以增大空间和缩小空间。使用lvresize命令调整逻辑卷空间大小和缩小空间时需要谨慎，因为有可能导致数据丢失。\\n', '\\n', 'lvresize [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-f：强制调整逻辑卷大小，不需要用户确认。\\n', 'lvname：指定要调整的逻辑卷名称。\\n', '\\n', '示例1：为逻辑卷/dev/vg1/lv1增加200M空间。\\n', '\\n', '# lvresize -L +200 /dev/vg1/lv1\\n', '示例2：为逻辑卷/dev/vg1/lv1减少200M空间。\\n', '\\n', '# lvresize -L -200 /dev/vg1/lv1\\n', '扩展逻辑卷\\n', '可在root权限下通过lvextend命令动态在线扩展逻辑卷的空间大小，而不中断应用程序对逻辑卷的访问。\\n', '\\n', 'lvextend [option] lvname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-f：强制调整逻辑卷大小，不需要用户确认。\\n', 'lvname：指定要扩展空间的逻辑卷的设备文件。\\n', '\\n', '示例：为逻辑卷/dev/vg1/lv1增加100M空间。\\n', '\\n', '# lvextend -L +100M /dev/vg1/lv1\\n', '收缩逻辑卷\\n', '可在root权限下通过lvreduce命令减少逻辑卷占用的空间大小。使用lvreduce命令收缩逻辑卷的空间大小有可能会删除逻辑卷上已有的数据，所以在操作前必须进行确认。\\n', '\\n', 'lvreduce [option] lvname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-f：强制调整逻辑卷大小，不需要用户确认。\\n', 'lvname：指定要扩展空间的逻辑卷的设备文件。\\n', '\\n', '示例：将逻辑卷/dev/vg1/lv1的空间减少100M。\\n', '\\n', '# lvreduce -L -100M /dev/vg1/lv1\\n', '删除逻辑卷\\n', '可在root权限下通过lvremove命令删除逻辑卷。如果逻辑卷已经使用mount命令加载，则不能使用lvremove命令删除。必须使用umount命令卸载后，逻辑卷方可被删除。\\n', '\\n', 'lvremove [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制删除逻辑卷，不需要用户确认。\\n', 'vgname：指定要删除的逻辑卷。\\n', '\\n', '示例：删除逻辑卷/dev/vg1/lv1。\\n', '\\n', '# lvremove /dev/vg1/lv1\\n', '创建并挂载文件系统\\n', '在创建完逻辑卷之后，需要在逻辑卷之上创建文件系统并挂载文件系统到相应目录下。\\n', '\\n', '创建文件系统\\n', '可在root权限下通过mkfs命令创建文件系统。\\n', '\\n', 'mkfs [option] lvname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-t：指定创建的linux系统类型，如ext2，ext3，ext4等等，默认类型为ext2。\\n', 'lvname：指定要创建的文件系统对应的逻辑卷设备文件名。\\n', '\\n', '示例：在逻辑卷/dev/vg1/lv1上创建ext4文件系统。\\n', '\\n', '# mkfs -t ext4 /dev/vg1/lv1\\n', '手动挂载文件系统\\n', '手动挂载的文件系统仅在当时有效，一旦操作系统重启则会不存在。\\n', '\\n', '可在root权限下通过mount命令挂载文件系统。\\n', '\\n', 'mount lvname mntpath\\n', '其中：\\n', '\\n', 'lvname：指定要挂载文件系统的逻辑卷设备文件名。\\n', 'mntpath：挂载路径。\\n', '示例：将逻辑卷/dev/vg1/lv1挂载到/mnt/data目录。\\n', '\\n', '# mount /dev/vg1/lv1 /mnt/data\\n', '自动挂载文件系统\\n', '手动挂载的文件系统在操作系统重启之后会不存在，需要重新手动挂载文件系统。但若在手动挂载文件系统后在root权限下进行如下设置，可以实现操作系统重启后文件系统自动挂载文件系统。\\n', '\\n', '执行blkid命令查询逻辑卷的UUID，逻辑卷以/dev/vg1/lv1为例。\\n', '\\n', '# blkid /dev/vg1/lv1\\n', '查看打印信息，打印信息中包含如下内容，其中 uuidnumber 是一串数字，为UUID， fstype 为文件系统。\\n', '\\n', '/dev/vg1/lv1: UUID=\" uuidnumber \" TYPE=\" fstype \"\\n', '\\n', '执行vi /etc/fstab命令编辑fstab文件，并在最后加上如下内容。\\n', '\\n', 'UUID=uuidnumber  mntpath                   fstype    defaults        0 0\\n', '内容说明如下：\\n', '\\n', '第一列：UUID，此处填写1查询的 uuidnumber 。\\n', '第二列：文件系统的挂载目录 mntpath 。\\n', '第三列：文件系统的文件格式，此处填写1查询的 fstype 。\\n', '第四列：挂载选项，此处以“defaults”为例；\\n', '第五列：备份选项，设置为“1”时，系统自动对该文件系统进行备份；设置为“0”时，不进行备份。此处以“0”为例；\\n', '第六列：扫描选项，设置为“1”时，系统在启动时自动对该文件系统进行扫描；设置为“0”时，不进行扫描。此处以“0”为例。\\n', '验证自动挂载功能。\\n', '\\n', '执行umount命令卸载文件系统，逻辑卷以/dev/vg1/lv1为例。\\n', '\\n', '# umount /dev/vg1/lv1\\n', '执行如下命令，将/etc/fstab文件所有内容重新加载。\\n', '\\n', '# mount -a\\n', '执行如下命令，查询文件系统挂载信息，挂载目录以/mnt/data为例。\\n', '\\n', '# mount | grep /mnt/data\\n', '查看打印信息，若信息中包含如下信息表示自动挂载功能生效。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_可信计算.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97.html", "text_entry": "['可信计算\\n', '可信计算\\n', '可信计算基础\\n', '可信计算\\n', '内核完整性度量（IMA）\\n', '概述\\n', '约束限制\\n', '使用场景\\n', '操作指导\\n', 'FAQ\\n', '附录\\n', '可信计算基础\\n', '可信计算\\n', '不同国际组织对可信（Trusted）做了不同的定义。\\n', '\\n', '可信计算组织（TCG）的定义：\\n', '\\n', '一个实体是可信的，它的行为总是以预期的方式达到预期的目标。\\n', '\\n', '国际标准化组织与国际电子技术委员会定义（1999）：\\n', '\\n', '参与计算的组件、操作或过程在任意的条件下是可预测的，并能够抵御病毒和一定程度的物理干扰。\\n', '\\n', 'IEEE Computer Society Technical Committee on Dependable Computing 定义：\\n', '\\n', '所谓可信，是指计算机系统所提供的服务是可被论证其是可信赖的，可信赖主要是指系统的可靠性和可用性。\\n', '\\n', '简而言之，可信就是系统按照预定的设计和策略运行，不做其他事情。\\n', '\\n', '一个可信计算系统由信任根、可信硬件平台、可信操作系统和可信应用组成，它的基本思想是首先创建一个安全信任根（TCB），然后建立从硬件平台、操作系统到应用的信任链，在这条信任链上从根开始，前一级认证后一级，实现信任的逐级扩展，从而实现一个安全可信的计算环境。\\n', '\\n', '\\n', '\\n', '相比于传统安全机制的“头痛医头，脚痛医脚”，发现一个病毒消灭一个病毒，可信计算采用的是白名单机制，即只允许经过认证的内核、内核模块、应用程序等在系统上运行，如果发现程序已发生更改（或本来就是一个未知的程序），就拒绝其执行。\\n', '\\n', '内核完整性度量（IMA）\\n', '概述\\n', 'IMA\\n', 'IMA，全称 Integrity Measurement Architecture（完整性度量架构），是内核中的一个子系统，能够基于自定义策略对通过 execve()、mmap() 和 open() 系统调用访问的文件进行度量，度量结果可被用于本地/远程证明，或者和已有的参考值比较以控制对文件的访问。\\n', '\\n', '根据 IMA wiki 的定义，内核完整性子系统的功能可以被分为三部分：\\n', '\\n', '度量（measure）：检测对文件的意外或恶意修改，无论远程还是本地。\\n', '评估（appraise）：度量文件并与一个存储在扩展属性中的参考值作比较，控制本地文件完整性。\\n', '审计（audit）：将度量结果写到系统日志中，用于审计。\\n', '可以看到，相比于 IMA 度量作为一个“只记录不干涉”的观察员，IMA 评估更像是一位严格的保安人员，它的职责是拒绝对所有“人证不一”的程序的访问。\\n', '\\n', 'EVM\\n', 'EVM，全称 Extended Verification Module（扩展验证模块），它的作用就是将系统当中某个文件的安全扩展属性，包括 security.ima 、security.selinux 等合起来计算一个哈希值，然后使用 TPM 中存的密钥或其他可信环境中的密钥对其进行签名，签名之后的值存在 security.evm 中，这个签名后的值是不能被篡改的，如果被篡改，再次访问的时候就会验签失败。\\n', '\\n', '总而言之，EVM 的作用就是通过对安全扩展属性计算摘要和签名并将其存储在 security.evm 中，提供对安全扩展属性的离线保护。\\n', '\\n', 'IMA Digest Lists\\n', 'IMA Digest Lists（IMA 摘要列表扩展）是 openEuler 对内核原生完整性保护机制的增强，它取代了原生 IMA 机制为文件完整性提供保护。\\n', '\\n', '“摘要列表”（digest lists）是一种特殊格式的二进制数据文件，它与 rpm 包一一对应，记录了 rpm 包中受保护文件（即可执行文件和动态库文件）的哈希值。\\n', '\\n', '当正确配置启动参数后，内核将维护一个哈希表（对用户空间不可见），并通过 securityfs 对外提供更新哈希表的接口（digest_list_data 和 digest_list_data_del）。摘要列表在构建阶段经过私钥签名，通过接口上传到内核时，需经过内核中的公钥验证。\\n', '\\n', '\\n', '\\n', '在开启 IMA 评估的情况下，每当访问一个可执行文件或动态库文件，就会调用内核中的钩子，计算文件内容和扩展属性的哈希值，并在内核哈希表中进行搜索，如果匹配就允许文件的执行，否则就拒绝访问。\\n', '\\n', '1599719649188\\n', '\\n', '相比内核社区原生 IMA 机制，openEuler 内核提供的 IMA 摘要列表扩展从安全性、性能、易用性三个方面进行了改良，助力完整性保护机制在生产环境下落地：\\n', '\\n', '具备完整的信任链，安全性好\\n', '\\n', '原生 IMA 机制要求在现网环境下预先生成并标记文件扩展属性，访问文件时将文件扩展属性作为参考值，信任链不完整。\\n', '\\n', 'IMA 摘要列表扩展将文件参考摘要值保存在内核空间中，构建阶段通过摘要列表的形式携带在发布的 rpm 包中，安装 rpm 包的同时导入摘要列表并执行验签，确保了参考值来自于软件发行商，实现了完整的信任链。\\n', '\\n', '惊艳的性能\\n', '\\n', '由于 TPM 芯片是一种低速芯片，因此 PCR 扩展操作成为了 IMA 度量场景的性能瓶颈。摘要列表扩展在确保安全性的前提下，减少了不必要的 PCR 扩展操作，相比原生 IMA 性能提升高达 65%。\\n', '\\n', 'IMA 评估场景下，摘要列表扩展将签名验证统一移动到启动阶段进行，避免每次访问文件时都执行验签，相比原生 IMA 评估场景提升运行阶段文件访问的性能约 20%。\\n', '\\n', '快速部署，平滑升级\\n', '\\n', '原生 IMA 机制在初次部署或每次更新软件包时，都需要切换到 fix 模式手动标记文件扩展属性后再重启进入 enforce 模式，才能正常访问安装的程序。\\n', '\\n', '摘要列表扩展可实现安装完成后开箱即用，且允许直接在 enforce 模式下安装或升级 rpm 包，无需重启和手动标记即可使用，实现了用户感知最小化，适合现网环境下的快速部署和平滑升级。\\n', '\\n', '需要注意的是，IMA 摘要列表扩展将原生 IMA 的验签过程提前到启动阶段进行，也引入了一个假设，即内核空间的内存无法被篡改，这就使得 IMA 也依赖于其他安全机制（内核模块安全启动和内存动态度量）以保护内核内存的完整性。\\n', '\\n', '但无论社区原生 IMA 机制还是 IMA 摘要列表扩展，都只是可信计算信任链中的一环，无法孤立地保证系统的安全性，安全自始至终都是一个构建纵深防御的系统工程。\\n', '\\n', '约束限制\\n', '当前 IMA 评估模式仅支持保护系统中的不可变文件（包括可执行文件和动态库文件）。\\n', 'IMA 提供的是应用层的完整性度量，它的安全性依赖于之前环节的可信。\\n', '当前阶段 IMA 不支持第三方应用摘要列表的导入。\\n', '启动日志中可能存在 Unable to open file: /etc/keys/x509_ima.der 字样，该报错来自于开源社区，不影响 IMA 摘要列表特性的使用。\\n', 'ARM 版本中 IMA 开启日志模式可能存在一些 audit 报错信息，这是由于 modprobe 在摘要列表未导入时加载内核模块所致，不影响正常功能。\\n', '使用场景\\n', 'IMA measurement\\n', 'IMA 度量的目的是检测对系统文件的意外或恶意修改，度量结果可被用于本地证明或远程证明。\\n', '\\n', '如果系统中存在 TPM 芯片，度量结果将被扩展到 TPM 芯片的指定 PCR 寄存器中，由于 PCR 扩展的单向性以及 TPM 芯片的硬件安全性，用户无法修改已被扩展的度量结果，这就确保了度量结果的真实性。\\n', '\\n', 'IMA 度量的文件范围和触发条件可以由用户通过 IMA 策略自行配置。\\n', '\\n', '默认情况下 IMA 不启用，但系统会前往 /etc/ima/ 路径下寻找 ima-policy 策略文件，如果找到，就会按照策略在启动时度量系统中的文件。如果不想手动编写策略文件，也可以在启动参数中配置 ima_policy=tcb 使用默认策略（更多策略参数请参考附录“IMA启动参数”章节）。\\n', '\\n', '系统当前加载的 IMA 策略可以在 /sys/kernel/security/ima/policy 文件中查看，IMA 度量日志则位于/sys/kernel/security/ima/ascii_runtime_measurements 文件中，如下所示：\\n', '\\n', '$ head /sys/kernel/security/ima/ascii_runtime_measurements\\n', '10 ddee6004dc3bd4ee300406cd93181c5a2187b59b ima-ng sha1:9797edf8d0eed36b1cf92547816051c8af4e45ee boot_aggregate\\n', '10 180ecafba6fadbece09b057bcd0d55d39f1a8a52 ima-ng sha1:db82919bf7d1849ae9aba01e28e9be012823cf3a /init\\n', '10 ac792e08a7cf8de7656003125c7276968d84ea65 ima-ng sha1:f778e2082b08d21bbc59898f4775a75e8f2af4db /bin/bash\\n', '10 0a0d9258c151356204aea2498bbca4be34d6bb05 ima-ng sha1:b0ab2e7ebd22c4d17d975de0d881f52dc14359a7 /lib64/ld-2.27.so\\n', '10 0d6b1d90350778d58f1302d00e59493e11bc0011 ima-ng sha1:ce8204c948b9fe3ae67b94625ad620420c1dc838 /etc/ld.so.cache\\n', '10 d69ac2c1d60d28b2da07c7f0cbd49e31e9cca277 ima-ng sha1:8526466068709356630490ff5196c95a186092b8 /lib64/libreadline.so.7.0\\n', '10 ef3212c12d1fbb94de9534b0bbd9f0c8ea50a77b ima-ng sha1:f80ba92b8a6e390a80a7a3deef8eae921fc8ca4e /lib64/libc-2.27.so\\n', '10 f805861177a99c61eabebe21003b3c831ccf288b ima-ng sha1:261a3cd5863de3f2421662ba5b455df09d941168 /lib64/libncurses.so.6.1\\n', '10 52f680881893b28e6f0ce2b132d723a885333500 ima-ng sha1:b953a3fa385e64dfe9927de94c33318d3de56260 /lib64/libnss_files-2.27.so\\n', '10 4da8ce3c51a7814d4e38be55a2a990a5ceec8b27 ima-ng sha1:99a9c095c7928ecca8c3a4bc44b06246fc5f49de /etc/passwd\\n', '每一条记录从左到右分别是：\\n', '\\n', 'PCR：用于扩展度量结果的 PCR 寄存器，默认是 10，只在系统装了 TPM 芯片的情况下有意义。\\n', '模板哈希值：最终被用于扩展的哈希值，组合了文件内容哈希和文件路径的长度和值。\\n', '模板：扩展度量值的模板，如 ima-ng。\\n', '文件内容哈希值：被度量的文件内容的哈希值。\\n', '文件路径：被度量的文件路径。\\n', '本版本使能了ko压缩特性，当加载被压缩ko文件时，如需IMA使能appraise func=MODULE_CHECK策略，需要在启动参数配置module.sig_enforce=1。\\n', 'IMA appraisal\\n', 'IMA 评估的目的是通过与标准参考值的比较，控制对本地文件的访问。\\n', '\\n', 'IMA 首先使用安全扩展属性 security.ima 和 security.evm 存储文件完整性度量的参考值：\\n', '\\n', 'security.ima：存储文件内容的哈希值；\\n', 'security.evm：存储文件扩展属性的哈希值签名。\\n', '访问受保护文件时，将会触发内核中的钩子，依次验证文件扩展属性和内容的完整性：\\n', '\\n', '使用内核 keyring 中的公钥对文件 security.evm 扩展属性中的签名值验签，与当前文件扩展属性的哈希值比较，如果匹配就证明文件的扩展属性是完整的（包括 security.ima）。\\n', '在文件扩展属性完整的前提下，将文件 security.ima 扩展属性的内容与当前文件内容的摘要值比较，如果匹配就允许对文件的访问。\\n', '同样，IMA 评估的文件范围和触发条件也可以由用户通过 IMA 策略自行配置。\\n', '\\n', 'IMA Digest Lists\\n', 'IMA 摘要列表扩展当前提供对以下三种启动参数组合的支持：\\n', '\\n', 'IMA measurement 度量模式：\\n', '\\n', 'ima_policy=exec_tcb ima_digest_list_pcr=11\\n', 'IMA appraisal 日志模式 + IMA measurement 度量模式：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=log evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', 'IMA appraisal 强制模式 + IMA measurement 度量模式：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=enforce-evm evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', '操作指导\\n', '原生 IMA 场景初次部署\\n', '第一次启动时，需要在启动参数中配置：\\n', '\\n', 'ima_appraise=fix ima_policy=appraise_tcb\\n', 'fix 模式会允许系统在没有参考值的情况下启动，appraise_tcb 对应了一种 IMA 策略，具体可参考附录中的“IMA 启动参数”章节。\\n', '\\n', '接下来，你需要访问所有需要被校验的文件，从而为它们添加 IMA 扩展属性：\\n', '\\n', \"$ time find / -fstype ext4 -type f -uid 0 -exec dd if='{}' of=/dev/null count=0 status=none \\\\;\\n\", '该过程会花费一定时间，请耐心等待。命令执行完成后，你可以从受保护文件的扩展属性中看到参考值已被标记：\\n', '\\n', '$ getfattr -m - -d /sbin/init\\n', '# file: sbin/init\\n', 'security.ima=0sAXr7Qmun5mkGDS286oZxCpdGEuKT\\n', 'security.selinux=\"system_u:object_r:init_exec_t\"\\n', '最后，配置以下启动参数并重新启动系统：\\n', '\\n', 'ima_appraise=enforce ima_policy=appraise_tcb\\n', '摘要列表场景初次部署\\n', '配置内核参数进入 log 模式。\\n', '\\n', '编辑 /boot/efi/EFI/euleros/grub.cfg 文件，加入以下参数：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=log evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', '使用 reboot 重启系统进入 log 模式，该模式下已开启完整性校验，但不会因校验失败而无法启动。\\n', '\\n', '安装依赖包。\\n', '\\n', '使用 yum 安装 digest-list-tools 和 ima-evm-utils，确认不低于以下版本：\\n', '\\n', '$ yum install digest-list-tools ima-evm-utils\\n', '$ rpm -qa | grep digest-list-tools\\n', 'digest-list-tools-0.3.93-1.oe1.x86_64\\n', '$ rpm -qa | grep ima-evm-utils\\n', 'ima-evm-utils-1.2.1-9.oe1.x86_64\\n', '如果安装了 plymouth 包，需要编辑 /usr/libexec/plymouth/plymouth-populate-initrd 脚本文件，在第 147 行的 cp 命令后增加 -a：\\n', '\\n', '    ...\\n', '    ddebug \"Installing $_src\"\\n', ' cp -a --sparse=always -pfL \"$PLYMOUTH_SYSROOT$_src\" \"${initdir}/$target\"\\n', '}\\n', '执行 dracut 重新生成 initrd：\\n', '\\n', '$ dracut -f -e xattr\\n', '编辑 /boot/efi/EFI/euleros/grub.cfg 文件，将 ima_appraise=log 改为 ima_appraise=enforce-evm：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=enforce-evm evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', '使用 reboot 重启即可完成初次部署。\\n', '\\n', '在 OBS 上进行摘要列表构建\\n', 'OBS 全称 Open Build Service，是一种编译系统，最早在 openSUSE 用于软件包的构建，能够支持多架构的分布式编译。\\n', '\\n', '进行摘要列表构建之前，首先确保您的工程包含以下 rpm 包，且来自 openEuler：\\n', '\\n', 'digest-list-tools\\n', 'pesign-obs-integration\\n', 'selinux-policy\\n', 'rpm\\n', 'openEuler-rpm-config\\n', '在交付件工程中增加 Project Config：\\n', '\\n', 'Preinstall: pesign-obs-integration digest-list-tools selinux-policy-targeted\\n', 'Macros:\\n', '%__brp_digest_list /usr/lib/rpm/openEuler/brp-digest-list %{buildroot}\\n', ':Macros\\n', '在 Preinstall 中新增 digest-list-tools 用于生成摘要列表，pesign-obs-integration 用于生成摘要列表的签名，新增 selinux-policy-targeted 用于确保生成摘要列表时构建环境内 SELinux 标签正确。\\n', '在 Macros 中定义宏 %__brp_digest_list，rpm 将在构建阶段通过这个宏执行命令为编译完成的二进制文件生成摘要列表。这个宏可以作为一个开关控制工程中的摘要列表是否生成。\\n', '配置完成后，OBS 会自动执行全量构建，正常情况下构建完成后，软件包中会新增以下两个文件：\\n', '\\n', '/etc/ima/digest_lists/0-metadata_list-compact-[包名]-[版本号]\\n', '/etc/ima/digest_lists.tlv/0-metadata_list-compact_tlv-[包名]-[版本号]\\n', '在 Koji 上进行摘要列表构建\\n', 'Koji 是 Fedora 社区的编译系统，openEuler 社区将在后续支持，敬请期待。\\n', '\\n', 'FAQ\\n', '为什么进入 enforce 模式后系统无法启动或启动后命令无法执行/服务不正常？\\n', '\\n', 'enforce 模式下 IMA 会对文件访问做控制，如果访问文件的内容或扩展属性不完整，就会被拒绝访问，当影响启动的关键命令无法执行时，就会造成系统无法启动。\\n', '\\n', '请确认是否存在以下问题：\\n', '\\n', '摘要列表是否被加入到 initrd 中？\\n', '\\n', '初次部署时是否执行了 dracut 命令将摘要列表加入内核？如果摘要列表没有加入 initrd，启动阶段就无法导入摘要列表，从而导致启动失败。\\n', '\\n', '是否使用官方提供的 rpm 包？\\n', '\\n', '如果使用的是非 openEuler 官方提供的 rpm 包，rpm 包可能没有携带摘要列表，或者对摘要列表签名的私钥与内核中的验签公钥不匹配，从而导致摘要列表没有被导入内核。\\n', '\\n', '如果原因还不明确，可以进入 log 模式启动，从错误日志中寻找原因：\\n', '\\n', '$ dmesg | grep appraise\\n', '为什么 enforce 模式下没有对系统文件做访问控制？\\n', '\\n', '系统没有按照预期对文件执行访问控制，首先查看启动参数中的 IMA 策略是否已被正确配置：\\n', '\\n', '$ cat /proc/cmdline\\n', '...ima_policy=exec_tcb|appraise_exec_tcb|appraise_exec_immutable...\\n', '其次查看当前内核中 IMA 策略是否已生效：\\n', '\\n', '$ cat /sys/kernel/security/ima/policy\\n', '如果 policy 文件是空的，证明策略没有设置成功，系统也就不会进行访问控制。\\n', '\\n', '初次部署完成后，安装/升级/卸载软件包后还需要手动执行 dracut 生成 initrd 吗？\\n', '\\n', '不需要。rpm 包提供的 digest_list.so 插件能够在 rpm 包粒度提供摘要列表的自动更新，可以实现用户对摘要列表的无感知。\\n', '\\n', '附录\\n', 'IMA securityfs 接口说明\\n', '原生 IMA 提供的 securityfs 接口如下：\\n', '\\n', '注：以下接口路径都位于 /sys/kernel/security/ 目录下。\\n', '\\n', '路径\\t权限\\t说明\\n', 'ima/policy\\t600\\tIMA 策略接口\\n', 'ima/ascii_runtime_measurement\\t440\\tascii 码形式表示的 IMA 度量结果\\n', 'ima/binary_runtime_measurement\\t440\\t二进制形式表示的 IMA 度量结果\\n', 'ima/runtime_measurement_count\\t440\\t度量结果数量统计\\n', 'ima/violations\\t440\\tIMA 度量结果冲突数\\n', 'evm\\t660\\tEVM 模式，即校验文件扩展属性完整性的方式\\n', '其中，/sys/kernel/security/evm 的取值有以下三种：\\n', '\\n', '0：EVM 未初始化；\\n', '1：使用 HMAC（对称加密）方式校验扩展属性完整性；\\n', '2：使用公钥验签（非对称加密）方式校验扩展属性完整性；\\n', '6：关闭扩展属性完整性校验（openEuler 使用此方式）。\\n', 'IMA 摘要列表扩展额外提供的 securityfs 接口如下：\\n', '\\n', '路径\\t权限\\t说明\\n', 'ima/digests_count\\t440\\t显示系统哈希表中的总摘要数量（IMA+EVM）\\n', 'ima/digest_list_data\\t200\\t摘要列表新增接口\\n', 'ima/digest_list_data_del\\t200\\t摘要列表删除接口\\n', 'IMA 策略语法\\n', '每条 IMA 策略语句都必须以 action 关键字代表的动作开头，后接筛选条件：\\n', '\\n', 'action：表示该条策略具体的动作，一条策略只能选一个 action。\\n', '\\n', '注：实际书写时可忽略 action 字样，直接书写 dont_measure，不需要写成 action=dont_measure。\\n', '\\n', 'func：表示被度量或鉴定的文件类型，常和 mask 匹配使用，一条策略只能选一个 func。\\n', '\\n', 'FILE_CHECK 只能同 MAY_EXEC、MAY_WRITE、MAY_READ 匹配使用。\\n', 'MODULE_CHECK、MMAP_CHECK、BPRM_CHECK 只能同 MAY_EXEC 匹配使用。\\n', '匹配关系以外的组合不会产生效果。\\n', 'mask：表示文件在做什么操作时将被度量或鉴定，一条策略只能选一个 mask。\\n', '\\n', 'fsmagic：表示文件系统类型的十六进制魔数，定义在 /usr/include/linux/magic.h 文件中。\\n', '\\n', '注：默认情况下度量所有文件系统，除非使用 dont_measure/dont_appraise 标记不度量某文件系统。\\n', '\\n', 'fsuuid：表示系统设备 uuid 的 16 位的十六进制字符串。\\n', '\\n', 'objtype：表示文件类型，一条策略只能选一个文件类型。\\n', '\\n', '注：objtype 相比 func 而言，划分的粒度更细，比如 obj_type=nova_log_t 表示 nova log 类型的文件。\\n', '\\n', 'uid：表示哪个用户（用用户 id 表示）对文件进行操作，一条策略只能选一个 uid。\\n', '\\n', 'fowner：表示文件的属主（用用户 id 表示）是谁，一条策略只能选一个 fowner。\\n', '\\n', '关键字的具体取值及说明如下：\\n', '\\n', '关键字\\t值\\t说明\\n', 'action\\tmeasure\\t开启 IMA 度量\\n', 'dont_measure\\t禁用 IMA 度量\\n', 'appraise\\t开启 IMA 评估\\n', 'dont_appraise\\t禁用 IMA 评估\\n', 'audit\\t开启审计\\n', 'func\\tFILE_CHECK\\t将要被打开的文件\\n', 'MODULE_CHECK\\t将要被装载的内核模块文件\\n', 'MMAP_CHECK\\t将要被映射到进程内存空间的动态库文件\\n', 'BRPM_CHECK\\t将要被执行的文件（不含通过 /bin/hash 等程序打开的脚本文件）\\n', 'POLICY_CHECK\\t将要被作为补充 IMA 策略装载的文件\\n', 'FIRMWARE_CHECK\\t将要被加载到内存中的固件\\n', 'DIGEST_LIST_CHECK\\t将要被加载到内核中的摘要列表文件\\n', 'KEXEC_KERNEL_CHECK\\t将要切换的 kexec 内核\\n', 'mask\\tMAY_EXEC\\t执行文件\\n', 'MAY_WRITE\\t写文件。不建议使用，受限于 echo、vim 等开源机制（修改本质是新建临时文件再重命名），并不是每次修改都会触发 MAY_WRITE 的 IMA 度量。\\n', 'MAY_READ\\t读文件\\n', 'MAY_APPEND\\t扩展文件属性\\n', 'fsmagic\\tfsmagic=xxx\\t表示文件系统类型的十六进制魔数\\n', 'fsuuid\\tfsuuid=xxx\\t表示系统设备 uuid 的 16 位的十六进制字符串\\n', 'fowner\\tfowner=xxx\\t文件属主的用户 id\\n', 'uid\\tuid=xxx\\t操作文件的用户 id\\n', 'obj_type\\tobj_type=xxx_t\\t表示文件的类型（基于 SELinux 标签）\\n', 'pcr\\tpcr=<num>\\t选择 TPM 中用于扩展度量值的 PCR（默认为 10）\\n', 'appraise_type\\timasig\\t基于签名进行 IMA 评估\\n', 'meta_immutable\\t基于签名进行文件扩展属性的评估（支持摘要列表）\\n', '注：PATH_CHECK 等同于 FILE_CHECK，FILE_MMAP 等同于 MMAP_CHECK，不在本表提及。\\n', '\\n', 'IMA 原生启动参数\\n', '原生 IMA 的内核启动参数列表如下：\\n', '\\n', '参数名称\\t取值\\t功能\\n', 'ima_appraise\\toff\\t关闭 IMA 评估模式，在访问文件时不进行完整性校验，也不为文件生成新的参考值。\\n', 'enforce\\t开启 IMA 评估强制模式，在访问文件时进行完整性校验，即计算文件摘要值并与参考值比对，如果比对失败就拒绝对文件的访问。IMA 会为新文件生成新的参考值。\\n', 'fix\\t开启 IMA 修复模式，在该模式下允许更新受保护文件的参考值。\\n', 'log\\t开启 IMA 评估日志模式，在访问文件时进行完整性校验，但即使校验失败也允许执行命令，只进行日志记录。\\n', 'ima_policy\\ttcb\\t度量所有文件执行、动态库映射、内核模块导入以及设备驱动加载，此外，root 用户读文件的行为也会被度量。\\n', 'appraise_tcb\\t对所有 root 属主的文件进行评估。\\n', 'secure_boot\\t对所有内核模块导入、硬件驱动加载、kexec 内核切换以及 IMA 策略进行评估，前提是这些文件都具有 IMA 签名，\\n', 'ima_tcb\\t无\\t等价于 ima_policy=tcb\\n', 'ima_appraise_tcb\\t无\\t等价于 ima_policy=appraise_tcb\\n', 'ima_hash\\tsha1/md5/…\\tIMA 摘要算法，默认为 sha1\\n', 'ima_template\\tima\\tIMA 度量扩展模板\\n', 'ima-ng\\tIMA 度量扩展模板\\n', 'ima-sig\\tIMA 度量扩展模板\\n', 'integrity_audit\\t0\\t基础完整性审计信息（默认）\\n', '1\\t额外完整性审计信息\\n', '注：ima_policy 参数可以同时指定多个值，例如 ima_policy=tcb|appraise_tcb，启动后系统的 IMA 策略就是这两种参数对应的策略的总和。\\n', '\\n', '启动参数 ima_policy=tcb 对应的 IMA 策略为：\\n', '\\n', '# PROC_SUPER_MAGIC = 0x9fa0\\n', 'dont_measure fsmagic=0x9fa0\\n', '# SYSFS_MAGIC = 0x62656572\\n', 'dont_measure fsmagic=0x62656572\\n', '# DEBUGFS_MAGIC = 0x64626720\\n', 'dont_measure fsmagic=0x64626720\\n', '# TMPFS_MAGIC = 0x01021994\\n', 'dont_measure fsmagic=0x1021994\\n', '# DEVPTS_SUPER_MAGIC=0x1cd1\\n', 'dont_measure fsmagic=0x1cd1\\n', '# BINFMTFS_MAGIC=0x42494e4d\\n', 'dont_measure fsmagic=0x42494e4d\\n', '# SECURITYFS_MAGIC=0x73636673\\n', 'dont_measure fsmagic=0x73636673\\n', '# SELINUX_MAGIC=0xf97cff8c\\n', 'dont_measure fsmagic=0xf97cff8c\\n', '# SMACK_MAGIC=0x43415d53\\n', 'dont_measure fsmagic=0x43415d53\\n', '# CGROUP_SUPER_MAGIC=0x27e0eb\\n', 'dont_measure fsmagic=0x27e0eb\\n', '# CGROUP2_SUPER_MAGIC=0x63677270\\n', 'dont_measure fsmagic=0x63677270\\n', '# NSFS_MAGIC=0x6e736673\\n', 'dont_measure fsmagic=0x6e736673 \\n', 'measure func=MMAP_CHECK mask=MAY_EXEC \\n', 'measure func=BPRM_CHECK mask=MAY_EXEC \\n', 'measure func=FILE_CHECK mask=MAY_READ uid=0 \\n', 'measure func=MODULE_CHECK \\n', 'measure func=FIRMWARE_CHECK\\n', '启动参数 ima_policy=tcb_appraise 对应的 IMA 策略为：\\n', '\\n', '# PROC_SUPER_MAGIC = 0x9fa0\\n', 'dont_appraise fsmagic=0x9fa0\\n', '# SYSFS_MAGIC = 0x62656572\\n', 'dont_appraise fsmagic=0x62656572\\n', '# DEBUGFS_MAGIC = 0x64626720 \\n', 'dont_appraise fsmagic=0x64626720 \\n', '# TMPFS_MAGIC = 0x01021994\\n', 'dont_appraise fsmagic=0x1021994\\n', '# RAMFS_MAGIC\\n', 'dont_appraise fsmagic=0x858458f6 \\n', '# DEVPTS_SUPER_MAGIC=0x1cd1\\n', 'dont_appraise fsmagic=0x1cd1\\n', '# BINFMTFS_MAGIC=0x42494e4d\\n', 'dont_appraise fsmagic=0x42494e4d \\n', '# SECURITYFS_MAGIC=0x73636673\\n', 'dont_appraise fsmagic=0x73636673\\n', '# SELINUX_MAGIC=0xf97cff8c\\n', 'dont_appraise fsmagic=0xf97cff8c \\n', '# SMACK_MAGIC=0x43415d53\\n', 'dont_appraise fsmagic=0x43415d53 \\n', '# NSFS_MAGIC=0x6e736673\\n', 'dont_appraise fsmagic=0x6e736673 \\n', '# CGROUP_SUPER_MAGIC=0x27e0eb\\n', 'dont_appraise fsmagic=0x27e0eb \\n', '# CGROUP2_SUPER_MAGIC=0x63677270\\n', 'dont_appraise fsmagic=0x63677270 \\n', 'appraise fowner=0\\n', '启动参数 ima_policy=secure_boot 对应的 IMA 策略为：\\n', '\\n', 'appraise func=MODULE_CHECK appraise_type=imasig \\n', 'appraise func=FIRMWARE_CHECK appraise_type=imasig \\n', 'appraise func=KEXEC_KERNEL_CHECK appraise_type=imasig \\n', 'appraise func=POLICY_CHECK appraise_type=imasig\\n', 'IMA 摘要列表启动参数\\n', 'IMA 摘要列表特性额外引入的内核启动参数如下：\\n', '\\n', '参数名称\\t取值\\t功能\\n', 'integrity\\t0\\tIMA 特性总开关关闭（默认）\\n', '1\\tIMA 特性总开关打开\\n', 'ima_appraise\\toff\\t关闭 IMA 评估模式\\n', 'enforce-evm\\tIMA 评估强制模式，在访问文件时进行完整性校验并进行访问控制\\n', 'ima_appraise_digest_list\\tdigest\\t当 EVM 被禁用时，使用摘要列表进行 IMA appraise，摘要列表同时保护文件内容和扩展属性\\n', 'digest-nometadata\\t在EVM摘要值不存在的情况下，仅基于IMA摘要值进行完整性校验（不保护文件扩展属性）\\n', 'evm\\tfix\\t允许任何对扩展属性的修改（即使修改会导致扩展属性完整性校验失败）\\n', 'ignore\\t只有在扩展属性不存在或不正确的情况下才允许修改\\n', 'ima_policy\\texec_tcb\\tIMA 度量策略，详见下文策略说明。\\n', 'appraise_exec_tcb\\tIMA 评估策略，详见下文策略说明。\\n', 'appraise_exec_immutable\\tIMA 评估策略，详见下文策略说明。\\n', 'ima_digest_list_pcr\\t11\\t使用 PCR 11 替代 PCR 10，仅使用摘要列表进行度量\\n', '+11\\t依然保留 PCR 10 的度量，在有TPM芯片时也往TPM芯片写度量结果\\n', 'initramtmpfs\\t无\\t添加对 tmpfs 的支持\\n', '启动参数 ima_policy=exec_tcb 对应的 IMA 策略为：\\n', '\\n', 'dont_measure fsmagic=0x9fa0 \\n', 'dont_measure fsmagic=0x62656572 \\n', 'dont_measure fsmagic=0x64626720 \\n', 'dont_measure fsmagic=0x1cd1 \\n', 'dont_measure fsmagic=0x42494e4d \\n', 'dont_measure fsmagic=0x73636673 \\n', 'dont_measure fsmagic=0xf97cff8c \\n', 'dont_measure fsmagic=0x43415d53 \\n', 'dont_measure fsmagic=0x27e0eb \\n', 'dont_measure fsmagic=0x63677270 \\n', 'dont_measure fsmagic=0x6e736673 \\n', 'measure func=MMAP_CHECK mask=MAY_EXEC \\n', 'measure func=BPRM_CHECK mask=MAY_EXEC \\n', 'measure func=MODULE_CHECK \\n', 'measure func=FIRMWARE_CHECK \\n', 'measure func=POLICY_CHECK \\n', 'measure func=DIGEST_LIST_CHECK \\n', 'measure parser\\n', '启动参数 ima_policy=appraise_exec_tcb 对应的 IMA 策略为：\\n', '\\n', 'appraise func=MODULE_CHECK appraise_type=imasig \\n', 'appraise func=FIRMWARE_CHECK appraise_type=imasig \\n', 'appraise func=KEXEC_KERNEL_CHECK appraise_type=imasig \\n', 'appraise func=POLICY_CHECK appraise_type=imasig \\n', 'appraise func=DIGEST_LIST_CHECK appraise_type=imasig \\n', 'dont_appraise fsmagic=0x9fa0 \\n', 'dont_appraise fsmagic=0x62656572 \\n', 'dont_appraise fsmagic=0x64626720 \\n', 'dont_appraise fsmagic=0x858458f6 \\n', 'dont_appraise fsmagic=0x1cd1 \\n', 'dont_appraise fsmagic=0x42494e4d \\n', 'dont_appraise fsmagic=0x73636673 \\n', 'dont_appraise fsmagic=0xf97cff8c \\n', 'dont_appraise fsmagic=0x43415d53 \\n', 'dont_appraise fsmagic=0x6e736673 \\n', 'dont_appraise fsmagic=0x27e0eb \\n', 'dont_appraise fsmagic=0x63677270\\n', '启动参数 ima_policy=appraise_exec_immutable 对应的 IMA 策略为：\\n', '\\n', 'appraise func=BPRM_CHECK appraise_type=imasig appraise_type=meta_immutable \\n', 'appraise func=MMAP_CHECK \\n', 'appraise parser appraise_type=imasig\\n', 'IMA 内核编译选项详解\\n', '原生 IMA 提供的编译选项如下：\\n', '\\n', '编译选项\\t功能\\n', 'CONFIG_INTEGRITY\\tIMA/EVM 总编译开关\\n', 'CONFIG_INTEGRITY_SIGNATURE\\t使能 IMA 签名校验\\n', 'CONFIG_INTEGRITY_ASYMMETRIC_KEYS\\t使能 IMA 非对称签名校验\\n', 'CONFIG_INTEGRITY_TRUSTED_KEYRING\\t使能 IMA/EVM 密钥环\\n', 'CONFIG_INTEGRITY_AUDIT\\t编译 IMA audit 审计模块\\n', 'CONFIG_IMA\\tIMA 总编译开关\\n', 'CONFIG_IMA_WRITE_POLICY\\t允许在运行阶段更新 IMA 策略\\n', 'CONFIG_IMA_MEASURE_PCR_IDX\\t允许指定 IMA 度量 PCR 序号\\n', 'CONFIG_IMA_LSM_RULES\\t允许配置 LSM 规则\\n', 'CONFIG_IMA_APPRAISE\\tIMA 评估总编译开关\\n', 'IMA_APPRAISE_BOOTPARAM\\t启用 IMA 评估启动参数\\n', 'CONFIG_EVM\\tEVM 总编译开关\\n', 'IMA 摘要列表扩展额外提供的编译选项如下：\\n', '\\n', '编译选项\\t功能\\n', 'CONFIG_DIGEST_LIST\\t开启 IMA 摘要列表特性开关\\n', 'IMA 性能参考数据\\n', '下图对比了不开启 IMA、开启原生 IMA、开启 IMA 摘要列表特性时的性能：']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_基础配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html", "text_entry": "['基础配置\\n', '基础配置\\n', '设置语言环境\\n', '显示当前语言环境状态\\n', '列出可用的语言环境\\n', '设置语言环境\\n', '设置键盘\\n', '显示当前设置\\n', '列出可用的键盘布局\\n', '设置键盘布局\\n', '设置日期和时间\\n', '使用timedatectl命令设置\\n', '使用date命令设置\\n', '使用hwclock命令设置\\n', '设置kdump\\n', '设置kdump预留内存\\n', '预留内存推荐值\\n', '禁用网络相关驱动\\n', '设置磁盘调度算法\\n', '临时修改调度策略\\n', '永久设置调度策略\\n', '设置语言环境\\n', '您可以通过localectl修改系统的语言环境，对应的参数设置保存在/etc/locale.conf文件中。这些参数会在系统启动过程中被systemd的守护进程读取。\\n', '\\n', '显示当前语言环境状态\\n', '显示当前语言环境，命令如下：\\n', '\\n', '$ localectl status\\n', '例如显示系统当前的设置，命令和输出如下：\\n', '\\n', '$ localectl status\\n', '   System Locale: LANG=zh_CN.UTF-8\\n', '       VC Keymap: cn\\n', '      X11 Layout: cn\\n', '列出可用的语言环境\\n', '显示当前可用的语言环境，命令如下：\\n', '\\n', '$ localectl list-locales\\n', '例如显示当前系统中所有可用的中文环境，命令和输出如下：\\n', '\\n', '$ localectl list-locales | grep zh\\n', 'zh_CN.UTF-8\\n', '设置语言环境\\n', '要设置语言环境，在root权限下执行如下命令，其中 locale 是您要设置的语言类型，取值范围可通过localectl list-locales获取，请根据实际情况修改。\\n', '\\n', '# localectl set-locale LANG=locale\\n', '例如设置为简体中文语言环境，在root权限下执行如下命令：\\n', '\\n', '# localectl set-locale LANG=zh_CN.UTF-8\\n', ' 说明：\\n', '修改后需要重新登录或者在root权限下执行source /etc/locale.conf命令刷新配置文件，使修改生效。\\n', '\\n', '设置键盘\\n', '您可以通过localectl修改系统的键盘设置，对应的参数设置保存在/etc/locale.conf文件中。这些参数，会在系统启动的早期被systemd的守护进程读取。\\n', '\\n', '显示当前设置\\n', '显示当前键盘设置，命令如下：\\n', '\\n', '$ localectl status\\n', '例如显示系统当前的设置，命令和输出如下：\\n', '\\n', '$ localectl status\\n', '   System Locale: LANG=zh_CN.UTF-8\\n', '       VC Keymap: cn\\n', '      X11 Layout: cn\\n', '列出可用的键盘布局\\n', '显示当前可用的键盘布局，命令如下：\\n', '\\n', '$ localectl list-keymaps\\n', '例如显示系统当前的中文键盘布局，命令和输出如下：\\n', '\\n', '$ localectl list-keymaps | grep cn\\n', 'cn\\n', '设置键盘布局\\n', '设置键盘布局，在root权限下执行如下命令，其中 map 是您想要设置的键盘类型，取值范围可通过localectl list-keymaps获取，请根据实际情况修改：\\n', '\\n', '# localectl set-keymap map\\n', '此时设置的键盘布局同样也会应用到图形界面中。\\n', '\\n', '设置完成后，查看当前状态：\\n', '\\n', '$ localectl status\\n', '   System Locale: LANG=zh_CN.UTF-8\\n', '       VC Keymap: cn\\n', '      X11 Layout: us\\n', '设置日期和时间\\n', '本节介绍如何通过timedatectl、date、hwclock命令来设置系统的日期、时间和时区等。\\n', '\\n', '使用timedatectl命令设置\\n', '显示日期和时间\\n', '显示当前的日期和时间，命令如下：\\n', '\\n', '$ timedatectl\\n', '例如显示系统当前的日期和时间，命令和输出如下：\\n', '\\n', '$ timedatectl\\n', '               Local time: Mon 2019-09-30 04:05:00 EDT\\n', '           Universal time: Mon 2019-09-30 08:05:00 UTC\\n', '                 RTC time: Mon 2019-09-30 08:05:00\\n', '                Time zone: America/New_York (EDT, -0400)\\n', 'System clock synchronized: no\\n', '              NTP service: inactive\\n', '          RTC in local TZ: no\\n', '通过远程服务器进行时间同步\\n', '您可以启用NTP远程服务器进行系统时钟的自动同步。是否启用NTP，可在root权限下执行如下命令进行设置。其中 boolean 可取值yes和no，分别表示启用和不启用NTP进行系统时钟自动同步，请根据实际情况修改。\\n', '\\n', ' 说明：\\n', '若启用了NTP远程服务器进行系统时钟自动同步，则不能手动修改日期和时间。若需要手动修改日期或时间，则需确保已经关闭NTP系统时钟自动同步。可执行timedatectl set-ntp no命令进行关闭。\\n', '\\n', '# timedatectl set-ntp boolean\\n', '例如开启自动远程时间同步，命令如下：\\n', '\\n', '# timedatectl set-ntp yes\\n', '修改日期\\n', ' 说明：\\n', '修改日期前，请确保已经关闭NTP系统时钟自动同步。\\n', '\\n', '修改当前的日期，在root权限下执行如下命令，其中 YYYY 代表年份，MM 代表月份，DD 代表某天，请根据实际情况修改：\\n', '\\n', '# timedatectl set-time YYYY-MM-DD\\n', '例如修改当前的日期为2019年8月14号，命令如下：\\n', '\\n', \"# timedatectl set-time '2019-08-14'\\n\", '修改时间\\n', ' 说明：\\n', '修改时间前，请确保已经关闭NTP系统时钟自动同步。\\n', '\\n', '修改当前的时间，在root权限下执行如下命令，其中 HH 代表小时，MM 代表分钟，SS 代表秒，请根据实际情况修改：\\n', '\\n', '# timedatectl set-time HH:MM:SS\\n', '例如修改当前的时间为15点57分24秒，命令如下：\\n', '\\n', '# timedatectl set-time 15:57:24\\n', '修改时区\\n', '显示当前可用时区，命令如下：\\n', '\\n', '$ timedatectl list-timezones\\n', '要修改当前的时区，在root权限下执行如下命令，其中 time_zone 是您想要设置的时区，请根据实际情况修改：\\n', '\\n', '# timedatectl set-timezone time_zone\\n', '例如修改当前的时区，首先查询所在地域的可用时区，此处以Asia为例：\\n', '\\n', '# timedatectl list-timezones | grep Asia\\n', 'Asia/Aden\\n', 'Asia/Almaty\\n', 'Asia/Amman\\n', 'Asia/Anadyr\\n', 'Asia/Aqtau\\n', 'Asia/Aqtobe\\n', 'Asia/Ashgabat\\n', 'Asia/Baghdad\\n', 'Asia/Bahrain\\n', '……\\n', '\\n', 'Asia/Seoul\\n', 'Asia/Shanghai\\n', 'Asia/Singapore\\n', 'Asia/Srednekolymsk\\n', 'Asia/Taipei\\n', 'Asia/Tashkent\\n', 'Asia/Tbilisi\\n', 'Asia/Tehran\\n', 'Asia/Thimphu\\n', 'Asia/Tokyo\\n', '然后修改当前的时区为“Asia/Shanghai”，命令如下：\\n', '\\n', '# timedatectl set-timezone Asia/Shanghai\\n', '使用date命令设置\\n', '显示当前的日期和时间\\n', '显示当前的日期和时间，命令如下：\\n', '\\n', '$ date\\n', '默认情况下，date命令显示本地时间。要显示UTC时间，添加--utc或-u参数：\\n', '\\n', '$ date --utc\\n', '要自定义对应的输出信息格式，添加 +“format” 参数：\\n', '\\n', '$ date +\"format\"\\n', '表 1 参数说明\\n', '\\n', '\\n', '格式参数\\n', '\\n', '说明\\n', '\\n', '%H\\n', '\\n', '小时以HH格式（例如 17）。\\n', '\\n', '%M\\n', '\\n', '分钟以MM格式（例如 37）。\\n', '\\n', '%S\\n', '\\n', '秒以SS格式（例如 25）。\\n', '\\n', '%d\\n', '\\n', '日期以DD格式（例如 15）。\\n', '\\n', '%m\\n', '\\n', '月份以MM格式（例如 07）。\\n', '\\n', '%Y\\n', '\\n', '年份以YYYY格式（例如 2019）。\\n', '\\n', '%Z\\n', '\\n', '时区缩写（例如CEST）。\\n', '\\n', '%F\\n', '\\n', '日期整体格式为YYYY-MM-DD（例如 2019-7-15），等同%Y-%m-%d。\\n', '\\n', '%T\\n', '\\n', '时间整体格式为HH:MM:SS（例如 18:30:25），等同%H:%M:%S。\\n', '\\n', '实际使用示例如下：\\n', '\\n', '显示当前的日期和本地时间。\\n', '\\n', '$ date \\n', '2019年 08月 17日 星期六 17:26:34 CST\\n', '显示当前的日期和UTC时间。\\n', '\\n', '$ date --utc\\n', '2019年 08月 17日 星期六 09:26:18 UTC\\n', '自定义date命令的输出。\\n', '\\n', '$ date +\"%Y-%m-%d %H:%M\"\\n', '2019-08-17 17:24\\n', '修改时间\\n', '要修改当前的时间，添加--set或者-s参数。在root权限下执行如下命令，其中 HH 代表小时，MM 代表分钟，SS 代表秒，请根据实际情况修改：\\n', '\\n', '# date --set HH:MM:SS\\n', '默认情况下， date命令设置本地时间。要设置UTC时间，添加--utc或-u参数：\\n', '\\n', '# date --set HH:MM:SS --utc\\n', '例如修改当前的时间为23点26分00秒，在root权限下执行如下命令：\\n', '\\n', '# date --set 23:26:00\\n', '修改日期\\n', '修改当前的日期，添加--set或者-s参数。在root权限下执行如下命令，其中 YYYY 代表年份，MM 代表月份，DD 代表某天，请根据实际情况修改：\\n', '\\n', '# date --set YYYY-MM-DD\\n', '例如修改当前的日期为2019年11月2日，命令如下：\\n', '\\n', '# date --set 2019-11-02\\n', '使用hwclock命令设置\\n', '可以使用 hwclock 命令设置硬件时钟RTC (Real Time Clock) 。\\n', '\\n', '硬件时钟和系统时钟\\n', 'Linux 将时钟分为：\\n', '\\n', '系统时钟 (System Clock) ：当前Linux Kernel中的时钟。\\n', '硬件时钟 RTC：主板上由电池供电的主板硬件时钟，该时钟可以在BIOS的 “Standard BIOS Feature” 项中进行设置。\\n', '当Linux启动时，会读取硬件时钟，并根据硬件时间来设置系统时间。\\n', '\\n', '显示日期和时间\\n', '显示当前硬件的日期和时间，在root权限下执行如下命令：\\n', '\\n', '# hwclock\\n', '例如显示当前硬件的日期和时间，命令和输出如下：\\n', '\\n', '# hwclock\\n', '2019-08-26 10:18:42.528948+08:00\\n', '设置日期和时间\\n', '修改当前硬件的日期和时间，在root权限下执行如下命令，其中 dd 表示日，mm 表示月份，yyyy 表示年份，HH 表示小时，MM 表示分钟，请根据实际情况修改：\\n', '\\n', '# hwclock --set --date \"dd mm yyyy HH:MM\"\\n', '例如修改当前的时间为2019年10月21日21点17分，命令如下：\\n', '\\n', '# hwclock --set --date \"21 Oct 2019 21:17\" --utc\\n', '设置kdump\\n', '本节介绍如何设置kdump预留内存及修改kdump配置文件参数。\\n', '\\n', '设置kdump预留内存\\n', '预留内存参数格式\\n', 'kdump预留内存参数必须添加到内核启动参数中，配置文件为/boot/efi/EFI/openEuler/grub.cfg(UEFI引导模式)或/boot/grub2/grub.cfg(legacy引导模式)，openEuler发布版本中默认已经添加，可以根据实际使用情况调整。添加和修改启动参数后，重启系统生效。kdump预留内存参数格式如下：\\n', '\\n', '内核启动参数\\t描述\\t默认值\\t备注\\n', 'crashkernel=x\\t在4G以下的物理内存预留x大小的内存给kdump使用。\\tx86版本默认配置512M\\t该配置方法只在4G以下内存预留，必须保证4G以下连续可用内存足够预留。\\n', 'crashkernel=x@y\\t在y起始地址预留x大小的内存给kdump使用。\\t未使用\\t需要确保y起始地址的x大小的内存未被其他模块预留。\\n', 'crashkernel=x,high\\t在4G以下的物理内存中预留256M内存，在4G以上预留x大小内存给kdump使用。\\tarm64版本默认配置1024M,high\\t需要确保4G以下有256M连续可用的物理内存，4G以上有连续的x大小的连续物理内存。实际预留内存大小为256M+x。\\n', 'crashkernel=x,low crashkernel=y,high\\t在4G以下的物理内存中预留x大小，在4G以上预留y大小内存给kdump使用。\\t未使用\\t需要确保4G以下有连续的x大小物理内存，4G以上有连续的y大小物理内存。\\n', '预留内存推荐值\\n', '推荐方案\\t预留参数\\t参数说明\\n', '通用方案\\tcrashkernel=2048M,high\\t4G以下预留256M，4G以上预留2048M内存给kdump使用。共256+2048M。\\n', '经济方案\\tcrashkernel=1024M,high\\t4G以下预留256M，4G以上预留1024M内存给kdump使用。共256+1024M。 推荐系统512G内存以内的场景，并不使用网络转储kdump文件。对于虚拟机场景，可以适当减少内存预留值，推荐虚拟机设置为crashkernel=512M或者crashkernel=256M,high\\n', ' 说明：\\n', '不通过网络转储kdump文件时，需要设置kdump文件系统不打包网络相关驱动。网络驱动加载需要申请较大内存，可能导致预留内存不足，kdump失败。因此建议禁用网络相关驱动。\\n', '\\n', '禁用网络相关驱动\\n', 'kdump配置文件（/etc/kdump.conf）中，dracut参数可以设置裁剪的驱动模块，可以将网络驱动配置到裁剪驱动列表中，让kdump文件系统中不加载该驱动，修改配置文件后，重启kdump服务生效。dracut参数配置如下所示：\\n', '\\n', 'dracut_args --omit-drivers \"mdio-gpi usb_8dev et1011c rt2x00usb bcm-phy-lib mac80211_hwsim rtl8723be rndis_host hns3_cae amd vrf rtl8192cu mt76x02-lib int51x1 ppp_deflate team_mode_loadbalance smsc911x aweth bonding mwifiex_usb hnae dnet rt2x00pci vaser_pci hdlc_ppp marvell rtl8xxxu mlxsw_i2c ath9k_htc rtl8150 smc91x cortina at803x rockchip cxgb4 spi_ks8995 mt76x2u smsc9420 mdio-cavium bnxt_en ch9200 dummy macsec ice mt7601u rtl8188ee ixgbevf net1080 liquidio_vf be2net mlxsw_switchx2 gl620a xilinx_gmii2rgmii ppp_generic rtl8192de sja1000_platform ath10k_core cc770_platform realte igb c_can_platform c_can ethoc dm9601 smsc95xx lg-vl600 ifb enic ath9 mdio-octeon ppp_mppe ath10k_pci cc770 team_mode_activebackup marvell10g hinic rt2x00lib mlx4_en iavf broadcom igc c_can_pci alx rtl8192se rtl8723ae microchip lan78xx atl1c rtl8192c-common almia ax88179_178a qed netxen_nic brcmsmac rt2800usb e1000 qla3xxx mdio-bitbang qsemi mdio-mscc-miim plx_pci ipvlan r8152 cx82310_eth slhc mt76x02-usb ems_pci xen-netfront usbnet pppoe mlxsw_minimal mlxsw_spectrum cdc_ncm rt2800lib rtl_usb hnae3 ath9k_common ath9k_hw catc mt76 hns_enet_drv ppp_async huawei_cdc_ncm i40e rtl8192ce dl2 qmi_wwan mii peak_usb plusb can-dev slcan amd-xgbe team_mode_roundrobin ste10Xp thunder_xcv pptp thunder_bgx ixgbe davicom icplus tap tun smsc75xx smsc dlci hns_dsaf mlxsw_core rt2800mmi softing uPD60620 vaser_usb dp83867 brcmfmac mwifiex_pcie mlx4_core micrel team macvlan bnx2 virtio_net rtl_pci zaurus hns_mdi libcxgb hv_netvsc nicvf mt76x0u teranetics mlxfw cdc_eem qcom-emac pppox mt76-usb sierra_net i40evf bcm87xx mwifiex pegasus rt2x00mmi sja1000 ena hclgevf cnic cxgb4vf ppp_synctty iwlmvm team_mode_broadcast vxlan vsockmon hdlc_cisc rtl8723-common bsd_comp fakelb dp83822 dp83tc811 cicada fm10 8139t sfc hs geneve hclge xgene-enet-v2 cdc_mbim hdlc asix netdevsim rt2800pci team_mode_random lxt ems_usb mlxsw_pci sr9700 mdio-thunder mlxsw_switchib macvtap atlantic cdc_ether mcs7830 nicpf mdi peak_pci atl1e cdc_subset ipvtap btcoexist mt76x0-common veth slip iwldvm bcm7xxx vitesse netconsole epic100 myri10ge r8169 qede microchip_t1 liquidi bnx2x brcmutil mwifiex_sdi mlx5_core rtlwifi vmxnet3 nlmon hns3 hdlc_raw esd_usb2 atl2 mt76x2-common iwlwifi mdio-bcm-unimac national ath rtwpci rtw88 nfp rtl8821ae fjes thunderbolt-net 8139cp atl1 mscc vcan dp83848 dp83640 hdlc_fr e1000e ipheth net_failover aquantia rtl8192ee igbvf rocker intel-xway tg3\" --omit \"ramdisk network ifcfg qemu-net\" --install \"chmod\" --nofscks\\n', '\\n', '设置磁盘调度算法\\n', '本节介绍如何设置磁盘调度算法。\\n', '\\n', '临时修改调度策略\\n', '例如将所有IO调度算法修改为mq-deadline，此修改重启后会失效。\\n', '\\n', 'echo mq-deadline > /sys/block/sd*/queue/scheduler\\n', '永久设置调度策略\\n', '可以通过在内核启动配置文件grub.cfg中的kernel行追加：elevator=mq-deadline，重启后生效。\\n', '\\n', 'linux   /vmlinuz-4.19.90-2003.4.0.0036.oe1.x86_64 root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建FTP服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建FTP服务器\\n', '搭建FTP服务器\\n', '总体介绍\\n', 'FTP简介\\n', 'FTP使用到的端口\\n', 'vsftpd简介\\n', '使用vsftpd\\n', '安装vsftpd\\n', '管理vsftpd服务\\n', '配置vsftpd\\n', 'vsftpd配置文件介绍\\n', '默认配置说明\\n', '配置本地时间\\n', '配置欢迎信息\\n', '配置系统帐号登录权限\\n', '验证FTP服务是否搭建成功\\n', '配置防火墙\\n', '传输文件\\n', '概述\\n', '连接服务器\\n', '下载文件\\n', '上传文件\\n', '删除文件\\n', '断开服务器\\n', '总体介绍\\n', 'FTP简介\\n', 'FTP（File Transfer Protocol）即文件传输协议，是互联网最早的传输协议之一，其最主要的功能是服务器和客户端之间的文件传输。FTP使用户可以通过一套标准的命令访问远程系统上的文件，而不需要直接登录远程系统。另外，FTP服务器还提供了如下主要功能：\\n', '\\n', '用户分类\\n', '\\n', '默认情况下，FTP服务器依据登录情况，将用户分为实体用户（real user）、访客（guest）、匿名用户（anonymous）三类。三类用户对系统的访问权限差异较大，实体用户具有较完整的访问权限，匿名用户仅有下载资源的权限。\\n', '\\n', '命令记录和日志文件记录\\n', '\\n', 'FTP可以利用系统的syslogd记录数据，这些数据包括用户历史使用命令与用户传输数据（传输时间、文件大小等），用户可以在/var/log/中获得各项日志信息。\\n', '\\n', '限制用户的访问范围\\n', '\\n', 'FTP可以将用户的工作范围限定在用户主目录。用户通过FTP登录后系统显示的根目录就是用户主目录，这种环境被称为change root，简称chroot。这种方式可以限制用户只能访问主目录，而不允许访问/etc、/home、/usr/local等系统的重要目录，从而保护系统，使系统更安全。\\n', '\\n', 'FTP使用到的端口\\n', 'FTP的正常工作需要使用到多个网络端口，服务器端会使用到的端口主要有：\\n', '\\n', '命令通道，默认端口为21\\n', '数据通道，默认端口为20\\n', '两者的连接发起端不同，端口21主要接收来自客户端的连接，端口20则是FTP服务器主动连接至客户端。\\n', '\\n', 'vsftpd简介\\n', '由于FTP历史悠久，它采用未加密的传输方式，所以被认为是一种不安全的协议。为了更安全地使用FTP，这里介绍FTP较为安全的守护进程vsftpd（Very Secure FTP Daemon）。\\n', '\\n', '之所以说vsftpd安全，是因为它最初的发展理念就是构建一个以安全为中心的FTP服务器。它具有如下特点：\\n', '\\n', 'vsftpd服务的启动身份为一般用户，具有较低的系统权限。此外，vsftpd使用chroot改变根目录，不会误用系统工具。\\n', '任何需要较高执行权限的vsftpd命令均由一个特殊的上层程序控制，该上层程序的权限较低，以不影响系统本身为准。\\n', 'vsftpd整合了大部分FTP会使用到的额外命令（例如dir、ls、cd等），一般不需要系统提供额外命令，对系统来说比较安全。\\n', '使用vsftpd\\n', '安装vsftpd\\n', '使用vsftpd需要安装vsftpd软件，在已经配置yum源的情况下，通过root权限执行如下命令，即可完成vsftpd的安装。\\n', '\\n', '# dnf install vsftpd\\n', '管理vsftpd服务\\n', '启动、停止和重启vsftpd服务，请在root权限下执行对应命令。\\n', '\\n', '启动vsftpd服务\\n', '\\n', '# systemctl start vsftpd\\n', '可以通过netstat命令查看通信端口21是否开启，如下显示说明vsftpd已经启动。\\n', '\\n', '# netstat -tulnp | grep 21\\n', 'tcp6       0      0 :::21                   :::*                    LISTEN      19716/vsftpd\\n', ' 说明：\\n', '如果没有netstat命令，可以执行dnf install net-tools命令安装后再使用netstat命令。\\n', '\\n', '停止vsftpd服务\\n', '\\n', '# systemctl stop vsftpd\\n', '重启vsftpd服务\\n', '\\n', '# systemctl restart vsftpd\\n', '配置vsftpd\\n', 'vsftpd配置文件介绍\\n', '用户可以通过修改vsftpd的配置文件，控制用户权限等。vsftpd的主要配置文件和含义如表1所示，用户可以根据需求修改配置文件的内容。更多的配置参数含义可以通过man查看。\\n', '\\n', '表 1 vsftpd配置文件介绍\\n', '\\n', '\\n', '配置文件\\n', '\\n', '含义\\n', '\\n', '/etc/vsftpd/vsftpd.conf\\n', '\\n', 'vsftpd进程的主配置文件，配置内容格式为“参数=参数值”，且参数和参数值不能为空。\\n', '\\n', 'vsftpd.conf 的详细介绍可以使用如下命令查看：\\n', '\\n', 'man 5 vsftpd.conf\\n', '\\n', '/etc/pam.d/vsftpd\\n', '\\n', 'PAM（Pluggable Authentication Modules）认证文件，主要用于身份认证和限制一些用户的操作。\\n', '\\n', '/etc/vsftpd/ftpusers\\n', '\\n', '禁用使用vsftpd的用户列表文件。默认情况下，系统帐号也在该文件中，因此系统帐号默认无法使用vsftpd。\\n', '\\n', '/etc/vsftpd/user_list\\n', '\\n', '禁止或允许登录vsftpd服务器的用户列表文件。该文件是否生效，取决于主配置文件vsftpd.conf中的如下参数：\\n', '\\n', 'userlist_enable：是否启用userlist机制，YES为启用，此时userlist_deny配置有效，NO为禁用。\\n', '\\n', 'userlist_deny：是否禁止user_list中的用户登录，YES为禁止名单中的用户登录，NO为允许命令中的用户登录。\\n', '\\n', '例如userlist_enable=YES，userlist_deny=YES，则user_list中的用户都无法登录。\\n', '\\n', '/etc/vsftpd/chroot_list\\n', '\\n', '是否限制在主目录下的用户列表。该文件默认不存在，需要手动建立。它是主配置文件vsftpd.conf中参数chroot_list_file的参数值。\\n', '\\n', '其作用是限制还是允许，取决于主配置文件vsftpd.conf中的如下参数：\\n', '\\n', 'chroot_local_user：是否将所有用户限制在主目录，YES为启用，NO禁用。\\n', 'chroot_list_enable：是否启用限制用户的名单，YES为启用，NO禁用。\\n', '例如chroot_local_user=YES，chroot_list_enable=YES，且指定chroot_list_file=/etc/vsftpd/chroot_list时，表示所有用户被限制在其主目录下，而chroot_list中的用户不受限制。\\n', '\\n', '/usr/sbin/vsftpd\\n', '\\n', 'vsftpd的唯一执行文件。\\n', '\\n', '/var/ftp/\\n', '\\n', '匿名用户登录的默认根目录，与ftp帐户的用户主目录有关。\\n', '\\n', '默认配置说明\\n', ' 说明：\\n', '文档中的配置内容仅供参考，请用户根据实际情况（例如安全加固需要）进行修改。\\n', '\\n', 'openEuler系统中 ，vsftpd默认不开放匿名用户，使用vim命令查看主配置文件，其内容如下：\\n', '\\n', '$ vim /etc/vsftpd/vsftpd.conf\\n', 'anonymous_enable=NO\\n', 'local_enable=YES\\n', 'write_enable=YES\\n', 'local_umask=022\\n', 'dirmessage_enable=YES\\n', 'xferlog_enable=YES\\n', 'connect_from_port_20=YES\\n', 'xferlog_std_format=YES\\n', 'listen=NO\\n', 'listen_ipv6=YES\\n', 'pam_service_name=vsftpd\\n', 'userlist_enable=YES\\n', '其中各参数含义如表2所示。\\n', '\\n', '表 2 参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '含义\\n', '\\n', 'anonymous_enable\\n', '\\n', '是否允许匿名用户登录，YES为允许匿名登录，NO为不允许。\\n', '\\n', 'local_enable\\n', '\\n', '是否允许本地用户登入，YES 为允许本地用户登入，NO为不允许。\\n', '\\n', 'write_enable\\n', '\\n', '是否允许登录用户有写权限，YES为启用上传写入功能，NO为禁用。\\n', '\\n', 'local_umask\\n', '\\n', '本地用户新增档案时的umask值。\\n', '\\n', 'dirmessage_enable\\n', '\\n', '当用户进入某个目录时，是否显示该目录需要注意的内容，YES为显示注意内容，NO为不显示。\\n', '\\n', 'xferlog_enable\\n', '\\n', '是否记录使用者上传与下载文件的操作，YES为记录操作，NO为不记录。\\n', '\\n', 'connect_from_port_20\\n', '\\n', 'Port模式进行数据传输是否使用端口20，YES为使用端口20，NO为不使用端口20。\\n', '\\n', 'xferlog_std_format\\n', '\\n', '传输日志文件是否以标准xferlog格式书写，YES为使用该格式书写，NO为不使用。\\n', '\\n', 'listen\\n', '\\n', '设置vsftpd是否以stand alone的方式启动，YES为使用stand alone方式启动，NO为不使用该方式。\\n', '\\n', 'pam_service_name\\n', '\\n', '支持PAM模块的管理，配置值为服务名称，例如vsftpd。\\n', '\\n', 'userlist_enable\\n', '\\n', '是否支持/etc/vsftpd/user_list文件内的账号登录控制，YES为支持，NO为不支持。\\n', '\\n', 'tcp_wrappers\\n', '\\n', '是否支持TCP Wrappers的防火墙机制，YES为支持，NO为不支持。\\n', '\\n', 'listen_ipv6\\n', '\\n', '是否侦听IPv6的FTP请求，YES为侦听，NO为不侦听。listen和listen_ipv6不能同时开启。\\n', '\\n', '配置本地时间\\n', '概述\\n', 'openEuler系统中，vsftpd默认使用GMT时间（格林尼治时间），可能和本地时间不一致，例如GMT时间比北京时间晚8小时，请用户改为本地时间，否则服务器和客户端时间不一致，在上传下载文件时可能引起错误。\\n', '\\n', '设置方法\\n', '在root权限下设置vsftpd时间为本地时间的操作步骤如下：\\n', '\\n', '打开配置文件vsftpd.conf，将参数use_localtime的参数值改为YES。命令如下：\\n', '\\n', '# vim /etc/vsftpd/vsftpd.conf\\n', '配置内容如下：\\n', '\\n', 'use_localtime=YES\\n', '重启vsftpd服务。\\n', '\\n', '# systemctl restart vsftpd\\n', '设置vsftpd服务开机启动。\\n', '\\n', '# systemctl enable vsftpd\\n', '配置欢迎信息\\n', '正常使用vsftpd服务，需要存在欢迎信息文件。在root权限下设置vsftp的欢迎信息welcome.txt文件的操作步骤如下：\\n', '\\n', '打开配置文件vsftpd.conf，加入欢迎信息文件配置内容后保存退出。\\n', '\\n', '# vim /etc/vsftpd/vsftpd.conf\\n', '需要加入的配置行如下：\\n', '\\n', 'banner_file=/etc/vsftpd/welcome.txt\\n', '建立欢迎信息。即打开welcome.txt文件，写入欢迎信息后保存退出。\\n', '\\n', '# vim /etc/vsftpd/welcome.txt\\n', '欢迎信息举例如下：\\n', '\\n', 'Welcome to this FTP server!\\n', '配置系统帐号登录权限\\n', '一般情况下，用户需要限制部分帐号的登录权限。用户可根据需要进行配置。\\n', '\\n', '限制系统帐号登录的文件有两个，默认如下：\\n', '\\n', '/etc/vsftpd/ftpusers：受/etc/pam.d/vsftpd文件的设置影响，由PAM模块掌管。\\n', '/etc/vsftpd/user_list：由vsftpd.conf的userlist_file设置，由vsftpd主动提供。\\n', '两个文件的必须同时存在且内容相同，请参考/etc/passwd文件，将UID小于500的帐号写入这两个文件，每一行代表一个帐号。\\n', '\\n', '如果用户需要限制系统帐号登录，需要在root权限下将对应帐号添加到/etc/vsftpd/ftpusers和/etc/vsftpd/user_list。\\n', '\\n', '打开user_list可以查看当前文件中包含的帐号信息，命令和回显如下：\\n', '\\n', '$ vim /etc/vsftpd/user_list\\n', 'root\\n', 'bin\\n', 'daemon\\n', 'adm\\n', 'lp\\n', 'sync\\n', 'shutdown\\n', 'halt\\n', 'mail\\n', 'news\\n', 'uucp\\n', 'operator\\n', 'games\\n', 'nobody\\n', '验证FTP服务是否搭建成功\\n', '可以使用openEuler提供的FTP客户端进行验证。命令和回显如下，根据提示输入用户名（用户为系统中存在的用户）和密码。如果显示Login successful，即说明FTP服务器搭建成功。\\n', '\\n', '$ ftp localhost\\n', 'Trying 127.0.0.1...\\n', 'Connected to localhost (127.0.0.1).\\n', '220-Welcome to this FTP server!\\n', '220\\n', 'Name (localhost:root): USERNAME\\n', '331 Please specify the password.\\n', 'Password:\\n', '230 Login successful.\\n', 'Remote system type is UNIX.\\n', 'Using binary mode to transfer files.\\n', 'ftp> bye\\n', '221 Goodbye.\\n', ' 说明：\\n', '如果没有ftp命令，可以在root权限下执行dnf install ftp命令安装后再使用ftp命令。\\n', '\\n', '配置防火墙\\n', '如果要将FTP开放给Internet使用，需要在root权限下对防火墙和SElinux进行设置。\\n', '\\n', '# firewall-cmd --add-service=ftp --permanent\\n', 'success\\n', '# firewall-cmd --reload\\n', 'success\\n', '# setsebool -P ftpd_full_access on\\n', '传输文件\\n', '概述\\n', '这里给出vsftpd服务启动后，如何进行文件传输的指导。\\n', '\\n', '连接服务器\\n', '命令格式\\n', '\\n', 'ftp [hostname | ip-address]\\n', '\\n', '其中hostname为服务器名称，ip-address为服务器IP地址。\\n', '\\n', '操作说明\\n', '\\n', '在openEuler系统的命令行终端，执行如下命令：\\n', '\\n', '$ ftp ip-address\\n', '根据提示输入用户名和密码，认证通过后显示如下，说明ftp连接成功，此时进入了连接到的服务器目录。\\n', '\\n', 'ftp>\\n', '在该提示符下，可以输入不同的命令进行相关操作：\\n', '\\n', '显示服务器当前路径\\n', '\\n', 'ftp>pwd\\n', '显示本地路径，用户可以将该路径下的文件上传到FTP服务器对应位置\\n', '\\n', 'ftp>lcd\\n', '退出当前窗口，返回本地Linux终端\\n', '\\n', 'ftp>！\\n', '下载文件\\n', '通常使用get或mget命令下载文件。\\n', '\\n', 'get使用方法\\n', '\\n', '功能说明：将文件从远端主机中传送至本地主机中\\n', '\\n', '命令格式：get [remote-file] [local-file]\\n', '\\n', '其中 remote-file 为远程文件，local-file 为本地文件\\n', '\\n', '示例：获取远程服务器上的/home/openEuler/openEuler.htm文件到本地/home/myopenEuler/，并改名为myopenEuler.htm，命令如下：\\n', '\\n', 'ftp> get /home/openEuler/openEuler.htm /home/myopenEuler/myopenEuler.htm\\n', 'mget使用方法\\n', '\\n', '功能说明：从远端主机接收一批文件至本地文件\\n', '\\n', '命令格式：mget [remote-file]\\n', '\\n', '其中 remote-file 为远程文件\\n', '\\n', '示例：获取服务器上/home/openEuler/目录下的所有文件，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> mget *.*\\n', ' 说明：\\n', '\\n', '此时每下载一个文件，都会有提示信息。如果要屏蔽提示信息，则在 mget *.* 命令前先执行prompt off\\n', '文件都被下载到Linux主机的当前目录下。比如，在/home/myopenEuler/下运行的ftp命令，则文件都下载到/home/myopenEuler/下。\\n', '上传文件\\n', '通常使用put或mput命令上传文件。\\n', '\\n', 'put使用方法\\n', '\\n', '功能说明：将本地的一个文件传送到远端主机中\\n', '\\n', '命令格式：put [local-file] [remote-file]\\n', '\\n', '其中 remote-file 为远程文件，local-file 为本地文件\\n', '\\n', '示例：将本地的myopenEuler.htm传送到远端主机/home/openEuler/，并改名为openEuler.htm，命令如下：\\n', '\\n', 'ftp> put myopenEuler.htm /home/openEuler/openEuler.htm\\n', 'mput使用方法\\n', '\\n', '功能说明：将本地主机中一批文件传送至远端主机\\n', '\\n', '命令格式：mput [local-file]\\n', '\\n', '其中 local-file 为本地文件\\n', '\\n', '示例：将本地当前目录下所有htm文件上传到服务器/home/openEuler/下，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> mput *.htm\\n', '删除文件\\n', '通常使用delete或mdelete命令删除文件。\\n', '\\n', 'delete使用方法\\n', '\\n', '功能说明：删除远程服务器上的一个或多个文件\\n', '\\n', '命令格式：delete [remote-file]\\n', '\\n', '其中 remote-file 为远程文件\\n', '\\n', '示例：删除远程服务器上/home/openEuler/下的openEuler.htm文件，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> delete openEuler.htm\\n', 'mdelete使用方法\\n', '\\n', '功能说明：删除远程服务器上的文件，常用于批量删除\\n', '\\n', '命令格式：mdelete [remote-file]\\n', '\\n', '其中 remote-file 为远程文件\\n', '\\n', '示例：删除远程服务器上/home/openEuler/下所有a开头的文件，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> mdelete a*\\n', '断开服务器\\n', '断开与服务器的连接，使用bye命令，如下：\\n', '\\n', 'ftp> bye ']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建repo服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BArepo%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建repo服务器\\n', ' 说明：\\n', 'openEuler提供了多种repo源供用户在线使用，各repo源含义可参考系统安装。若用户无法在线获取openEuler repo源，则可使用openEuler提供的ISO发布包创建为本地openEuler repo源。本章节中以openEuler-22.03-LTS-aarch64-dvd.iso发布包为例，请根据实际需要的ISO发布包进行修改。\\n', '\\n', '搭建repo服务器\\n', '概述\\n', '创建/更新本地repo源\\n', '获取ISO发布包\\n', '挂载ISO创建repo源\\n', '创建本地repo源\\n', '更新repo源\\n', '部署远端repo源\\n', 'nginx安装与配置\\n', '启动nginx服务\\n', 'repo源部署\\n', '使用repo源\\n', 'repo配置为yum源（软件源）\\n', 'repo优先级\\n', 'dnf相关命令\\n', '概述\\n', '将openEuler提供的ISO发布包openEuler-22.03-LTS-aarch64-dvd.iso创建为repo源，如下以使用nginx进行repo源部署，提供http服务为例进行说明。\\n', '\\n', '创建/更新本地repo源\\n', '使用mount挂载，将openEuler的ISO发布包openEuler-22.03-LTS-aarch64-dvd.iso创建为repo源，并能够对repo源进行更新。\\n', '\\n', '获取ISO发布包\\n', '请从如下网址获取openEuler的ISO发布包：\\n', '\\n', 'https://repo.openeuler.org/openEuler-22.03-LTS/ISO/\\n', '\\n', '挂载ISO创建repo源\\n', '在root权限下使用mount命令挂载ISO发布包。\\n', '\\n', '示例如下：\\n', '\\n', '# mount /home/openEuler/openEuler-22.03-LTS-aarch64-dvd.iso /mnt/\\n', '挂载好的mnt目录如下：\\n', '\\n', '.\\n', '│── boot.catalog\\n', '│── docs\\n', '│── EFI\\n', '│── images\\n', '│── Packages\\n', '│── repodata\\n', '│── TRANS.TBL\\n', '└── RPM-GPG-KEY-openEuler\\n', '其中，Packages为rpm包所在的目录，repodata为repo源元数据所在的目录，RPM-GPG-KEY-openEuler为openEuler的签名公钥。\\n', '\\n', '创建本地repo源\\n', '可以拷贝ISO发布包中相关文件至本地目录以创建本地repo源，示例如下：\\n', '\\n', '# mount /home/openEuler/openEuler-22.03-LTS-aarch64-dvd.iso /mnt/\\n', '$ mkdir -p ~/srv/repo/\\n', '$ cp -r /mnt/Packages ~/srv/repo/\\n', '$ cp -r /mnt/repodata ~/srv/repo/\\n', '$ cp -r /mnt/RPM-GPG-KEY-openEuler ~/srv/repo/\\n', '从而本地repo目录如下：\\n', '\\n', '.\\n', '│── Packages\\n', '│── repodata\\n', '└── RPM-GPG-KEY-openEuler\\n', 'Packages为rpm包所在的目录，repodata为repo源元数据所在的目录，RPM-GPG-KEY-openEuler为openEuler的签名公钥。\\n', '\\n', '更新repo源\\n', '更新repo源有两种方式：\\n', '\\n', '通过新版本的ISO更新已有的repo源，与创建repo源的方式相同，即挂载ISO发布包或重新拷贝ISO发布包至本地目录。\\n', '\\n', '在repo源的Packages目录下添加rpm包，然后通过createrepo命令更新repo源\\n', '\\n', '$ createrepo --update --workers=10 ~/srv/repo\\n', '其中，--update表示更新，--workers表示线程数，可自定义。\\n', '\\n', ' 说明：\\n', '若命令打印信息为“createrepo：未找到命令”，则表示未安装createrepo软件，可在root权限下执行dnf install createrepo进行安装。\\n', '\\n', '部署远端repo源\\n', '安装openEuler操作系统，在openEuler上通过nginx部署repo源。\\n', '\\n', 'nginx安装与配置\\n', '请自行下载nginx工具并在root权限下安装nginx。\\n', '\\n', '安装nginx之后，在root权限下配置/etc/nginx/nginx.conf。\\n', '\\n', ' 说明：\\n', '文档中的配置内容仅供参考，请用户根据实际情况（例如安全加固需要）进行配置。\\n', '\\n', 'user  nginx;\\n', 'worker_processes  auto;                          # 建议设置为core-1\\n', 'error_log  /var/log/nginx/error.log  warn;       # log存放位置\\n', 'pid        /var/run/nginx.pid;\\n', '\\n', 'events {\\n', '    worker_connections  1024;\\n', '}\\n', '\\n', 'http {\\n', '    include       /etc/nginx/mime.types;\\n', '    default_type  application/octet-stream;\\n', '\\n', '    log_format  main  \\'$remote_addr - $remote_user [$time_local] \"$request\" \\'\\n', '                      \\'$status $body_bytes_sent \"$http_referer\" \\'\\n', '                      \\'\"$http_user_agent\" \"$http_x_forwarded_for\"\\';\\n', '\\n', '    access_log  /var/log/nginx/access.log  main;\\n', '    sendfile        on;\\n', '    keepalive_timeout  65;\\n', '\\n', '    server {\\n', '        listen       80;\\n', '        server_name  localhost;                 # 服务器名（url）\\n', '        client_max_body_size 4G;\\n', '        root         /usr/share/nginx/repo;                 # 服务默认目录\\n', '\\n', '        location / {\\n', '            autoindex            on;            # 开启访问目录下层文件\\n', '            autoindex_exact_size on;\\n', '            autoindex_localtime  on; \\n', '        }\\n', '\\n', '    }\\n', '\\n', '}\\n', '启动nginx服务\\n', '在root权限下通过systemd启动nginx服务：\\n', '\\n', '# systemctl enable nginx\\n', '# systemctl start nginx\\n', 'nginx是否启动成功可通过下面命令查看：\\n', '\\n', '$ systemctl status nginx\\n', '图1表示nginx服务启动成功\\n', '\\n', '图 1 nginx服务启动成功\\n', '\\n', '\\n', '若nginx服务启动失败，查看错误信息：\\n', '\\n', '$ systemctl status nginx.service --full\\n', '图 2 nginx服务启动失败\\n', '\\n', '\\n', '如图2所示nginx服务创建失败，是由于目录/var/spool/nginx/tmp/client_body创建失败，在root权限下手动进行创建，类似的问题也这样处理：\\n', '\\n', '# mkdir -p /var/spool/nginx/tmp/client_body\\n', '# mkdir -p /var/spool/nginx/tmp/proxy\\n', '# mkdir -p /var/spool/nginx/tmp/fastcgi\\n', '# mkdir -p /usr/share/nginx/uwsgi_temp\\n', '# mkdir -p /usr/share/nginx/scgi_temp\\n', 'repo源部署\\n', '在root权限下创建nginx配置文件/etc/nginx/nginx.conf中指定的目录/usr/share/nginx/repo：\\n', '\\n', '# mkdir -p /usr/share/nginx/repo\\n', '在root权限下修改目录/usr/share/nginx/repo的权限：\\n', '\\n', '# chmod -R 755 /usr/share/nginx/repo\\n', '设置防火墙规则，开启nginx设置的端口（此处为80端口），在root权限下通过firewall设置端口开启：\\n', '\\n', '# firewall-cmd --add-port=80/tcp --permanent\\n', '# firewall-cmd --reload\\n', '在root权限下查询80端口是否开启成功，输出为yes则表示80端口开启成功：\\n', '\\n', '# firewall-cmd --query-port=80/tcp\\n', '也可在root权限下通过iptables来设置80端口开启：\\n', '\\n', '# iptables -I INPUT -p tcp --dport 80 -j ACCEPT\\n', 'nginx服务设置好之后，即可通过ip直接访问网页，如图3：\\n', '\\n', '图 3 nginx部署成功\\n', '\\n', '\\n', '通过下面几种方式将repo源放入到/usr/share/nginx/repo下：\\n', '\\n', '在root权限下拷贝镜像中相关文件至/usr/share/nginx/repo下，并修改目录权限。\\n', '\\n', '# mount /home/openEuler/openEuler-22.03-LTS-aarch64-dvd.iso  /mnt/\\n', '# cp -r /mnt/Packages /usr/share/nginx/repo\\n', '# cp -r /mnt/repodata /usr/share/nginx/repo\\n', '# cp -r /mnt/RPM-GPG-KEY-openEuler /usr/share/nginx/repo\\n', '# chmod -R 755 /usr/share/nginx/repo\\n', 'openEuler-22.03-LTS-aarch64-dvd.iso存放在/home/openEuler目录下。\\n', '\\n', '使用root在/usr/share/nginx/repo下创建repo源的软链接。\\n', '\\n', '# ln -s /mnt /usr/share/nginx/repo/os\\n', '/mnt为已经创建好的repo源，/usr/share/nginx/repo/os将指向/mnt。\\n', '\\n', '使用repo源\\n', 'repo可配置为yum源，yum（全称为 Yellow dog Updater, Modified）是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载和安装。\\n', '\\n', 'repo配置为yum源（软件源）\\n', '构建好的repo可以配置为yum源使用，在/etc/yum.repos.d/目录下使用root权限创建***.repo的配置文件（必须以.repo为扩展名），分为本地和http服务器配置yum源两种方式：\\n', '\\n', '配置本地yum源\\n', '\\n', '在/etc/yum.repos.d目录下创建openEuler.repo文件，使用构建的本地repo源作为yum源，openEuler.repo的内容如下：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=file:///home/openEuler/srv/repo\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=file:///home/openEuler/srv/repo/RPM-GPG-KEY-openEuler\\n', ' 说明：\\n', '\\n', '[repoid]中的repoid为软件仓库（repository）的ID号，所有.repo配置文件中的各repoid不能重复，必须唯一。示例中repoid设置为base。\\n', 'name为软件仓库描述的字符串。\\n', 'baseurl为软件仓库的地址。\\n', 'enabled为是否启用该软件源仓库，可选值为1和0。默认值为1，表示启用该软件源仓库。\\n', 'gpgcheck可设置为1或0，1表示进行gpg（GNU Private Guard）校验，0表示不进行gpg校验，gpgcheck可以确定rpm包的来源是有效和安全的。\\n', 'gpgkey为验证签名用的公钥。\\n', '配置http服务器yum源\\n', '\\n', '在/etc/yum.repos.d目录下创建openEuler.repo文件。\\n', '\\n', '若使用用户部署的http服务端的repo源作为yum源，openEuler.repo的内容如下：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=http://192.168.139.209/\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=http://192.168.139.209/RPM-GPG-KEY-openEuler\\n', ' 说明：\\n', '“192.168.139.209”为示例地址，请用户根据实际情况进行配置。\\n', '\\n', '若使用openEuler提供的openEuler repo源作为yum源，以AArch64架构的OS repo源为例，openEuler.repo的内容如下：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=http://repo.openeuler.org/openEuler-22.03-LTS/OS/aarch64/\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=http://repo.openeuler.org/openEuler-22.03-LTS/OS/aarch64/RPM-GPG-KEY-openEuler\\n', 'repo优先级\\n', '当有多个repo源时，可通过在.repo文件的priority参数设置repo的优先级（如果不设置，默认优先级是99，当相同优先级的源中存在相同rpm包时，会安装最新的版本）。其中，1为最高优先级，99为最低优先级，如给openEuler.repo配置优先级为2：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=http://192.168.139.209/\\n', 'enabled=1\\n', 'priority=2\\n', 'gpgcheck=1\\n', 'gpgkey=http://192.168.139.209/RPM-GPG-KEY-openEuler\\n', 'dnf相关命令\\n', 'dnf命令在安装升级时能够自动解析包的依赖关系，一般的使用方式如下：\\n', '\\n', 'dnf <command> <packages name>\\n', '常用的命令如下：\\n', '\\n', '安装，需要在root权限下执行。\\n', '\\n', '# dnf install <packages name>\\n', '升级，需要在root权限下执行。\\n', '\\n', '# dnf update <packages name>\\n', '回退，需要在root权限下执行。\\n', '\\n', '# dnf downgrade <packages name>\\n', '检查更新\\n', '\\n', '$ dnf check-update\\n', '卸载，需要在root权限下执行。\\n', '\\n', '# dnf remove <packages name>\\n', '查询\\n', '\\n', '$ dnf search <packages name>\\n', '本地安装，需要在root权限下执行。\\n', '\\n', '# dnf localinstall <absolute path to package name>\\n', '查看历史记录\\n', '\\n', '$ dnf history\\n', '清除缓存目录\\n', '\\n', '$ dnf clean all\\n', '更新缓存\\n', '\\n', '$ dnf makecache']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建web服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建web服务器\\n', '搭建web服务器\\n', 'Apache服务器\\n', '概述\\n', '管理httpd\\n', '配置文件说明\\n', '管理模块和SSL\\n', '验证web服务是否搭建成功\\n', 'Nginx服务器\\n', '概述\\n', '安装\\n', '管理nginx\\n', '配置文件说明\\n', '管理模块\\n', '验证web服务是否搭建成功\\n', 'Apache服务器\\n', '概述\\n', 'Web（World Wide Web）是目前最常用的Internet协议之一。目前在Unix-Like系统中的web服务器主要通过Apache服务器软件实现。为了实现运营动态网站，产生了LAMP（Linux + Apache +MySQL + PHP）。web服务可以结合文字、图形、影像以及声音等多媒体，并支持超链接（Hyperlink）的方式传输信息。\\n', '\\n', 'openEuler系统中的web服务器版本是Apache HTTP服务器2.4版本，即httpd，一个由Apache软件基金会发展而来的开源web服务器。\\n', '\\n', '管理httpd\\n', '概述\\n', '通过systemctl工具，可以对httpd服务进行管理，包括启动、停止、重启服务，以及查看服务状态等。本章介绍Apache HTTP服务的管理操作，以指导用户使用。\\n', '\\n', '前提条件\\n', '为了能够使用Apache HTTP服务，请确保您的系统中已经安装httpd服务的rpm包。在root权限下执行如下命令进行安装：\\n', '\\n', '# dnf install httpd\\n', '更多关于管理服务的内容，请参见管理服务。\\n', '\\n', '启动、停止和重启httpd服务，需要使用root权限。\\n', '\\n', '启动服务\\n', '启动并运行httpd服务，命令如下：\\n', '\\n', '# systemctl start httpd\\n', '假如希望在系统启动时，httpd服务自动启动，则命令和回显如下：\\n', '\\n', '# systemctl enable httpd\\n', 'Created symlink /etc/systemd/system/multi-user.target.wants/httpd.service → /usr/lib/systemd/system/httpd.service.\\n', ' 说明：\\n', '假如正在运行的Apache HTTP服务器作为一个安全服务器，系统开机启动后需要密码，这个密码使用的是加密的私有SSL密钥。\\n', '\\n', '停止服务\\n', '停止运行的httpd服务，命令如下：\\n', '\\n', '# systemctl stop httpd\\n', '如果希望防止服务在系统开机阶段自动开启，命令和回显如下：\\n', '\\n', '# systemctl disable httpd\\n', 'Removed /etc/systemd/system/multi-user.target.wants/httpd.service.\\n', '重启服务\\n', '重启服务有三种方式：\\n', '\\n', '完全重启服务\\n', '\\n', '# systemctl restart httpd\\n', '该命令会停止运行的httpd服务并且立即重新启动它。一般在服务安装以后或者去除一个动态加载的模块（例如PHP）时使用这个命令。\\n', '\\n', '重新加载配置\\n', '\\n', '# systemctl reload httpd\\n', '该命令会使运行的httpd服务重新加载它的配置文件。任何当前正在处理的请求将会被中断，从而造成客户端浏览器显示一个错误消息或者重新渲染部分页面。\\n', '\\n', '重新加载配置而不影响激活的请求\\n', '\\n', '# apachectl graceful\\n', '该命令会使运行的httpd服务重新加载它的配置文件。任何当前正在处理的请求将会继续使用旧的配置文件。\\n', '\\n', '验证服务状态\\n', '验证httpd服务是否正在运行\\n', '\\n', '$ systemctl is-active httpd\\n', '回显为“active”说明服务处于运行状态。\\n', '\\n', '配置文件说明\\n', '当httpd服启动后，默认情况下它会读取如表1所示的配置文件。\\n', '\\n', '表 1 配置文件说明\\n', '\\n', '\\n', '文件\\n', '\\n', '说明\\n', '\\n', '/etc/httpd/conf/httpd.conf\\n', '\\n', '主要的配置文件\\n', '\\n', '/etc/httpd/conf.d\\n', '\\n', '配置文件的辅助目录，这些配置文件也被包含在主配置文件当中\\n', '\\n', '一个配置文件的辅助目录被包含在主要的配置文件中\\n', '\\n', '虽然默认配置可以适用于多数情况，但是用户至少需要熟悉里面的一些重要配置项。配置文件修改完成后，可以在root权限下使用如下命令检查配置文件可能出现的语法错误。\\n', '\\n', '# apachectl configtest\\n', '如果回显如下，说明配置文件语法正确。\\n', '\\n', 'Syntax OK\\n', ' 说明：\\n', '\\n', '在修改配置文件之前，请先备份原始文件，以便出现问题时能够快速恢复配置文件。\\n', '需要重启web服务，才能使修改后的配置文件生效。\\n', '管理模块和SSL\\n', '概述\\n', 'httpd服务是一个模块化的应用，它和许多动态共享对象DSO（Dynamic Shared Objects）一起分发。动态共享对象DSO，在必要情况下，可以在运行时被动态加载或卸载。服务器操作系统中这些模块位于/usr/lib64/httpd/modules/目录下。本节介绍如何加载和写入模块。\\n', '\\n', '加载模块\\n', '为了加载一个特殊的DSO模块，在配置文件中使用加载模块指示。独立软件包提供的模块一般在/etc/httpd/conf.modules.d目录下有他们自己的配置文件。\\n', '\\n', '例如，加载asis DSO模块的操作步骤如下：\\n', '\\n', '在/etc/httpd/conf.modules.d/00-optional.conf文件中，使用root权限取消注释如下配置行。\\n', '\\n', 'LoadModule asis_module modules/mod_asis.so\\n', '加载完成后，请使用root权限重启httpd服务以便于重新加载配置文件。\\n', '\\n', '# systemctl restart httpd\\n', '加载完成后，在root权限下使用httpd -M的命令查看是否已经加载了asis DSO模块。\\n', '\\n', '# httpd -M | grep asis\\n', '回显如下，说明asis DSO模块加载成功。\\n', '\\n', 'asis_module (shared)\\n', ' 说明：\\n', 'httpd 的常用命令\\n', '\\n', 'httpd -v : 查看httpd的版本号。\\n', 'httpd -l：查看编译进httpd程序的静态模块。\\n', 'httpd -M：查看已经编译进httpd程序的静态模块和已经加载的动态模块。\\n', 'SSL介绍\\n', '安全套接层SSL（Secure Sockets Layer）是一个允许服务端和客户端之间进行安全通信的加密协议。其中，传输层安全性协议TLS（Transport Layer Security）为网络通信提供了安全性和数据完整性保障。openEuler支持Mozilla NSS（Network Security Services）作为安全性协议TLS进行配置。加载SSL的操作步骤如下：\\n', '\\n', '在root权限下安装mod_ssl的rpm包。\\n', '\\n', '# dnf install mod_ssl\\n', '安装完成后，请在root权限下重启httpd服务以便于重新加载配置文件。\\n', '\\n', '# systemctl restart httpd\\n', '加载完成后，在root权限下使用httpd -M的命令查看是否已经加载了SSL。\\n', '\\n', '# httpd -M | grep ssl\\n', '回显如下，说明SSL已加载成功。\\n', '\\n', 'ssl_module (shared)\\n', '验证web服务是否搭建成功\\n', 'Web服务器搭建完成后，可以通过如下方式验证是否搭建成功。\\n', '\\n', '在root权限下查看服务器的IP地址，命令如下：\\n', '\\n', '# ifconfig\\n', '回显信息如下，说明服务器IP为 192.168.1.60。\\n', '\\n', 'enp3s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'inet 192.168.1.60  netmask 255.255.255.0  broadcast 192.168.1.255\\n', 'inet6 fe80::5054:ff:fe95:499f  prefixlen 64  scopeid 0x20<link>\\n', 'ether 52:54:00:95:49:9f  txqueuelen 1000  (Ethernet)\\n', 'RX packets 150713207  bytes 49333673733 (45.9 GiB)\\n', 'RX errors 0  dropped 43  overruns 0  frame 0\\n', 'TX packets 2246438  bytes 203186675 (193.7 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'enp4s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'ether 52:54:00:7d:80:9e  txqueuelen 1000  (Ethernet)\\n', 'RX packets 149937274  bytes 44652889185 (41.5 GiB)\\n', 'RX errors 0  dropped 1102561  overruns 0  frame 0\\n', 'TX packets 0  bytes 0 (0.0 B)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\\n', 'inet 127.0.0.1  netmask 255.0.0.0\\n', 'inet6 ::1  prefixlen 128  scopeid 0x10<host>\\n', 'loop  txqueuelen 1000  (Local Loopback)\\n', 'RX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'RX errors 0  dropped 0  overruns 0  frame 0\\n', 'TX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '在root权限下配置防火墙：\\n', '\\n', '# firewall-cmd --add-service=http --permanent\\n', 'success\\n', '# firewall-cmd --reload\\n', 'success\\n', '验证web服务器是否搭建成功，用户可选择Linux或Windows系统进行验证。\\n', '\\n', '使用Linux系统验证\\n', '\\n', '执行如下命令，查看是否可以访问网页信息，服务搭建成功时，该网页可以正常访问。\\n', '\\n', '$ curl http://192.168.1.60\\n', '执行如下命令，查看命令返回值是否为0，返回值为0，说明httpd服务器搭建成功。\\n', '\\n', '$ echo $?\\n', '使用Windows系统验证\\n', '\\n', '打开浏览器，在地址栏输入如下地址，如果能正常访问网页，说明httpd服务器搭建成功。\\n', '\\n', 'http://192.168.1.60\\n', '\\n', '如果修改了端口号，输入地址格式如下：\\n', '\\n', 'http://192.168.1.60:端口号\\n', '\\n', 'Nginx服务器\\n', '概述\\n', 'Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强，支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能，并且支持很多第三方的模块扩展。\\n', '\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装nginx服务。\\n', '\\n', '# dnf install nginx\\n', '查看安装后的rpm包。\\n', '\\n', '$ dnf list all | grep nginx\\n', '管理nginx\\n', '概述\\n', '通过systemctl工具，可以对nginx服务进行管理，包括启动、停止、重启服务，以及查看服务状态等。本章介绍nginx服务的管理操作，以指导用户使用。\\n', '\\n', '前提条件\\n', '为了能够使用nginx服务，请确保您的系统中已经安装nginx服务。若未安装，可参考安装进行安装。\\n', '\\n', '更多关于管理服务的内容，请参见管理服务。\\n', '\\n', '启动、停止和重启nginx服务，需要使用root权限。\\n', '\\n', '启动服务\\n', '启动并运行nginx服务，命令如下：\\n', '\\n', '# systemctl start nginx\\n', '假如希望在系统启动时，nginx服务自动启动，则命令和回显如下：\\n', '\\n', '# systemctl enable nginx\\n', 'Created symlink /etc/systemd/system/multi-user.target.wants/nginx.service → /usr/lib/systemd/system/nginx.service.\\n', ' 说明：\\n', '假如正在运行的nginx服务器作为一个安全服务器，系统开机启动后需要密码，这个密码使用的是加密的私有SSL密钥。\\n', '\\n', '停止服务\\n', '停止运行的nginx服务，命令如下：\\n', '\\n', '# systemctl stop nginx\\n', '如果希望防止服务在系统开机阶段自动开启，命令和回显如下：\\n', '\\n', '# systemctl disable nginx\\n', 'Removed /etc/systemd/system/multi-user.target.wants/nginx.service.\\n', '重启服务\\n', '重启服务有三种方式：\\n', '\\n', '完全重启服务\\n', '\\n', '# systemctl restart nginx\\n', '该命令会停止运行的nginx服务并且立即重新启动它。一般在服务安装以后或者去除一个动态加载的模块（例如PHP）时使用这个命令。\\n', '\\n', '重新加载配置\\n', '\\n', '# systemctl reload nginx\\n', '该命令会使运行的nginx服务重新加载它的配置文件。任何当前正在处理的请求将会被中断，从而造成客户端浏览器显示一个错误消息或者重新渲染部分页面。\\n', '\\n', '平滑重启nginx\\n', '\\n', '# kill -HUP 主进程ID\\n', '该命令会使运行的nginx服务重新加载它的配置文件。任何当前正在处理的请求将会继续使用旧的配置文件。\\n', '\\n', '验证服务状态\\n', '验证nginx服务是否正在运行\\n', '\\n', '$ systemctl is-active nginx\\n', '回显为“active”说明服务处于运行状态。\\n', '\\n', '配置文件说明\\n', '当nginx服启动后，默认情况下它会读取如表2所示的配置文件。\\n', '\\n', '表 2 配置文件说明\\n', '\\n', '\\n', '文件\\n', '\\n', '说明\\n', '\\n', '/etc/nginx/nginx.conf\\n', '\\n', '主要的配置文件\\n', '\\n', '/etc/nginx/conf.d\\n', '\\n', '配置文件的辅助目录，这些配置文件也被包含在主配置文件当中\\n', '\\n', '一个配置文件的辅助目录被包含在主要的配置文件中\\n', '\\n', '虽然默认配置可以适用于多数情况，但是用户至少需要熟悉里面的一些重要配置项。配置文件修改完成后，可以在root权限下使用如下命令检查配置文件可能出现的语法错误。\\n', '\\n', '# nginx -t\\n', '如果回显信息中有“syntax is ok”，说明配置文件语法正确。\\n', '\\n', ' 说明：\\n', '\\n', '在修改配置文件之前，请先备份原始文件，以便出现问题时能够快速恢复配置文件。\\n', '需要重启web服务，才能使修改后的配置文件生效。\\n', '管理模块\\n', '概述\\n', 'nginx服务是一个模块化的应用，它和许多动态共享对象DSO（Dynamic Shared Objects）一起分发。动态共享对象DSO，在必要情况下，可以在运行时被动态加载或卸载。服务器操作系统中这些模块位于/usr/lib64/nginx/modules/目录下。本节介绍如何加载和写入模块。\\n', '\\n', '加载模块\\n', '为了加载一个特殊的DSO模块，在配置文件中使用加载模块指示。独立软件包提供的模块一般在/usr/share/nginx/modules目录下有他们自己的配置文件。\\n', '\\n', '因openEuler操作系统中使用dnf install nginx安装nginx是会自动加载DSO。\\n', '\\n', '验证web服务是否搭建成功\\n', 'Web服务器搭建完成后，可以通过如下方式验证是否搭建成功。\\n', '\\n', '在root权限下查看服务器的IP地址，命令如下：\\n', '\\n', '# ifconfig\\n', '回显信息如下，说明服务器IP为 192.168.1.60。\\n', '\\n', 'enp3s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'inet 192.168.1.60  netmask 255.255.255.0  broadcast 192.168.1.255\\n', 'inet6 fe80::5054:ff:fe95:499f  prefixlen 64  scopeid 0x20<link>\\n', 'ether 52:54:00:95:49:9f  txqueuelen 1000  (Ethernet)\\n', 'RX packets 150713207  bytes 49333673733 (45.9 GiB)\\n', 'RX errors 0  dropped 43  overruns 0  frame 0\\n', 'TX packets 2246438  bytes 203186675 (193.7 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'enp4s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'ether 52:54:00:7d:80:9e  txqueuelen 1000  (Ethernet)\\n', 'RX packets 149937274  bytes 44652889185 (41.5 GiB)\\n', 'RX errors 0  dropped 1102561  overruns 0  frame 0\\n', 'TX packets 0  bytes 0 (0.0 B)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\\n', 'inet 127.0.0.1  netmask 255.0.0.0\\n', 'inet6 ::1  prefixlen 128  scopeid 0x10<host>\\n', 'loop  txqueuelen 1000  (Local Loopback)\\n', 'RX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'RX errors 0  dropped 0  overruns 0  frame 0\\n', 'TX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '在root权限下配置防火墙：\\n', '\\n', '# firewall-cmd --add-service=http --permanent\\n', 'success\\n', '# firewall-cmd --reload\\n', 'success\\n', '验证web服务器是否搭建成功，用户可选择Linux或Windows系统进行验证。\\n', '\\n', '使用Linux系统验证\\n', '\\n', '执行如下命令，查看是否可以访问网页信息，服务搭建成功时，该网页可以正常访问。\\n', '\\n', '$ curl http://192.168.1.60\\n', '执行如下命令，查看命令返回值是否为0，返回值为0，说明nginx服务器搭建成功。\\n', '\\n', '$ echo $?\\n', '使用Windows系统验证\\n', '\\n', '打开浏览器，在地址栏输入如下地址，如果能正常访问网页，说明nginx服务器搭建成功。\\n', '\\n', 'http://192.168.1.60\\n', '\\n', '如果修改了端口号，输入地址格式如下：\\n', '\\n', 'http://192.168.1.60:端口号']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建数据库服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建数据库服务器\\n', '搭建数据库服务器\\n', 'PostgreSql服务器\\n', '软件介绍\\n', '配置环境\\n', '安装、运行和卸载\\n', '管理数据库角色\\n', '管理数据库\\n', 'Mariadb服务器\\n', '软件介绍\\n', '配置环境\\n', '安装、运行和卸载\\n', '管理数据库用户\\n', '管理数据库\\n', 'MySQL服务器\\n', '软件介绍\\n', '配置环境\\n', '安装、运行和卸载\\n', '管理数据库用户\\n', '管理数据库\\n', 'PostgreSql服务器\\n', '软件介绍\\n', 'PostgreSQL的架构如图1所示，主要进程说明如表1所示。\\n', '\\n', '图 1 PostgreSql架构\\n', '\\n', '\\n', '表 1 PostgreSql中的主要进程说明\\n', '\\n', '\\n', '进程类别\\n', '\\n', '进程名称\\n', '\\n', '说明\\n', '\\n', '主进程\\n', '\\n', 'Postmaster\\n', '\\n', 'Postmaster是整个数据库实例的总控进程，负责启动和关闭该数据库实例。\\n', '\\n', '常驻进程\\n', '\\n', 'Postgres（常驻进程）\\n', '\\n', '管理后端的常驻进程，也称为“postmaster”。其默认侦听UNIXDomain Socket和TCP/IP（Windows等，一部分的平台只侦听TCP/IP）的5432端口，等待来自前端的的连接处理。侦听的端口号可以在PostgreSql的设置文件postgresql.conf中修改。\\n', '\\n', '子进程\\n', '\\n', 'Postgres（子进程）\\n', '\\n', '子进程根据pg_hba.conf定义的安全策略来判断是否允许进行连接，根据策略，会拒绝某些特定的IP及网络，或者也可以只允许某些特定的用户或者对某些数据库进行连接。\\n', '\\n', 'Postgres会接受前端过来的查询，然后对数据库进行检索，最后把结果返回，有时也会对数据库进行更新。更新的数据同时还会记录在事务日志里面（PostgreSQL称为WAL日志）。这个主要是当停电、服务器宕机、重新启动的时候进行恢复处理的时候使用。另外，把日志归档保存起来，可在需要进行恢复的时候使用。在PostgreSQL 9.0以后，通过把WAL日志传送其他的postgreSQL，可以实时的进行数据库复制，这就是所谓的“数据库复制”功能。\\n', '\\n', '辅助进程\\n', '\\n', 'SysLogger（系统日志）\\n', '\\n', '需要在Postgres.conf中logging_collection设置为on，此时主进程才会启动Syslogger辅助进程。\\n', '\\n', 'BgWriter（后台写）\\n', '\\n', '把共享内存中的脏页写到磁盘上的进程。主要是为了提高插入、更新和删除数据的性能。\\n', '\\n', 'WALWriter（预写式日志）\\n', '\\n', '在修改数据之前把修改操作记录到磁盘中，以便后面更新实时数据时就不需要数据持久化到文件中。\\n', '\\n', 'PgArch（归档）\\n', '\\n', 'WAL日志会被循环使用，PgArch在归档前会把WAL日志备份出来。通过PITY（Point in Time Recovery）技术，可以对数据库进行一次全量备份后，该技术将备份时间点之后的WAL日志通过归档进行备份，使用数据库的全量备份再加上后面产生的WAL日志，即可把数据库向前推到全量备份后的任意一个时间点。\\n', '\\n', 'AutoVacuum（系统自动清理）\\n', '\\n', '在PostgreSQL数据库中，对表进行DELETE操作后，旧的数据并不会立即被删除，并且，在更新数据时，也并不会在旧的数据上做更新，而是新生成一行数据。旧的数据只是被标识为删除状态，只有在没有并发的其他事务读到这些就数据时，它们才会被清除。这个清除工作就由AutoVacuum进程完成。\\n', '\\n', 'PgStat（统计收集）\\n', '\\n', '做数据的统计收集工作。主要用于查询优化时的代价估算，包括一个表和索引进行了多少次的插入、更新、删除操作，磁盘块读写的次数、行的读次数。pg_statistic中存储了PgStat收集的各类信息。\\n', '\\n', 'CheckPoint（检查点）\\n', '\\n', '检查点是系统设置的事务序列点，设置检查点保证检查点前的日志信息刷到磁盘中。\\n', '\\n', '配置环境\\n', ' 说明：\\n', '以下环境配置仅为参考示例，具体配置视实际需求做配置\\n', '\\n', '关闭防火墙并取消开机自启动\\n', ' 说明：\\n', '测试环境下通常会关闭防火墙以避免部分网络因素影响，视实际需求做配置。\\n', '\\n', '在root权限下停止防火墙。\\n', '\\n', '# systemctl stop firewalld\\n', '在root权限下关闭防火墙。\\n', '\\n', '# systemctl disable firewalld\\n', ' 说明：\\n', '执行disable命令关闭防火墙的同时，也取消了开机自启动。\\n', '\\n', '修改SELINUX为disabled\\n', '在root权限下修改配置文件。\\n', '\\n', \"# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\\n\", '创建组和用户\\n', ' 说明：\\n', '服务器环境下，为了系统安全，通常会为进程分配单独的用户，以实现权限隔离。本章节创建的组和用户都是操作系统层面的，不是数据库层面的。\\n', '\\n', '在root权限下创建PostgreSQL用户（组）。\\n', '\\n', '# groupadd  postgres\\n', '# useradd  -g postgres postgres\\n', '在root权限下设置postgres用户密码（重复输入密码）。\\n', '\\n', '# passwd postgres\\n', '搭建数据盘\\n', ' 说明：\\n', '\\n', '测试极限性能时，建议单独挂载IO性能更优的NVME SSD存储介质创建PostgreSQL测试实例，避免磁盘IO对性能测试结果的影响，本文以单独挂载NVME SSD为例，参考步骤1~步骤4。\\n', '非性能测试时，在root权限下执行以下命令，创建数据目录即可。然后跳过本小节：\\n', '# mkdir /data\\n', '在root权限下创建文件系统（以xfs为例，根据实际需求创建文件系统），若磁盘之前已做过文件系统，执行此命令会出现报错，可使用-f参数强制创建文件系统。\\n', '\\n', '# mkfs.xfs /dev/nvme0n1\\n', '在root权限下创建数据目录。\\n', '\\n', '# mkdir /data\\n', '在root权限下挂载磁盘。\\n', '\\n', '# mount -o noatime,nobarrier /dev/nvme0n1 /data\\n', '数据目录授权\\n', '在root权限下修改目录权限。\\n', '\\n', '# chown -R postgres:postgres /data/\\n', '安装、运行和卸载\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装PostgreSQL服务器。\\n', '\\n', '# dnf install postgresql-server\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep postgresql\\n', '运行\\n', '初始化数据库\\n', ' 须知：\\n', '此步骤在postgres用户下操作。\\n', '\\n', '切换到已创建的PostgreSQL用户。\\n', '\\n', '# su - postgres\\n', '初始化数据库，其中命令中的/usr/bin是命令initdb所在的目录。\\n', '\\n', '$ /usr/bin/initdb -D /data/\\n', '启动数据库\\n', '启动PostgreSQL数据库。\\n', '\\n', '$ /usr/bin/pg_ctl -D /data/ -l /data/logfile start\\n', '确认PostgreSQL数据库进程是否正常启动。\\n', '\\n', '$ ps -ef | grep postgres\\n', '命令执行后，打印信息如下图所示，PostgreSQL相关进程已经正常启动了。\\n', '\\n', '\\n', '\\n', '登录数据库\\n', '登录数据库。\\n', '\\n', '$ /usr/bin/psql -U postgres\\n', '\\n', '\\n', ' 说明：\\n', '初次登录数据库，无需密码。\\n', '\\n', '配置数据库账号密码\\n', '登录后，设置postgres密码。\\n', '\\n', \"postgres=#alter user postgres with password '123456';\\n\", '\\n', '\\n', '退出数据库\\n', '执行\\\\q退出数据库。\\n', '\\n', 'postgres=#\\\\q\\n', '停止数据库\\n', '停止PostgreSQL数据库。\\n', '\\n', '$ /usr/bin/pg_ctl -D /data/ -l /data/logfile stop\\n', '卸载\\n', '在postgres用户下停止数据库。\\n', '\\n', '$ /usr/bin/pg_ctl -D /data/ -l /data/logfile stop\\n', '在root用户下执行dnf remove postgresql-server卸载PostgreSQL数据库。\\n', '\\n', '# dnf remove postgresql-server\\n', '管理数据库角色\\n', '创建角色\\n', '可以使用CREATE ROLE语句或createuser来创建角色。createuser是对CREATE ROLE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', 'CREATE ROLE rolename [ [ WITH ] option [ ... ] ];\\n', 'createuser rolename\\n', '其中：\\n', '\\n', 'rolename：角色名。\\n', 'option为参数选项，常用的有：\\n', 'SUPERUSER | NOSUPERUSER：决定一个新角色是否为\"超级用户\"，若未指定，则默认为NOSUPERUSER，即不是超级用户。\\n', 'CREATEDB | NOCREATEDB：定义一个角色是否能创建数据库，若未指定，则默认为NOCREATEDB，即不能创建数据库。\\n', 'CREATEROLE | NOCREATEROLE：决定一个角色是否可以创建新角色，若未指定，则默认为NOCREATEROLE，即不能创建新角色。\\n', 'INHERIT | NOINHERIT：决定一个角色是否\"继承\"它所在组的角色的权限。一个带有 INHERIT 属性的角色可以自动使用已经赋与它直接或间接所在组的任何权限。若未指定，则默认为INHERIT。\\n', 'LOGIN | NOLOGIN：决定一个角色是否可以登录，一个拥有LOGIN属性的角色可以认为是一个用户，若无此属性的角色可以用于管理数据库权限，但是并不是用户，若未指定，则默认为NOLOGIN。但若创建角色是使用的是CREATE USER而不是CREATE ROLE，则默认是LOGIN属性。\\n', \"[ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'：设置角色的密码，密码只对那些拥有 LOGIN 属性的角色有意义。ENCRYPTED | UNENCRYPTED表示是否对密码进行加密，若未指定，则默认为ENCRYPTED，即加密。\\n\", \"VALID UNTIL 'timestamp'：角色的密码失效的时间戳，若为指定，则表示密码永久有效。\\n\", 'IN ROLE rolename1：列出一个或多个现有的角色，新角色rolename将立即加入这些角色，成为rolename1的成员。\\n', 'ROLE rolename2：列出一个或多个现有的角色，它们将自动添加为新角色rolename的成员，即新角色为\"组\"。\\n', '要使用这条命令，必须拥有 CREATEROLE 权限或者是数据库超级用户。\\n', '\\n', '示例\\n', '#创建一个可以登录的角色roleexample1。\\n', '\\n', 'postgres=# CREATE ROLE roleexample1 LOGIN;\\n', '#创建一个密码为123456的角色roleexample2。\\n', '\\n', \"postgres=# CREATE ROLE roleexample2 WITH LOGIN PASSWORD '123456';\\n\", '#创建角色名为roleexample3的角色。。\\n', '\\n', '[postgres@localhost ~]$ createuser roleexample3\\n', '查看角色\\n', '可以使用SELECT语句或psql的元命令\\\\du查看角色。\\n', '\\n', 'SELECT rolename FROM pg_roles;\\n', '\\\\du\\n', '其中：rolename：角色名。\\n', '\\n', '示例\\n', '#查看roleexample1角色。\\n', '\\n', 'postgres=# SELECT roleexample1 from pg_roles;\\n', '#查看现有角色。\\n', '\\n', 'postgres=# \\\\du\\n', '修改角色\\n', '修改用户名\\n', '可以使用ALTER ROLE语句修改一个已经存在的角色名。\\n', '\\n', 'ALTER ROLE oldrolername RENAME TO newrolename;\\n', '其中：\\n', '\\n', 'oldrolername：旧的角色名。\\n', 'newrolename：新的角色名。\\n', '修改用户示例\\n', '#将角色名roleexample1修改为roleexapme2。\\n', '\\n', 'postgres=# ALTER ROLE roleexample1 RENAME TO roleexample2;\\n', '修改用户密码\\n', '可以使用ALTER ROLE语句修改一个角色的登录密码。\\n', '\\n', \"ALTER ROLE rolename PASSWORD 'password'\\n\", '其中：\\n', '\\n', 'rolename：角色名。\\n', 'password：密码。\\n', '修改角色密码示例\\n', '#将roleexample1的密码修改为456789。\\n', '\\n', \"postgres=# ALTER ROLE roleexample1 WITH PASSWORD '456789';\\n\", '删除角色\\n', '可以使用DROP ROLE语句或dropuser来删除角色。dropuser是对DROP ROLE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', 'DROP ROLE rolename;\\n', 'dropuser rolename\\n', '其中：rolename：角色名。\\n', '\\n', '示例\\n', '#删除userexample1角色。\\n', '\\n', 'postgres=# DROP ROLE userexample1;\\n', '#删除userexample2角色。。\\n', '\\n', '[postgres@localhost ~]$ dropuser userexample2\\n', '角色授权\\n', '可以使用GRANT语句来对角色授权。\\n', '\\n', '对角色授予表的操作权限：\\n', '\\n', 'GRANT { { SELECT | INSERT | UPDATE | DELETE | REFERENCES | TRIGGER } [,...] | ALL [ PRIVILEGES ] } ON [ TABLE ] tablename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]\\n', '对角色授予序列的操作权限：\\n', '\\n', 'GRANT { { USAGE | SELECT | UPDATE } [,...] | ALL [ PRIVILEGES ] } ON SEQUENCE sequencename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ] \\n', '对角色授予数据库的操作权限：\\n', '\\n', 'GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] } ON DATABASE databasename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予函数的操作权限：\\n', '\\n', 'GRANT { EXECUTE | ALL [ PRIVILEGES ] } ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予过程语言的操作权限：\\n', '\\n', 'GRANT { USAGE | ALL [ PRIVILEGES ] } ON LANGUAGE langname [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予模式的操作权限：\\n', '\\n', 'GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] } ON SCHEMA schemaname [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予表空间的操作权限：\\n', '\\n', 'GRANT { CREATE | ALL [ PRIVILEGES ] } ON TABLESPACE tablespacename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ] \\n', '将角色rolename1的成员关系赋予角色rolename2：\\n', '\\n', 'GRANT rolename1 [, ...] TO rolename2 [, ...] [ WITH ADMIN OPTION ]\\n', '其中：\\n', '\\n', 'SELECT、INSERT、UPDATE、DELETE、REFERENCES、TRIGGER、USAGE、CREATE、CONNECT、TEMPORARY、TEMP、EXECUTE、ALL [ PRIVILEGES ]：用户的操作权限，ALL [ PRIVILEGES ]表示所有的权限，PRIVILEGES关键字在 PostgreSQL里是可选的，但是严格的SQL 要求有这个关键字。\\n', 'ON字句：用于指定权限授予的对象。\\n', 'tablename：表名。\\n', 'TO字句：用来指定被赋予权限的角色。\\n', 'rolename、rolename1、rolename2：角色名。\\n', 'groupname：角色组名。\\n', 'PUBLIC：表示该权限要赋予所有角色，包括那些以后可能创建的用户。\\n', 'WITH GRANT OPTION：表示权限的接收者也可以将此权限赋予他人，否则就不能授权他人。该选项不能赋予给PUBLIC。\\n', 'sequencename：序列名。\\n', 'databasename：数据库名。\\n', 'funcname ( [ [ argmode ] [ argname ] argtype [, …] ] )：函数名及其参数。\\n', 'langname：过程语言名。\\n', 'schemaname：模式名。\\n', 'tablespacename：表空间名。\\n', 'WITH ADMIN OPTION：表示成员随后就可以将角色的成员关系赋予其它角色，以及撤销其它角色的成员关系。\\n', '示例\\n', '#对userexample授予数据库database1的CREATE权限。\\n', '\\n', 'postgres=# GRANT CREATE ON DATABASE database1 TO userexample; \\n', '#对所有用户授予表table1的所有权限。\\n', '\\n', 'postgres=# GRANT ALL PRIVILEGES ON TABLE table1 TO PUBLIC; \\n', '删除用户权限\\n', '可以使用REVOKE语句来撤销以前赋予一个或多个角色的权限。\\n', '\\n', '撤销角色对表的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { SELECT | INSERT | UPDATE | DELETE | REFERENCES | TRIGGER } [,...] | ALL [ PRIVILEGES ] } ON [ TABLE ] tablename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...]\\n', '撤销角色对序列的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { USAGE | SELECT | UPDATE } [,...] | ALL [ PRIVILEGES ] } ON SEQUENCE sequencename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ]  \\n', '撤销角色对数据库的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] } ON DATABASE databasename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '撤销角色对函数的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { EXECUTE | ALL [ PRIVILEGES ] } ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '撤销角色对过程语言的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { USAGE | ALL [ PRIVILEGES ] } ON LANGUAGE langname [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '撤销角色对模式的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] } ON SCHEMA schemaname [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ]  \\n', '撤销角色对表空间的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { CREATE | ALL [ PRIVILEGES ] } ON TABLESPACE tablespacename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '删除rolename2的rolename1的成员关系：\\n', '\\n', 'REVOKE [ ADMIN OPTION FOR ] rolename1 [, ...] FROM rolename2 [, ...] [ CASCADE | RESTRICT ]\\n', '其中：\\n', '\\n', 'GRANT OPTION FOR：表示只是撤销对该权限的授权的权力，而不是撤销该权限本身。\\n', 'SELECT、INSERT、UPDATE、DELETE、REFERENCES、TRIGGER、USAGE、CREATE、CONNECT、TEMPORARY、TEMP、EXECUTE、ALL [ PRIVILEGES ]：用户的操作权限，ALL [ PRIVILEGES ]表示所有的权限，PRIVILEGES关键字在 PostgreSQL里是可选的，但是严格的SQL 要求有这个关键字。\\n', 'ON字句：用于指定撤销权限的对象。\\n', 'tablename：表名。\\n', 'FROM字句：用来指定被撤销权限的角色。\\n', 'rolename、rolename1、rolename2：角色名。\\n', 'groupname：角色组名。\\n', 'PUBLIC：表示撤销隐含定义的、拥有所有角色的组，但并不意味着所有角色都失去了权限，那些直接得到的权限以及通过一个组得到的权限仍然有效。\\n', 'sequencename：序列名。\\n', 'CASCADE：撤销所有依赖性权限。\\n', 'RESTRICT：不撤销所有依赖性权限。\\n', 'databasename：数据库名。\\n', 'funcname ( [ [ argmode ] [ argname ] argtype [, …] ] )：函数名及其参数。\\n', 'langname：过程语言名。\\n', 'schemaname：模式名。\\n', 'tablespacename：表空间名。\\n', 'ADMIN OPTION FOR：表示传递的授权不会自动收回。\\n', '示例\\n', '#对userexample授予数据库database1的CREATE权限。\\n', '\\n', 'postgres=# GRANT CREATE ON DATABASE database1 TO userexample; \\n', '#对所有用户授予表table1的所有权限。\\n', '\\n', 'postgres=# GRANT ALL PRIVILEGES ON TABLE table1 TO PUBLIC; \\n', '管理数据库\\n', '创建数据库\\n', '可以使用CREATE DATABASE语句或createdb来创建角色。createrdb是对CREATE DATABASE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', 'CREATE DATABASE databasename;\\n', 'createdb databasename\\n', '其中：databasename为数据库名。\\n', '\\n', '要使用这条命令，必须拥有CREATEDB权限。\\n', '\\n', '示例\\n', '#创建一个数据库database1。\\n', '\\n', 'postgres=# CREATE DATABASE database1;\\n', '选择数据库\\n', '可以使用\\\\c语句来选择数据库。\\n', '\\n', '\\\\c databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', '示例\\n', '#选择databaseexample数据库。\\n', '\\n', 'postgres=# \\\\c databaseexample;\\n', '查看数据库\\n', '可以使用\\\\l语句来查看数据库。\\n', '\\n', '\\\\l;\\n', '示例\\n', '#查看所有数据库。\\n', '\\n', 'postgres=# \\\\l;\\n', '删除数据库\\n', '可以使用DROP DATABASE语句或dropdb来删除数据库。dropdb是对DROP DATABASE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', ' 注意：\\n', '删除数据库要谨慎操作，一旦删除，数据库中的所有表和数据都会删除。\\n', '\\n', 'DROP DATABASE databasename;\\n', 'dropdb databasename\\n', '其中：databasename为数据库名称。\\n', '\\n', 'DROP DATABASE会删除数据库的系统目录项并且删除包含数据的文件目录。\\n', '\\n', 'DROP DATABASE只能由超级管理员或数据库拥有者执行。\\n', '\\n', '示例\\n', '#删除databaseexample数据库。\\n', '\\n', 'postgres=# DROP DATABASE databaseexample;\\n', '备份数据库\\n', '可以使用pg_dump命令备份数据库，将数据库转储到一个脚本文件或其他归档文件中。\\n', '\\n', 'pg_dump [option]... [databasename] > outfile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。如果没有声明这个参数，那么使用环境变量 PGDATABASE 。如果那个环境变量也没声明，那么使用发起连接的用户名。\\n', 'outfile：数据库备份的文件。\\n', 'option：pg_dump命令参数选项，多个参数之间可以使用空格分隔。常用的pg_dump命令参数选项如下：\\n', '-f，--file= filename ：指输出到指定的文件。如果忽略，则使用标准输出。\\n', '-d，--dbname= databasename ：指定转储的数据库。\\n', '-h，--host= hostname ：指定主机名。\\n', '-p，--port= portnumber ：指定端口。\\n', '-U，--username= username ：指定连接的用户名。\\n', '-W，--password：强制口令提示（自动）。\\n', '示例\\n', '#备份主机为192.168.202.144，端口为3306，postgres用户下的database1数据库到db1.sql中。\\n', '\\n', '[postgres@localhost ~]$ pg_dump -h 192.168.202.144 -p 3306 -U postgres -W database1 > db1.sql\\n', '恢复数据库\\n', '可以使用psql命令恢复数据库。\\n', '\\n', 'psql [option]... [databasename [username]] < infile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。如果没有声明这个参数，那么使用环境变量 PGDATABASE 。如果那个环境变量也没声明，那么使用发起连接的用户名。\\n', 'username：用户名。\\n', 'infile：pg_dump命令中的outfile参数。\\n', 'option：psql命令参数选项，多个参数之间可以使用空格分隔。常用的psql命令参数选项如下：\\n', '-f，--file=filename：指输出到指定的文件。如果忽略，则使用标准输出。\\n', '-d，--dbname=databasename：指定转储的数据库。\\n', '-h，--host=hostname：指定主机名。\\n', '-p，--port=portnumber：指定端口。\\n', '-U，--username=username：指定连接的用户名。\\n', '-W，--password：强制口令提示（自动）。\\n', 'psql命令不会自动创建databasename数据库，所以在执行psql恢复数据库之前需要先创建databasename数据库。\\n', '\\n', '示例\\n', '#将db1.sql脚本文件导入到主机为192.168.202.144，端口为3306，postgres用户下newdb数据库中。\\n', '\\n', '[postgres@localhost ~]$ createdb newdb\\n', '[postgres@localhost ~]$ psql -h 192.168.202.144 -p 3306 -U postgres -W -d newdb < db1.sql\\n', 'Mariadb服务器\\n', '软件介绍\\n', 'MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品，MariaDB还提供了许多更好的新特性。\\n', '\\n', 'MariaDB的架构如图2所示。\\n', '\\n', '图 2 MariaDB逻辑架构\\n', '\\n', '\\n', '当Mariadb接受到Sql语句时，其详细的执行过程如下：\\n', '\\n', '当客户端连接到mariadb的时候，会认证客户端的主机名、用户、密码，认证功能可以做成插件。\\n', '如果登录成功，客户端发送sql命令到服务端。由解析器解析sql语句。\\n', '服务端检查客户端是否有权限去获取它想要的资源。\\n', '如果查询已经存储在query cache当中，那么结果立即返回。\\n', '优化器将会找出最快的执行策略，或者是执行计划，也就是说优化器可以决定什么表将会被读，以及哪些索引会被访问，哪些临时表会被使用，一个好的策略能够减少大量的磁盘访问和排序操作等。\\n', '存储引擎读写数据和索引文件，cache用来加速这些操作，其他的诸如事物和外键特性，都是在存储引擎层处理的。\\n', '存储引擎在物理层管控数据，它负责数据文件、数据、索引、cache等的管理，这使得管理和读取数据变得更高效，每一张表，都有一个.frm文件，这些文件包含着表的定义。\\n', '\\n', '每一个存储引擎管理、存储数据的方式都是不同的，所支持的特性和性能也不尽相同。例如：\\n', '\\n', 'MyISAM，适合读多写少的环境，且不支持事务，支持全文索引等。\\n', 'noDB，支持事务，支持行锁和外键等。\\n', 'MEMORY，将数据存储在内存当中。\\n', 'CSV，将数据存储为CSV格式。\\n', '配置环境\\n', ' 说明：\\n', '以下环境配置仅为参考示例，具体配置视实际需求做配置\\n', '\\n', '关闭防火墙并取消开机自启动\\n', ' 说明：\\n', '测试环境下通常会关闭防火墙以避免部分网络因素影响，视实际需求做配置。\\n', '\\n', '在root权限下停止防火墙。\\n', '\\n', '# systemctl stop firewalld\\n', '在root权限下关闭防火墙。\\n', '\\n', '# systemctl disable firewalld\\n', ' 说明：\\n', '执行disable命令关闭防火墙的同时，也取消了开机自启动。\\n', '\\n', '修改SELINUX为disabled\\n', '在root权限下修改配置文件。\\n', '\\n', \"# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\\n\", '创建组和用户\\n', ' 说明：\\n', '服务器环境下，为了系统安全，通常会为进程分配单独的用户，以实现权限隔离。本章节创建的组和用户都是操作系统层面的，不是数据库层面的。\\n', '\\n', '在root权限下创建MySQL用户（组）。\\n', '\\n', '# groupadd mysql\\n', '# useradd -g mysql mysql\\n', '在root权限下设置MySQL用户密码。\\n', '\\n', '# passwd mysql\\n', '重复输入密码（根据实际需求设置密码）。\\n', '\\n', '搭建数据盘\\n', ' 说明：\\n', '\\n', '进行性能测试时，数据目录使用单独硬盘，需要对硬盘进行格式化并挂载，参考方法一或者方法二\\n', '非性能测试时，在root权限下执行以下命令，创建数据目录即可。然后跳过本小节：\\n', '#mkdir /data\\n', '方法一：在root权限下使用fdisk进行磁盘管理\\n', '创建分区（以/dev/sdb为例，根据实际情况创建）\\n', '\\n', '# fdisk /dev/sdb\\n', '输入n，按回车确认。\\n', '\\n', '输入p，按回车确认。\\n', '\\n', '输入1，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '输入w，按回车保存。\\n', '\\n', '创建文件系统（以xfs为例，根据实际需求创建文件系统）\\n', '\\n', '# mkfs.xfs /dev/sdb1\\n', '挂载分区到“/data”以供操作系统使用。\\n', '\\n', '# mkdir /data\\n', '# mount /dev/sdb1 /data\\n', '执行命令“vi /etc/fstab\", 编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/nvme0n1p1为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '方法二：在root权限下使用LVM进行磁盘管理\\n', ' 说明：\\n', '此步骤需要安装镜像中的lvm2相关包，步骤如下：\\n', '\\n', '配置本地yum源，详细信息请参考搭建repo服务器。如果已经执行，则可跳过此步。\\n', '在root权限下执行命令安装lvm2。\\n', '# yum install lvm2\\n', '创建物理卷（sdb为硬盘名称，具体名字以实际为准）。\\n', '\\n', '# pvcreate /dev/sdb\\n', '创建物理卷组（其中datavg为创建的卷组名称，具体名字以实际规划为准）。\\n', '\\n', '# vgcreate datavg  /dev/sdb\\n', '创建逻辑卷（其中600G为规划的逻辑卷大小，具体大小以实际情况为准；datalv为创建的逻辑卷的名字，具体名称以实际规划为准。)。\\n', '\\n', '# lvcreate -L 600G -n datalv datavg\\n', '创建文件系统。\\n', '\\n', '# mkfs.xfs /dev/datavg/datalv\\n', '创建数据目录并挂载。\\n', '\\n', '# mkdir /data\\n', '# mount /dev/datavg/datalv /data\\n', '执行命令vi /etc/fstab，编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/datavg/datalv为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '创建数据库目录并且授权\\n', '在已创建的数据目录 /data 基础上，使用root权限继续创建进程所需的相关目录并授权MySQL用户（组）。\\n', '\\n', '# mkdir -p /data/mariadb\\n', '# cd /data/mariadb\\n', '# mkdir data tmp run log\\n', '# chown -R mysql:mysql /data\\n', '安装、运行和卸载\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装mariadb服务器。\\n', '\\n', '# dnf install mariadb-server\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep mariadb\\n', '运行\\n', '在root权限下开启mariadb服务器。\\n', '\\n', '# systemctl start mariadb\\n', '在root权限下初始化数据库。\\n', '\\n', '# /usr/bin/mysql_secure_installation\\n', '命令执行过程中需要输入数据库的root设置的密码，若没有密码则直接按“Enter”。然后根据提示及实际情况进行设置。\\n', '\\n', '登录数据库。\\n', '\\n', '$ mysql -u root -p\\n', '命令执行后提示输入密码。密码为2中设置的密码。\\n', '\\n', ' 说明：\\n', '执行 \\\\q 或者 exit 可退出数据库。\\n', '\\n', '卸载\\n', '在root权限下关闭数据库进程。\\n', '\\n', '$ ps -ef | grep mysql\\n', '# kill -9 进程ID\\n', '在root权限下执行dnf remove mariadb-server命令卸载mariadb。\\n', '\\n', '# dnf remove mariadb-server\\n', '管理数据库用户\\n', '创建用户\\n', '可以使用CREATE USER语句来创建一个或多个用户，并设置相应的口令。\\n', '\\n', \"CREATE USER 'username'@'hostname' IDENTIFIED BY 'password';\\n\", '其中：\\n', '\\n', 'username：用户名。\\n', 'host：主机名，即用户连接数据库时所在的主机的名字。若是本地用户可用localhost，若在创建的过程中，未指定主机名，则主机名默认为“%”，表示一组主机。\\n', 'password：用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器，但从安全的角度而言，不推荐这种做法。\\n', '使用CREATE USER语句必须拥有数据库的INSERT权限或全局CREATE USER权限。\\n', '\\n', '使用CREATE USER语句创建一个用户账号后，会在系统自身的数据库的user表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。\\n', '\\n', '新创建的用户拥有的权限很少，只允许进行不需要权限的操作，如使用SHOW语句查询所有存储引擎和字符集的列表等。\\n', '\\n', '示例\\n', '#创建密码为123456，用户名为userexample1的本地用户。\\n', '\\n', \"> CREATE USER 'userexample1'@'localhost' IDENTIFIED BY '123456';\\n\", '#创建密码为123456，用户名为userexample2，主机名为192.168.1.100的用户。\\n', '\\n', \"> CREATE USER 'userexample2'@'192.168.1.100' IDENTIFIED BY '123456';\\n\", '查看用户\\n', '可以使用SHOW GRANTS语句或SELECT语句查看一个或多个用户。\\n', '\\n', '查看特定用户：\\n', '\\n', \"SHOW GRANTS [FOR 'username'@'hostname'];\\n\", \"SELECT USER,HOST,PASSWORD FROM mysql.user WHERE USER='username';\\n\", '查看所有用户：\\n', '\\n', 'SELECT USER,HOST,PASSWORD FROM mysql.user;\\n', '其中：\\n', '\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '示例\\n', '#查看userexample1用户。\\n', '\\n', \"> SHOW GRANTS FOR 'userexample1'@'localhost';\\n\", '#查看mysql数据库中所有用户。\\n', '\\n', '> SELECT USER,HOST,PASSWORD FROM mysql.user;\\n', '修改用户\\n', '修改用户名\\n', '可以使用RENAME USER语句修改一个或多个已经存在的用户名。\\n', '\\n', \"RENAME USER 'oldusername'@'hostname' TO 'newusername'@'hostname';\\n\", '其中：\\n', '\\n', 'oldusername：旧的用户名。\\n', 'newusername：新的用户名。\\n', 'hostname：主机名。\\n', 'RENAME USER语句用于对原有的账号进行重命名。若系统中旧账号不存在或者新账号已存在，则该语句执行时会出现错误。\\n', '\\n', '使用RENAME USER语句，必须拥有数据库的UPDATE权限或全局CREATE USER权限。\\n', '\\n', '修改用户示例\\n', '#将用户名userexample1修改为userexapme2，主机名为locahost。\\n', '\\n', \"> RENAME USER 'userexample1'@'localhost' TO 'userexample2'@'localhost';\\n\", '修改用户密码\\n', '可以使用SET PASSWORD语句修改一个用户的登录密码。\\n', '\\n', \"SET PASSWORD FOR 'username'@'hostname' = PASSWORD('newpassword');\\n\", '其中：\\n', '\\n', \"FOR 'username'@'hostname'：FOR字句，可选项，指定欲修改密码的用户名及主机名。\\n\", \"PASSWORD('newpassword')：表示使用函数PASSWORD()设置新口令，即新口令必须传递到函数PASSWORD()中进行加密。\\n\", ' 注意：\\n', 'PASSWORD()函数为单向加密函数，一旦加密后不能解密出原明文。\\n', '\\n', '在SET PASSWORD语句中，若不加上FOR子句，表示修改当前用户的密码。\\n', '\\n', \"FOR字句中必须以'username'@'hostname'的格式给定，username为账户的用户名，hostname为账户的主机名。\\n\", '\\n', '欲修改密码的账号必须在系统中存在，否则语句执行时会出现错误。\\n', '\\n', '修改用户密码示例\\n', '#将用户名为userexample的密码修改为0123456，主机名为locahost。\\n', '\\n', \"> SET PASSWORD FOR 'userexample'@'localhost' = PASSWORD('0123456') ;\\n\", '删除用户\\n', '可以使用DROP USER语句来删除一个或多个用户账号以及相关的权限。\\n', '\\n', \"DROP USER 'username1'@'hostname1' [,'username2'@'hostname2']…;\\n\", ' 注意：\\n', '用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为数据库并不会记录创建了这些对象的账号。\\n', '\\n', 'DROP USER语句可用于删除一个或多个数据库账号，并删除其原有权限。\\n', '\\n', '使用DROP USER语句必须拥有数据库的DELETE权限或全局CREATE USER权限。\\n', '\\n', '在DROP USER语句的使用中，若没有明确地给出账号的主机名，则该主机名默认为“%”。\\n', '\\n', '示例\\n', '#删除用户名为userexample的本地用户。\\n', '\\n', \"> DROP USER 'userexample'@'localhost';\\n\", '用户授权\\n', '可以使用GRANT语句来对新建用户的授权。\\n', '\\n', \"GRANT privileges ON databasename.tablename TO 'username'@'hostname';\\n\", '其中：\\n', '\\n', 'ON字句：用于指定权限授予的对象和级别。\\n', 'privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所有的权限则使用ALL。\\n', 'databasename：数据库名。\\n', 'tablename：表名。\\n', 'TO字句：用来设定用户密码，以及指定被赋予权限的用户。\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*。\\n', '\\n', '如果在TO子句中给系统中存在的用户指定密码，则新密码会将原密码覆盖。\\n', '\\n', '如果权限被授予给一个不存在的用户，则会自动执行一条CREATE USER语句来创建这个用户，但同时必须为该用户指定密码。\\n', '\\n', '示例\\n', '#对本地用户userexample授予SELECT和INSERT权限。\\n', '\\n', \"> GRANT SELECT,INSERT ON *.* TO 'userexample'@'localhost'; \\n\", '删除用户权限\\n', '可以使用REVOKE语句来删除一个用户的权限，但此用户不会被删除。\\n', '\\n', \"REVOKE privilege ON databasename.tablename FROM 'username'@'hostname';\\n\", '其中REVOKE语句的参数与GRANT语句的参数含义相同。\\n', '\\n', '要使用 REVOKE 语句，必须拥有数据库的全局CREATE USER权限或UPDATE权限。\\n', '\\n', '示例\\n', '#删除本地用户userexample的INSERT权限。\\n', '\\n', \"> REVOKE INSERT ON *.* FROM 'userexample'@'localhost';\\n\", '管理数据库\\n', '创建数据库\\n', '可以使用CREATE DATABASE语句来创建数据库。\\n', '\\n', 'CREATE DATABASE databasename;\\n', '其中：databasename为数据库名称，且数据库名称不区分大小写。\\n', '\\n', '示例\\n', '#创建数据库名为databaseexample的数据库。\\n', '\\n', '> CREATE DATABASE databaseexample;\\n', '查看数据库\\n', '可以使用SHOW DATABASES语句来查看数据库。\\n', '\\n', 'SHOW DATABASES;\\n', '示例\\n', '#查看所有数据库。\\n', '\\n', '> SHOW DATABASES;\\n', '选择数据库\\n', '一般创建表，查询表等操作首先需要选择一个目标数据库。可以使用USE语句来选择数据库。\\n', '\\n', 'USE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', '示例\\n', '#选择databaseexample数据库。\\n', '\\n', '> USE databaseexample;\\n', '删除数据库\\n', '可以使用DROP DATABASE语句来删除数据库。\\n', '\\n', ' 注意：\\n', '删除数据库要谨慎操作，一旦删除，数据库中的所有表和数据都会删除。\\n', '\\n', 'DROP DATABASE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', 'DROP DATABASE命令用于删除创建过(已存在)的数据库，且会删除数据库中的所有表，但数据库的用户权限不会自动删除。\\n', '\\n', '要使用DROP DATABASE，您需要数据库的DROP权限。\\n', '\\n', 'DROP SCHEMA是DROP DATABASE的同义词。\\n', '\\n', '示例\\n', '#删除databaseexample数据库。\\n', '\\n', '> DROP DATABASE databaseexample;\\n', '备份数据库\\n', '可以在root权限下使用mysqldump命令备份数据库。\\n', '\\n', '备份一个或多个表：\\n', '\\n', 'mysqldump [options] databasename [tablename ...] > outfile\\n', '备份一个或多个库：\\n', '\\n', 'mysqldump [options] -databases databasename ... > outfile\\n', '备份所有库：\\n', '\\n', 'mysqldump [options] -all-databases > outputfile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。\\n', 'tablename：数据表名称。\\n', 'outfile：数据库备份的文件。\\n', 'options：mysqldump命令参数选项，多个参数之间可以使用空格分隔。常用的mysqldump命令参数选项如下：\\n', '-u, --user= username ：指定用户名。\\n', '-p, --password[= password]：指定密码。\\n', '-P, --port= portnumber ：指定端口。\\n', '-h, --host= hostname ：指定主机名。\\n', '-r, --result-file= filename ：将导出结果保存到指定的文件中，等同于“>”。\\n', '-t：只备份数据。\\n', '-d：只备份表结构。\\n', '示例\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的所有数据库到alldb.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --all-databases > alldb.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --databases db1 > db1.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的tb1表到db1tb1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 db1 tb1 > db1tb1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的表结构到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -d db1 > db1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的数据到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 > db1.sql\\n', '恢复数据库\\n', '可以在root权限下使用mysql命令恢复数据库。\\n', '\\n', '恢复一个或多个表：\\n', '\\n', 'mysql -h hostname -P portnumber -u username -ppassword databasename < infile\\n', '其中：\\n', '\\n', 'hostname：主机名。\\n', 'portnumber：端口号。\\n', 'username：用户名。\\n', 'password：密码。\\n', 'databasename：数据库名。\\n', 'infile：mysqldump命令中的outfile参数。\\n', '示例\\n', '#恢复数据库。\\n', '\\n', '# mysql -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 < db1.sql\\n', 'MySQL服务器\\n', '软件介绍\\n', 'MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle旗下产品。MySQL是业界最流行的RDBMS (Relational Database Management System，关系数据库管理系统)之一，尤其在WEB应用方面。\\n', '\\n', '关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就加快了速度并提高了灵活性。\\n', '\\n', 'MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL软件采用了双授权模式，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。\\n', '\\n', '配置环境\\n', ' 说明：\\n', '以下环境配置仅为参考示例，具体配置视实际需求做配置\\n', '\\n', '关闭防火墙并取消开机自启动\\n', ' 说明：\\n', '测试环境下通常会关闭防火墙以避免部分网络因素影响，视实际需求做配置。\\n', '\\n', '在root权限下停止防火墙。\\n', '\\n', '# systemctl stop firewalld\\n', '在root权限下关闭防火墙。\\n', '\\n', '# systemctl disable firewalld\\n', ' 说明：\\n', '执行disable命令关闭防火墙的同时，也取消了开机自启动。\\n', '\\n', '修改SELINUX为disabled\\n', '在root权限下修改配置文件。\\n', '\\n', \"# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\\n\", '创建组和用户\\n', ' 说明：\\n', '服务器环境下，为了系统安全，通常会为进程分配单独的用户，以实现权限隔离。本章节创建的组和用户都是操作系统层面的，不是数据库层面的。\\n', '\\n', '在root权限下创建MySQL用户（组）。\\n', '\\n', '# groupadd mysql\\n', '# useradd -g mysql mysql\\n', '在root权限下设置MySQL用户密码。\\n', '\\n', '# passwd mysql\\n', '重复输入密码（根据实际需求设置密码）。\\n', '\\n', '搭建数据盘\\n', ' 说明：\\n', '\\n', '进行性能测试时，数据目录使用单独硬盘，需要对硬盘进行格式化并挂载，参考方法一或者方法二\\n', '非性能测试时，在root权限下执行以下命令，创建数据目录即可。然后跳过本小节：\\n', '# mkdir /data\\n', '方法一：在root权限下使用fdisk进行磁盘管理\\n', '创建分区（以/dev/sdb为例，根据实际情况创建）\\n', '\\n', '# fdisk /dev/sdb\\n', '输入n，按回车确认。\\n', '\\n', '输入p，按回车确认。\\n', '\\n', '输入1，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '输入w，按回车保存。\\n', '\\n', '创建文件系统（以xfs为例，根据实际需求创建文件系统）\\n', '\\n', '# mkfs.xfs /dev/sdb1\\n', '挂载分区到“/data”以供操作系统使用。\\n', '\\n', '# mkdir /data\\n', '# mount /dev/sdb1 /data\\n', '执行命令“vi /etc/fstab\", 编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/nvme0n1p1为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '方法二：在root权限下使用LVM进行磁盘管理\\n', ' 说明：\\n', '此步骤需要安装镜像中的lvm2相关包，步骤如下：\\n', '\\n', '配置本地yum源，详细信息请参考搭建repo服务器。如果已经执行，则可跳过此步。\\n', '执行命令安装lvm2。\\n', '#yum install lvm2\\n', '创建物理卷（sdb为硬盘名称，具体名字以实际为准）。\\n', '\\n', '#pvcreate /dev/sdb\\n', '创建物理卷组（其中datavg为创建的卷组名称，具体名字以实际规划为准）。\\n', '\\n', '#vgcreate  datavg  /dev/sdb\\n', '创建逻辑卷（其中600G为规划的逻辑卷大小，具体大小以实际情况为准；datalv为创建的逻辑卷的名字，具体名称以实际规划为准。)。\\n', '\\n', '#lvcreate -L 600G -n datalv datavg\\n', '创建文件系统。\\n', '\\n', '#mkfs.xfs /dev/datavg/datalv\\n', '创建数据目录并挂载。\\n', '\\n', '#mkdir /data\\n', '#mount /dev/datavg/datalv /data\\n', '执行命令vi /etc/fstab，编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/datavg/datalv为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '创建数据库目录并且授权\\n', '在已创建的数据目录 /data 基础上，使用root权限继续创建进程所需的相关目录并授权MySQL用户（组）。\\n', '\\n', '# mkdir -p /data/mysql\\n', '# cd /data/mysql\\n', '# mkdir data tmp run log\\n', '# chown -R mysql:mysql /data\\n', '安装、运行和卸载\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器章节。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装MySQL服务器。\\n', '\\n', '# dnf install mysql-server\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep mysql-server\\n', '运行\\n', '修改配置文件。\\n', '\\n', '在root权限下创建my.cnf文件，其中文件路径（包括软件安装路径basedir、数据路径datadir等）根据实际情况修改。\\n', '\\n', '# vi /etc/my.cnf\\n', '编辑my.cnf内容如下：\\n', '\\n', '[mysqld_safe]\\n', 'log-error=/data/mysql/log/mysql.log\\n', 'pid-file=/data/mysql/run/mysqld.pid\\n', '[mysqldump]\\n', 'quick\\n', '[mysql]\\n', 'no-auto-rehash\\n', '[client]\\n', 'default-character-set=utf8\\n', '[mysqld]\\n', 'basedir=/usr/local/mysql\\n', 'socket=/data/mysql/run/mysql.sock\\n', 'tmpdir=/data/mysql/tmp\\n', 'datadir=/data/mysql/data\\n', 'default_authentication_plugin=mysql_native_password\\n', 'port=3306\\n', 'user=mysql\\n', '确保my.cnf配置文件修改正确。\\n', '\\n', '$ cat /etc/my.cnf\\n', '\\n', '\\n', ' 注意：\\n', '其中basedir为软件安装路径，请根据实际情况修改。\\n', '\\n', '在root权限下修改/etc/my.cnf文件的组和用户为mysql:mysql\\n', '\\n', '# chown mysql:mysql /etc/my.cnf\\n', '配置环境变量。\\n', '\\n', '安装完成后，在root权限下将MySQL二进制文件路径到PATH。\\n', '\\n', '# echo export  PATH=$PATH:/usr/local/mysql/bin  >> /etc/profile\\n', ' 注意：\\n', '其中PATH中的“/usr/local/mysql/bin“路径，为MySQL软件安装目录下的bin文件的绝对路径。请根据实际情况修改。\\n', '\\n', '在root权限下使环境变量配置生效。\\n', '\\n', '# source /etc/profile\\n', '在root权限下初始化数据库。\\n', '\\n', ' 说明：\\n', '本步骤倒数第2行中有初始密码，请注意保存，登录数据库时需要使用。\\n', '\\n', '# mysqld --defaults-file=/etc/my.cnf --initialize\\n', '2020-03-18T03:27:13.702385Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.17) initializing of server in progress as process 34014\\n', '2020-03-18T03:27:24.112453Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: iNat=)#V2tZu\\n', '2020-03-18T03:27:28.576003Z 0 [System] [MY-013170] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.17) initializing of server has completed\\n', '查看打印信息，打印信息中包括“initializing of server has completed”表示初始化数据库完成，且打印信息中“A temporary password is generated for root@localhost: iNat=)#V2tZu”的“iNat=)#V2tZu”为初始密码。\\n', '\\n', '启动数据库。\\n', '\\n', ' 注意：\\n', '如果第一次启动数据库服务，以root用户启动数据库，则启动时会提示缺少mysql.log文件而导致失败。使用mysql用户启动之后，会在/data/mysql/log目录下生成mysql.log文件，再次使用root用户启动则不会报错。\\n', '\\n', '在root权限下修改文件权限。\\n', '\\n', '# chmod 777 /usr/local/mysql/support-files/mysql.server\\n', '在root权限下启动MySQL。\\n', '\\n', '# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql\\n', '# chkconfig mysql on\\n', '以mysql用户启动数据库。\\n', '\\n', '# su - mysql\\n', '$ service mysql start\\n', '登录数据库。\\n', '\\n', ' 说明：\\n', '\\n', '提示输入密码时，请输入3产生的初始密码。\\n', '如果采用官网RPM安装方式，则mysql文件在/usr/bin目录下。登录数据库的命令根据实际情况修改。\\n', '$ /usr/local/mysql/bin/mysql -uroot -p  -S /data/mysql/run/mysql.sock\\n', '\\n', '\\n', '配置数据库帐号密码。\\n', '\\n', '登录数据库以后，修改通过root用户登录数据库的密码。\\n', '\\n', 'mysql> alter user \\'root\\'@\\'localhost\\' identified by \"123456\";\\n', '创建全域root用户（允许root从其他服务器访问）。\\n', '\\n', \"mysql> create user 'root'@'%' identified by '123456';\\n\", '进行授权。\\n', '\\n', \"mysql> grant all privileges on *.* to 'root'@'%';\\n\", 'mysql> flush privileges;\\n', '\\n', '\\n', '退出数据库。\\n', '\\n', '执行 \\\\q 或者 exit 退出数据库。\\n', '\\n', 'mysql> exit\\n', '\\n', '\\n', '卸载\\n', '在root权限下关闭数据库进程。\\n', '\\n', '$ ps -ef | grep mysql\\n', '# kill -9 进程ID\\n', '在root权限下执行dnf remove mysql命令卸载MySQL。\\n', '\\n', '# dnf remove mysql\\n', '管理数据库用户\\n', '创建用户\\n', '可以使用CREATE USER语句来创建一个或多个用户，并设置相应的口令。\\n', '\\n', \"CREATE USER 'username'@'hostname' IDENTIFIED BY 'password';\\n\", '其中：\\n', '\\n', 'username：用户名。\\n', 'host：主机名，即用户连接数据库时所在的主机的名字。若是本地用户可用localhost，若在创建的过程中，未指定主机名，则主机名默认为“%”，表示一组主机。\\n', 'password：用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器，但从安全的角度而言，不推荐这种做法。\\n', '使用CREATE USER语句必须拥有数据库的INSERT权限或全局CREATE USER权限。\\n', '\\n', '使用CREATE USER语句创建一个用户账号后，会在系统自身的数据库的user表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。\\n', '\\n', '新创建的用户拥有的权限很少，只允许进行不需要权限的操作，如使用SHOW语句查询所有存储引擎和字符集的列表等。\\n', '\\n', '示例\\n', '#创建密码为123456，用户名为userexample1的本地用户。\\n', '\\n', \"> CREATE USER 'userexample1'@'localhost' IDENTIFIED BY '123456';\\n\", '#创建密码为123456，用户名为userexample2，主机名为192.168.1.100的用户。\\n', '\\n', \"> CREATE USER 'userexample2'@'192.168.1.100' IDENTIFIED BY '123456';\\n\", '查看用户\\n', '可以使用SHOW GRANTS语句或SELECT语句查看一个或多个用户。\\n', '\\n', '查看特定用户：\\n', '\\n', \"SHOW GRANTS [FOR 'username'@'hostname'];\\n\", \"SELECT USER,HOST,PASSWORD FROM mysql.user WHERE USER='username';\\n\", '查看所有用户：\\n', '\\n', 'SELECT USER,HOST FROM mysql.user;\\n', '其中：\\n', '\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '示例\\n', '#查看userexample1用户。\\n', '\\n', \"> SHOW GRANTS FOR 'userexample1'@'localhost';\\n\", '#查看mysql数据库中所有用户。\\n', '\\n', '> SELECT USER,HOST FROM mysql.user;\\n', '修改用户\\n', '修改用户名\\n', '可以使用RENAME USER语句修改一个或多个已经存在的用户名。\\n', '\\n', \"RENAME USER 'oldusername'@'hostname' TO 'newusername'@'hostname';\\n\", '其中：\\n', '\\n', 'oldusername：旧的用户名。\\n', 'newusername：新的用户名。\\n', 'hostname：主机名。\\n', 'RENAME USER语句用于对原有的账号进行重命名。若系统中旧账号不存在或者新账号已存在，则该语句执行时会出现错误。\\n', '\\n', '使用RENAME USER语句，必须拥有数据库的UPDATE权限或全局CREATE USER权限。\\n', '\\n', '修改用户示例\\n', '#将用户名userexample1修改为userexapme2，主机名为locahost。\\n', '\\n', \"> RENAME USER 'userexample1'@'localhost' TO 'userexample2'@'localhost';\\n\", '修改用户密码\\n', '可以使用SET PASSWORD语句修改一个用户的登录密码。\\n', '\\n', \"SET PASSWORD FOR 'username'@'hostname' = 'newpassword';\\n\", '其中：\\n', '\\n', \"FOR 'username'@'hostname'：FOR字句，可选项，指定欲修改密码的用户名及主机名。\\n\", \"'newpassword'：新密码。\\n\", '在SET PASSWORD语句中，若不加上FOR子句，表示修改当前用户的密码。\\n', '\\n', \"FOR字句中必须以'username'@'hostname'的格式给定，username为账户的用户名，hostname为账户的主机名。\\n\", '\\n', '欲修改密码的账号必须在系统中存在，否则语句执行时会出现错误。\\n', '\\n', '修改用户密码示例\\n', '#将用户名为userexample的密码修改为0123456，主机名为locahost。\\n', '\\n', \"> SET PASSWORD FOR 'userexample'@'localhost' = '0123456';\\n\", '删除用户\\n', '可以使用DROP USER语句来删除一个或多个用户账号以及相关的权限。\\n', '\\n', \"DROP USER 'username1'@'hostname1' [,'username2'@'hostname2']…;\\n\", ' 注意：\\n', '用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为数据库并不会记录创建了这些对象的账号。\\n', '\\n', 'DROP USER语句可用于删除一个或多个数据库账号，并删除其原有权限。\\n', '\\n', '使用DROP USER语句必须拥有数据库的DELETE权限或全局CREATE USER权限。\\n', '\\n', '在DROP USER语句的使用中，若没有明确地给出账号的主机名，则该主机名默认为“%”。\\n', '\\n', '示例\\n', '#删除用户名为userexample的本地用户。\\n', '\\n', \"> DROP USER 'userexample'@'localhost';\\n\", '用户授权\\n', '可以使用GRANT语句来对新建用户的授权。\\n', '\\n', \"GRANT privileges ON databasename.tablename TO 'username'@'hostname';\\n\", '其中：\\n', '\\n', 'ON字句：用于指定权限授予的对象和级别。\\n', 'privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所有的权限则使用ALL。\\n', 'databasename：数据库名。\\n', 'tablename：表名。\\n', 'TO字句：用来设定用户密码，以及指定被赋予权限的用户。\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*。\\n', '\\n', '如果在TO子句中给系统中存在的用户指定密码，则新密码会将原密码覆盖。\\n', '\\n', '如果权限被授予给一个不存在的用户，则会自动执行一条CREATE USER语句来创建这个用户，但同时必须为该用户指定密码。\\n', '\\n', '示例\\n', '#对本地用户userexample授予SELECT和INSERT权限。\\n', '\\n', \"> GRANT SELECT,INSERT ON *.* TO 'userexample'@'localhost'; \\n\", '删除用户权限\\n', '可以使用REVOKE语句来删除一个用户的权限，但此用户不会被删除。\\n', '\\n', \"REVOKE privilege ON databasename.tablename FROM 'username'@'hostname';\\n\", '其中REVOKE语句的参数与GRANT语句的参数含义相同。\\n', '\\n', '要使用 REVOKE 语句，必须拥有数据库的全局CREATE USER权限或UPDATE权限。\\n', '\\n', '示例\\n', '#删除本地用户userexample的INSERT权限。\\n', '\\n', \"> REVOKE INSERT ON *.* FROM 'userexample'@'localhost';\\n\", '管理数据库\\n', '创建数据库\\n', '可以使用CREATE DATABASE语句来创建数据库。\\n', '\\n', 'CREATE DATABASE databasename;\\n', '其中：databasename为数据库名称，且数据库名称不区分大小写。\\n', '\\n', '示例\\n', '#创建数据库名为databaseexample的数据库。\\n', '\\n', '> CREATE DATABASE databaseexample;\\n', '查看数据库\\n', '可以使用SHOW DATABASES语句来查看数据库。\\n', '\\n', 'SHOW DATABASES;\\n', '示例\\n', '#查看所有数据库。\\n', '\\n', '> SHOW DATABASES;\\n', '选择数据库\\n', '一般创建表，查询表等操作首先需要选择一个目标数据库。可以使用USE语句来选择数据库。\\n', '\\n', 'USE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', '示例\\n', '#选择databaseexample数据库。\\n', '\\n', '> USE databaseexample;\\n', '删除数据库\\n', '可以使用DROP DATABASE语句来删除数据库。\\n', '\\n', ' 注意：\\n', '删除数据库要谨慎操作，一旦删除，数据库中的所有表和数据都会删除。\\n', '\\n', 'DROP DATABASE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', 'DROP DATABASE命令用于删除创建过(已存在)的数据库，且会删除数据库中的所有表，但数据库的用户权限不会自动删除。\\n', '\\n', '要使用DROP DATABASE，您需要数据库的DROP权限。\\n', '\\n', 'DROP SCHEMA是DROP DATABASE的同义词。\\n', '\\n', '示例\\n', '#删除databaseexample数据库。\\n', '\\n', '> DROP DATABASE databaseexample;\\n', '备份数据库\\n', '可以在root权限下使用mysqldump命令备份数据库。\\n', '\\n', '备份一个或多个表：\\n', '\\n', 'mysqldump [options] databasename [tablename ...] > outfile\\n', '备份一个或多个库：\\n', '\\n', 'mysqldump [options] -databases databasename ... > outfile\\n', '备份所有库：\\n', '\\n', 'mysqldump [options] -all-databases > outputfile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。\\n', 'tablename：数据表名称。\\n', 'outfile：数据库备份的文件。\\n', 'options：mysqldump命令参数选项，多个参数之间可以使用空格分隔。常用的mysqldump命令参数选项如下：\\n', '-u, --user= username ：指定用户名。\\n', '-p, --password[= password]：指定密码。\\n', '-P, --port= portnumber ：指定端口。\\n', '-h, --host= hostname ：指定主机名。\\n', '-r, --result-file= filename ：将导出结果保存到指定的文件中，等同于“>”。\\n', '-t：只备份数据。\\n', '-d：只备份表结构。\\n', '示例\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的所有数据库到alldb.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --all-databases > alldb.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --databases db1 > db1.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的tb1表到db1tb1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 db1 tb1 > db1tb1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的表结构到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -d db1 > db1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的数据到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 > db1.sql\\n', '恢复数据库\\n', '可以在root权限下使用mysql命令恢复数据库。\\n', '\\n', '恢复一个或多个表：\\n', '\\n', 'mysql -h hostname -P portnumber -u username -ppassword databasename < infile\\n', '其中：\\n', '\\n', 'hostname：主机名。\\n', 'portnumber：端口号。\\n', 'username：用户名。\\n', 'password：密码。\\n', 'databasename：数据库名。\\n', 'infile：mysqldump命令中的outfile参数。\\n', '示例\\n', '#恢复数据库。\\n', '\\n', '# mysql -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 < db1.sql']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_查看系统信息.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF.html", "text_entry": "['查看系统信息\\n', '查看系统信息，命令如下：\\n', '\\n', '$ cat /etc/os-release\\n', '例如，命令和输出如下：\\n', '\\n', '$ cat /etc/os-release\\n', 'NAME=\"openEuler\"\\n', 'VERSION=\"22.03 LTS\"\\n', 'ID=\"openEuler\"\\n', 'VERSION_ID=\"22.03\"\\n', 'PRETTY_NAME=\"openEuler 22.03 LTS\"\\n', 'ANSI_COLOR=\"0;31\"\\n', '查看系统相关的资源信息。\\n', '\\n', '查看CPU信息，命令如下：\\n', '\\n', '$ lscpu\\n', '查看内存信息，命令如下：\\n', '\\n', '$ free\\n', '查看磁盘信息，命令如下：\\n', '\\n', '$ fdisk -l\\n', '查看系统资源实时信息，命令如下：\\n', '\\n', '$ top']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理内存.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/memory-management.html", "text_entry": "['etmem内存分级扩展\\n', '介绍\\n', '随着CPU算力的发展，尤其是ARM核成本的降低，内存成本和内存容量成为约束业务成本和性能的核心痛点，因此如何节省内存成本，如何扩大内存容量成为存储迫切要解决的问题。\\n', '\\n', 'etmem内存分级扩展技术，通过DRAM+内存压缩/高性能存储新介质形成多级内存存储，对内存数据进行分级，将分级后的内存冷数据从内存介质迁移到高性能存储介质中，达到内存容量扩展的目的，从而实现内存成本下降。(当前暂时还没有对非易失内存介质的支持）\\n', '\\n', '软件架构\\n', '\\n', '\\n', 'etmem客户端通过socket通信机制与服务端进行交互，下发创建/删除工程、启动/停止工程、查询工程的命令，服务端通过客户端下发的配置文件，读取project管理配置信息，以及engine配置信息，并执行客户端下发的操作。启动工程之后，服务端会对业务进程进行扫描，并根据扫描统计结果以及淘汰策略，对页面进行分级淘汰，实现节省内存的目标。\\n', '\\n', '编译教程\\n', '下载etmem源码\\n', '   # git clone https://gitee.com/src-openeuler/etmem.git\\n', '编译和运行依赖\\n', 'etmem的编译和运行依赖于libboundscheck组件。\\n', '\\n', '编译\\n', '   # cd etmem\\n', '   # mkdir build\\n', '   # cd build\\n', '   # cmake ..\\n', '   # make\\n', '使用说明\\n', '启动etmemd进程\\n', '使用方法\\n', '通过运行etmemd二进制运行服务端进程，例如：\\n', '\\n', '# etmemd -l 0 -s etmemd_socket\\n', '帮助信息\\n', 'options：\\n', '-l|--log-level <log-level>  Log level\\n', '-s|--socket <sockect name>  Socket name to listen to\\n', '-h|--help  Show this message\\n', '命令行参数说明\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t参数范围\\t示例说明\\n', '-l或–log-level\\tetmemd日志级别\\t否\\t是\\t0~3\\t0：debug级别 1：info级别 2：warning级别 3：error级别 只有大于等于配置的级别才会打印到/var/log/message文件中\\n', '-s或–socket\\tetmemd监听的名称，用于与客户端交互\\t是\\t是\\t107个字符之内的字符串\\t指定服务端监听的名称\\n', '-h或–help\\t帮助信息\\t否\\t否\\tNA\\t执行时带有此参数会打印后退出\\n', 'etmem配置文件\\n', '在运行etmem进程之前，需要管理员预先规划哪些进程需要做内存扩展，将进程信息配置到etmem配置文件中，并配置内存扫描的周期、扫描次数、内存冷热阈值等信息。\\n', '\\n', '配置文件的示例文件在源码包中，放置在源码根目录的conf/example_conf.yaml，建议在使用时放置在/etc/etmem/目录下，示例内容为：\\n', '\\n', 'options:    \\n', '\\tloop : 3\\n', '    interval : 1\\n', '    sleep: 2\\n', '\\tpolicies:\\n', '\\t\\ttype : pid/name\\n', '   \\t\\tvalue : 123456/mysql\\n', '    \\tmax_threads: 3\\n', '    \\tengine : slide\\n', '\\t\\t\\tparam:\\n', '\\t\\t\\t\\tT: 3\\n', '配置文件各字段说明：\\n', '\\n', '置项\\t配置项含义\\t是否必须\\t是否有参数\\t参数范围\\t示例说明\\n', 'options\\tproject公用配置段起始标识\\t是\\t否\\tNA\\t每个配置文件有且仅有一个此字段，并且文件以此字段开始\\n', 'loop\\t内存扫描的循环次数\\t是\\t是\\t1~120\\tloop:3 //扫描3次\\n', 'interval\\t每次内存扫描的时间间隔\\t是\\t是\\t1~1200\\tinterval:5 //每次扫描之间间隔5s\\n', 'sleep\\t每个内存扫描+操作的大周期之间时间间隔\\t是\\t是\\t1~1200\\tsleep:10 //每次大周期之间间隔10s\\n', 'policies\\tproject中各task任务配置段起始标识\\t是\\t否\\tNA\\t一个project中可以配置多个task，每个task以policies:开头\\n', 'type\\t目标进程识别的方式\\t是\\t是\\tpid/name\\tpid代表通过进程号识别，name代表通过进程名称识别\\n', 'value\\t目标进程识别的具体字段\\t是\\t是\\t实际的进程号/进程名称\\t与type字段配合使用，指定目标进程的进程号或进程名称，由使用者保证配置的正确及唯一性\\n', 'max_threads\\tetmemd内部线程池最大线程数，每个线程处理一个进程/子进程的内存扫描+操作任务\\t否\\t是\\t1~2 * core数 + 1，默认为1\\t对外部无表象，控制etmemd服务端内部处理线程个数，当目标进程有多个子进程时，配置越大，并发执行的个数也多，但占用资源也越多\\n', 'engine\\t扫描引擎类型\\t是\\t是\\tslide\\t声明使用slide引擎进行冷热内存识别\\n', 'param\\t扫描引擎私有参数配置起始标识\\t是\\t否\\tNA\\t引擎私有参数配置段以此标识起始，每个task对应一种引擎，每个引擎对应一个param及其字段\\n', 'T\\tslide引擎的水线配置\\t是\\t否\\t1~3 * loop\\t水线阈值，大于等于此值的内存会被识别为热内存，反之为冷内存\\n', 'etmem工程创建、删除、查询\\n', '场景描述\\n', '1）管理员创建etmem工程（一个工程可包含多个etmem任务）\\n', '\\n', '2）管理员查询已有的etmem工程\\n', '\\n', '3）管理员删除已有的etmem工程（删除工程前，会自动先停止该工程中的所有任务）\\n', '\\n', '使用方法\\n', '通过etmem二进制执行工程创建/删除/查询操作，前提是服务端已经成功运行，并且配置文件（e.g. /etc/etmem/example_conf.yaml）内容正确。\\n', '\\n', '添加工程：\\n', '\\n', '# etmem project add -n test -f /etc/etmem/example_conf.yaml -s etmemd_socket\\n', '删除工程：\\n', '\\n', '# etmem project del -n test -s etmemd_socket\\n', '查询工程：\\n', '\\n', '# etmem project show -s etmemd_socket\\n', '打印帮助：\\n', '\\n', '# etmem project help\\n', '帮助信息\\n', 'Usage:\\n', ' etmem project add [options]\\n', ' etmem project del [options]\\n', ' etmem project show\\n', ' etmem project help\\n', '\\n', ' Options:\\n', ' -f|--file <conf_file> Add configuration file\\n', ' -n|--name <proj_name> Add project name\\n', ' -s|--sock <sock_name> Socket name to connect\\n', '\\n', ' Notes:\\n', ' 1. Project name and socket name must be given when execute add or del option.\\n', ' 2. Configuration file must be given when execute add option.\\n', ' 3. Socket name must be given when execute show option.\\n', '命令行参数说明\\n', 'add命令：\\n', '\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-n或–name\\t指定project名称\\t是\\t是\\tproject名称，与配置文件一一对应\\n', '-f或–file\\t指定project的配置文件\\t是\\t是\\t需要指定路径名称\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信\\n', 'del命令：\\n', '\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-n或–name\\t指定project名称\\t是\\t是\\tproject名称，与配置文件一一对应\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信\\n', 'show命令：\\n', '\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信\\n', 'etmem任务启动、停止\\n', '场景描述\\n', '在已经通过etmem project add添加工程之后，在还未调用etmem project del删除工程之前，可以对etmem的工程进行启动和停止。\\n', '\\n', '1）管理员启动已添加的工程\\n', '\\n', '2）管理员停止已启动的工程\\n', '\\n', '在管理员调用project del删除工程时，如果工程已经启动，则会自动停止。\\n', '\\n', '使用方法\\n', '通过etmem二进制执行任务启动/停止操作，前提是服务端已经成功运行，配置文件（e.g. /etc/etmem/example_conf.yaml）内容正确，且etmem工程已经创建。\\n', '\\n', '启动工程\\n', '\\n', '# etmem migrate start -n test -s etmemd_socket\\n', '停止工程\\n', '\\n', '# etmem migrate stop -n test -s etmemd_socket\\n', '打印帮助\\n', '\\n', '# etmem migrate help\\n', '帮助信息\\n', 'Usage:\\n', ' etmem migrate start [options]\\n', ' etmem migrate stop [options]\\n', ' etmem migrate help\\n', '\\n', ' Options:\\n', ' -n|--name <proj_name> Add project name\\n', ' -s|--sock <sock_name> Socket name to connect\\n', '\\n', ' Notes:\\n', ' Project name and socket name must be given when execute start or stop option.\\n', '命令行参数说明\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-n或–name\\t指定project名称\\t是\\t是\\tproject名称，与配置文件一一对应\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理服务.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.html", "text_entry": "['管理服务\\n', '本章介绍如何使用systemd进行系统和服务管理。\\n', '\\n', '管理服务\\n', '简介\\n', '概念介绍\\n', '特性说明\\n', '更快的启动速度\\n', '提供按需启动能力\\n', '采用cgroup特性跟踪和管理进程的生命周期\\n', '启动挂载点和自动挂载的管理\\n', '实现事务性依赖关系管理\\n', '与SysV初始化脚本兼容\\n', '能够对系统进行快照和恢复\\n', '管理系统服务\\n', 'sysvinit命令和systemd命令\\n', '显示所有当前服务\\n', '显示服务状态\\n', '运行服务\\n', '关闭服务\\n', '重启服务\\n', '启用服务\\n', '禁用服务\\n', '改变运行级别\\n', 'Target和运行级别\\n', '查看系统默认启动目标\\n', '查看当前系统所有的启动目标\\n', '改变默认目标\\n', '改变当前目标\\n', '切换到救援模式\\n', '切换到紧急模式\\n', '关闭、暂停和休眠系统\\n', 'systemctl命令\\n', '关闭系统\\n', '重启系统\\n', '使系统待机\\n', '使系统休眠\\n', '简介\\n', 'systemd是在Linux下，与SysV和LSB初始化脚本兼容的系统和服务管理器。systemd使用socket和D-Bus来开启服务，提供基于守护进程的按需启动策略，支持快照和系统状态恢复，维护挂载和自挂载点，实现了各服务间基于从属关系的一个更为精细的逻辑控制，拥有更高的并行性能。\\n', '\\n', '概念介绍\\n', 'systemd开启和监督整个系统是基于unit的概念。unit是由一个与配置文件对应的名字和类型组成的（例如：avahi.service unit有一个具有相同名字的配置文件，是守护进程Avahi的一个封装单元）。unit有多重类型，如表1所示。\\n', '\\n', '表 1 unit说明\\n', '\\n', '\\n', 'unit名称\\n', '\\n', '后缀名\\n', '\\n', '描述\\n', '\\n', 'Service unit\\n', '\\n', '.service\\n', '\\n', '系统服务。\\n', '\\n', 'Target unit\\n', '\\n', '.target\\n', '\\n', '一组systemd units。\\n', '\\n', 'Automount unit\\n', '\\n', '.automount\\n', '\\n', '文件系统挂载点。\\n', '\\n', 'Device unit\\n', '\\n', '.device\\n', '\\n', '内核识别的设备文件。\\n', '\\n', 'Mount unit\\n', '\\n', '.mount\\n', '\\n', '文件系统挂载点。\\n', '\\n', 'Path unit\\n', '\\n', '.path\\n', '\\n', '在一个文件系统中的文件或目录。\\n', '\\n', 'Scope unit\\n', '\\n', '.scope\\n', '\\n', '外部创建的进程。\\n', '\\n', 'Slice unit\\n', '\\n', '.slice\\n', '\\n', '一组用于管理系统进程分层组织的units。\\n', '\\n', 'Socket unit\\n', '\\n', '.socket\\n', '\\n', '一个进程间通信的Socket。\\n', '\\n', 'Swap unit\\n', '\\n', '.swap\\n', '\\n', 'swap设备或者swap文件。\\n', '\\n', 'Timer unit\\n', '\\n', '.timer\\n', '\\n', 'systemd计时器。\\n', '\\n', '所有的可用systemd unit类型，可在如表2所示的路径下查看。\\n', '\\n', '表 2 可用systemd unit类型\\n', '\\n', '\\n', '路径\\n', '\\n', '描述\\n', '\\n', '/usr/lib/systemd/system/\\n', '\\n', '随安装的RPM产生的systemd units。\\n', '\\n', '/run/systemd/system/\\n', '\\n', '在运行时创建systemd units。\\n', '\\n', '/etc/systemd/system/\\n', '\\n', '由系统管理员创建和管理的systemd units。\\n', '\\n', '特性说明\\n', '更快的启动速度\\n', 'systemd提供了比UpStart更激进的并行启动能力，采用了socket/D-Bus activation等技术启动服务，带来了更快的启动速度。\\n', '\\n', '为了减少系统启动时间，systemd的目标是：\\n', '\\n', '尽可能启动更少的进程。\\n', '尽可能将更多进程并行启动。\\n', '提供按需启动能力\\n', '当sysvinit系统初始化的时候，它会将所有可能用到的后台服务进程全部启动运行。并且系统必须等待所有的服务都启动就绪之后，才允许用户登录。这种做法有两个缺点：首先是启动时间过长；其次是系统资源浪费。\\n', '\\n', '某些服务很可能在很长一段时间内，甚至整个服务器运行期间都没有被使用过。比如CUPS，打印服务在多数服务器上很少被真正使用到。您可能没有想到，在很多服务器上SSHD也是很少被真正访问到的。花费在启动这些服务上的时间是不必要的；同样，花费在这些服务上的系统资源也是一种浪费。\\n', '\\n', 'systemd可以提供按需启动的能力，只有在某个服务被真正请求的时候才启动它。当该服务结束，systemd可以关闭它，等待下次需要时再次启动它。\\n', '\\n', '采用cgroup特性跟踪和管理进程的生命周期\\n', 'init系统的一个重要职责就是负责跟踪和管理服务进程的生命周期。它不仅可以启动一个服务，也能够停止服务。这看上去没有什么特别的，然而在真正用代码实现的时候，您或许会发现停止服务比一开始想的要困难。\\n', '\\n', '服务进程一般都会作为守护进程（daemon）在后台运行，为此服务程序有时候会派生（fork）两次。在UpStart中，需要在配置文件中正确地配置expect小节。这样UpStart通过对fork系统调用进行计数，从而获知真正的精灵进程的PID号。\\n', '\\n', 'cgroup已经出现了很久，它主要用来实现系统资源配额管理。cgroup提供了类似文件系统的接口，使用方便。当进程创建子进程时，子进程会继承父进程的cgroup。因此无论服务如何启动新的子进程，所有的这些相关进程都会属于同一个cgroup，systemd只需要简单地遍历指定的cgroup即可正确地找到所有的相关进程，将它们逐一停止即可。\\n', '\\n', '启动挂载点和自动挂载的管理\\n', '传统的Linux系统中，用户可以用/etc/fstab文件来维护固定的文件系统挂载点。这些挂载点在系统启动过程中被自动挂载，一旦启动过程结束，这些挂载点就会确保存在。这些挂载点都是对系统运行至关重要的文件系统，比如HOME目录。和sysvinit一样，systemd管理这些挂载点，以便能够在系统启动时自动挂载它们。systemd还兼容/etc/fstab文件，您可以继续使用该文件管理挂载点。\\n', '\\n', '有时候用户还需要动态挂载点，比如打算访问DVD内容时，才临时执行挂载以便访问其中的内容，而不访问光盘时该挂载点被取消（umount)，以便节约资源。传统地，人们依赖autofs服务来实现这种功能。\\n', '\\n', 'systemd内建了自动挂载服务，无需另外安装autofs服务，可以直接使用systemd提供的自动挂载管理能力来实现autofs的功能。\\n', '\\n', '实现事务性依赖关系管理\\n', '系统启动过程是由很多的独立工作共同组成的，这些工作之间可能存在依赖关系，比如挂载一个NFS文件系统必须依赖网络能够正常工作。systemd虽然能够最大限度地并发执行很多有依赖关系的工作，但是类似“挂载NFS”和“启动网络”这样的工作还是存在天生的先后依赖关系，无法并发执行。对于这些任务，systemd维护一个“事务一致性”的概念，保证所有相关的服务都可以正常启动而不会出现互相依赖，以至于死锁的情况。\\n', '\\n', '与SysV初始化脚本兼容\\n', '和UpStart一样，systemd引入了新的配置方式，对应用程序的开发也有一些新的要求。如果systemd想替代目前正在运行的初始化系统，就必须和现有程序兼容。任何一个Linux发行版都很难为了采用systemd而在短时间内将所有的服务代码都修改一遍。\\n', '\\n', 'systemd提供了和sysvinit以及LSB initscripts兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向systemd迁移的成本，使得systemd替换现有初始化系统成为可能。\\n', '\\n', '能够对系统进行快照和恢复\\n', 'systemd支持按需启动，因此系统的运行状态是动态变化的，人们无法准确地知道系统当前运行了哪些服务。systemd快照提供了一种将当前系统运行状态保存并恢复的能力。\\n', '\\n', '比如系统当前正运行服务A和B，可以用systemd命令行对当前系统运行状况创建快照。然后将进程A停止，或者做其他的任意的对系统的改变，比如启动新的进程C。在这些改变之后，运行systemd的快照恢复命令，就可立即将系统恢复到快照时刻的状态，即只有服务A，B在运行。一个可能的应用场景是调试：比如服务器出现一些异常，为了调试用户将当前状态保存为快照，然后可以进行任意的操作，比如停止服务等等。等调试结束，恢复快照即可。\\n', '\\n', '管理系统服务\\n', 'systemd提供systemctl命令来运行、关闭、重启、显示、启用/禁用系统服务。\\n', '\\n', 'sysvinit命令和systemd命令\\n', 'systemd提供systemctl命令与sysvinit命令的功能类似。当前版本中依然兼容service和chkconfig命令，相关说明如表3，但建议用systemctl进行系统服务管理。\\n', '\\n', '表 3 sysvinit命令和systemd命令的对照表\\n', '\\n', '\\n', 'sysvinit命令\\n', '\\n', 'systemd命令\\n', '\\n', '备注\\n', '\\n', 'service network start\\n', '\\n', 'systemctl start network.service\\n', '\\n', '用来启动一个服务 (并不会重启现有的)。\\n', '\\n', 'service network stop\\n', '\\n', 'systemctl stop network.service\\n', '\\n', '用来停止一个服务 (并不会重启现有的)。\\n', '\\n', 'service network restart\\n', '\\n', 'systemctl restart network.service\\n', '\\n', '用来停止并启动一个服务。\\n', '\\n', 'service network reload\\n', '\\n', 'systemctl reload network.service\\n', '\\n', '当支持时，重新装载配置文件而不中断等待操作。\\n', '\\n', 'service network condrestart\\n', '\\n', 'systemctl condrestart network.service\\n', '\\n', '如果服务正在运行那么重启它。\\n', '\\n', 'service network status\\n', '\\n', 'systemctl status network.service\\n', '\\n', '检查服务的运行状态。\\n', '\\n', 'chkconfig network on\\n', '\\n', 'systemctl enable network.service\\n', '\\n', '在下次启动时或满足其他触发条件时设置服务为启用。\\n', '\\n', 'chkconfig network off\\n', '\\n', 'systemctl disable network.service\\n', '\\n', '在下次启动时或满足其他触发条件时设置服务为禁用。\\n', '\\n', 'chkconfig network\\n', '\\n', 'systemctl is-enabled network.service\\n', '\\n', '用来检查一个服务在当前环境下被配置为启用还是禁用。\\n', '\\n', 'chkconfig \\\\-\\\\-list\\n', '\\n', 'systemctl list-unit-files \\\\-\\\\-type=service\\n', '\\n', '输出在各个运行级别下服务的启用和禁用情况。\\n', '\\n', 'chkconfig network \\\\-\\\\-list\\n', '\\n', 'ls /etc/systemd/system/*.wants/network.service\\n', '\\n', '用来列出该服务在哪些运行级别下启用和禁用。\\n', '\\n', 'chkconfig network \\\\-\\\\-add\\n', '\\n', 'systemctl daemon-reload\\n', '\\n', '当您创建新服务文件或者变更设置时使用。\\n', '\\n', '显示所有当前服务\\n', '如果您需要显示当前正在运行的服务，使用命令如下：\\n', '\\n', 'systemctl list-units --type service\\n', '如果您需要显示所有的服务（包括未运行的服务），需要添加-all参数，使用命令如下：\\n', '\\n', 'systemctl list-units --type service --all\\n', '例如显示当前正在运行的服务，命令如下：\\n', '\\n', '$ systemctl list-units --type service\\n', 'UNIT                        LOAD   ACTIVE     SUB     JOB   DESCRIPTION  \\n', 'atd.service                 loaded active     running       Deferred execution scheduler  \\n', 'auditd.service              loaded active     running       Security Auditing Service  \\n', 'avahi-daemon.service        loaded active     running       Avahi mDNS/DNS-SD Stack  \\n', 'chronyd.service             loaded active     running       NTP client/server  \\n', 'crond.service               loaded active     running       Command Scheduler  \\n', 'dbus.service                loaded active     running       D-Bus System Message Bus  \\n', 'dracut-shutdown.service     loaded active     exited        Restore /run/initramfs on shutdown  \\n', 'firewalld.service           loaded active     running       firewalld - dynamic firewall daemon  \\n', 'getty@tty1.service          loaded active     running       Getty on tty1  \\n', 'gssproxy.service            loaded active     running       GSSAPI Proxy Daemon  \\n', 'irqbalance.service          loaded active     running       irqbalance daemon  \\n', 'iscsid.service              loaded activating start   start Open-iSCSI\\n', '显示服务状态\\n', '如果您需要显示某个服务的状态，可执行如下命令：\\n', '\\n', 'systemctl status name.service\\n', '相关状态显示参数说明如表4所示。\\n', '\\n', '表 4 状态参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '描述\\n', '\\n', 'Loaded\\n', '\\n', '说明服务是否被加载，并显示服务对应的绝对路径以及是否启用。\\n', '\\n', 'Active\\n', '\\n', '说明服务是否正在运行，并显示时间节点。\\n', '\\n', 'Main PID\\n', '\\n', '相应的系统服务的PID值。\\n', '\\n', 'CGroup\\n', '\\n', '相关控制组（CGroup）的其他信息。\\n', '\\n', '如果您需要鉴别某个服务是否运行，可执行如下命令：\\n', '\\n', 'systemctl is-active name.service\\n', 'is-active命令的返回结果如下：\\n', '\\n', '表 5 is-active命令的返回结果\\n', '\\n', '\\n', '状态\\n', '\\n', '含义\\n', '\\n', 'active(running)\\n', '\\n', '有一只或多只程序正在系统中执行\\n', '\\n', 'active(exited)\\n', '\\n', '仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 举例来说，开机或者 是挂载时才会进行一次的 quotaon 功能\\n', '\\n', 'active(waiting)\\n', '\\n', '正在执行当中，不过要等待其他的事件才能继续处理。例如：打印的队列相关服务 就是这种状态，虽然正在启动中，不过也需要真的有队列进来 (打印作业) 这样他才会继续唤醒打印机 服务来进行下一步打印的功能\\n', '\\n', 'inactive\\n', '\\n', '这个服务没有运行\\n', '\\n', '同样，如果您需要判断某个服务是否被启用，可执行如下命令：\\n', '\\n', 'systemctl is-enabled name.service\\n', 'is-enabled命令的返回结果如下：\\n', '\\n', '表 6 is-enabled命令的返回结果\\n', '\\n', '\\n', '状态\\n', '\\n', '含义\\n', '\\n', '\"enabled\"\\n', '\\n', '已经通过 /etc/systemd/system/ 目录下的 Alias= 别名、 .wants/ 或 .requires/ 软连接被永久启用。\\n', '\\n', '\"enabled-runtime\"\\n', '\\n', '已经通过 /run/systemd/system/ 目录下的 Alias= 别名、 .wants/ 或 .requires/ 软连接被临时启用。\\n', '\\n', '\"linked\"\\n', '\\n', '虽然单元文件本身不在标准单元目录中，但是指向此单元文件的一个或多个软连接已经存在于 /etc/systemd/system/ 永久目录中。\\n', '\\n', '\"linked-runtime\"\\n', '\\n', '虽然单元文件本身不在标准单元目录中，但是指向此单元文件的一个或多个软连接已经存在于 /run/systemd/system/ 临时目录中。\\n', '\\n', '\"masked\"\\n', '\\n', '已经被 /etc/systemd/system/ 目录永久屏蔽(软连接指向 /dev/null 文件)，因此 start 操作会失败。\\n', '\\n', '\"masked-runtime\"\\n', '\\n', '已经被 /run/systemd/systemd/ 目录临时屏蔽(软连接指向 /dev/null 文件)，因此 start 操作会失败。\\n', '\\n', '\"static\"\\n', '\\n', '尚未被启用，并且单元文件的 \"[Install]\" 小节中没有可用于 enable 命令的选项。\\n', '\\n', '\"indirect\"\\n', '\\n', '尚未被启用，但是单元文件的 \"[Install]\" 小节中 Also= 选项的值列表非空(也就是列表中的某些单元可能已被启用)、或者它拥有一个不在 Also= 列表中的其他名称的别名软连接。对于模版单元来说，表示已经启用了一个不同于 DefaultInstance= 的实例。\\n', '\\n', '\"disabled\"\\n', '\\n', '尚未被启用，但是单元文件的 \"[Install]\" 小节中存在可用于 enable 命令的选项\\n', '\\n', '\"generated\"\\n', '\\n', '单元文件是被单元生成器动态生成的。被生成的单元文件可能并未被直接启用，而是被单元生成器隐含的启用了。\\n', '\\n', '\"transient\"\\n', '\\n', '单元文件是被运行时API动态临时生成的。该临时单元可能并未被启用。\\n', '\\n', '\"bad\"\\n', '\\n', '单元文件不正确或者出现其他错误。 is-enabled 不会返回此状态，而是会显示一条出错信息。 list-unit-files 命令有可能会显示此单元。\\n', '\\n', '例如查看gdm.service服务状态，命令如下：\\n', '\\n', '# systemctl status gdm.service\\n', 'gdm.service - GNOME Display Manager   Loaded: loaded (/usr/lib/systemd/system/gdm.service; enabled)   Active: active (running) since Thu 2013-10-17 17:31:23 CEST; 5min ago\\n', ' Main PID: 1029 (gdm)\\n', '   CGroup: /system.slice/gdm.service\\n', '           ├─1029 /usr/sbin/gdm\\n', '           ├─1037 /usr/libexec/gdm-simple-slave --display-id /org/gno...           \\n', '           └─1047 /usr/bin/Xorg :0 -background none -verbose -auth /r...Oct 17 17:31:23 localhost systemd[1]: Started GNOME Display Manager.\\n', '运行服务\\n', '如果您需要运行某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl start name.service\\n', '例如运行httpd服务，命令如下：\\n', '\\n', '# systemctl start httpd.service\\n', '关闭服务\\n', '如果您需要关闭某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl stop name.service\\n', '例如关闭蓝牙服务，命令如下：\\n', '\\n', '# systemctl stop bluetooth.service\\n', '重启服务\\n', '如果您需要重启某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl restart name.service\\n', '执行命令后，当前服务会被关闭，但马上重新启动。如果您指定的服务，当前处于关闭状态，执行命令后，服务也会被启动。\\n', '\\n', '例如重启蓝牙服务，命令如下：\\n', '\\n', '# systemctl restart bluetooth.service\\n', '启用服务\\n', '如果您需要在开机时启用某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl enable name.service\\n', '例如设置httpd服务开机时启动，命令如下：\\n', '\\n', '# systemctl enable httpd.service\\n', \"ln -s '/usr/lib/systemd/system/httpd.service' '/etc/systemd/system/multi-user.target.wants/httpd.service'\\n\", '禁用服务\\n', '如果您需要在开机时禁用某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl disable name.service\\n', '例如在开机时禁用蓝牙服务启动，命令如下：\\n', '\\n', '# systemctl disable bluetooth.service\\n', 'Removed /etc/systemd/system/bluetooth.target.wants/bluetooth.service.\\n', 'Removed /etc/systemd/system/dbus-org.bluez.service.\\n', '改变运行级别\\n', 'Target和运行级别\\n', 'systemd用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其他服务，来创建自己的目标。表7列举了systemd下的目标和常见runlevel的对应关系。\\n', '\\n', '表 7 运行级别和systemd目标\\n', '\\n', '\\n', '运行级别\\n', '\\n', 'systemd目标（target）\\n', '\\n', '描述\\n', '\\n', '0\\n', '\\n', 'runlevel0.target，poweroff.target\\n', '\\n', '关闭系统。\\n', '\\n', '1, s, single\\n', '\\n', 'runlevel1.target，rescue.target\\n', '\\n', '单用户模式。\\n', '\\n', '2, 4\\n', '\\n', 'runlevel2.target，runlevel4.target，multi-user.target\\n', '\\n', '用户定义/域特定运行级别。默认等同于3。\\n', '\\n', '3\\n', '\\n', 'runlevel3.target，multi-user.target\\n', '\\n', '多用户，非图形化。用户可以通过多个控制台或网络登录。\\n', '\\n', '5\\n', '\\n', 'runlevel5.target，graphical.target\\n', '\\n', '多用户，图形化。通常为所有运行级别3的服务外加图形化登录。\\n', '\\n', '6\\n', '\\n', 'runlevel6.target，reboot.target\\n', '\\n', '重启系统。\\n', '\\n', 'emergency\\n', '\\n', 'emergency.target\\n', '\\n', '紧急Shell\\n', '\\n', '查看系统默认启动目标\\n', '查看当前系统默认的启动目标，命令如下：\\n', '\\n', 'systemctl get-default\\n', '查看当前系统所有的启动目标\\n', '查看当前系统所有的启动目标，命令如下：\\n', '\\n', 'systemctl list-units --type=target\\n', '改变默认目标\\n', '改变系统默认的目标，在root权限下执行如下命令：\\n', '\\n', 'systemctl set-default name.target\\n', '改变当前目标\\n', '改变当前系统的目标，在root权限下执行如下命令：\\n', '\\n', 'systemctl isolate name.target\\n', '切换到救援模式\\n', '改变当前系统为救援模式，在root权限下执行如下命令：\\n', '\\n', 'systemctl rescue\\n', '这条命令和“systemctl isolate rescue.target”类似。命令执行后会在串口有如下打印信息：\\n', '\\n', 'You are in rescue mode. After logging in, type \"journalctl -xb\" to viewsystem logs, \"systemctl reboot\" to reboot, \"systemctl default\" or \"exit\"to boot into default mode.\\n', 'Give root password for maintenance\\n', '(or press Control-D to continue):\\n', ' 说明：\\n', '用户需要重启系统，从救援模式进入正常模式。\\n', '\\n', '切换到紧急模式\\n', '改变当前系统为紧急模式，在root权限下执行如下命令：\\n', '\\n', 'systemctl emergency\\n', '这条命令和“systemctl isolate emergency.target”类似。命令执行后会在串口有如下打印信息：\\n', '\\n', 'You are in emergency mode. After logging in, type \"journalctl -xb\" to viewsystem logs, \"systemctl reboot\" to reboot, \"systemctl default\" or \"exit\"to boot into default mode.\\n', 'Give root password for maintenance\\n', '(or press Control-D to continue):\\n', ' 说明：\\n', '用户需要重启系统，从紧急模式进入正常模式。\\n', '\\n', '关闭、暂停和休眠系统\\n', 'systemctl命令\\n', 'systemd通过systemctl命令可以对系统进行关机、重启、休眠等一系列操作。当前仍兼容部分Linux常用管理命令，对应关系如表8。建议用户使用systemctl命令进行操作。\\n', '\\n', '表 8 命令对应关系\\n', '\\n', '\\n', 'Linux常用管理命令\\n', '\\n', 'systemctl命令\\n', '\\n', '描述\\n', '\\n', 'halt\\n', '\\n', 'systemctl halt\\n', '\\n', '关闭系统\\n', '\\n', 'poweroff\\n', '\\n', 'systemctl poweroff\\n', '\\n', '关闭电源\\n', '\\n', 'reboot\\n', '\\n', 'systemctl reboot\\n', '\\n', '重启\\n', '\\n', '关闭系统\\n', '关闭系统并下电，在root权限下执行如下命令：\\n', '\\n', 'systemctl poweroff\\n', '关闭系统但不下电机器，在root权限下执行如下命令：\\n', '\\n', 'systemctl halt\\n', '执行上述命令会给当前所有的登录用户发送一条提示消息。如果不想让systemd发送该消息，您可以添加“--no-wall”参数。具体命令如下：\\n', '\\n', 'systemctl --no-wall poweroff\\n', '重启系统\\n', '重启系统，在root权限下执行如下命令：\\n', '\\n', 'systemctl reboot\\n', '执行上述命令会给当前所有的登录用户发送一条提示消息。如果不想让systemd发送该消息，您可以添加“--no-wall”参数。具体命令如下：\\n', '\\n', 'systemctl --no-wall reboot\\n', '使系统待机\\n', '使系统待机，在root权限下执行如下命令：\\n', '\\n', 'systemctl suspend\\n', '使系统休眠\\n', '使系统休眠，在root权限下执行如下命令：\\n', '\\n', 'systemctl hibernate\\n', '使系统待机且处于休眠状态，在root权限下执行如下命令：\\n', '\\n', 'systemctl hybrid-sleep']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理用户和用户组.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84.html", "text_entry": "['管理用户\\n', '在Linux中，每个普通用户都有一个账户，包括用户名、密码和主目录等信息。除此之外，还有一些系统本身创建的特殊用户，它们具有特殊的意义，其中最重要的是管理员账户，默认用户名是root。同时Linux也提供了用户组，使每一个用户至少属于一个组，从而便于权限管理。\\n', '\\n', '用户和用户组管理是系统安全管理的重要组成部分，本章主要介绍openEuler提供的用户管理和组管理命令，以及为普通用户分配特权的方法。\\n', '\\n', '管理用户\\n', '管理用户\\n', '增加用户\\n', '修改用户账号\\n', '删除用户\\n', '管理员账户授权\\n', '管理用户组\\n', '增加用户组\\n', '修改用户组\\n', '删除用户组\\n', '将用户加入用户组或从用户组中移除\\n', '切换用户组\\n', '管理用户\\n', '增加用户\\n', 'useradd命令\\n', '在root权限下，通过useradd命令可以为系统添加新用户信息，其中 options 为相关参数， username 为用户名称。\\n', '\\n', 'useradd [options] username\\n', '用户信息文件\\n', '与用户账号信息有关的文件如下：\\n', '\\n', '/etc/passwd：用户账号信息文件。\\n', '/etc/shadow：用户账号信息加密文件。\\n', '/etc/group：组信息文件。\\n', '/etc/default/useradd：定义默认设置文件。\\n', '/etc/login.defs：系统广义设置文件。\\n', '/etc/skel：默认的初始配置文件目录。\\n', '创建用户实例\\n', '例如新建一个用户名为userexample的用户，在root权限下执行如下命令：\\n', '\\n', '# useradd userexample\\n', ' 说明：\\n', '没有任何提示，表明用户建立成功。这时请使用passwd命令设置用户的密码，没有设置密码的新账号不能登录系统。\\n', '\\n', '使用id命令查看新建的用户信息，命令如下：\\n', '\\n', '# id userexample\\n', 'uid=502(userexample)    gid=502(userexample)    groups=502(userexample)\\n', '修改用户userexample的密码：\\n', '\\n', '# passwd userexample\\n', '建议在修改用户密码时满足密码复杂度要求，密码的复杂度的要求如下：\\n', '\\n', '口令长度至少8个字符。\\n', '口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种。\\n', '口令不能和账号一样。\\n', '口令不能使用字典词汇。\\n', '查询字典 在已装好的openEuler环境中，可以通过如下命令导出字典库文件dictionary.txt，用户可以查询密码是否在该字典中。\\n', 'cracklib-unpacker /usr/share/cracklib/pw_dict > dictionary.txt\\n', '修改字典\\n', '修改上面导出的字典文件，执行如下命令更新系统字典库。\\n', '# create-cracklib-dict dictionary.txt\\n', '在原字典库基础上新增其他字典内容custom.txt。\\n', '# create-cracklib-dict dictionary.txt custom.txt\\n', '根据提示两次输入新用户的密码，完成密码更改。过程如下：\\n', '\\n', '# passwd userexample\\n', 'Changing password for user userexample.\\n', 'New password:\\n', 'Retype new password:\\n', 'passwd: all authentication tokens updated successfully.\\n', ' 说明：\\n', '若打印信息中出现“BAD PASSWORD: The password fails the dictionary check - it is too simplistic/sytematic”，表示设置的密码过于简单，建议设置复杂度较高的密码。\\n', '\\n', '修改用户账号\\n', '修改密码\\n', '普通用户可以用passwd修改自己的密码，只有管理员才能用passwd username为其他用户修改密码。\\n', '\\n', '修改用户shell设置\\n', '使用chsh命令可以修改自己的shell，只有管理员才能用chsh username为其他用户修改shell设置。\\n', '\\n', '用户也可以使用usermod命令修改shell信息，在root权限下执行如下命令，其中 new_shell_path 为目标shell路径，username 为要修改用户的用户名，请根据实际情况修改：\\n', '\\n', 'usermod -s new_shell_path username\\n', '例如，将用户userexample的shell改为csh，命令如下：\\n', '\\n', '# usermod -s /bin/csh userexample\\n', '修改主目录\\n', '修改主目录，可以在root权限下执行如下命令，其中 new_home_directory 为已创建的目标主目录的路径，username 为要修改用户的用户名，请根据实际情况修改：\\n', '\\n', 'usermod -d new_home_directory username\\n', '如果想将现有主目录的内容转移到新的目录，应该使用-m选项，命令如下：\\n', '\\n', 'usermod -d new_home_directory -m username\\n', '修改UID\\n', '修改用户ID，在root权限下执行如下命令，其中 UID 代表目标用户ID，username 代表用户名，请根据实际情况修改：\\n', '\\n', 'usermod -u UID username\\n', '该用户主目录中所拥有的文件和目录都将自动修改UID设置。但是，对于主目录外所拥有的文件，只能使用chown命令手动修改所有权。\\n', '\\n', '修改账号的有效期\\n', '如果使用了影子口令，则可以在root权限下，执行如下命令来修改一个账号的有效期，其中 MM 代表月份，DD 代表某天，YY 代表年份，username 代表用户名，请根据实际情况修改：\\n', '\\n', 'usermod -e MM/DD/YY username\\n', '删除用户\\n', '在root权限下，使用userdel命令可删除现有用户。\\n', '\\n', '例如，删除用户Test，命令如下：\\n', '\\n', '# userdel Test\\n', '如果想同时删除该用户的主目录以及其中所有内容，要使用-r参数递归删除。\\n', '\\n', ' 说明：\\n', '不建议直接删除已经进入系统的用户，如果需要强制删除，请使用 userdel -f Test 命令。\\n', '\\n', '管理员账户授权\\n', '使用sudo命令可以允许普通用户执行管理员账户才能执行的命令。\\n', '\\n', 'sudo命令允许已经在/etc/sudoers文件中指定的用户运行管理员账户命令。例如，一个已经获得许可的普通用户可以运行如下命令：\\n', '\\n', 'sudo /usr/sbin/useradd newuserl\\n', '实际上，sudo的配置完全可以指定某个已经列入/etc/sudoers文件的普通用户可以做什么，不可以做什么。\\n', '\\n', '/etc/sudoers的配置行如下所示。\\n', '\\n', '空行或注释行（以#字符打头）：无具体功能的行。\\n', '\\n', '可选的主机别名行：用来创建主机列表的简称。必须以Host_Alias关键词开头，列表中的主机必须用逗号隔开，如：\\n', '\\n', 'Host_Alias  linux=ted1,ted2\\n', '其中ted1和ted2是两个主机名，可使用linux（别名）称呼它们。\\n', '\\n', '可选的用户别名行：用来创建用户列表的简称。用户别名行必须以User_Alias关键词开头，列表中的用户名必须以逗号隔开。其格式同主机别名行。\\n', '\\n', '可选的命令别名行：用来创建命令列表的简称。必须以Cmnd_Alias开头，列表中的命令必须用逗号隔开。\\n', '\\n', '可选的运行方式别名行：用来创建用户列表的简称。不同的是，使用这样的别名可以告诉sudo程序以列表中某一用户的身份来运行程序。\\n', '\\n', '必要的用户访问说明行。\\n', '\\n', '用户访问的说明语法如下：\\n', '\\n', 'user host = [ run as user ] command list\\n', '在user处指定一个真正的用户名或定义过的别名，host也可以是一个真正的主机名或者定义过的主机别名。默认情况下，sudo执行的所有命令都是以root身份执行。如果您想使用其他身份可以指定。command list可以是以逗号分隔的命令列表，也可以是一个已经定义过的别名，如：\\n', '\\n', 'ted1   ted2=/sbin/shutdown\\n', '这一句说明ted1可以在ted2主机上运行关机命令。\\n', '\\n', 'newuser1 ted1=(root) /usr/sbin/useradd,/usr/sbin/userdel\\n', '这一句说明ted1主机上的newuser1可以以root用户权限执行useradd，userdel命令。\\n', '\\n', ' 说明：\\n', '\\n', '可以在一行定义多个别名，中间用冒号 (:) 隔开。\\n', '可在命令或命令别名之前加上感叹号 (!)，使该命令或命令别名无效。\\n', '有两个关键词：ALL和NOPASSWD。ALL意味着“所有”（所有文件、所有主机或所有命令），NOPASSWD意味着不用密码。\\n', '通过修改用户访问，将普通用户的访问权限修改为同root一样，则可以给普通用户分配特权。\\n', '下面是一个sudoers文件的例子：\\n', '\\n', '#sudoers files\\n', '#User alias specification\\n', 'User_Alias ADMIN=ted1:POWERUSER=globus,ted2\\n', '#user privilege specification\\n', 'ADMIN ALL=ALL\\n', 'POWERUSER ALL=ALL,!/bin/su\\n', '其中：\\n', '\\n', 'User_Alias ADMIN=ted1:POWERUSER=globus,ted2\\n', '\\n', '定义了两个别名ADMIN和POWERUSER\\n', '\\n', 'ADMIN ALL=ALL\\n', '\\n', '说明在所有主机上，ADMIN用户都可以以root身份执行所有命令\\n', '\\n', 'POWERUSER ALL=ALL,!/bin/su\\n', '\\n', '给POWERUSER用户除了运行su命令外等同ADMIN的权限\\n', '\\n', '管理用户组\\n', '增加用户组\\n', 'groupadd命令\\n', '在root权限下，通过groupadd命令可以为系统添加新用户组信息，其中 options 为相关参数， groupname 为用户组名称。\\n', '\\n', 'groupadd [options] groupname\\n', '用户组信息文件\\n', '与用户组信息有关的文件如下：\\n', '\\n', '/etc/gshadow：用户组信息加密文件。\\n', '/etc/group：组信息文件。\\n', '/etc/login.defs：系统广义设置文件。\\n', '创建用户组实例\\n', '例如新建一个用户组名为groupexample的用户，在root权限下执行如下命令：\\n', '\\n', '# groupadd groupexample\\n', '修改用户组\\n', '修改GID\\n', '修改用户组ID，在root权限下执行如下命令，其中 GID 代表目标用户组ID， groupname 代表用户组，请根据实际情况修改：\\n', '\\n', 'groupmod -g GID groupname\\n', '修改用户组名\\n', '修改用户组名，在root权限下执行如下命令，其中 newgroupname 代表新用户组名， oldgroupname 代表已经存在的待修改的用户组名，请根据实际情况修改：\\n', '\\n', 'groupmod -n newgroupname oldgroupname\\n', '删除用户组\\n', '在root权限下，使用groupdel命令可删除用户组。\\n', '\\n', '例如，删除用户组Test，命令如下：\\n', '\\n', '# groupdel Test\\n', ' 说明：\\n', 'groupdel不能直接删除用户的主组，如果需要强制删除用户主组，请使用 groupdel -f Test 命令。\\n', '\\n', '将用户加入用户组或从用户组中移除\\n', '在root权限下，使用gpasswd命令将用户加入用户组或从用户组中移除。\\n', '\\n', '例如，将用户 userexample 加入用户组 Test ，命令如下：\\n', '\\n', '# gpasswd -a userexample Test\\n', '例如，将用户 userexample 从 Test 用户组中移除，命令如下：\\n', '\\n', '# gpasswd -d userexample Test\\n', '切换用户组\\n', '一个用户同时属于多个用户组时，则在用户登录后，使用newgrp命令可以切换到其他用户组，以便具有其他用户组的权限。\\n', '\\n', '例如，将用户 userexample 切换到 Test 用户组，命令如下：\\n', '\\n', '$ newgrp Test']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理进程.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B.html", "text_entry": "['管理进程\\n', '操作系统管理多个用户的请求和多个任务。大多数系统都只有一个CPU和一个主要存储，但一个系统可能有多个二级存储磁盘和多个输入/输出设备。操作系统管理这些资源并在多个用户间共享资源，当用户提出一个请求时，造成好像系统被用户独占的假象。实际上操作系统监控着一个等待执行的任务队列，这些任务包括用户任务、操作系统任务、邮件和打印任务等。本章节将从用户的角度讲述如何控制进程。\\n', '\\n', '管理进程\\n', '查看进程\\n', 'who命令\\n', 'ps命令\\n', 'top命令\\n', 'kill命令\\n', '调度启动进程\\n', '定时运行一批程序（at）\\n', '周期性运行一批程序（cron）\\n', '挂起/恢复进程\\n', '查看进程\\n', 'Linux是一个多任务系统，经常需要对这些进程进行一些调配和管理。要进行管理，首先就要知道现在的进程情况：有哪些进程、进程的状态如何等。Linux提供了多种命令来了解进程的状况。\\n', '\\n', 'who命令\\n', 'who命令主要用于查看当前系统中的用户情况。如果用户想和其他用户建立即时通讯，比如使用talk命令，那么首先要确定的就是该用户确实在线上，不然talk进程就无法建立起来。又如，系统管理员希望监视每个登录的用户此时此刻的所作所为，也要使用who命令。who命令应用起来非常简单，可以比较准确地掌握用户的情况，所以使用非常广泛。\\n', '\\n', '例如查看系统中的用户及其状态。使用如下：\\n', '\\n', '$ who\\n', 'admin     tty1         Jul 28 15:55\\n', 'admin     pts/0        Aug  5 15:46 (192.168.0.110)\\n', 'admin     pts/2        Jul 29 19:52 (192.168.0.110)\\n', 'root     pts/3        Jul 30 12:07 (192.168.0.110)\\n', 'root     pts/4        Jul 31 10:29 (192.168.0.144)\\n', 'root     pts/5        Jul 31 14:52 (192.168.0.11)\\n', 'root     pts/6        Aug  6 10:12 (192.168.0.234)\\n', 'root     pts/8        Aug  6 11:34 (192.168.0.234)\\n', 'ps命令\\n', 'ps命令是最基本又非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等，大部分进程信息都是可以通过执行该命令得到的。\\n', '\\n', 'ps命令最常用的还是用来监控后台进程的工作情况，因为后台进程是不与屏幕、键盘这些标准输入/输出设备进行通信的，所以如果需要检测其状况，就可使用ps命令。ps命令的常见选项如表1所示。\\n', '\\n', '表 1 选项说明\\n', '\\n', '\\n', '选项\\n', '\\n', '描述\\n', '\\n', '-e\\n', '\\n', '显示所有进程。\\n', '\\n', '-f\\n', '\\n', '全格式。\\n', '\\n', '-h\\n', '\\n', '不显示标题。\\n', '\\n', '-l\\n', '\\n', '使用长格式。\\n', '\\n', '-w\\n', '\\n', '宽行输出。\\n', '\\n', '-a\\n', '\\n', '显示终端上的所有进程，包括其他用户的进程。\\n', '\\n', '-r\\n', '\\n', '只显示正在运行的进程。\\n', '\\n', '-x\\n', '\\n', '显示没有控制终端的进程。\\n', '\\n', '例如显示系统中终端上的所有进行进程。命令如下：\\n', '\\n', '$ ps -a\\n', '  PID TTY          TIME CMD\\n', '12175 pts/6    00:00:00 bash\\n', '24526 pts/0    00:00:00 vsftpd\\n', '29478 pts/5    00:00:00 ps\\n', '32461 pts/0    1-01:58:33 sh\\n', 'top命令\\n', 'top命令和ps命令的基本作用是相同的，显示系统当前的进程和其他状况，但是top是一个动态显示过程，即可以通过用户按键来不断刷新进程的当前状态，如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。其实top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序，而且该命令的很多特性都可以通过交互式命令或者在定制文件中进行设定。\\n', '\\n', 'top命令输出的实例如图1所示：\\n', '\\n', '图 1 top显示\\n', '\\n', '\\n', 'kill命令\\n', '当需要中断一个前台进程的时候，通常足使用“Ctrl+c”组合键，而对于后台进程不能用组合键来终止，这时就可以使用kill命令。该命令可以终止前台和后台进程。终止后台进程的原因包括：该进程占用CPU的时间过多、该进程已经死锁等。\\n', '\\n', 'kill命令是通过向进程发送指定的信号来结束进程的。如果没有指定发送的信号，那么默认值为TERM信号。TERM信号将终止所有不能捕获该信号的进程。至于那些可以捕获该信号的进程可能就需要使用KILL信号（它的编号为9），而该信号不能被捕捉。\\n', '\\n', 'kill命令的浯法格式有以下两种方式：\\n', '\\n', 'kill [-s 信号 | -p] [-a] 进程号…\\n', 'kill -l [信号]\\n', '其中进程号可以通过ps命令的输出得到。-s选项是给程序发送指定的信号，详细的信号可以用“kill -l”命令查看；-p选项只显示指定进程的ID号。\\n', '\\n', '杀死pid为1409的进程，在root权限下执行如下命令：\\n', '\\n', '# kill -9 1409\\n', '显示所有的信号及其编号对应关系，示例如下：\\n', '\\n', '$ kill -l\\n', ' 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP\\n', ' 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1\\n', '11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM\\n', '16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\\n', '21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ\\n', '26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR\\n', '31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\\n', '38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\\n', '43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\\n', '48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\\n', '53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7\\n', '58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\\n', '63) SIGRTMAX-1  64) SIGRTMAX\\n', '调度启动进程\\n', '有时候需要对系统进行一些比较费时而且占用资源的维护工作，这些工作适合在深夜进行，这时候用户就可以事先进行调度安排，指定任务运行的时间或者场合，到时候系统会自动完成这些任务。要使用自动启动进程的功能，就需要掌握以下几个启动命令。\\n', '\\n', '定时运行一批程序（at）\\n', 'at命令\\n', '用户使用at命令在指定时刻执行指定的命令序列。该命令至少需要指定一个命令和一个执行时间。at命令可以只指定时间，也可以时间和日期一起指定。\\n', '\\n', 'at命令的语法格式如下：\\n', '\\n', ' at [-V] [-q 队列] [-f 文件名] [-mldbv] 时间\\n', ' at -c 作业 [作业…]\\n', '设置时间\\n', 'at允许使用一套相当复杂的时间指定方法，比如：\\n', '\\n', '接受在当天的hh:mm（小时：分钟）式的时间指定。如果该时间已经过去，那么就放存第二天执行。\\n', '使用midnight（深夜）、noon（中午）、teatime（饮茶时间，一般是下午4点）等比较模糊的词语来指定时间。\\n', '采用12小时计时制，即在时间后面加上AM（上午）或者PM（下午）来说明是上午还是下午。\\n', '指定命令执行的具体日期，指定格式为month day（月日）或者mm/dd/yy（月/日/年）或者dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。\\n', '上面介绍的都是绝对计时法，其实还可以使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为now+count time-units，now就是当前时间，time-units是时间单位，这里可以是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时等。还有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。下面通过一些例子来说明具体用法。\\n', '\\n', '例如指定在今天下午4:30执行某个命令。假设现在时间是中午12:30，2019年6月7日，可用命令格式如下：\\n', '\\n', ' at 4:30pm\\n', ' at 16:30\\n', ' at 16:30 today\\n', ' at now+4 hours\\n', ' at now+ 240 minutes\\n', ' at 16:30 7.6.19\\n', ' at 16:30 6/7/19\\n', ' at 16:30 Jun 7\\n', '以上这些命令表达的意义是完全一样的，所以在安排时间的时候完全可以根据个人喜好和具体情况自由选择。一般采用绝对时间的24小时计时法可以避免由于用户自己的疏忽造成计时错误，例如上例可以写成：at 16:30 6/7/19。\\n', '\\n', '执行权限\\n', '对于at命令来说，需要定时执行的命令是从标准输入或者使用-f选项指定的文件中读取并执行的。如果at命令是从一个使用su命令切换到用户shell中执行的，那么当前用户被认为是执行用户，所有的错误和输出结果都会送给这个用户。但是如果有邮件送出的话，收到邮件的将是原来的用户，也就是登录时shell的所有者。\\n', '\\n', '例如在6月8日上午10点执行slocate -u命令。在root权限下执行命令如下：\\n', '\\n', '# at  10:00  6/8/19\\n', 'at> slocate -u\\n', 'at>\\n', '[1]+   Stopped    at  10:00  6/8/19\\n', '上面的结果中，输入at命令之后，会出现提示符at>，提示用户输入命令，在此输入了slocate -u，然后按回车键。还可以输入多条命令，当所有要执行的命令输入结束后，按Ctrl+d键结束at命令。\\n', '\\n', '在任何情况下，管理员账户都可以使用这个命令。对于其他用户来说，是否可以使用就取决于/etc/at.allow和/etc/at.deny文件。\\n', '\\n', '周期性运行一批程序（cron）\\n', '前面介绍at命令都会在一定时间内完成一定任务，但是它只能执行一次。也就是说，当指定了运行命令后，系统在指定时间完成任务，以后就不再执行了。但是在很多情况下需要周期性重复执行一些命令，这时候就需要使用cron命令来完成任务。\\n', '\\n', '运行机制\\n', '首先cron命令会搜索/var/spool/cron目录，寻找以/etc/passwd文件中的用户名命名的crontab文件，被找到的这种文件将装入内存。比如一个用户名为userexample的用户，对应的crontab文件应该是/var/spool/cron/userexample，即以该用户命名的crontab文件存放在/var/spool/cron目录下面。\\n', '\\n', 'cron命令还将搜索/etc/crontab文件，这个文件是用不同的格式写成的。cron启动以后，它将首先检查是否有用户设置了crontab文件，如果没有就转入睡眠状态，释放系统资源。所以该后台进程占用资源极少，它每分钟被换醒一次，查看当前是否有需要运行的命令。\\n', '\\n', '命令执行结束后，任何输出都将作为邮件发送给crontab的所有者，或者是/etc/crontab文件中MAILTO环境变量中指定的用户。这是cron的工作原理，但是cron命令的执行不需要用户干涉，用户只需要修改crontab中要执行的命令。\\n', '\\n', 'crontab命令\\n', 'crontab命令用于安装、删除或者显示用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行，而且每个用户都可以有自己的crontab文件。\\n', '\\n', 'crontab命令的常用方法如下：\\n', '\\n', 'crontab -u //设置某个用户的cron服务，root用户在执行crontab时需要此参数。\\n', 'crontab -l //列出某个用户cron服务的详细内容。\\n', 'crontab -r //删除某个用户的cron服务。\\n', 'crontab -e //编辑某个用户的cron服务。\\n', '例如root查看自己的cron设置。命令如下：\\n', '\\n', '# crontab -u root -l\\n', 'crontab文件\\n', '在crontab文件中输入需要执行的命令和时间。该文件中每行都包括6个域，其中前5个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下：\\n', '\\n', 'minute hour day-of-month month-of-year day-of-week commands\\n', '对于每一项的说明如所示。\\n', '\\n', '表 2 参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '描述\\n', '\\n', 'minute\\n', '\\n', '分钟（0~59）。\\n', '\\n', 'hour\\n', '\\n', '小时（0~23）。\\n', '\\n', 'day-of-month\\n', '\\n', '一个月的第几天（1~31）。\\n', '\\n', 'month-of-year\\n', '\\n', '一年的第几个月（1~12）。\\n', '\\n', 'day-of-week\\n', '\\n', '一周的星期几（0~6），0代表星期天。\\n', '\\n', 'commands\\n', '\\n', '需要执行的命令。\\n', '\\n', '这些项都不能为空，必须指定值。除了数字还有几个特殊的符号“*”、“/”和“-”、“，”。其中，*代表所有的取值范围内的数字，/代表每的意思，“*/5”表示每5个单位，“-”代表从某个数字到某个数字，“，”分开几个离散时数字。对于要执行的命令，调用的时候需要写出命令的完整路径。\\n', '\\n', '例如晚上18点到22点之间每两个小时，在/tmp/test.txt文件中加入sleepy文本。在crontab文件中对应的行如下：\\n', '\\n', '* 18-22/2 * * * echo \"sleepy\" >> /tmp/test.txt\\n', '每次编辑完某个用户的cron设置后，cron自动在/var/spool/cron下生成一个与此用户同名的文件。此用户的cron信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用crontab -e来编辑。用户也可以另外建立一个文件，使用“cron文件名”命令导入cron设置。\\n', '\\n', '假设有个用户名为userexample，它需要为自己创建的一个crontab文件。步骤如下：\\n', '\\n', '首先可以使用任何文本编辑器建立一个新文件，并将向该文件加入需要运行的命令和要定期执行的时间，假设该文件为 ~/userexample.cron。\\n', '\\n', '然后在root权限下使用crontab命令安装这个文件，使用crontab命令使之成为该用户的crontab文件。命令如下：\\n', '\\n', '# crontab -u userexample ~/userexample.cron\\n', '这样crontab文件就建立好了，可以转到/var/spool/cron目录下面查看，发现多了一个userexample文件。这个文件就是所需的crontab文件。\\n', '\\n', ' 说明：\\n', 'cron启动后，每过一分钟读一次crontab文件，检查是否要执行里面的命令。因此该文件被修改后不需要重新启动cron服务。\\n', '\\n', '编辑配置文件\\n', 'cron服务每分钟不仅要读一次/var/spool/cron内的所有文件，还需要读一次/etc/crontab，因此通过配置这个文件也能得到cron的服务。用crontab配置是针对某个用户的，而编辑/etc/crontab是针对系统的任务。此文件的文件格式如下：\\n', '\\n', 'SHELL=/bin/sh\\n', 'PATH=/usr/bin:/usr/sbin:/sbin:/bin:/usr/lib/news/bin\\n', 'MAILTO=root  //如果出现错误，或者有数据输出，数据作为邮件发给这个账号\\n', 'HOME=/\\n', '#  run-parts\\n', '01  * * * *   root run-parts /etc/cron.hourly     //每个小时执行一次/etc/cron.hourly里的脚本\\n', '02 4 * * *   root run-parts /etc/cron.daily    //每天执行一次/etc/cron.daily里的脚本\\n', '22 4 * * 0  root run-parts /etc/cron.weekly     //每周执行一次/etc/cron.weekly里的脚本\\n', '42 4 1  * *  root run-parts /etc/cron.monthly     //每月执行一次/etc/cron.monthly里的脚本\\n', ' 说明：\\n', '如果去掉run-parts参数，其后面就是运行的某个脚本名，而不是目录名。\\n', '\\n', '挂起/恢复进程\\n', '作业控制允许进程挂起并可以在需要时恢复进程的运行，被挂起的作业恢复后将从中止处开始继续运行。只要在键盘上按Ctrl+Z键，即可挂起当前的前台作业。在键盘上按Ctrl+Z键后，将挂起当前执行的命令cat。使用jobs命令可以显示shell的作业清单，包括具体的作业、作业号以及作业当前所处的状态。\\n', '\\n', '恢复进程执行时，有两种选择：用fg命令将挂起的作业放回到前台执行；用bg命令将挂起的作业放到后台执行。灵活使用上述命令，将给自己带来很大的方便。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_配置网络.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C.html", "text_entry": "['配置网络\\n', '配置网络\\n', '配置 IP\\n', '使用nmcli命令\\n', '使用ip命令\\n', '通过ifcfg文件配置网络\\n', '配置主机名\\n', '简介\\n', '使用hostnamectl配置主机名\\n', '使用nmcli配置主机名\\n', '配置网络绑定\\n', '使用nmcli\\n', '使用命令行\\n', 'IPv6使用差异说明（vs IPv4）\\n', '约束限制\\n', '配置说明\\n', 'FAQ\\n', '配置 IP\\n', '使用nmcli命令\\n', ' 说明：\\n', '使用nmcli命令配置的网络配置可以立即生效且系统重启后配置也不会丢失。\\n', '\\n', 'nmcli介绍\\n', 'nmcli是NetworkManager的一个命令行工具，它提供了使用命令行配置由NetworkManager管理网络连接的方法。nmcli命令的基本格式为：\\n', '\\n', ' nmcli [OPTIONS] OBJECT { COMMAND | help }\\n', '其中，OBJECT选项可以是general、networking、radio、connection或device等。在日常使用中，最常使用的是-t, --terse（用于脚本）、-p, --pretty选项（用于用户）及-h, --help选项，用户可以使用“ nmcli help”获取更多参数及使用信息。\\n', '\\n', '$ nmcli help\\n', '常用命令使用举例如下：\\n', '\\n', '显示NetworkManager状态：\\n', '\\n', '$ nmcli general status\\n', '显示所有连接：\\n', '\\n', '$ nmcli connection show\\n', '只显示当前活动连接，如下所示添加 -a, --active：\\n', '\\n', '$ nmcli connection show --active\\n', '显示由NetworkManager识别到设备及其状态：\\n', '\\n', '$ nmcli device status\\n', '使用nmcli工具启动和停止网络接口，在root权限下执行如下命令：\\n', '\\n', '# nmcli connection up id enp3s0\\n', '# nmcli device disconnect enp3s0\\n', '设备管理\\n', '连接到设备\\n', '使用如下命令，NetworkManager将连接到对应网络设备，尝试找到合适的连接配置，并激活配置。\\n', '\\n', '$nmcli device connect \"$IFNAME\"  \\n', '如果不存在相应的配置连接，NetworkManager将创建并激活具有默认设置的新配置文件。\\n', '\\n', '断开设备连接\\n', '使用如下命令，NetworkManager将断开设备连接，并防止设备自动激活。\\n', '\\n', '$nmcli device disconnect \"$IFNAME\"  \\n', '设置网络连接\\n', '列出目前可用的网络连接：\\n', '\\n', '$ nmcli con show\\n', '\\n', '\\n', 'NAME    UUID                                  TYPE      DEVICE\\n', 'enp4s0  5afce939-400e-42fd-91ee-55ff5b65deab  ethernet  enp4s0\\n', 'enp3s0  c88d7b69-f529-35ca-81ab-aa729ac542fd  ethernet  enp3s0\\n', 'virbr0  ba552da6-f014-49e3-91fa-ec9c388864fa  bridge    virbr0\\n', ' 说明：\\n', '输出结果中的NAME字段代表连接ID（名称）。\\n', '\\n', '添加一个网络连接会生成相应的配置文件，并与相应的设备关联。检查可用的设备，方法如下：\\n', '\\n', '$ nmcli dev status\\n', '\\n', 'DEVICE      TYPE      STATE      CONNECTION\\n', 'enp3s0      ethernet  connected  enp3s0\\n', 'enp4s0      ethernet  connected  enp4s0\\n', 'virbr0      bridge    connected  virbr0\\n', 'lo          loopback  unmanaged  --\\n', 'virbr0-nic  tun       unmanaged  --\\n', '配置动态IP连接\\n', '配置IP\\n', '要使用 DHCP 分配网络时，可以使用动态IP配置添加网络配置文件，命令格式如下：\\n', '\\n', 'nmcli connection add type ethernet con-name connection-name ifname interface-name\\n', '例如创建名为net-test的动态连接配置文件，在root权限下使用以下命令：\\n', '\\n', '# nmcli connection add type ethernet con-name net-test ifname enp3s0\\n', \"Connection 'net-test' (a771baa0-5064-4296-ac40-5dc8973967ab) successfully added.\\n\", 'NetworkManager 会将参数 connection.autoconnect 设定为 yes，并将设置保存到 “/etc/sysconfig/network-scripts/ifcfg-net-test”文件中，在该文件中会将 ONBOOT 设置为 yes。\\n', '\\n', '激活连接并检查状态\\n', '在root权限下使用以下命令激活网络连接：\\n', '\\n', '# nmcli con up net-test \\n', 'Connection successfully activated (D-Bus active path:/org/freedesktop/NetworkManager/ActiveConnection/5)\\n', '检查这些设备及连接的状态，使用以下命令：\\n', '\\n', '$ nmcli device status\\n', '\\n', 'DEVICE      TYPE      STATE      CONNECTION\\n', 'enp4s0      ethernet  connected  enp4s0\\n', 'enp3s0      ethernet  connected  net-test\\n', 'virbr0      bridge    connected  virbr0\\n', 'lo          loopback  unmanaged  --\\n', 'virbr0-nic  tun       unmanaged  --\\n', '配置静态IP连接\\n', '配置IP\\n', '添加静态 IPv4 配置的网络连接，可使用以下命令：\\n', '\\n', 'nmcli connection add type ethernet con-name connection-name ifname interface-name ip4 address gw4 address\\n', ' 说明：\\n', '如果要添加 IPv6 地址和网关信息，使用 ip6 和 gw6 选项。\\n', '\\n', '例如创建名为 net-static的静态连接配置文件，在root权限下使用以下命令：\\n', '\\n', '# nmcli con add type ethernet con-name net-static ifname enp3s0 ip4 192.168.0.10/24 gw4 192.168.0.254\\n', '还可为该设备同时指定 IPv6 地址和网关，示例如下：\\n', '\\n', '# nmcli con add type ethernet con-name test-lab ifname enp3s0 ip4 192.168.0.10/24 gw4 192.168.0.254 ip6 abbe::**** gw6 2001:***::*\\n', \"Connection 'net-static' (63aa2036-8665-f54d-9a92-c3035bad03f7) successfully added.\\n\", 'NetworkManager 会将其内部参数 ipv4.method 设定为 manual，将 connection.autoconnect 设定为yes，并将设置写入 /etc/sysconfig/network-scripts/ifcfg-my-office 文件，其中会将对应 BOOTPROTO 设定为 none，将 ONBOOT 设定为 yes。\\n', '\\n', '设定两个 IPv4 DNS 服务器地址，在root权限下使用以下命令：\\n', '\\n', '# nmcli con mod net-static ipv4.dns \"*.*.*.* *.*.*.*\"\\n', '设置两个 IPv6 DNS 服务器地址，在root权限下使用以下命令：\\n', '\\n', '# nmcli con mod net-static ipv6.dns \"2001:4860:4860::**** 2001:4860:4860::****\"\\n', '激活连接并检查状态\\n', '激活新的网络连接，在root权限下使用以下命令：\\n', '\\n', '# nmcli con up net-static ifname enp3s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/6)\\n', '检查这些设备及连接的状态，使用以下命令：\\n', '\\n', '$ nmcli device status\\n', '\\n', 'DEVICE      TYPE      STATE      CONNECTION\\n', 'enp4s0      ethernet  connected  enp4s0\\n', 'enp3s0      ethernet  connected  net-static\\n', 'virbr0      bridge    connected  virbr0\\n', 'lo          loopback  unmanaged  --\\n', 'virbr0-nic  tun       unmanaged  --\\n', '查看配置的连接详情，使用以下命令（使用 -p, --pretty 选项在输出结果中添加标题和分段）：\\n', '\\n', '$ nmcli -p con show net-static \\n', '===============================================================================\\n', 'Connection profile details (net-static )\\n', '===============================================================================\\n', 'connection.id:                          net-static\\n', 'connection.uuid:                        b9f18801-6084-4aee-af28-c8f0598ff5e1\\n', 'connection.stable-id:                   --\\n', 'connection.type:                        802-3-ethernet\\n', 'connection.interface-name:              enp3s0\\n', 'connection.autoconnect:                 yes\\n', 'connection.autoconnect-priority:        0\\n', 'connection.autoconnect-retries:         -1 (default)\\n', 'connection.multi-connect:               0 (default)\\n', 'connection.auth-retries:                -1\\n', 'connection.timestamp:                   1578988781\\n', 'connection.read-only:                   no\\n', 'connection.permissions:                 --\\n', 'connection.zone:                        --\\n', 'connection.master:                      --\\n', 'connection.slave-type:                  --\\n', 'connection.autoconnect-slaves:          -1 (default)\\n', 'connection.secondaries:                 --\\n', 'connection.gateway-ping-timeout:        0\\n', 'connection.metered:                     unknown\\n', 'connection.lldp:                        default\\n', 'connection.mdns:                        -1 (default)\\n', 'connection.llmnr:                       -1 (default)\\n', '添加 Wi-Fi 连接\\n', '有两种方式添加Wi-Fi 连接。\\n', '\\n', '方法1，通过网络接口连接wifi\\n', '\\n', '连接到由SSID或BSSID指定的wifi网络。命令如下，该命令找到匹配的连接或创建一个连接，然后在设备上激活它。\\n', '\\n', '$ nmcli device wifi connect \"$SSID\" password \"$PASSWORD\" ifname \"$IFNAME\"  \\n', '$ nmcli --ask device wifi connect \"$SSID\" \\n', '方法2，通过配置文件连接Wi-Fi\\n', '\\n', '1，使用以下命令查看可用 Wi-Fi 访问点：\\n', '\\n', '$ nmcli dev wifi list\\n', '2，使用以下命令生成使用的静态 IP 配置，但允许自动 DNS 地址分配的 Wi-Fi 连接：\\n', '\\n', '$ nmcli con add con-name Wifi ifname wlan0 type wifi ssid MyWifi ip4 192.168.100.101/24 gw4 192.168.100.1\\n', '3，请使用以下命令设定 WPA2 密码，例如 “answer”：\\n', '\\n', '$ nmcli con modify Wifi wifi-sec.key-mgmt wpa-psk\\n', '$ nmcli con modify Wifi wifi-sec.psk answer\\n', '4，使用以下命令更改 Wi-Fi 状态：\\n', '\\n', '$ nmcli radio wifi [ on | off ]\\n', '更改属性\\n', '请使用以下命令检查具体属性，比如 mtu：\\n', '\\n', \"$ nmcli connection show id 'Wifi ' | grep mtu\\n\", '802-11-wireless.mtu: auto\\n', '使用如下命令更改设置的属性：\\n', '\\n', \"$ nmcli connection modify id 'Wifi ' 802-11-wireless.mtu 1350\\n\", '使用如下命令确认更改：\\n', '\\n', \"$ nmcli connection show id 'Wifi ' | grep mtu\\n\", '802-11-wireless.mtu: 1350\\n', '配置静态路由\\n', '使用nmcli命令为网络连接配置静态路由，使用命令如下：\\n', '\\n', '$ nmcli connection modify enp3s0 +ipv4.routes \"192.168.122.0/24 10.10.10.1\"\\n', '使用编辑器配置静态路由，使用如下命令：\\n', '\\n', '$ nmcli con edit type ethernet con-name enp3s0\\n', '===| nmcli interactive connection editor |===\\n', \"Adding a new '802-3-ethernet' connection\\n\", \"Type 'help' or '?' for available commands.\\n\", \"Type 'describe [<setting>.<prop>]' for detailed property description.\\n\", 'You may edit the following settings: connection, 802-3-ethernet (ethernet), 802-1x, ipv4, ipv6, dcb\\n', 'nmcli> set ipv4.routes 192.168.122.0/24 10.10.10.1\\n', 'nmcli>\\n', 'nmcli> save persistent\\n', \"Saving the connection with 'autoconnect=yes'. That might result in an immediate activation of the connection.\\n\", 'Do you still want to save? [yes] yes\\n', \"Connection 'enp3s0' (1464ddb4-102a-4e79-874a-0a42e15cc3c0) successfully saved.\\n\", 'nmcli> quit\\n', '使用ip命令\\n', ' 说明：\\n', '使用ip命令配置的网络配置可以立即生效但系统重启后配置会丢失。\\n', '\\n', '配置IP地址\\n', '使用ip命令为接口配置地址，命令格式如下，其中 interface-name 为网卡名称。\\n', '\\n', 'ip addr [ add | del ] address dev interface-name\\n', '配置静态地址\\n', '在root权限下，配置设置IP地址，使用示例如下：\\n', '\\n', '# ip address add 192.168.0.10/24 dev enp3s0\\n', '查看配置结果，在root权限使用如下命令：\\n', '\\n', '# ip addr show dev enp3s0\\n', '2: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\\n', '    link/ether 52:54:00:aa:ad:4a brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.202.248/16 brd 192.168.255.255 scope global dynamic noprefixroute enp3s0\\n', '       valid_lft 9547sec preferred_lft 9547sec\\n', '    inet 192.168.0.10/24 scope global enp3s0\\n', '       valid_lft forever preferred_lft forever\\n', '    inet6 fe80::32e8:cc22:9db2:f4d4/64 scope link noprefixroute\\n', '       valid_lft forever preferred_lft forever\\n', '配置多个地址\\n', 'ip 命令支持为同一接口分配多个地址，可在root权限下重复多次使用 ip 命令实现分配多个地址。使用示例如下：\\n', '\\n', '# ip address add 192.168.2.223/24 dev enp4s0\\n', '# ip address add 192.168.4.223/24 dev enp4s0\\n', '# ip addr\\n', '\\n', '3: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\\n', '    link/ether 52:54:00:aa:da:e2 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.203.12/16 brd 192.168.255.255 scope global dynamic noprefixroute enp4s0\\n', '       valid_lft 8389sec preferred_lft 8389sec\\n', '    inet 192.168.2.223/24 scope global enp4s0\\n', '       valid_lft forever preferred_lft forever\\n', '    inet 192.168.4.223/24 scope global enp4s0\\n', '       valid_lft forever preferred_lft forever\\n', '    inet6 fe80::1eef:5e24:4b67:f07f/64 scope link noprefixroute\\n', '       valid_lft forever preferred_lft forever\\n', '配置静态路由\\n', '如果需要静态路由，可使用 ip route add 命令在路由表中添加，使用 ip route del 命令删除。最常使用的 ip route 命令格式如下：\\n', '\\n', 'ip route [ add | del | change | append | replace ] destination-address\\n', '在root权限下使用 ip route 命令显示当前的 IP 路由表。示例如下：\\n', '\\n', '# ip route\\n', '\\n', 'default via 192.168.0.1 dev enp3s0 proto dhcp metric 100\\n', 'default via 192.168.0.1 dev enp4s0 proto dhcp metric 101\\n', '192.168.0.0/16 dev enp3s0 proto kernel scope link src 192.168.202.248 metric 100\\n', '192.168.0.0/16 dev enp4s0 proto kernel scope link src 192.168.203.12 metric 101\\n', '192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 linkdown\\n', '在主机地址中添加一个静态路由，在 root 权限下，使用以下命令格式：\\n', '\\n', 'ip route add 192.168.2.1 via 10.0.0.1 [dev interface-name]\\n', '其中 192.168.2.1 是用点分隔的十进制符号中的 IP 地址，10.0.0.1 是下一个跃点，interface-name 是进入下一个跃点的退出接口。\\n', '\\n', '要在网络中添加一个静态路由，即代表 IP 地址范围的 IP 地址，请在root权限下运行以下命令格式：\\n', '\\n', 'ip route add 192.168.2.0/24 via 10.0.0.1 [dev interface-name]\\n', '其中 192.168.2.1 是目标网络的 IP 地址，10.0.0.1 是网络前缀，interface-name 为网卡名称。\\n', '\\n', '通过ifcfg文件配置网络\\n', ' 说明：\\n', '通过ifcfg文件配置的网络配置不会立即生效，需要在root权限下执行systemctl reload NetworkManager命令以重启网络服务后才生效。\\n', '\\n', '配置静态网络\\n', '以enp4s0网络接口进行静态网络设置为例，通过在root权限下修改ifcfg文件实现，在/etc/sysconfig/network-scripts/目录中生成名为ifcfg-enp4s0的文件中，修改参数配置，示例如下：\\n', '\\n', 'TYPE=Ethernet\\n', 'PROXY_METHOD=none\\n', 'BROWSER_ONLY=no\\n', 'BOOTPROTO=none\\n', 'IPADDR=192.168.0.10\\n', 'PREFIX=24\\n', 'DEFROUTE=yes\\n', 'IPV4_FAILURE_FATAL=no\\n', 'IPV6INIT=yes\\n', 'IPV6_AUTOCONF=yes\\n', 'IPV6_DEFROUTE=yes\\n', 'IPV6_FAILURE_FATAL=no\\n', 'IPV6_ADDR_GEN_MODE=stable-privacy\\n', 'NAME=enp4s0static\\n', 'UUID=08c3a30e-c5e2-4d7b-831f-26c3cdc29293\\n', 'DEVICE=enp4s0\\n', 'ONBOOT=yes\\n', '配置动态网络\\n', '要通过ifcfg文件为em1接口配置动态网络，请按照如下操作在/etc/sysconfig/network-scripts/目录中生成名为 ifcfg-em1 的文件，示例如下：\\n', '\\n', 'DEVICE=em1\\n', 'BOOTPROTO=dhcp\\n', 'ONBOOT=yes\\n', '要配置一个向DHCP服务器发送不同的主机名的接口，请在ifcfg文件中新增一行内容，如下所示：\\n', '\\n', 'DHCP_HOSTNAME=hostname\\n', '要配置忽略由DHCP服务器发送的路由，防止网络服务使用从DHCP服务器接收的DNS服务器更新/etc/resolv.conf。请在ifcfg文件中新增一行内容，如下所示：\\n', '\\n', 'PEERDNS=no\\n', '要配置一个接口使用具体DNS服务器，请将参数PEERDNS=no，并在ifcfg文件中添加以下行：\\n', '\\n', 'DNS1=ip-address\\n', 'DNS2=ip-address\\n', '其中ip-address是DNS服务器的地址。这样就会让网络服务使用指定的DNS服务器更新/etc/resolv.conf。\\n', '\\n', '配置默认网关\\n', '在确定默认网关时，首先解析 /etc/sysconfig/network 文件，然后解析 ifcfg 文件 ，将最后读取的 GATEWAY 的取值作为路由表中的默认路由。\\n', '\\n', '在动态网络环境中，使用 NetworkManager 管理主机时，建议设置为由 DHCP 来分配。\\n', '\\n', '配置主机名\\n', '简介\\n', 'hostname有三种类型：static、transient和pretty。\\n', '\\n', 'static：静态主机名，可由用户自行设置，并保存在/etc/hostname 文件中。\\n', 'transient：动态主机名，由内核维护，初始是 static 主机名，默认值为“localhost”。可由DHCP或mDNS在运行时更改。\\n', 'pretty：灵活主机名，允许使用自由形式（包括特殊/空白字符）进行设置。静态/动态主机名遵从域名的通用限制。\\n', ' 说明：\\n', 'static和transient主机名只能包含a-z、A-Z、0-9、“-”、“_”和“.”，不能在开头或结尾处使用句点，不允许使用两个相连的句点，大小限制为 64 个字符。\\n', '\\n', '使用hostnamectl配置主机名\\n', '查看所有主机名\\n', '查看当前的主机名，使用如下命令：\\n', '\\n', '$ hostnamectl status\\n', ' 说明：\\n', '如果命令未指定任何选项，则默认使用status选项。\\n', '\\n', '设定所有主机名\\n', '在root权限下，设定系统中的所有主机名，使用如下命令：\\n', '\\n', '# hostnamectl set-hostname name\\n', '设定特定主机名\\n', '在root权限下，通过不同的参数来设定特定主机名，使用如下命令：\\n', '\\n', '# hostnamectl set-hostname name [option...]\\n', '其中option可以是--pretty、--static、--transient中的一个或多个选项。\\n', '\\n', '如果--static或--transient与--pretty选项一同使用时，则会将static和transient主机名简化为pretty主机名格式，使用“-”替换空格，并删除特殊字符。\\n', '\\n', '当设定pretty主机名时，如果主机名中包含空格或单引号，需要使用引号。命令示例如下：\\n', '\\n', '# hostnamectl set-hostname \"Stephen\\'s notebook\" --pretty\\n', '清除特定主机名\\n', '要清除特定主机名，并将其还原为默认形式，在root权限下，使用如下命令：\\n', '\\n', '# hostnamectl set-hostname \"\" [option...]\\n', '其中 \"\" 是空白字符串，option是--pretty、--static和--transient中的一个或多个选项。\\n', '\\n', '远程更改主机名\\n', '在远程系统中运行hostnamectl命令时，要使用-H，--host 选项，在root权限下使用如下命令：\\n', '\\n', '# hostnamectl set-hostname -H [username]@hostname new_hostname\\n', '其中hostname是要配置的远程主机，username为自选项，new_hostname为新主机名。hostnamectl会通过SSH连接到远程系统。\\n', '\\n', '使用nmcli配置主机名\\n', '查询static主机名，使用如下命令：\\n', '\\n', '$ nmcli general hostname\\n', '在root权限下，将static主机名设定为host-server，使用如下命令：\\n', '\\n', '# nmcli general hostname host-server\\n', '要让系统hostnamectl感知到static主机名的更改，在root权限下，重启hostnamed服务，使用如下命令：\\n', '\\n', '# systemctl restart systemd-hostnamed\\n', '配置网络绑定\\n', '使用nmcli\\n', '创建名为mybond0的绑定，使用示例如下：\\n', '\\n', '$ nmcli con add type bond con-name mybond0 ifname mybond0 mode active-backup\\n', '添加从属接口，使用示例如下：\\n', '\\n', '$ nmcli con add type bond-slave ifname enp3s0 master mybond0\\n', '要添加其他从属接口，重复上一个命令，并在命令中使用新的接口，使用示例如下：\\n', '\\n', '$ nmcli con add type bond-slave ifname enp4s0 master mybond0\\n', \"Connection 'bond-slave-enp4s0' (05e56afc-b953-41a9-b3f9-0791eb49f7d3) successfully added.\\n\", '要启动绑定，则必须首先启动从属接口，使用示例如下：\\n', '\\n', '$ nmcli con up bond-slave-enp3s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/14)\\n', '$ nmcli con up bond-slave-enp4s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/15)\\n', '现在可以启动绑定，使用示例如下：\\n', '\\n', '$ nmcli con up mybond0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/16)\\n', '使用命令行\\n', '检查是否已安装Bonding内核模块\\n', '在系统中默认已加载相应模块。要载入绑定模块，可在root权限下使用如下命令：\\n', '\\n', '# modprobe --first-time bonding\\n', '显示该模块的信息，可在root权限下使用如下命令：\\n', '\\n', '# modinfo bonding\\n', '更多命令请在root权限下使用modprobe --help查看。\\n', '\\n', '创建频道绑定接口\\n', '要创建绑定接口，可在root权限下通过在 /etc/sysconfig/network-scripts/ 目录中创建名为 ifcfg-bondN 的文件（使用接口号码替换 N，比如 0）。\\n', '\\n', '根据要绑定接口类型的配置文件来编写相应的内容，比如网络接口。接口配置文件示例如下：\\n', '\\n', 'DEVICE=bond0\\n', 'NAME=bond0\\n', 'TYPE=Bond\\n', 'BONDING_MASTER=yes\\n', 'IPADDR=192.168.1.1\\n', 'PREFIX=24\\n', 'ONBOOT=yes\\n', 'BOOTPROTO=none\\n', 'BONDING_OPTS=\"bonding parameters separated by spaces\"\\n', '创建从属接口\\n', '创建频道绑定接口后，必须在从属接口的配置文件中添加 MASTER 和 SLAVE 指令。\\n', '\\n', '例如将两个网络接口enp3s0 和 enp4s0 以频道方式绑定，其配置文件示例分别如下：\\n', '\\n', 'TYPE=Ethernet\\n', 'NAME=bond-slave-enp3s0\\n', 'UUID=3b7601d1-b373-4fdf-a996-9d267d1cac40\\n', 'DEVICE=enp3s0\\n', 'ONBOOT=yes\\n', 'MASTER=bond0\\n', 'SLAVE=yes\\n', 'TYPE=Ethernet\\n', 'NAME=bond-slave-enp4s0\\n', 'UUID=00f0482c-824f-478f-9479-abf947f01c4a\\n', 'DEVICE=enp4s0\\n', 'ONBOOT=yes\\n', 'MASTER=bond0\\n', 'SLAVE=yes\\n', '激活频道绑定\\n', '要激活绑定，则需要启动所有从属接口。请在root权限下，运行以下命令：\\n', '\\n', '# ifup enp3s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)\\n', '# ifup enp4s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/8)\\n', ' 说明：\\n', '对于已经处于“up”状态的接口，请首先使用“ifdown enp3s0 ”命令修改状态为down，其中 enp3s0 为实际网卡名称。\\n', '\\n', '完成后，启动所有从属接口以便启动绑定（不将其设定为 “down”）。\\n', '\\n', '要让 NetworkManager 感知到系统所做的修改，在每次修改后，请在root权限下，运行以下命令：\\n', '\\n', '# nmcli con load /etc/sysconfig/network-scripts/ifcfg-device\\n', '查看绑定接口的状态，请在root权限下运行以下命令：\\n', '\\n', '# ip link show\\n', '\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\\n', '    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '2: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\\n', '    link/ether 52:54:00:aa:ad:4a brd ff:ff:ff:ff:ff:ff\\n', '3: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\\n', '    link/ether 52:54:00:aa:da:e2 brd ff:ff:ff:ff:ff:ff\\n', '4: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000\\n', '    link/ether 86:a1:10:fb:ef:07 brd ff:ff:ff:ff:ff:ff\\n', '5: virbr0-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel master virbr0 state DOWN mode DEFAULT group default qlen 1000\\n', '    link/ether 52:54:00:29:35:4c brd ff:ff:ff:ff:ff:ff\\n', '创建多个绑定\\n', '系统会为每个绑定创建一个频道绑定接口，包括 BONDING_OPTS 指令。使用这个配置方法可让多个绑定设备使用不同的配置。请按照以下操作创建多个频道绑定接口：\\n', '\\n', '创建多个 ifcfg-bondN 文件，文件中包含 BONDING_OPTS 指令，让网络脚本根据需要创建绑定接口。\\n', '创建或编辑要绑定的现有接口配置文件，添加 SLAVE 指令。\\n', '使用 MASTER 指令工具在频道绑定接口中分配要绑定的接口，即从属接口。\\n', '以下是频道绑定接口配置文件示例：\\n', '\\n', 'DEVICE=bondN\\n', 'NAME=bondN\\n', 'TYPE=Bond\\n', 'BONDING_MASTER=yes\\n', 'IPADDR=192.168.1.1\\n', 'PREFIX=24\\n', 'ONBOOT=yes\\n', 'BOOTPROTO=none\\n', 'BONDING_OPTS=\"bonding parameters separated by spaces\"\\n', '在这个示例中，使用绑定接口的号码替换 N。例如要创建两个接口，则需要使用正确的 IP 地址创建两个配置文件 ifcfg-bond0 和 ifcfg-bond1。\\n', '\\n', 'IPv6使用差异说明（vs IPv4）\\n', '约束限制\\n', 'chrony支持全局地址（global address），不支持链路本地地址（link-local address）。\\n', 'Firefox支持通过http/https协议访问全局地址（global address），不支持链路本地地址（link-local address）。\\n', '配置说明\\n', '设置接口设备MTU值\\n', '概述\\n', 'IPv6场景中会发现整个路由路径中的最小mtu的值作为当前链接的PMTU的值，源端根据PMTU的值确定是否进行分片发送，而在整个路径中的其它设备将不再需要进行分片处理，从而可以降低中间路由设备的负载大小。其中IPv6 PMTU设置的最小值为1280。\\n', '\\n', '设置接口设备的mtu\\n', '如果在配置了IPv6地址的接口上设置mtu的值小于1280（IPv6 PMTU设置的最小值），则会导致该接口的IPv6地址被删除。并且无法再次添加IPv6地址。所以在IPv6场景中，对接口设备的mtu的配置一定要大于等于1280。 请在root权限下运行如下命令查看具体现象：\\n', '\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38663sec preferred_lft 38663sec\\n', '    inet6 2001:222::2/64 scope global\\n', '       valid_lft forever preferred_lft forever\\n', '# ip link set dev enp3s0 mtu 1200\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1200 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38642sec preferred_lft 38642sec\\n', '# ip addr add 2001:222::2/64 dev enp3s0\\n', 'RTNETLINK answers: No buffer space available\\n', '# ip link set dev enp3s0 mtu 1500\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38538sec preferred_lft 38538sec\\n', '# ip addr add 2001:222::2/64 dev enp3s0\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38531sec preferred_lft 38531sec\\n', '    inet6 2001:222::2/64 scope global\\n', '       valid_lft forever preferred_lft forever\\n', '有状态自动配置IPv6地址\\n', '概述\\n', 'IPv6与IPv4都可以在root权限下通过DHCP的方式获得IP地址。IPv6地址有两种配置方式：无状态自动配置和有状态自动配置。\\n', '\\n', '无状态自动配置\\n', '\\n', '不需要DHCP服务进行管理，设备根据网络RA（路由公告）获得网络前缀，或者link-local地址为固定fe80::。而接口ID则根据ifcfg配置IPV6_ADDR_GEN_MODE的具体设置来进行自动获得：\\n', '\\n', 'IPv6_ADDR_GEN_MODE=“stable-privacy” 则根据设备及网络环境来确定一个随机接口ID。\\n', 'IPv6_ADDR_GEN_MODE=“EUI64” 则根据设备MAC地址来确定接口ID。\\n', '有状态自动配置：需要DHCP服务器进行管理分配，服从DHCPv6协议来从DHCPv6服务器端租赁IPv6地址。\\n', '\\n', '在有状态自动配置IPv6地址时，DHCPv6服务端可以通过客户端设置的vendor class将客户端进行分类，不同类别分配不同地址段的IPv6地址。在IPv4场景中，客户端可以直接用dhclient的-V选项来设置vendor-class-identifier，DHCP服务端在配置文件中根据vendor-class-identifier来对客户端进行分类处理。而IPv6场景中，如果使用同样的方法对客户端分类，则分类并不会生效。\\n', '\\n', 'dhclient -6 <interface> -V <vendor-class-identifier string> <interface>\\n', '这是由于DHCPv6和DHCP协议存在较大差异，DHCPv6的可选项中使用vendor-class-option替代了DHCP中的vendor-class-identifier。而dhclient的-V选项并不能设置vendor-class-option。\\n', '\\n', '有状态自动配置IPv6地址时dhclient设置vendor class方法\\n', '在客户端使用配置文件方式添加对vendor class的设置，使用方法如下：\\n', '\\n', '客户端配置文件（/etc/dhcp/dhclient6.conf），文件位置可以自定义，在使用时需要通过dhclient -cf选项来指定配置文件：\\n', '\\n', 'option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};\\n', 'interface \"enp3s0\" {\\n', '        send dhcp6.vendor-class <Enterprise-ID number> <vendor class string length> <vendor class string>;\\n', '}\\n', ' 说明：\\n', '\\n', '<Enterprise-ID number>，32位整型数字，企业标识号，企业通过IANA注册。\\n', '<vendor class string length>，16位整型数字，vendor class字符串长度。\\n', '<vendor class string>，要设置的vendor class字符串，例如：“HWHW”。\\n', '客户端使用方法：\\n', '\\n', 'dhclient -6 <interface> -cf /etc/dhcp/dhclient6.conf\\n', 'DHCPv6服务端配置文件（/etc/dhcp/dhcpd6.conf），需要dhcpd -cf选项来指定该配置文件：\\n', '\\n', 'option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};\\n', 'subnet6 fc00:4:12:ffff::/64 {\\n', '        class \"hw\" {\\n', '                match if substring ( option dhcp6.vendor-class, 6, 10 ) = \"HWHW\";\\n', '        }\\n', '        pool6 {\\n', '                allow members of \"hw\";\\n', '                range6 fc00:4:12:ffff::ff10 fc00:4:12:ffff::ff20;\\n', '        }\\n', '        pool6 {\\n', '                allow unknown clients;\\n', '                range6 fc00:4:12:ffff::100 fc00:4:12:ffff::120;\\n', '        }\\n', '}\\n', ' 说明：\\n', 'substring ( option dhcp6.vendor-class, 6, 10 ) 其中子字符串的开始位置为6，因为前面包含4个字节的<Enterprise-ID number>和2个字节的<string length>。而子字符串的结束位置位：6+<vendor class string length>。这里vendor class string为“HWHW”，字符串的长度为4，所以子字符串的结束位置为6+4=10。用户可以根据实际需要来确定<vendor class string>及相应的<vendor class string length>。\\n', '\\n', '服务端使用方法：\\n', '\\n', 'dhcpd -6 -cf /etc/dhcp/dhcpd6.conf <interface>\\n', '内核支持socket相关系统调用\\n', '概述\\n', 'IPv6地址长度扩展到128比特，所以有足够的IPv6地址可供分配使用。同时IPv6头相比IPv4头进行了简化，并增强了IPv6的自动配置功能。IPv6地址分为单播地址，组播地址和任意播地址。常用的单播地址又包含：链路本地地址（link-local address），唯一本地地址（Unique local address）和全局地址（global address）。由于IPv6的全局地址十分充足，唯一本地地址一般不被使用（其前身为站点本地地址（site-local address），已于2004年被废弃）。当前主要使用的单播地址为：链路本地地址（link-local address）和全局地址（global address）。当前内核支持socket系统调用，在使用单播地址的链路本地地址和全局地址时存在差异。\\n', '\\n', 'link-local地址和global地址在socket调用时的差异\\n', 'RFC 2553： Basic Socket Interface Extensions for IPv6 定义sockaddr_in6的数据结构如下；\\n', '\\n', 'struct sockaddr_in6 {     \\n', '    uint8_t         sin6_len;       /* length of this struct */     \\n', '    sa_family_t     sin6_family;    /* AF_INET6 */     \\n', '    in_port_t       sin6_port;      /* transport layer port # */     \\n', '    uint32_t        sin6_flowinfo;  /* IPv6 flow information */     \\n', '    struct in6_addr sin6_addr;      /* IPv6 address */     \\n', '    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */ \\n', '}; \\n', ' 说明：\\n', 'sin6_scope_id： 32位整型，对于链路本地地址（link-local address），对于链路范围的sin6_addr，它可以用来标识指定的接口索引号。如果是站点范围的sin6_addr，则用来作为站点的标识符（站点本地地址已被抛弃）。\\n', '\\n', '在使用link-local地址进行socket通信时，在构造目的地址时，需要制定该地址所对应的接口索引号。一般可以通过if_nametoindex函数将接口名转化为接口索引号。具体方式如下，\\n', '\\n', 'int port = 1234;\\n', 'int sk_fd;\\n', 'int iff_index = 0;\\n', 'char iff_name[100] = \"enp3s0\";\\n', 'char * ll_addr[100] = \"fe80::123:456:789\";\\n', 'struct sockaddr_in6 server_addr;\\n', '\\n', 'memset(&server_addr,0,sizeof(structsockaddr_in6));\\n', 'iff_index=if_nametoindex(iff_name);\\n', '\\n', 'server_addr.sin6_family=AF_INET6;\\n', 'server_addr.sin6_port=htons(port);\\n', 'server_addr.sin6_scope_id=iff_index;\\n', 'inet_pton(AF_INET6, ll_addr, &(server_addr.sin6_addr));\\n', '\\n', 'sk_fd=socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\\n', 'connect(sk_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr_in6));\\n', 'IPv4的dhclient守护进程持久化配置\\n', '概述\\n', '通过NetworkManager服务来管理网络服务时，如果接口ifcfg-<interface-name>配置文件中配置了DHCP方式获得IP地址，则相应地NetworkManager服务会拉起dhclient守护进程来通过DHCP协议方式来从DHCP服务器获取IP地址。\\n', '\\n', 'dhclient提供了\"-1\"选项来决定dhclient进程在未获得DHCP服务响应时，是会不断持久化尝试请求地址还是会尝试时间超时后退出。针对IPv4的dhclient守护进程，可以在ifcfg-<interface-name>配置文件中设置PERSISTENT_DHCLIENT来决定是否设置IPv4的dhclient进程的持久化。\\n', '\\n', '约束限制\\n', '当dhclient进程在运行中被杀死，network服务无法自动将其拉起，可靠性需要用户自己保障。\\n', '配置了持久化选项PERSISTENT_DHCLIENT，需要确保有相应的DHCP服务器。如果在拉起network时无可用DHCP服务器，dhclient进程不断尝试发送请求包但无回应，则会导致network服务卡死直到network服务超时失败。由于network服务在拉起多个网卡的IPv4 dhclient进程时，是通过串行的方式来拉起的。如果有网卡配置了持久化而DHCP服务器没有准备好，则会导致network服务在给该网卡获取IPv4地址超时卡死，进而导致后续网卡无法获得IPv4/IPv6地址。\\n', '以上两种约束限制是特殊的应用场景，需要用户自己进行可靠性保障。\\n', '\\n', 'IPv4 DHCP和IPv6 DHCPv6方式获取地址的配置差异\\n', '可以通过配置接口ifcfg-<interface-name>参数来分别实现IPv4和IPv6通过DHCP/DHCPv6协议来动态获取IP地址，具体配置说明如下；\\n', '\\n', 'BOOTPROTO=none|bootp|dhcp\\n', 'DHCPV6C=yes|no\\n', 'PERSISTENT_DHCLIENT=yes|no|1|0\\n', 'BOOTPROTO： none表示静态配置IPv4地址，bootp|dhcp则会拉起DHCP dhclient来动态获取IPv4地址。\\n', '\\n', 'DHCPV6C： no表示静态配置IPv6地址，yes则会拉起DHCPv6 dhclient来动态获取IPv6地址。\\n', '\\n', 'PERSISTENT_DHCLIENT：no|0表示IPv4的dhclient进程配置为“非持久化”，当dhclient向DHCP服务器发送一次请求报文而无响应，则会间隔一段时间后退出，退出值为2。yes|1则表示IPv4的dhclient进程配置为“持久化”，dhclient会向DHCP服务器反复发送请求报文。如果没有配置PERSISTENT_DHCLIENT项，则IPv4的dhclient会默认设置为“持久化”。\\n', '\\n', ' 说明：\\n', 'PERSISTENT_DHCLIENT配置只针对IPv4生效，对IPv6相关dhclient -6进程不生效，IPv6默认不进行持久化配置。\\n', '\\n', 'iproute相关命令配置IPv4与IPv6时的差异说明\\n', '概述\\n', '由于IPv4和IPv6是两个不同的协议标准，iproute相关命令在使用方法上存在一定的差异。本章节主要梳理iproute包中用户经常使用到命令在IPv4和IPv6使用方面的差异，从而可以更好地指导用户使用iproute包中相关命令。\\n', '\\n', 'iproute相关命令均需要在root权限下运行。\\n', '\\n', 'IPv6地址的生命周期\\n', '\\n', 'IPv6状态\\n', '\\n', '解释\\n', '\\n', 'tentative\\n', '\\n', '临时状态：刚添加地址还处于地址重复检测DAD过程\\n', '\\n', 'preferred\\n', '\\n', '首选状态：完成DAD过程，没有收到相应的NA报文，表示该地址没有冲突。\\n', '\\n', 'deprecated\\n', '\\n', '弃用状态：地址有一定的使用时限（valid_lft和preferred_lft），preferred_lft到期后地址会变化deprecated状态。\\n', '\\n', '该状态下的地址不能用于创建新的连接，但是原有的连接可以继续使用。\\n', '\\n', 'invalid\\n', '\\n', '无效状态：使用时限超过preferred_lft一段时间后仍然没有成功进行租约续约，则valid_lft时间到后地址状态会被设置为invalid，表示该地址不可以再被使用。\\n', '\\n', '其它说明：\\n', '\\n', 'preferred_lft：preferred lifetime，地址为首选状态的寿命，preferred_lft没有到期的地址可以用于正常通信使用，若有多个preferred地址则按照内核具体机制选择地址。\\n', 'valid_lft： valid lifetime，地址有效的寿命，在[preferred_lft, valid_lft]时间段内该地址不能被用于新建连接，已经创建的连接继续有效。\\n', 'ip link 命令\\n', '命令：\\n', '\\n', 'ip link set IFNAME mtu MTU\\n', 'IPv6中PMTU的最小值为1280，如果mtu值设置小于1280则会导致IPv6地址丢失。其它设备无法ping通该IPv6地址。\\n', '\\n', 'ip addr命令\\n', '命令：\\n', '\\n', 'ip [-6] addr add IFADDR dev IFNAME\\n', '添加IPv6地址可以选择添加-6选项也可以不添加，ip addr命令会根据具体地址类型来判断是ipv4地址还是IPv6地址。\\n', '\\n', '如果指定“-6”选项，但是IFADDR 是ipv4地址则会有错误返回。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] addr add IFADDR  dev IFNAME [home|nodad]\\n', '[home|nodad] 选项只针对IPv6地址有效。\\n', '\\n', 'home：将该地址指定为RFC 6275中定义的家庭地址。（这是移动节点从家庭链路获取的地址， 是移动节点的永久地址，如果移动节点保持在相同的归属链路中，则各种实体之间的通信照常进行。）\\n', 'nodad：配置该项（仅限IPv6）添加此地址时不执行重复地址检测DAD（RFC 4862）。如果一台设备上多个接口通过nodad配置了多个相同的IPv6地址，则会按照接口顺序使用该IPv6地址。同一个接口上不能添加一个nodad一个非nodad的相同IPv6地址。因为两个地址是一样的，所以会报“RTNETLINK answers: File exists”。\\n', '命令：\\n', '\\n', 'ip [-6] addr del IFADDR dev IFNAME\\n', '删除IPv6地址可以选择添加-6选项也可以不添加，ip addr del命令会根据具体地址类型来判断是ipv4地址还是IPv6地址。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] addr show dev IFNAME [tentative|-tentative|deprecated|-deprecated|dadfailed|-dadfailed|temporary]\\n', '不指定-6选项，则会同时打印IPv4和IPv6地址。指定-6选项则只打印IPv6地址。\\n', '[tentative|-tentative|deprecated|-deprecated|dadfailed|-dadfailed|temporary]，这些选项只针对IPv6，可以根据IPv6地址状态对地址进行筛选查看。\\n', 'tentative：（仅限IPv6）仅列出尚未通过重复地址检测的地址。\\n', '-tentative：（仅限IPv6）仅列出当前未处于重复地址检测过程中的地址。\\n', 'deprecated：（仅限IPv6）仅列出已弃用的地址。\\n', '-deprecated：（仅限IPv6）仅列出未弃用的地址。\\n', 'dadfailed：（仅限IPv6）仅列出重复地址检测失败的地址。\\n', '-dadfailed：（仅限IPv6）仅列出未重复地址检测失败的地址。\\n', 'temporary：（仅限IPv6）仅列出临时地址\\n', 'ip route命令\\n', '命令：\\n', '\\n', 'ip [-6] route add ROUTE [mtu lock MTU]\\n', '-6选项：添加IPv6路由可以选择添加-6选项也可以不添加，ip route命令会根据具体地址类型来判断是IPv4地址还是IPv6地址。\\n', '\\n', 'mtu lock MTU：锁定路由的MTU值。如果不锁定MTU，则MTU的值则可能在PMTUD过程中被内核改变。如果锁定MTU，则不会尝试PMTUD，所有IPv4包都将不设置DF位发出，IPv6包则会按照MTU进行分段处理。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] route del ROUTE\\n', '删除IPv6路由可以选择添加-6选项也可以不添加，ip route命令会根据具体地址类型来判断是IPv4地址还是IPv6地址。\\n', '\\n', 'ip rule命令\\n', '命令：\\n', '\\n', 'ip [-6] rule list\\n', '-6选项：设置-6选项打印IPv6的策略路由，不设置-6选项打印IPv4的策略路由。所以需要根据具体协议类型来配置-6选项。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] rule [add|del] [from|to] ADDR table TABLE pref PREF\\n', '-6选项：IPv6相关的策略路由表项需要设置-6选项，否则会报错：“Error: Invalid source address.”。相应地，IPv4相关的策略路由表项不可以设置-6选项，否则会报错：“Error: Invalid source address.”。\\n', '\\n', 'NetworkManager服务配置差异说明\\n', '概述\\n', 'NetworkManager服务使用ifup/ifdown的逻辑接口定义进行高级网络设置。其参数大多数都是在/etc/sysconfig/network和/etc/sysconfig/network-scripts/ifcfg-<interface-name>两个配置文件设置。前者为全局设置，后者为指定网卡的设置，当两者有冲突时，后者生效。\\n', '\\n', '配置差异说明\\n', '其中在/etc/sysconfig/network下的配置差异有：\\n', '\\n', '\\n', 'IPv4\\n', '\\n', 'IPv6\\n', '\\n', '含义说明\\n', '\\n', 'NA\\n', '\\n', 'IPV6FORWARDING=yes|no\\n', '\\n', 'IPv6转发，默认不转发。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_AUTOCONF=yes|no\\n', '\\n', 'IPv6转发打开是no，否则是yes。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_ROUTER=yes|no\\n', '\\n', 'IPv6转发打开是yes，否则是no。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_AUTOTUNNEL=yes|no\\n', '\\n', '指定Tunnel为自动隧道模式，默认是no。\\n', '\\n', 'GATEWAY\\n', '\\n', 'IPV6_DEFAULTGW=<IPv6 address[%interface]> (optional)\\n', '\\n', '在IPv6中设置默认网关。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_DEFAULTDEV=<interface> (optional)\\n', '\\n', '指定默认转发的网卡。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_RADVD_PIDFILE=<pid-file> (optional)\\n', '\\n', '默认ipv6_radvd_pid路径：/var/run/radvd/radvd.pid。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_RADVD_TRIGGER_ACTION=startstop|reload|restart|SIGHUP (optional)\\n', '\\n', 'radvd默认触发动作。\\n', '\\n', '而在/etc/sysconfig/network-scripts/ifcfg-<interface-name>下的差异主要有：\\n', '\\n', '\\n', 'IPv4\\n', '\\n', 'IPv6\\n', '\\n', '含义说明\\n', '\\n', 'IPADDRn\\n', '\\n', 'IPV6ADDR=<IPv6 address>[/<prefix length>]\\n', '\\n', 'ip地址。\\n', '\\n', 'PREFIXn\\n', '\\n', 'NA\\n', '\\n', '网络前缀，网络别名和ppp无效，优先级高于NETMASK。\\n', '\\n', 'NETMASKn\\n', '\\n', 'NA\\n', '\\n', '子网掩码，仅用于别名和ppp。\\n', '\\n', 'GATEWAY\\n', '\\n', 'IPV6_DEFAULTGW=<IPv6 address[%interface]> (optional)\\n', '\\n', '默认网关。\\n', '\\n', 'MTU\\n', '\\n', 'IPV6_MTU=<MTU of link> (optional)\\n', '\\n', '默认MTU。\\n', '\\n', 'IPV4_FAILURE_FATAL=yes|no\\n', '\\n', 'IPV6_FAILURE_FATAL\\n', '\\n', '默认值是no。若设置为yes，dhclient失败ifup-eth会直接退出。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_PRIVACY=rfc3041\\n', '\\n', '默认禁用。\\n', '\\n', 'NA\\n', '\\n', 'IPV6INIT=yes|no\\n', '\\n', '默认开启IPv6。\\n', '\\n', 'NA\\n', '\\n', 'IPV6FORWARDING=yes|no\\n', '\\n', '默认关闭，已废弃。\\n', '\\n', 'FAQ\\n', 'iscsi-initiator-utils不支持登录fe80 IPv6地址\\n', '问题现象\\n', '客户端通过IPv6登录iscsi服务端时，使用如“iscsiadm -m node -p ipv6address -l”的命令格式登录，如果是全局地址（global address），直接替换将命令范例中的“ipv6address”替换为全局地址即可；但如果是链路本地地址（link-local address，fe80开头的IPv6地址）则无法使用，因为iscsi-initiator-utils目前机制还不支持用链路本地地址（link-local address）地址登录iscsi服务端。\\n', '\\n', '原因分析\\n', '如果使用格式如“iscsiadm -m node -p fe80::xxxx -l”登录，会登录超时返回，这是因为使用链路本地地址必须指定接口，否则使用iscsi_io_tcp_connect函数调用connect函数会失败，并且产生标准错误码22。\\n', '\\n', '如果使用格式如“iscsiadm -m node -p fe80::xxxx%enp3s0 -l”登录时，iscsi_addr_match函数会将地址“fe80::xxxx%enp3s0”与服务端返回的node信息中的地址“fe80::xxxx”对比，对比结果不匹配，导致登录失败。\\n', '\\n', '因此，iscsi-initiator-utils目前机制还不支持用链路本地地址（link-local address）登录iscsi服务端。\\n', '\\n', '网卡down掉之后，IPv6地址丢失\\n', '问题现象\\n', '通过ip link down+up网卡或ifconfig down+up网卡命令，将网卡down掉之后再上线，查看网卡上配置的ip地址，发现ipv4地址不丢失，而配置的IPv6地址丢失。\\n', '\\n', '原因分析\\n', '内核中的处理逻辑为如果网卡设置为down状态，会清空所有IPv4及IPv6地址，将网卡重新up之后，ipv4地址自动恢复，网卡上自动配置的IPv6链路本地地址也会恢复，但是其他IPv6地址默认会丢失。如果需要保留这些IPv6地址，可以通过“sysctl -w net.ipv6.conf.<网卡名>.keep_addr_on_down=1”来实现。\\n', '\\n', 'bond口已具有多个IPv6地址时，添加或删除IPv6地址耗时过久\\n', '问题现象\\n', '下列方式配置或删除（包括flush）IPv6地址方式，X为动态变化的低16位，并且配置在bond口时，耗时会随已配置的IPv6地址数量成数倍增加。例如由4个物理网卡组成的bond口添加IPv6地址时，单线程添加删除3000 IPv6地址均需大概5分钟，而普通物理网卡耗时在10秒内。\\n', '\\n', 'ip a add/del 192:168::18:X/64 dev DEVICE\\n', '原因分析\\n', 'bond口在添加IPv6地址时，会生成IPv6组播地址，并进行同步到所有的物理网卡上，此耗时会随IPv6数量增加而增加，导致耗时过长。\\n', '\\n', '解决方法\\n', 'IPv6的组播地址是由IPv6地址的低24位与33-33-ff组合生成，组播地址过多会导致添加删除耗时增加，如果生成的组播地址为少量，耗时不会受此影响。\\n', '\\n', '建议添加IPv6地址时，可保持低24位一致，保持高位变动，单网卡中仅需一个网段的一个地址即可与外部正常通信，此配置更符合常规使用。\\n', '\\n', 'Rsyslog在IPv4和IPv6混合使用场景中日志传输延迟\\n', '问题现象\\n', 'rsyslog客户端配置文件同时配置IPv4和IPv6地址，且端口配置相同的情况下，服务端收集log时会概率性出现日志打印延迟。\\n', '\\n', '原因分析\\n', '延迟是因为rsyslog内部存在缓冲队列机制，默认情况下需要缓冲区队列达到一定数量才会写入文件。\\n', '\\n', '解决方法\\n', '可在root权限下通过配置Direct模式，关闭缓冲队列机制解决该问题。在rsyslog远程传输服务端的/etc/rsyslog.d目录下新增的远程传输配置文件中，最开头增加如下配置：\\n', '\\n', '$ActionQueueType Direct\\n', '$MainMsgQueueType Direct\\n', ' 说明：\\n', '\\n', 'Direct模式减少队列大小为1，所以在队列中会保留1条日志到下次日志打印；\\n', 'Direct模式会降低服务器端的rsyslog性能。']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_安装虚拟化.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E5%8C%96.html", "text_entry": "['安装虚拟化\\n', '本章介绍在openEuler中安装虚拟化组件的方法。\\n', '\\n', '安装虚拟化\\n', '最低硬件要求\\n', '安装虚拟化核心组件\\n', '安装方法\\n', '验证安装是否成功\\n', '最低硬件要求\\n', '在openEuler系统中安装虚拟化组件，最低硬件要求：\\n', '\\n', 'AArch64处理器架构：ARMv8以上并且支持虚拟化扩展\\n', 'x86_64处理器架构：支持VT-x\\n', '2核CPU\\n', '4GB的内存\\n', '16GB可用磁盘空间\\n', '安装虚拟化核心组件\\n', '安装方法\\n', '前提条件\\n', '已经配置yum源。配置方式请参见《openEuler 22.03 LTS 管理员指南》。\\n', '安装操作需要root用户权限。\\n', '安装步骤\\n', '安装QEMU组件。\\n', '\\n', '# yum install -y qemu\\n', '安装libvirt组件。\\n', '\\n', '# yum install -y libvirt\\n', '启动libvirtd服务。\\n', '\\n', '# systemctl start libvirtd\\n', ' 说明：\\n', 'KVM模块已经集成在openEuler内核中，因此不需要单独安装。\\n', '\\n', '验证安装是否成功\\n', '查看内核是否支持KVM虚拟化，即查看/dev/kvm和/sys/module/kvm文件是否存在，命令和回显如下：\\n', '\\n', '$ ls /dev/kvm\\n', '/dev/kvm\\n', '$ ls /sys/module/kvm\\n', 'parameters  uevent\\n', '若上述文件存在，说明内核支持KVM虚拟化。若上述文件不存在，则说明系统内核编译时未开启KVM虚拟化，需要更换支持KVM虚拟化的Linux内核。\\n', '\\n', '确认QEMU是否安装成功。若安装成功则可以看到QEMU软件包信息，命令和回显如下：\\n', '\\n', '$ rpm -qi qemu\\n', 'Name        : qemu\\n', 'Epoch       : 2\\n', 'Version     : 4.0.1\\n', 'Release     : 10\\n', 'Architecture: aarch64\\n', 'Install Date: Wed 24 Jul 2019 04:04:47 PM CST\\n', 'Group       : Unspecified\\n', 'Size        : 16869484\\n', 'License     : GPLv2 and BSD and MIT and CC-BY\\n', 'Signature   : (none)\\n', 'Source RPM  : qemu-4.0.0-1.src.rpm\\n', 'Build Date  : Wed 24 Jul 2019 04:03:52 PM CST\\n', 'Build Host  : localhost\\n', 'Relocations : (not relocatable)\\n', 'URL         : http://www.qemu.org\\n', 'Summary     : QEMU is a generic and open source machine emulator and virtualizer\\n', 'Description :\\n', 'QEMU is a generic and open source processor emulator which achieves a good\\n', 'emulation speed by using dynamic translation. QEMU has two operating modes:\\n', '\\n', ' * Full system emulation. In this mode, QEMU emulates a full system (for\\n', '   example a PC), including a processor and various peripherals. It can be\\n', '   used to launch different Operating Systems without rebooting the PC or\\n', '   to debug system code.\\n', ' * User mode emulation. In this mode, QEMU can launch Linux processes compiled\\n', '   for one CPU on another CPU.\\n', '\\n', 'As QEMU requires no host kernel patches to run, it is safe and easy to use.\\n', '确认libvirt是否安装成功。若安装成功则可以看到libvirt软件包信息，命令和回显如下：\\n', '\\n', '$ rpm -qi libvirt\\n', 'Name        : libvirt\\n', 'Version     : 5.5.0\\n', 'Release     : 1\\n', 'Architecture: aarch64\\n', 'Install Date: Tue 30 Jul 2019 04:56:21 PM CST\\n', 'Group       : Unspecified\\n', 'Size        : 0\\n', 'License     : LGPLv2+\\n', 'Signature   : (none)\\n', 'Source RPM  : libvirt-5.5.0-1.src.rpm\\n', 'Build Date  : Mon 29 Jul 2019 08:14:57 PM CST\\n', 'Build Host  : 71e8c1ce149f\\n', 'Relocations : (not relocatable)\\n', 'URL         : https://libvirt.org/\\n', 'Summary     : Library providing a simple virtualization API\\n', 'Description :\\n', 'Libvirt is a C toolkit to interact with the virtualization capabilities\\n', 'of recent versions of Linux (and other OSes). The main package includes\\n', 'the libvirtd server exporting the virtualization support.\\n', '查看libvirt服务是否启动成功。若服务处于“Active”状态，说明服务启动成功，可以正常使用libvirt提供的virsh命令行工具，命令和回显如下：\\n', '\\n', '$ systemctl status libvirtd\\n', '● libvirtd.service - Virtualization daemon\\n', '   Loaded: loaded (/usr/lib/systemd/system/libvirtd.service; enabled; vendor preset: enabled)\\n', '   Active: active (running) since Tue 2019-08-06 09:36:01 CST; 5h 12min ago\\n', '     Docs: man:libvirtd(8)\\n', '           https://libvirt.org\\n', ' Main PID: 40754 (libvirtd)\\n', '    Tasks: 20 (limit: 32768)\\n', '   Memory: 198.6M\\n', '   CGroup: /system.slice/libvirtd.service\\n', '           ─40754 /usr/sbin/libvirtd\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_工具使用指南_LibcarePlus.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/LibcarePlus.html", "text_entry": "['LibcarePlus\\n', '概述\\n', '软硬件要求\\n', '注意事项和约束\\n', '安装 LibcarePlus\\n', '制作 LibcarePlus 热补丁\\n', '应用 LibcarePlus 热补丁\\n', '概述\\n', 'LibcarePlus 是一个用户态进程热补丁框架，可以在不重启进程的情况下对 Linux 系统上运行的目标进程进行热补丁操作。热补丁可以应用于 CVE 漏洞修复，也可以应用于不中断应用服务的紧急 bug 修复。\\n', '\\n', '软硬件要求\\n', '在 openEuler 上使用 LibcarePlus，需要满足一定的软硬件要求：\\n', '\\n', '当前LibcarePlus支持 x86 体系架构和arm64体系架构。\\n', 'LibcarePlus 可以在任何支持安装 libunwind、 elfutils 以及 binutils 的 Linux 发行版系统上运行。\\n', 'LibcarePlus 使用ptrace()系统调用，需要对应Linux发行版本的相关编译选项支持。\\n', 'LibcarePlus 制作热补丁时，依赖原可执行文件的符号表，因此，请勿过早将符号表strip掉。\\n', '对于开启selinux的Linux系统，需要自行适配对应的selinux规则。\\n', '注意事项和约束\\n', '使用 LibcarePlus，需遵循以下热补丁规范和约束：\\n', '\\n', '仅支持对 C 语言编写的代码，不支持汇编语言等。\\n', '代码文件名必须符合 C 语言标识符命名规范：由字母（A-Z,a-z）、数字 （0-9）、下划线“_”组成；并且首字符不能是数字，但可以是字母或者下划线；不能包含“-”、“$”等特殊符号。\\n', '支持增量补丁，即支持对进程打多个补丁，但补丁加卸载管理需使用者执行设计，一般遵循FILO规则。\\n', '不支持补丁自动加载，对于特定进程，需使用者自行设计。\\n', '支持补丁查询功能。\\n', '静态函数补丁受限于系统中能找到该函数的符号表。\\n', '热补丁为进程粒度，即动态库热补丁只能对调用这个动态库的进程打补丁。\\n', '单个进程支持的补丁数受限于跳转指令的跳转范围和虚拟内存地址空洞大小，一般支持[1, 512]；\\n', '对于TLS变量，仅支持修改IE模式的TLS变量；\\n', '后续补丁不能使用之前补丁中定义的符号；\\n', '以下场景不支持热补丁:\\n', '死循环函数、不退出函数、inline 函数、初始化函数、NMI 中断处理函数\\n', '替换全局变量\\n', '小于5字节的短函数\\n', '修改头文件\\n', '增加和删除目标函数的出参和入参\\n', '数据结构成员变化（新增、删除、修改）\\n', '修改包含 LINE ， FILE 等gcc编译宏的 C 文件\\n', '修改 intel 矢量汇编指令\\n', '安装 LibcarePlus\\n', '安装软件依赖\\n', 'LibcarePlus 运行依赖于 libunwind、 elfutils 和 binutils，在配置了 yum 源的 openEuler 系统上，可以参考如下命令安装 LibcarePlus 的依赖软件。\\n', '\\n', '# yum install -y binutils elfutils elfutils-libelf-devel libunwind-devel\\n', '安装 LibcarePlus\\n', '# yum install libcareplus -y\\n', '查看安装是否成功：\\n', '\\n', '# libcare-ctl -h\\n', 'usage: libcare-ctl [options] <cmd> [args]\\n', '\\n', 'Options:\\n', '  -v          - verbose mode\\n', '  -h          - this message\\n', '\\n', 'Commands:\\n', '  patch  - apply patch to a user-space process\\n', '  unpatch- unapply patch from a user-space process\\n', '  info   - show info on applied patches\\n', '\\n', '制作 LibcarePlus 热补丁\\n', '概述\\n', 'LibcarePlus 支持如下方式制作热补丁：\\n', '\\n', '手动制作\\n', '通过脚本制作\\n', '手动制作热补丁的过程繁琐，对于代码量较大的工程，例如QEMU，手动制作热补丁极其困难。建议使用 LibcarePlus 自带脚本一键式地生成热补丁文件。\\n', '\\n', '手动制作\\n', '本节以原文件 foo.c 和补丁文件 bar.c 为例，给出手动制作热补丁的指导。\\n', '\\n', '准备 C 语言编写的原文件和补丁文件。例如原文件 foo.c 和补丁文件 bar.c 。\\n', '\\n', '点击展开 foo.c\\n', '点击展开 bar.c\\n', '编译得到原文件和补丁文件的汇编文件 foo.s 和 bar.s，参考命令如下：\\n', '\\n', '# gcc -S foo.c\\n', '# gcc -S bar.c\\n', '# ls\\n', 'bar.c  bar.s  foo.c  foo.s\\n', '使用 kpatch_gensrc 对比 foo.s 和 bar.s 差异，生成包含原文件的汇编内容和差异内容的 foobar.s，参考命令如下：\\n', '\\n', \"# sed -i 's/bar.c/foo.c/' bar.s\\n\", '# kpatch_gensrc --os=rhel6 -i foo.s -i bar.s -o foobar.s --force-global\\n', '由于 kpatch_gensrc 默认对同一 C 语言原文件进行对比，所以对比前需要使用 sed 命令将补丁汇编文件 bar.s 中的 bar.c 改为原文件名称 foo.c。随后调用 kpatch_gensrc，指定输入文件为 foo.s 与 bar.s，输出文件为 foobar.s。\\n', '\\n', '编译原文件的汇编文件 foo.s 和生成的汇编文件 foobar.s，得到可执行文件 foo 和 foobar，参考命令如下：\\n', '\\n', '# gcc -o foo foo.s\\n', '# gcc -o foobar foobar.s -Wl,-q\\n', '链接选项**-Wl, -q**将保留foobar中的重定位节。\\n', '\\n', '利用 kpatch_strip 去除可执行程序 foo 和 foobar 的相同内容，保留制作热补丁所需要的内容。\\n', '\\n', '# kpatch_strip --strip foobar foobar.stripped\\n', '# kpatch_strip --rel-fixup foo foobar.stripped\\n', '# strip --strip-unneeded foobar.stripped\\n', '# kpatch_strip --undo-link foo foobar.stripped\\n', '上述命令中的各参数含义为：\\n', '\\n', '–strip 用于去除 foobar 中对于补丁制作无用的 section；\\n', '–rel-fixup 用于修复补丁内所访问的变量以及函数的地址；\\n', 'strip –strip-unneeded 用于去除对于热补丁重定位操作无用的符号信息；\\n', '–undo-link 用于将补丁内符号的地址从绝对地址更改为相对地址。\\n', '制作热补丁文件。\\n', '\\n', '通过以上操作，已经得到了热补丁制作所需的主要内容。接下来需要使用 kpatch_make 将原可执行文件的 Build ID 以及 kpatch_strip 的输出文件 foobar.stripped 作为参数传递给 kpatch_make，最终生成热补丁文件，参考命令如下：\\n', '\\n', \"# str=$(readelf -n foo | grep 'Build ID')\\n\", '# substr=${str##* }\\n', '# kpatch_make -b $substr -i 0001 foobar.stripped -o foo.kpatch\\n', '# ls\\n', 'bar.c  bar.s  foo  foobar  foobar.s  foobar.stripped  foo.c  foo.kpatch  foo.s\\n', '至此，就得到了patch ID为0001的热补丁文件 foo.kpatch。\\n', '\\n', '通过脚本制作\\n', '本节介绍如何利用 LibcarePlus 自带的 libcare-patch-make 脚本制作热补丁文件，仍以原文件 foo.c 和补丁文件 bar.c 为例。\\n', '\\n', '利用 diff 命令生成 foo.c 和 bar.c 的对比文件，命令如下所示:\\n', '\\n', '# diff -up foo.c bar.c > foo.patch\\n', 'foo.patch 文件内容如下所示：\\n', '\\n', '点击展开 foo.patch\\n', '编写编译 foo.c 的 MakeFile 文件，具体如下所示：\\n', '\\n', '点击展开 MakeFile\\n', '编写好 MakeFile 之后，直接调用 libcare-patch-make 即可。若 libcare-patch-make 询问选择哪个文件进行打补丁操作，输入原文件名即可，具体如下所示：\\n', '\\n', '# libcare-patch-make --clean -i 0001 foo.patch\\n', 'rm -f foo\\n', 'BUILDING ORIGINAL CODE\\n', '/usr/local/bin/libcare-cc -o foo foo.c\\n', 'INSTALLING ORIGINAL OBJECTS INTO /libcareplus/test/lpmake\\n', 'mkdir $DESTDIR || :\\n', 'cp foo $DESTDIR\\n', 'applying foo.patch...\\n', \"can't find file to patch at input line 3\\n\", 'Perhaps you used the wrong -p or --strip option?\\n', 'The text leading up to this was:\\n', '--------------------------\\n', '|--- foo.c\\t2020-12-10 09:43:04.445375845 +0800\\n', '|+++ bar.c\\t2020-12-10 09:48:36.778379648 +0800\\n', '--------------------------\\n', 'File to patch: foo.c         \\n', 'patching file foo.c\\n', 'BUILDING PATCHED CODE\\n', '/usr/local/bin/libcare-cc -o foo foo.c\\n', 'INSTALLING PATCHED OBJECTS INTO /libcareplus/test/.lpmaketmp/patched\\n', 'mkdir $DESTDIR || :\\n', 'cp foo $DESTDIR\\n', 'MAKING PATCHES\\n', 'Fixing up relocation printf@@GLIBC_2.2.5+fffffffffffffffc\\n', 'Fixing up relocation print_hello+0\\n', 'patch for /libcareplus/test/lpmake/foo is in /libcareplus/test/patchroot/700297b7bc56a11e1d5a6fb564c2a5bc5b282082.kpatch\\n', '执行成功之后，输出显示：热补丁文件位于当前目录的 patchroot 目录下，可执行文件则在 lpmake 目录下。脚本生成的热补丁文件默认是采用 Build ID 作为热补丁文件的文件名。\\n', '\\n', '应用 LibcarePlus 热补丁\\n', '本节以原文件 foo.c 和补丁文件 bar.c 为例，介绍 LibcarePlus 热补丁的应用指导。\\n', '\\n', '前期准备\\n', '应用 LibcarePlus 热补丁之前，需要提前准备好原可执行程序 foo、以及热补丁文件 foo.kpatch。\\n', '\\n', '加载热补丁\\n', '本节介绍应用 LibcarePlus 热补丁的具体流程。\\n', '\\n', '首先在第一个 shell 窗口运行需要打补丁的可执行程序，如下所示：\\n', '\\n', '# ./lpmake/foo\\n', 'Hello world!\\n', 'Hello world!\\n', 'Hello world!\\n', '随后在第二个 shell 窗口运行 libcare-ctl 应用热补丁，命令如下所示：\\n', '\\n', '# libcare-ctl -v patch -p $(pidof foo) ./foo.kpatch\\n', '若此时热补丁应用成功，第二个 shell 窗口会有如下输出：\\n', '\\n', \"1 patch hunk(s) have been successfully applied to PID '10999'\\n\", '而第一个 shell 窗口内运行的目标进程则会出现如下输出：\\n', '\\n', 'Hello world!\\n', 'Hello world!\\n', 'Hello world being patched!\\n', 'Hello world being patched!\\n', '查询补丁\\n', '本节介绍查询LibcarePlus热补丁的具体流程。\\n', '\\n', '在第二个shell窗口执行如下命令：\\n', '\\n', '# libcare-ctl info -p $(pidof foo)\\n', '\\n', '此时若进程存在已经加载的热补丁，则第二个shell窗口会有如下输出：\\n', '\\n', 'Pid:                      551763\\n', 'Target:                   foo\\n', 'Build id:                 df05a25bdadd282812d3ee5f0a460e69038575de\\n', 'Applied patch number:     1\\n', 'Patch id:                 0001\\n', '卸载热补丁\\n', '本节介绍卸载 LibcarePlus 热补丁的具体流程。\\n', '\\n', '在第二个 shell 窗口执行如下命令：\\n', '\\n', '# libcare-ctl unpatch -p $(pidof foo)\\n', '此时若热补丁卸载成功，第二个 shell 窗口会有如下输出：\\n', '\\n', \"1 patch hunk(s) were successfully cancelled from PID '10999'\\n\", '第一个 shell 窗口内运行的目标进程则会出现如下输出：\\n', '\\n', 'Hello world being patched!\\n', 'Hello world being patched!\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_工具使用指南_vmtop.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/vmtop.html", "text_entry": "['工具使用指南\\n', 'vmtop使用指南\\n', 'vmtop使用指南\\n', '概述\\n', 'vmtop 是运行在宿主机host上的用户态工具。使用vmtop可以实时动态地查看虚拟机资源的使用情况，例如CPU占用率、内存占用率、vCPU陷入陷出次数等。因此，可以使用vmtop作为虚拟化问题定位和性能调优的工具。\\n', '\\n', '多架构支持\\n', '当前vmtop支持AArch64和x86_64处理器架构。\\n', '\\n', '显示项说明\\n', '不同处理器架构的操作系统，vmtop的显示项存在差异，这里给出各个显示项的含义及其是否在对应架构呈现。 说明：以下采样差是指指定时间间隔内获取的两次数据的差值。\\n', '\\n', 'AArch64和x86_64架构共有显示项\\n', 'VM/task-name: 虚拟机/进程名称\\n', 'DID: 虚拟机id\\n', 'PID: 虚拟机qemu进程的pid\\n', '%CPU: 进程的CPU占用率\\n', 'EXTsum: kvm exit总次数（采样差）\\n', 'S: 进程状态\\n', 'P: 进程所占用的物理CPU号\\n', '%ST: 被抢占时间与cpu运行时间的比\\n', '%GUE: 虚拟机内部占用时间与CPU运行时间的比\\n', '%HYP: 虚拟化开销占比\\n', '仅AArch64架构的显示项\\n', 'EXThvc: hvc-exit次数（采样差）\\n', 'EXTwfe: wfe-exit次数（采样差）\\n', 'EXTwfi: wfi-exit次数（采样差）\\n', 'EXTmmioU: mmioU-exit次数（采样差）\\n', 'EXTmmioK: mmioK-exit次数（采样差）\\n', 'EXTfp: fp-exit次数（采样差）\\n', 'EXTirq: irq-exit次数（采样差）\\n', 'EXTsys64: sys64 exit次数（采样差）\\n', 'EXTmabt: mem abort exit次数（采样差）\\n', '仅x86_64架构的显示项\\n', 'PFfix: 缺页次数（采样差）\\n', 'PFgu: 向guest OS注入缺页次数（采样差）\\n', 'INvlpg: 冲刷tlb某项次数(tlb其中一项，并不固定)\\n', 'EXTio: io VM-exit次数（采样差）\\n', 'EXTmmio: mmio VM-exit次数（采样差）\\n', 'EXThalt: halt VM-exit次数（采样差）\\n', 'EXTsig: 信号处理引起的VM-exit次数（采样差）\\n', 'EXTirq: 中断引起的VM-exit次数（采样差）\\n', 'EXTnmiW: 处理不可屏蔽中断引起的VM-exit次数（采样差）\\n', 'EXTirqW: interruptwindow机制，开启中断使能时exit，以便注入中断（采样差）\\n', 'IrqIn: 注入irq中断次数（采样差）\\n', 'NmiIn: 注入nmi中断次数（采样差）\\n', 'TLBfl: 冲刷整个tlb次数（采样差）\\n', 'HostReL: 重载主机状态次数（采样差）\\n', 'Hyperv: 模拟Guest操作系统辅助虚拟化调用hypercall的处理次数（采样差）\\n', 'EXTcr: 访问CR寄存器退出次数（采样差）\\n', 'EXTrmsr: 读msr退出次数（采样差）\\n', 'EXTwmsr: 写msr退出次数（采样差）\\n', 'EXTapic: 写apic次数（采样差）\\n', 'EXTeptv: Ept缺页退出次数（采样差）\\n', 'EXTeptm: Ept错误退出次数（采样差）\\n', 'EXTpau: Vcpu暂停退出次数（采样差）\\n', '使用方法\\n', 'vmtop是一款命令行工具，直接以命令行的方式运行 vmtop 即可。 另外，vmtop还提供了不同可选选项，用于查询不同信息。\\n', '\\n', '语法格式\\n', 'vmtop [选项]\\n', '选项说明\\n', '-d: 设置显示刷新的时间间隔，单位：秒\\n', '-H: 显示虚拟机的线程信息\\n', '-n: 设置显示刷新的次数，刷新完成后退出\\n', '-b: Batch模式显示，可以用于重定向到文件\\n', '-h: 显示帮助信息\\n', '-v: 显示版本\\n', '-p: 监控指定id的虚拟机\\n', '快捷键\\n', '在vmtop运行状态下使用的快捷键\\n', '\\n', 'H: 显示或关闭虚拟机线程信息，默认显示该信息\\n', 'up/down: 向上/向下移动显示的虚拟机列表\\n', 'left/right: 向左/向右移动显示的信息，从而显示因屏幕宽度被隐藏的列\\n', 'f: 进入监控项编辑模式，选择要开启的监控项\\n', 'q: 退出vmtop进程\\n', '示例\\n', '在host上直接以命令行的方式运行vmtop\\n', '\\n', 'vmtop\\n', '输出如下:\\n', '\\n', 'vmtop - 2020-09-14 09:54:48 - 1.0\\n', 'Domains: 1 running\\n', '\\n', '  DID  VM/task-name     PID  %CPU    EXThvc    EXTwfe    EXTwfi  EXTmmioU  EXTmmioK     EXTfp    EXTirq  EXTsys64   EXTmabt    EXTsum    S    P   %ST  %GUE  %HYP\\n', '    2       example 4054916  13.0         0         0      1206        10         0       144        62       174         0      1452    S  106   0.0  99.7  16.0\\n', '可以看到，host上只有一台名称为“example”的虚拟机，ID为2，CPU占用率是13.0%，在1秒内的陷入陷出总次数是1452，虚拟机进程占用的物理CPU为106号CPU，虚拟机内部占用时间与CPU运行时间的比是99.7%。\\n', '\\n', '1.显示虚拟机线程信息 按下‘H’后可以显示线程信息：\\n', '\\n', 'vmtop - 2020-09-14 10:11:27 - 1.0\\n', 'Domains: 1 running\\n', '\\n', '  DID  VM/task-name     PID  %CPU    EXThvc    EXTwfe    EXTwfi  EXTmmioU  EXTmmioK     EXTfp    EXTirq  EXTsys64   EXTmabt    EXTsum    S    P   %ST  %GUE  %HYP\\n', '    2       example 4054916  13.0         0         0\\t   1191        17         4       120        76       147         0      1435    S  119   0.0 123.7   4.0\\n', '   |_      qemu-kvm 4054916   0.0         0         0         0         0         0         0         0         0         0         0    S  119   0.0   0.0   0.0\\n', '   |_      qemu-kvm 4054928   0.0         0         0         0         0         0         0         0         0         0         0    S  119   0.0   0.0   0.0\\n', '   |_  signalfd_com 4054929   0.0         0         0         0         0         0         0         0         0         0         0    S  120   0.0   0.0   0.0\\n', '   |_  IO mon_iothr 4054932   0.0         0         0         0         0         0         0         0         0         0         0    S  117   0.0   0.0   0.0\\n', '   |_     CPU 0/KVM 4054933   3.0         0         0       280         6         4        28        19        41         0       350    S  105   0.0  27.9   0.0\\n', '   |_     CPU 1/KVM 4054934   3.0         0         0       260         0         0        16        12        36         0       308    S   31   0.0  20.0   0.0\\n', '   |_     CPU 2/KVM 4054935   3.0         0         0       341         0         0        44        20        26         0       387    R  108   0.0  27.9   4.0\\n', '   |_     CPU 3/KVM 4054936   5.0         0         0       310        11         0        32        25        44         0       390    S  103   0.0  47.9   0.0\\n', '   |_   memory_lock 4054940   0.0         0         0         0         0         0         0         0         0         0         0    S  126   0.0   0.0   0.0\\n', '   |_    vnc_worker 4054944   0.0         0         0         0         0         0         0         0         0         0         0    S  118   0.0   0.0   0.0\\n', '   |_        worker 4143738   0.0         0         0         0         0         0         0         0         0         0         0    S  120   0.0   0.0   0.0\\n', 'example虚拟机有11个线程，其中包括vCPU线程、vnc_worker、IO mon_iotreads等等，每个线程同样会显示详细CPU占用、陷入陷出等信息。\\n', '\\n', '2.选择监控项 按下‘f’进入监控项编辑模式：\\n', '\\n', 'field filter - select which field to be showed\\n', 'Use up/down to navigate, use space to set whether chosen filed to be showed\\n', \"'q' to quit to normal display\\n\", '\\n', ' * DID\\n', ' * VM/task-name\\n', ' * PID\\n', ' * %CPU\\n', ' * EXThvc\\n', ' * EXTwfe\\n', ' * EXTwfi\\n', ' * EXTmmioU\\n', ' * EXTmmioK\\n', ' * EXTfp\\n', ' * EXTirq\\n', ' * EXTsys64\\n', ' * EXTmabt\\n', ' * EXTsum\\n', ' * S\\n', ' * P\\n', ' * %ST\\n', ' * %GUE\\n', ' * %HYP\\n', '当前所有监控项都默认显示，通过up/down键选择，用space键来设置对应显示项是否显示/隐藏，按‘q’键退出。 将%ST、%GUE、%HYP设置为隐藏后，输出如下:\\n', '\\n', 'vmtop - 2020-09-14 10:23:25 - 1.0\\n', 'Domains: 1 running\\n', '\\n', '  DID  VM/task-name     PID  %CPU    EXThvc    EXTwfe    EXTwfi  EXTmmioU  EXTmmioK     EXTfp    EXTirq  EXTsys64   EXTmabt    EXTsum    S    P\\n', '    2       example 4054916  12.0         0         0\\t   1213        14         1       144        68       168         0      1464    S  125\\n', '   |_\\t   qemu-kvm 4054916   0.0         0         0         0         0         0         0         0         0         0         0    S  125\\n', '   |_\\t   qemu-kvm 4054928   0.0         0         0         0         0         0         0         0         0         0         0    S  119\\n', '   |_  signalfd_com 4054929   0.0         0         0         0         0         0         0         0         0         0         0    S  120\\n', '   |_  IO mon_iothr 4054932   0.0         0         0         0         0         0         0         0         0         0         0    S  117\\n', '   |_     CPU 0/KVM 4054933   2.0         0         0       303         6         0        29        10        35         0       354    S   98\\n', '   |_     CPU 1/KVM 4054934   4.0         0         0       279         0         0        39        17        49         0       345    S    1\\n', '   |_     CPU 2/KVM 4054935   3.0         0         0       283         0         0        33        20        40         0       343    S  122\\n', '   |_     CPU 3/KVM 4054936   3.0         0         0       348         8         1        43        21        44         0       422    S  110\\n', '   |_   memory_lock 4054940   0.0         0         0         0         0         0         0         0         0         0         0    S  126\\n', '   |_    vnc_worker 4054944   0.0         0         0         0         0         0         0         0         0         0         0    S  118\\n', '   |_        worker    1794   0.0         0         0         0         0         0         0         0         0         0         0    S  126\\n', '%ST、%GUE、%HYP将不会出现在显示界面上。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理系统资源.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90.html", "text_entry": "['管理系统资源\\n', '总体说明\\n', 'openEuler 虚拟化使用libvirt命令来管理虚拟机的系统资源，如vCPU、虚拟内存资源等。\\n', '\\n', '在开始前：\\n', '\\n', '确保主机上运行了libvirtd守护进程。\\n', '用virsh list –all命令确认虚拟机已经被定义。\\n', '管理虚拟CPU\\n', 'CPU份额\\n', '概述\\n', '虚拟化环境下，同一主机上的多个虚拟机竞争使用物理CPU。为了防止某些虚拟机占用过多的物理CPU资源，影响相同主机上其他虚拟机的性能，需要平衡虚拟机vCPU的调度，避免物理CPU的过度竞争。\\n', '\\n', 'CPU份额表示一个虚拟机竞争物理CPU计算资源的能力大小总和。用户通过调整cpu_shares值能够设置虚拟机抢占物理CPU资源的能力。cpu_shares值无单位，是一个相对值。虚拟机获得的CPU计算资源，是与其他虚拟机的CPU份额，按相对比例，瓜分物理CPU除预留外可用计算资源。通过调整CPU份额来保证虚拟机CPU计算资源服务质量。\\n', '\\n', '操作步骤\\n', '通过修改分配给虚拟机的运行时间的cpu_shares值，来平衡vCPU之间的调度。\\n', '\\n', '查看虚拟机的当前CPU份额：\\n', '\\n', '$ virsh schedinfo <VMInstance>\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 1024\\n', 'vcpu_period    : 100000\\n', 'vcpu_quota     : -1\\n', 'emulator_period: 100000\\n', 'emulator_quota : -1\\n', 'global_period  : 100000\\n', 'global_quota   : -1\\n', 'iothread_period: 100000\\n', 'iothread_quota : -1\\n', '在线修改：修改处于running状态的虚拟机的当前CPU份额，使用带**–live**参数的virsh schedinfo命令：\\n', '\\n', '$ virsh schedinfo <VMInstance> --live cpu_shares=<number>\\n', '比如将正在运行的虚拟机openEulerVM的CPU份额从1024改为2048：\\n', '\\n', '$ virsh schedinfo openEulerVM --live cpu_shares=2048\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 2048\\n', 'vcpu_period    : 100000\\n', 'vcpu_quota     : -1\\n', 'emulator_period: 100000\\n', 'emulator_quota : -1\\n', 'global_period  : 100000\\n', 'global_quota   : -1\\n', 'iothread_period: 100000\\n', 'iothread_quota : -1\\n', '对cpu_shares值的修改立即生效，虚拟机_openEulerVM_能得到的运行时间将是原来的2倍。但是这一修改将在虚拟机关机并重新启动后失效。\\n', '\\n', '持久化修改：在libvirt内部配置中修改虚拟机的CPU份额，使用带**–config**参数的virsh schedinfo命令：\\n', '\\n', '$ virsh schedinfo <VMInstance> --config cpu_shares=<number>\\n', '比如将虚拟机openEulerVM的CPU份额从1024改为2048：\\n', '\\n', '$ virsh schedinfo openEulerVM --config cpu_shares=2048\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 2048\\n', 'vcpu_period    : 0\\n', 'vcpu_quota     : 0\\n', 'emulator_period: 0\\n', 'emulator_quota : 0\\n', 'global_period  : 0\\n', 'global_quota   : 0\\n', 'iothread_period: 0\\n', 'iothread_quota : 0\\n', '对cpu_shares值的修改不会立即生效，在虚拟机openEulerVM下一次启动后才生效，并持久生效。虚拟机openEulerVM能得到的运行时间将是原来的2倍。\\n', '\\n', '绑定QEMU进程至物理CPU\\n', '概述\\n', 'QEMU主进程绑定特性是将QEMU主进程绑定到特定的物理CPU范围内，从而保证了运行不同业务的虚拟机不会干扰到邻位虚拟机。例如在一个典型的云计算场景中，一台物理机上会运行多台虚拟机，而每台虚拟机的业务不同，造成了不同程度的资源占用，为了避免存储IO密集的虚拟机对邻位虚拟机的干扰，需要将不同虚拟机处理IO的存储进程完全隔离，由于QEMU主进程是处理前后端的主要服务进程，故需要实现隔离。\\n', '\\n', '操作步骤\\n', '通过virsh emulatorpin命令可以绑定QEMU主进程到物理CPU。\\n', '\\n', '查看QEMU进程当前绑定的物理CPU范围：\\n', '\\n', '$ virsh emulatorpin openEulerVM\\n', 'emulator: CPU Affinity\\n', '----------------------------------\\n', '       *: 0-63\\n', '这说明虚拟机_openEulerVM_对应的QEMU主进程可以在主机的所有物理CPU上调度。\\n', '\\n', '在线绑定：修改处于running状态的虚拟机对应的QEMU进程的绑定关系，使用带**–live**参数的vcpu emulatorpin命令：\\n', '\\n', '$ virsh emulatorpin openEulerVM --live 2-3\\n', '\\n', '$ virsh emulatorpin openEulerVM\\n', 'emulator: CPU Affinity\\n', '----------------------------------\\n', '       *: 2-3\\n', '以上命令把虚拟机_open__Euler__VM_对应的QEMU进程绑定到物理CPU2、3上，即限制了QEMU进程只在这两个物理CPU上调度。这一绑定关系的调整立即生效，但在虚拟机关机并重新启动后失效。\\n', '\\n', '持久化绑定：在libvirt内部配置中修改虚拟机对应的QEMU进程的绑定关系，使用带**–config**参数的virsh emulatorpin命令：\\n', '\\n', '$ virsh emulatorpin openEulerVM --config 0-3,^1\\n', '\\n', '$ virsh emulatorpin openEulerVM --config\\n', 'emulator: CPU Affinity\\n', '----------------------------------\\n', '       *: 0,2-3\\n', '以上命令把虚拟机_open__Euler__VM_对应的QEMU进程绑定到物理CPU0、2、3上，即限制了QEMU进程只在这三个物理CPU上调度。这一绑定关系的调整不会立即生效，在虚拟机下一次启动后才生效，并持久生效。\\n', '\\n', '调整虚拟CPU绑定关系\\n', '概述\\n', '把虚拟机的vCPU绑定在物理CPU上，即vCPU只在绑定的物理CPU上调度，在特定场景下达到提升虚拟机性能的目的。比如在NUMA系统中，把vCPU绑定在同一个NUMA节点上，可以避免vCPU跨节点访问内存，避免影响虚拟机运行性能。如果未绑定，默认vCPU可在任何物理CPU上调度。具体的绑定策略由用户来决定。\\n', '\\n', '操作步骤\\n', '通过virsh vcpupin命令可以调整vCPU和物理CPU的绑定关系。\\n', '\\n', '查看虚拟机的当前vCPU绑定信息：\\n', '\\n', ' $ virsh vcpupin openEulerVM\\n', ' VCPU   CPU Affinity\\n', '----------------------\\n', ' 0      0-63\\n', ' 1      0-63\\n', ' 2      0-63\\n', ' 3      0-63\\n', '这说明虚拟机_openEulerVM_的所有vCPU可以在主机的所有物理CPU上调度。\\n', '\\n', '在线调整：修改处于running状态的虚拟机的当前vCPU绑定关系，使用带**–live**参数的vcpu vcpupin命令：\\n', '\\n', ' $ virsh vcpupin openEulerVM  --live 0 2-3\\n', '\\n', ' $ virsh vcpupin openEulerVM\\n', ' VCPU   CPU Affinity\\n', '----------------------\\n', ' 0      2-3\\n', ' 1      0-63\\n', ' 2      0-63\\n', ' 3      0-63\\n', '以上命令把虚拟机_open__Euler__VM_的vCPU0绑定到PCPU2、3上，即限制了vCPU0只在这两个物理CPU上调度。这一绑定关系的调整立即生效，但在虚拟机关机并重新启动后失效。\\n', '\\n', '持久化调整：在libvirt内部配置中修改虚拟机的vCPU绑定关系，使用带**–config**参数的virsh vcpupin命令：\\n', '\\n', ' $ virsh vcpupin openEulerVM --config 0 0-3,^1\\n', '\\n', ' $ virsh vcpupin openEulerVM --config\\n', ' VCPU   CPU Affinity\\n', '----------------------\\n', ' 0      0,2-3\\n', ' 1      0-63\\n', ' 2      0-63\\n', ' 3      0-63\\n', '以上命令把虚拟机_open__Euler__VM_的vCPU0绑定到物理CPU0、2、3上，即限制了vCPU0只在这三个物理CPU上调度。这一绑定关系的调整不会立即生效，在虚拟机下一次启动后才生效，并持久生效。\\n', '\\n', 'CPU热插\\n', '概述\\n', '在线增加（热插）虚拟机CPU是指在虚拟机处于运行状态下，为虚拟机热插CPU而不影响虚拟机正常运行的方案。当虚拟机内部业务压力不断增大，会出现所有CPU均处于较高负载的情形。为了不影响虚拟机内的正常业务运行，可以使用CPU热插功能（在不关闭虚拟机情况下增加虚拟机的CPU数目），提升虚拟机的计算能力。\\n', '\\n', '约束限制\\n', '如果处理器为AArch64架构，创建虚拟机时指定的虚拟机芯片组类型(machine)需为virt-4.1或virt更高版本。如果处理器为x86_64架构，创建虚拟机时指定的虚拟机芯片组类型(machine)需为pc-i440fx-1.5或pc更高版本。\\n', '在配置Guest NUMA的场景中，必须把属于同一个socket的vcpu配置在同一vNode中，否则热插CPU后可能导致虚拟机softlockup，进而可能导致虚拟机panic。\\n', '虚拟机在迁移、休眠唤醒、快照过程中均不支持CPU热插。\\n', '虚拟机CPU热插是否自动上线取决于虚拟机操作系统自身逻辑，虚拟化层不保证热插CPU自动上线。\\n', 'CPU热插同时受限于Hypervisor和GuestOS支持的最大CPU数目。\\n', '虚拟机启动、关闭、重启过程中可能出现热插CPU失效的情况，但再次重启会生效。\\n', '热插虚拟机CPU的时候，如果新增CPU数目不是虚拟机CPU拓扑配置项中Cores的整数倍，可能会导致虚拟机内部看到的CPU拓扑是混乱的，建议每次新增的CPU数目为Cores的整数倍。\\n', '若需要热插CPU在线生效且在虚拟机重启后仍有效，virsh setvcpus接口中需要同时传入–config和–live选项， 将热插CPU动作持久化。\\n', '操作步骤\\n', '一、配置虚拟机XML\\n', '\\n', '使用CPU热插功能，需要在创建虚拟机时配置虚拟机当前的CPU数目、虚拟机所支持的最大CPU数目，以及虚拟机芯片组类型（对于AArch64架构，需为virt-4.1及以上版本。对于x86_64架构，需为pc-i440fx-1.5及以上版本）。这里以AArch64架构虚拟机为例，配置模板如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', \"    <vcpu placement='static' current='m'>n</vcpu>\\n\", '    <os>\\n', \"        <type arch='aarch64' machine='virt-4.1'>hvm</type>\\n\", '    </os>\\n', '    ...\\n', '<domain>\\n', ' 说明：\\n', '\\n', 'placement的值必须是static。\\n', 'm为虚拟机当前CPU数目，即虚拟机启动后默认的CPU数目。n为虚拟机支持热插到的最大CPU数目，该值不能超过Hypervisor支持的虚拟机最大CPU规格及GuestOS支持的最大CPU规格。n大于或等于m。\\n', '例如，配一个虚拟机当前CPU数目为4，最大支持的热插CPU上限为64的XML配置为：\\n', '\\n', \"<domain type='kvm'>\\n\", '……\\n', \"    <vcpu placement='static' current='4'>64</vcpu>\\n\", '    <os>\\n', \"        <type arch='aarch64' machine='virt-4.1'>hvm</type>\\n\", '    </os>\\n', '……\\n', '二、热插并上线CPU\\n', '\\n', '如果热插CPU后需要自动上线热插的CPU，可以使用root权限在虚拟机内部创建udev rules文件/etc/udev/rules.d/99-hotplug-cpu.rules，并在其中定义udev规则，内容参考如下：\\n', '\\n', '# automatically online hot-plugged cpu\\n', 'ACTION==\"add\", SUBSYSTEM==\"cpu\", ATTR{online}=\"1\"\\n', ' 说明： 如果没有使用udev rules自动上线热插CPU，可以在热插CPU后，使用root权限，参考如下命令手动上线：\\n', '\\n', 'for i in `grep -l 0 /sys/devices/system/cpu/cpu*/online`\\n', 'do\\n', '   echo 1 > $i\\n', 'done\\n', '利用virsh工具进行虚拟机CPU热插操作。例如给虚拟机openEulerVM热插CPU到6，且在线生效的参考命令如下：\\n', '\\n', 'virsh setvcpus openEulerVM 6 --live\\n', ' 说明： virsh setvcpus 进行虚拟机CPU热插操作的格式如下：\\n', '\\n', 'virsh setvcpus <domain> <count> [--config] [--live]\\n', 'domain: 参数，必填。指定虚拟机名称。\\n', 'count: 参数，必填。指定目标CPU数目，即热插后虚拟机CPU数目。\\n', '–config: 选项，选填。虚拟机下次启动时仍有效。\\n', '–live: 选项，选填。在线生效。\\n', '管理虚拟内存\\n', 'NUMA简介\\n', '传统的多核运算使用SMP（Symmetric Multi-Processor）模式：将多个处理器与一个集中的存储器和I/O总线相连。所有处理器只能访问同一个物理存储器，因此SMP系统也被称为一致存储器访问（UMA）系统。一致性指无论在什么时候，处理器只能为内存的每个数据保持或共享唯一一个数值。很显然，SMP的缺点是可伸缩性有限，因为在存储器和I/O接口达到饱和的时候，增加处理器并不能获得更高的性能。\\n', '\\n', 'NUMA（Non Uniform Memory Access Architecture） 模式是一种分布式存储器访问方式，处理器可以同时访问不同的存储器地址，大幅度提高并行性。 NUMA模式下，处理器被划分成多个“节点”（NODE）， 每个节点分配一块本地存储器空间。所有节点中的处理器都可以访问全部的物理存储器，但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多。\\n', '\\n', '配置Host-NUMA\\n', '为提升虚拟机性能，在虚拟机启动前，用户可以通过虚拟机XML配置文件为虚拟机指定主机的NUMA节点，使虚拟机内存分配在指定的NUMA节点上。本特性一般与vCPU绑定一起使用，从而避免vCPU远端访问内存。\\n', '\\n', '操作步骤\\n', '查看host的NUMA拓扑结构：\\n', '\\n', ' $ numactl -H\\n', 'available: 4 nodes (0-3)\\n', 'node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\\n', 'node 0 size: 31571 MB\\n', 'node 0 free: 17095 MB\\n', 'node 1 cpus: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\\n', 'node 1 size: 32190 MB\\n', 'node 1 free: 28057 MB\\n', 'node 2 cpus: 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\\n', 'node 2 size: 32190 MB\\n', 'node 2 free: 10562 MB\\n', 'node 3 cpus: 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63\\n', 'node 3 size: 32188 MB\\n', 'node 3 free: 272 MB\\n', 'node distances:\\n', 'node   0   1   2   3\\n', '  0:  10  15  20  20\\n', '  1:  15  10  20  20\\n', '  2:  20  20  10  15\\n', '  3:  20  20  15  10\\n', '在虚拟机XML配置文件中添加numatune字段，创建并启动虚拟机。例如使用主机上的NUMA node 0给虚拟机分配内存，配置参数如下：\\n', '\\n', '  <numatune>\\n', '    <memory mode=\"strict\" nodeset=\"0\"/>\\n', '  </numatune>\\n', '假设虚拟机的vCPU也绑定在NODE0的物理CPU上，就可以避免由于vCPU访问远端内存带来的性能下降。\\n', '\\n', ' 说明：\\n', '\\n', '分配给虚拟机的内存不要超过该NUMA节点剩余的可用内存，否则可能导致虚拟机启动失败。\\n', '建议虚拟机内存和vCPU都绑定在同一NUMA节点，避免vCPU访问远端内存造成性能下降。例如将上例中vCPU也绑定在NUMA node 0上。\\n', '配置Guest-NUMA\\n', '虚拟机中运行的很多业务软件都针对NUMA架构进行了性能优化，尤其是对于大规格虚拟机，这种优化的作用更明显。openEuler提供了Guest NUMA特性，在虚拟机内部呈现出NUMA拓扑结构。用户可以通过识别这个结构，对业务软件的性能进行优化，从而保证业务更好的运行。\\n', '\\n', '配置Guest NUMA时可以指定vNode的内存在HOST上的分配位置，实现内存的分块绑定，同时配合vCPU绑定，使vNode上的vCPU和内存在同一个物理NUMA node上。\\n', '\\n', '操作步骤\\n', '在虚拟机的XML配置文件中，配置了Guest NUMA后，就可以在虚拟机内部查看NUMA拓扑结构。<numa>项是Guest NUMA的必配项。\\n', '\\n', '  <cputune>\\n', \"    <vcpupin vcpu='0' cpuset='0-3'/>\\n\", \"    <vcpupin vcpu='1' cpuset='0-3'/>\\n\", \"    <vcpupin vcpu='2' cpuset='16-19'/>\\n\", \"    <vcpupin vcpu='3' cpuset='16-19'/>\\n\", '  </cputune>\\n', '  <numatune>\\n', '    <memnode cellid=\"0\" mode=\"strict\" nodeset=\"0\"/>\\n', '    <memnode cellid=\"1\" mode=\"strict\" nodeset=\"1\"/>\\n', '  </numatune>\\n', '  [...]\\n', '  <cpu>\\n', '    <numa>\\n', \"      <cell id='0' cpus='0-1' memory='2097152'/>\\n\", \"      <cell id='1' cpus='2-3' memory='2097152'/>\\n\", '    </numa>\\n', '  </cpu>\\n', ' 说明：\\n', '\\n', '<numa>项提供虚拟机内部呈现NUMA拓扑功能，“cell id”表示vNode编号，“cpus”表示vCPU编号，“memory”表示对应vNode上的内存大小。\\n', '如果希望通过Guest NUMA提供更好的性能，则需要配置<numatune>和<cputune>，使vCPU和对应的内存分布在同一个物理NUMA NODE上：\\n', '<numatune>中的“cellid”和<numa>中的“cell id”是对应的；“mode”可以配置为“strict”（严格从指定node上申请内存，内存不够则失败）、“preferred”（优先从某一node上申请内存，如果不够则从其他node上申请）、“interleave”（从指定的node上交叉申请内存）；“nodeset”表示指定物理NUMA NODE。\\n', '<cputune>中需要将同一cell id中的vCPU绑定到与memnode相同的物理NUMA NODE上。\\n', '内存热插\\n', '概述\\n', '在虚拟化场景下，虚拟机的内存、CPU、外部设备都是软件模拟呈现的，因此可以在虚拟化底层为虚拟机提供内存在线调整的能力。当前openEuler版本支持在线给虚拟机添加内存，当虚拟机出现物理内存不足又无法关闭虚拟机的时候，可以使用此特性增加虚拟机的物理内存资源。\\n', '\\n', '约束限制\\n', '创建虚拟机的时候，AArch64平台上指定的主板类型(machine)需为virt-4.1或更高virt以上，x86平台上指定的主板类型需要为pc-i440fx-1.5以上版本。\\n', '内存热插特性依赖于Guest NUMA，虚拟机必须配置Guest NUMA，否则无法完成内存热插流程。\\n', '热插内存时候必须指定新增内存所属的Gust NUMA node编号，否则内存热插失败。\\n', '虚拟机内核必须支持内存热插能力，否则虚拟机无法识别新增内存或者无法上线内存。\\n', '配置使用大页的虚拟机，热插内存的容量必须是系统hugepagesz的整数倍，否则会导致热插失败。\\n', '热插内存的大小必须为Guest物理内存块大小block_size_bytes的整数倍，否则无法正常上线。在Guest内部执行lsmem可以获取block_size_bytes大小。\\n', '配置n个virtio-net网卡后，最大可热插次数取值为min{max_slot, 64 - n}，因为要给网卡预留slot。\\n', 'vhost-user设备和内存热插特性互斥。配置了vhost-user设备的虚拟机不支持内存热插；内存热插后，不支持虚拟机热插vhost-user设备。\\n', '如果虚拟机操作系统为Linux系列，请确保初始内存大于等于4GB。\\n', '如果虚拟机操作系统为Windows类型，第一次热插内存必须指定到Guest NUMA node0上，否则热插内存无法被虚拟机识别。\\n', '在直通场景下，由于需要预先分配内存，因此启动和热插内存都比普通虚拟机要慢（尤其是大规格虚拟机），属于正常现象。\\n', '建议虚拟机可用内存与热插内存的比例至少为1:32，即热插32G内存虚拟机至少需要有1G可用内存，如果低于该比例可能会导致虚拟机卡死。\\n', '热插内存是否自动上线取决于虚拟机操作系统自身逻辑，可以手动上线或者配置udev规则自动上线。\\n', '操作步骤\\n', '一、配置虚拟机XML\\n', '\\n', '使用内存热插功能，需要在创建虚拟机时配置可热插内存的最大范围、预留槽位号，并配置Guest NUMA拓扑结构。\\n', '\\n', '例如，为虚拟机配置32GiB初始内存，预留256个槽位号，最大支持1TiB内存上限，2个NUMA node的配置为：\\n', '\\n', \"<domain type='kvm'>\\n\", \"    <memory unit='GiB'>32</memory>\\n\", \"    <maxMemory slots='256' unit='GiB'>1024</maxMemory>\\n\", \"    <cpu mode='host-passthrough' check='none'>\\n\", \"        <topology sockets='2' cores='2' threads='1'/>\\n\", '        <numa>\\n', \"          <cell id='0' cpus='0-1' memory='16' unit='GiB'/>\\n\", \"          <cell id='1' cpus='2-3' memory='16' unit='GiB'/>\\n\", '        </numa>\\n', '     </cpu>\\n', '    ....\\n', ' 说明： 其中： maxMemory字段中slots号表示预留的内存插槽，最大取值为256。 maxMemory表示虚拟机支持的最大物理内存上限。 Guest NUMA配置请参见“配置Guest NUMA”相关章节。\\n', '\\n', '二、热插并上线内存\\n', '\\n', '如果热插内存后需要自动上线热插的内存，可以使用root权限在虚拟机内部创建udev rules文件/etc/udev/rules.d/99-hotplug-memory.rules，并在其中定义udev规则，内容参考如下：\\n', '\\n', '# automatically online hot-plugged memory\\n', 'ACTION==\"add\", SUBSYSTEM==\"memory\", ATTR{state}=\"online\"\\n', '根据需要热插的内存大小和虚拟机Guest NUMA Node创建内存描述xml文件。\\n', '\\n', '例如，热插1GiB内存到NUMA node0上：\\n', '\\n', \"<memory model='dimm'>\\n\", '  <target>\\n', \"  <size unit='MiB'>1024</size>\\n\", '  <node>0</node>\\n', '  </target>\\n', '</memory>\\n', '使用virsh attach-device命令为虚拟机热插内存。其中openEulerVM为虚拟机名称，memory.xml为热插内存的描述文件，–live表示热插内存在线生效，也可以使用–config 将热插内存持久化到虚拟机xml文件中。\\n', '\\n', '# virsh attach-device openEulerVM memory.xml --live\\n', ' 说明： 如果没有使用udev rules自动上线热插内存，也可以使用root权限，参考如下命令手动上线：\\n', '\\n', 'for i in `grep -l offline /sys/devices/system/memory/memory*/state`\\n', 'do\\n', '   echo online > $i\\n', 'done\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理虚拟机.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E6%9C%BA.html", "text_entry": "['管理虚拟机\\n', '管理虚拟机\\n', '虚拟机生命周期\\n', '总体介绍\\n', '管理命令\\n', '示例\\n', '在线修改虚拟机配置\\n', '查询虚拟机信息\\n', '登录虚拟机\\n', '使用VNC密码登录\\n', '配置VNC TLS登录\\n', '虚拟机安全启动\\n', '总体介绍\\n', '安全启动实践\\n', '虚拟机生命周期\\n', '总体介绍\\n', '概述\\n', '为了更好地利用硬件资源，降低成本，用户需要合理地管理虚拟机。本节介绍虚拟机生命周期过程中的基本操作，包括虚拟机创建、使用、删除等，指导用户更好地管理虚拟机。\\n', '\\n', '虚拟机状态\\n', '虚拟机主要有如下几种状态：\\n', '\\n', '未定义（undefined）：虚拟机未定义或未创建，即libvirt认为该虚拟机不存在。\\n', '关闭状态（shut off）：虚拟机已经被定义但未运行，或者虚拟机被终止。\\n', '运行中（running）：虚拟机处于运行状态。\\n', '暂停（paused）：虚拟机运行被挂起，其运行状态被临时保存在内存中，可以恢复到运行状态。\\n', '保存（saved）：与暂停（paused）状态类似，其运行状态被保存在持久性存储介质中，可以恢复到运行状态。\\n', '崩溃（crashed）：通常是由于内部错误导致虚拟机崩溃，不可恢复到运行状态。\\n', '状态转换\\n', '虚拟机不同状态之间可以相关转换，但必须满足一定规则。虚拟机不同状态之间的转换常用规则如图1所示。\\n', '\\n', '图 1 状态转换图\\n', '\\n', '\\n', '虚拟机标识\\n', '在libvirt中，完成创建的虚拟机实例称做一个“domain”，其描述了虚拟机的CPU、内存、网络设备、存储设备等各种资源的配置信息。在同一个主机上，每个domain具有唯一标识，通过虚拟机名称Name、UUID、Id表示，对应含义请参见表1。在虚拟机生命周期期间，可以通过虚拟机标识对特定虚拟机进行操作。\\n', '\\n', '表 1 domain标识说明\\n', '\\n', '\\n', '标识\\n', '\\n', '含义\\n', '\\n', 'Name\\n', '\\n', '虚拟机名称\\n', '\\n', 'UUID\\n', '\\n', '通用唯一识别码\\n', '\\n', 'Id\\n', '\\n', '虚拟机运行标识\\n', '\\n', '说明：\\n', '关闭状态的虚拟机无此标识。\\n', '\\n', ' 说明：\\n', '可通过virsh命令查询虚拟机Id和UUID，操作方法请参见查询虚拟机信息章节内容。\\n', '\\n', '管理命令\\n', '概述\\n', '用户可以使用virsh命令工具管理虚拟机生命周期。本节介绍生命周期相关的命令以指导用户使用。\\n', '\\n', '前提条件\\n', '执行虚拟机生命周期操作之前，需要查询虚拟机状态以确定可以执行对应操作。状态之间的基本转换关系请参见\"总体介绍\"中的\"状态转换\"的内容。\\n', '具备管理员权限。\\n', '准备好虚拟机XML配置文件。\\n', '命令使用说明\\n', '用户可以使用virsh命令管理虚拟机生命周期，命令格式为：\\n', '\\n', 'virsh <operate> <obj> <options>\\n', '各参数含义如下：\\n', '\\n', 'operate：管理虚拟机生命周期对应操作，例如创建、销毁、启动等。\\n', 'obj：命令操作对象，如指定需要操作的虚拟机。\\n', 'options：命令选项，该参数可选。\\n', '虚拟机生命周期管理各命令如表1所示。其中VMInstanse为虚拟机名称、虚拟机ID或者虚拟机UUID，XMLFile是虚拟机XML配置文件，DumpFile为转储文件，请根据实际情况修改。\\n', '\\n', '表 1 虚拟机生命周期管理命令\\n', '\\n', '\\n', '命令\\n', '\\n', '含义\\n', '\\n', 'virsh define <XMLFile>\\n', '\\n', '定义持久化虚拟机，定义完成后虚拟机处于关闭状态，虚拟机被看作为一个domian实例\\n', '\\n', 'virsh create <XMLFile>\\n', '\\n', '创建一个临时性虚拟机，创建完成后虚拟机处于运行状态\\n', '\\n', 'virsh start <VMInstanse>\\n', '\\n', '启动虚拟机\\n', '\\n', 'virsh shutdown <VMInstanse>\\n', '\\n', '关闭虚拟机。启动虚拟机关机流程，若关机失败可使用强制关闭\\n', '\\n', 'virsh destroy <VMInstanse>\\n', '\\n', '强制关闭虚拟机\\n', '\\n', 'virsh reboot <VMInstanse>\\n', '\\n', '重启虚拟机\\n', '\\n', 'virsh save <VMInstanse> <DumpFile>\\n', '\\n', '将虚拟机的运行状态转储到文件中\\n', '\\n', 'virsh restore <DumpFile>\\n', '\\n', '从虚拟机状态转储文件恢复虚拟机\\n', '\\n', 'virsh suspend <VMInstanse>\\n', '\\n', '暂停虚拟机的运行，使虚拟机处于pasued状态\\n', '\\n', 'virsh resume <VMInstanse>\\n', '\\n', '唤醒虚拟机，将处于paused状态的虚拟机恢复到运行状态\\n', '\\n', 'virsh undefine <VMInstanse>\\n', '\\n', '销毁持久性虚拟机，虚拟机生命周期完结，不能继续对该虚拟机继续操作\\n', '\\n', '示例\\n', '本节给出虚拟机生命周期管理相关命令的示例。\\n', '\\n', '创建虚拟机\\n', '\\n', '虚拟机XML配置文件为openEulerVM.xml，命令和回显如下：\\n', '\\n', '# virsh define openEulerVM.xml\\n', 'Domain openEulerVM defined from openEulerVM.xml\\n', '启动虚拟机\\n', '\\n', '启动名称为openEulerVM的虚拟机，命令和回显如下：\\n', '\\n', '# virsh start openEulerVM\\n', 'Domain openEulerVM started\\n', '重启虚拟机\\n', '\\n', '重启名称为openEulerVM的虚拟机，命令和回显如下：\\n', '\\n', '# virsh reboot openEulerVM\\n', 'Domain openEulerVM is being rebooted\\n', '关闭虚拟机\\n', '\\n', '关闭名称为openEulerVM的虚拟机，命令和回显如下：\\n', '\\n', '# virsh shutdown openEulerVM\\n', 'Domain openEulerVM is being shutdown\\n', '销毁虚拟机\\n', '\\n', '若虚拟机启动时未使用nvram文件，销毁虚拟机命令如下：\\n', '\\n', '# virsh undefine <VMInstanse>\\n', '若虚拟机启动时使用了nvram文件，销毁该虚拟机需要指定nvram的处理策略，命令如下：\\n', '\\n', '# virsh undefine <VMInstanse> <strategy>\\n', '其中<strategy>为销毁虚拟机的策略，可取值：\\n', '\\n', 'nvram：销毁虚拟机的同时删除其对应的nvram文件。\\n', '\\n', 'keep-nvram：销毁虚拟机，但保留其对应的nvram文件。\\n', '\\n', '例如，删除虚拟机openEulerVM及其nvram文件，命令和回显如下：\\n', '\\n', '# virsh undefine openEulerVM --nvram\\n', 'Domain openEulerVM has been undefined\\n', '在线修改虚拟机配置\\n', '概述\\n', '虚拟机创建之后用户可以修改虚拟机的配置信息，称为在线修改虚拟机配置。在线修改配置以后，新的虚拟机配置文件会被持久化，并在虚拟机关闭、重新启动后生效。\\n', '\\n', '修改虚拟机配置命令格式如下：\\n', '\\n', 'virsh edit <VMInstance>\\n', 'virsh edit命令通过编辑“domain”对应的XML配置文件，完成对虚拟机配置的更新。virsh edit使用vi程序作为默认的编辑器，可以通过修改环境变量“EDITOR”或“VISUAL”指定编辑器类型。virsh edit默认优先使用“VISUAL”环境变量指定的文本编辑器。\\n', '\\n', '操作步骤\\n', '（可选）设置virsh edit命令的编辑器为vim。\\n', '\\n', '# export VISUAL=vim\\n', '使用virsh edit打开虚拟机名称为openEulerVM对应的XML配置文件。\\n', '\\n', '# virsh edit openEulerVM\\n', '修改虚拟机配置文件。\\n', '\\n', '保存虚拟机配置文件并退出。\\n', '\\n', '关闭虚拟机。\\n', '\\n', '# virsh shutdown openEulerVM\\n', '启动虚拟机使配置修改生效。\\n', '\\n', '# virsh start openEulerVM\\n', '查询虚拟机信息\\n', '概述\\n', '管理员在管理虚拟机的过程中经常需要知道一些虚拟机信息，libvirt提供了一套命令行工具用于查询虚拟机的相关信息。本章介绍相关命令的使用方法，便于管理员来获取虚拟机的各种信息。\\n', '\\n', '前提条件\\n', '查询虚拟机信息需要：\\n', '\\n', 'libvirtd服务处于运行状态。\\n', '\\n', '命令行操作需要拥有管理员权限。\\n', '\\n', '查询主机上的虚拟机信息\\n', '查询主机上处于运行和暂停状态的虚拟机列表。\\n', '\\n', '# virsh list\\n', '例如，下述回显说明当前主机上存在3台虚拟机，其中openEulerVM01、openEulerVM02处于运行状态，openEulerVM03处于暂停状态。\\n', '\\n', ' Id    Name                           State\\n', '----------------------------------------------------\\n', ' 39    openEulerVM01                   running\\n', ' 40    openEulerVM02                   running\\n', ' 69    openEulerVM03                   paused\\n', '查询主机上已经定义的所有虚拟机信息列表。\\n', '\\n', '# virsh list --all\\n', '例如，下述回显说明当前主机上定义了4台虚拟机，其中虚拟机openEulerVM01处于运行状态，openEulerVM02处于暂停状态，openEulerVM03和openEulerVM04处于关机状态。\\n', '\\n', ' Id    Name                           State\\n', '----------------------------------------------------\\n', ' 39    openEulerVM01                  running\\n', ' 69    openEulerVM02                  paused\\n', ' -     openEulerVM03                  shut off\\n', ' -     openEulerVM04                  shut off\\n', '查询虚拟机基本信息\\n', 'Libvirt组件提供了一组查询虚拟机状态信息的命令，包括虚拟机运行状态、设备信息或者调度属性等，使用方法请参见表1。\\n', '\\n', '表 1 查询虚拟机基本信息\\n', '\\n', '\\n', '查询的信息内容\\n', '\\n', '命令行\\n', '\\n', '说明\\n', '\\n', '基本信息\\n', '\\n', 'virsh dominfo <VMInstance>\\n', '\\n', '包括虚拟机ID、UUID，虚拟机规格等信息。\\n', '\\n', '当前状态\\n', '\\n', 'virsh domstate <VMInstance>\\n', '\\n', '可以使用--reason选项查询虚拟机变为当前状态的原因。\\n', '\\n', '调度信息\\n', '\\n', 'virsh schedinfo <VMInstance>\\n', '\\n', '包括vCPU份额等信息。\\n', '\\n', 'vCPU数目\\n', '\\n', 'virsh vcpucount <VMInstance>\\n', '\\n', '查询虚拟机vCPU的个数。\\n', '\\n', '虚拟块设备状态\\n', '\\n', 'virsh domblkstat <VMInstance>\\n', '\\n', '查询块设备名称可以使用virsh domblklist命令。\\n', '\\n', '虚拟网卡状态\\n', '\\n', 'virsh domifstat <VMInstance>\\n', '\\n', '查询网卡名称可以使用virsh domiflist命令。\\n', '\\n', 'I/O线程\\n', '\\n', 'virsh iothreadinfo <VMInstance>\\n', '\\n', '查询虚拟机I/O线程及其CPU亲和性信息。\\n', '\\n', '示例\\n', '使用virsh dominfo查询一个创建好的虚拟机的基本信息，从查询结果可知，虚拟机ID为5，UUID为ab472210-db8c-4018-9b3e-fc5319a769f7，内存大小为8GiB，vCPU数目为4个等。\\n', '\\n', '# virsh dominfo openEulerVM\\n', 'Id:             5\\n', 'Name:           openEulerVM\\n', 'UUID:           ab472210-db8c-4018-9b3e-fc5319a769f7\\n', 'OS Type:        hvm\\n', 'State:          running\\n', 'CPU(s):         4\\n', 'CPU time:       6.8s\\n', 'Max memory:     8388608 KiB\\n', 'Used memory:    8388608 KiB\\n', 'Persistent:     no\\n', 'Autostart:      disable\\n', 'Managed save:   no\\n', 'Security model: none\\n', 'Security DOI:   0\\n', '使用virsh domstate查询虚拟机的当前状态，从查询结果可知，虚拟机openEulerVM当前处于运行状态。\\n', '\\n', '# virsh domstate openEulerVM\\n', 'running\\n', '使用virsh schedinfo查询虚拟机的调度信息，从查询结果可知，虚拟机CPU预留份额为1024。\\n', '\\n', '# virsh schedinfo openEulerVM\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 1024\\n', 'vcpu_period    : 100000\\n', 'vcpu_quota     : -1\\n', 'emulator_period: 100000\\n', 'emulator_quota : -1\\n', 'global_period  : 100000\\n', 'global_quota   : -1\\n', 'iothread_period: 100000\\n', 'iothread_quota : -1\\n', '使用virsh vcpucount查询虚拟机的vCPU数目，从查询结构可知，虚拟机有4个CPU。\\n', '\\n', '# virsh vcpucount openEulerVM\\n', 'maximum      live           4\\n', 'current      live           4\\n', '使用virsh domblklist查询虚拟机磁盘设备信息，从查询结构可知，虚拟机有2个磁盘，sda是qcow2格式的虚拟磁盘，sdb是一个cdrom设备。\\n', '\\n', ' # virsh domblklist openEulerVM\\n', ' Target   Source\\n', '---------------------------------------------------------------------\\n', ' sda      /home/openeuler/vm/openEuler_aarch64.qcow2\\n', ' sdb      /home/openeuler/vm/openEuler-20.09-aarch64-dvd.iso\\n', '使用virsh domiflist查询虚拟机网卡信息，从查询结果可知，虚拟机有1张网卡，对应的后端是vnet0在主机br0网桥上，MAC地址为00:05:fe:d4:f1:cc。\\n', '\\n', '# virsh domiflist openEulerVM\\n', 'Interface  Type       Source     Model       MAC\\n', '-------------------------------------------------------\\n', 'vnet0      bridge     br0        virtio      00:05:fe:d4:f1:cc\\n', '使用virsh iothreadinfo查询虚拟机I/O线程信息，从查询结果可知虚拟机有5个I/O线程，在物理CPU7-10上进行调度。\\n', '\\n', '# virsh iothreadinfo openEulerVM\\n', ' IOThread ID     CPU Affinity\\n', '---------------------------------------------------\\n', ' 3               7-10\\n', ' 4               7-10\\n', ' 5               7-10\\n', ' 1               7-10\\n', ' 2               7-10\\n', '登录虚拟机\\n', '本章介绍使用VNC登录虚拟机的方法。\\n', '\\n', '使用VNC密码登录\\n', '概述\\n', '当虚拟机操作系统安装部署完成之后，用户可以通过VNC协议远程登录虚拟机，从而对虚拟机进行管理操作。\\n', '\\n', '前提条件\\n', '使用RealVNC、TightVNC等客户端登录虚拟机，在登录虚拟机之前需要获取如下信息：\\n', '\\n', '虚拟机所在主机的IP地址。\\n', '\\n', '确保客户端所在的环境可以访问到主机的网络。\\n', '\\n', '虚拟机的VNC侦听端口，该端口一般在客户机启动时自动分配，一般为5900 + x（x为正整数，按照虚拟机启动的顺序递增，且5900对用户不可见）。\\n', '\\n', '如果VNC设置了密码，还需要获取虚拟机的VNC密码。\\n', '\\n', ' 说明：\\n', '为虚拟机VNC配置密码，需要编辑虚拟机XML配置文件，即为graphics元素新增一个passwd属性，属性的值为要配置的密码。例如，将虚拟机的VNC密码配置为n8VfjbFK的XML配置参考如下：\\n', '\\n', \"   <graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0' keymap='en-us' passwd='n8VfjbFK'>  \\n\", \"     <listen type='address' address='0.0.0.0'/>  \\n\", '   </graphics>  \\n', '操作步骤\\n', '查询虚拟机使用的VNC端口号。例如名称为openEulerVM的虚拟机，命令如下：\\n', '\\n', '# virsh vncdisplay openEulerVM\\n', ':3\\n', ' 说明：\\n', '登录 VNC 需要配置防火墙规则，允许 VNC 端口的连接。参考命令如下，其中X为数值“5900 + 端口号” ，例如本例中为5903。\\n', '\\n', 'firewall-cmd --zone=public --add-port=X/tcp  \\n', '打开VncViewer软件，输入主机IP和端口号。格式为“主机IP:端口号”，例如：“10.133.205.53:3”。\\n', '\\n', '单击“确定”输入VNC密码（可选），登录到虚拟机VNC进行操作。\\n', '\\n', '配置VNC-TLS登录\\n', '概述\\n', 'VNC服务端和客户端默认采用明文方式进行数据传输，因此通信内容可能被第三方截获。为了提升安全性，openEuler支持VNC服务端配置TLS模式进行加密认证。TLS（Tansport Layer Security）即传输层安全，可以实现VNC服务端和客户端之间加密通信，从而防止通信内容被第三方截获。\\n', '\\n', ' 说明：\\n', '\\n', '使用TLS加密认证模式需要VNC客户端支持TLS模式（例如TigerVNC），否则无法连接到VNC客户端。\\n', 'TLS加密认证模式配置粒度为主机服务器级别，开启该特性后，主机上正在运行的所有虚拟机对应的VNC客户端都将开启TLS加密认证模式。\\n', '操作步骤\\n', 'VNC开启TLS加密认证模式的操作步骤如下：\\n', '\\n', '登录VNC服务端所在主机登录VNC服务端所在主机，开启或修改服务端配置文件/etc/libvirt/qemu.conf中对应的配置项。相关配置内容如下所示：\\n', '\\n', 'vnc_listen = \"x.x.x.x\"          # \"x.x.x.x\"为VNC的侦听地址，请用户根据实际配置，VNC服务端只允许该地址或地址段范围内的客户端连接请求\\n', 'vnc_tls = 1                     # 配置为1，表示开启VNC TLS支持\\n', 'vnc_tls_x509_cert_dir = \"/etc/pki/libvirt-vnc\"        #指定证书存放的路径为/etc/pki/libvirt-vnc\\n', 'vnc_tls_x509_verify = 1                               #配置为1，表示TLS认证使用X509证书\\n', '为VNC创建证书和私钥文件。此处以GNU TLS为例进行说明。\\n', '\\n', ' 说明：\\n', '使用GNU TLS，请提前安装好gnu-utils软件包。\\n', '\\n', '制作证书颁发机构CA（Certificate Authority）的证书文件。\\n', '\\n', '# certtool --generate-privkey > ca-key.pem\\n', '制作自签名的CA证书公私钥。其中Your organization name为机构名，由用户指定。\\n', '\\n', '# cat > ca.info<<EOF\\n', 'cn = Your organization name \\n', 'ca\\n', 'cert_signing_key\\n', 'EOF\\n', '# certtool --generate-self-signed \\\\\\n', '         --load-privkey ca-key.pem \\\\\\n', '         --template ca.info \\\\\\n', '         --outfile ca-cert.pem\\n', '上述生成文件，ca-cert.pem是生成的CA公钥，ca-key.pem是生成的CA私钥，需要由CA妥善保管防止泄露。\\n', '\\n', '为VNC服务端颁发证书。其中Client Organization Name为实际的服务名称，例如cleint.foo.com，需要用户根据实际指定。\\n', '\\n', '# cat > server.info<<EOF\\n', 'cn = Server Organization Name\\n', 'tls_www_server\\n', 'encryption_key\\n', 'signing_key\\n', 'EOF\\n', '# certtool --generate-privkey > server-key.pem\\n', '# certtool --generate-certificate \\\\\\n', '           --load-ca-certificate ca-cert.pem \\\\\\n', '           --load-ca-privkey ca-key.pem \\\\\\n', '           --load-privkey server-key.pem \\\\\\n', '           --template server.info \\\\\\n', '           --outfile server-cert.pem\\n', '上述生成文件，server-key.pem是VNC服务端的私钥，server-cert.pem是VNC服务端的公钥。\\n', '\\n', '为VNC客户端颁发证书。\\n', '\\n', '# cat > client.info<<EOF\\n', 'cn = Client Organization Name\\n', 'tls_www_client\\n', 'encryption_key\\n', 'signing_key\\n', 'EOF\\n', '# certtool --generate-privkey > client-key.pem\\n', '# certtool --generate-certificate \\\\\\n', '           --load-ca-certificate ca-cert.pem \\\\\\n', '           --load-ca-privkey ca-key.pem \\\\\\n', '           --load-privkey client-key.pem \\\\\\n', '           --template client.info \\\\\\n', '           --outfile client-cert.pem\\n', '上述生成文件，client-key.pem是VNC客户端的私钥，client-cert.pem是VNC客户端的公钥，生成的公私钥对需要拷贝到VNC客户端。\\n', '\\n', '关闭需要被登录的虚拟机，重启VNC服务端所在主机的libvirtd服务。\\n', '\\n', '# systemctl restart libvirtd\\n', '将生成的服务端证书放置到VNC服务端指定目录并将证书的权限改为只允许当前用户读写。\\n', '\\n', '# sudo mkdir -m 750 /etc/pki/libvirt-vnc\\n', '# cp ca-cert.pem /etc/pki/libvirt-vnc/ca-cert.pem\\n', '# cp server-cert.pem /etc/pki/libvirt-vnc/server-cert.pem\\n', '# cp server-key.pem /etc/pki/libvirt-vnc/server-key.pem\\n', '# chmod 0600 /etc/pki/libvirt-vnc/*\\n', '将生成的客户端证书ca-cert.pem，client-cert.pem和client-key.pem拷贝到VNC客户端。配置VNC客户端的TLS证书后即可使用VNC TLS登录。\\n', '\\n', ' 说明：\\n', '\\n', 'VNC客户端证书的配置请参见各客户端对应的使用说明，由用户自行配置。\\n', '登录虚拟机的方式请参见“使用VNC密码登录”。\\n', '虚拟机安全启动\\n', '总体介绍\\n', '概述\\n', '安全启动（Secure Boot）就是利用公私钥对启动部件进行签名和验证。启动过程中，前一个部件验证后一个部件的数字签名，验证通过后，运行后一个部件，验证不通过则启动失败。安全启动的作用是检测设备启动阶段固件（Fireware）以及软件是否被篡改，防止恶意软件侵入和修改。通过安全启动可以保证系统启动过程中各个部件的完整性，防止没有经过认证的部件被加载运行，从而防止对系统及用户数据产生安全威胁。安全启动是在UEFI启动方式上实现的，Legacy启动方式不支持安全启动。根据UEFI规定，主板出厂的时候可以内置一些可靠的公钥。任何想要在这块主板上加载的操作系统或者硬件驱动程序，都必须通过这些公钥的认证。物理机上的安全启动由物理BIOS完成，虚拟机的安全启动通过软件模拟。虚拟机安全启动流程与host安全启动流程一致，都遵循开源UEFI规范。虚拟化平台上的UEFI由edk组件提供，虚拟机启动时qemu将UEFI镜像映射到内存中，为虚拟机模拟固件启动流程，安全启动正是虚拟机启动过程中edk提供的一个安全保护能力，用来保护虚拟机OS内核不被篡改。安全启动验签顺序：UEFI BIOS->shim->grub->vmlinuz（依次验签通过并加载）。\\n', '\\n', '中文\\t英文\\t缩略语\\t中文定义/描述\\n', '安全启动\\tSecure boot\\tSecure boot\\t安全启动就是启动过程中，前一个部件验证后一个部件的数字签名，验证通过后，运行后一个部件，验证不通过就停下来。通过安全启动可以保证系统启动过程中各个部件的完整性。\\n', '平台密钥\\tPlatform key\\tPK\\tOEM厂商所有，必须为 RSA 2048 或更强，PK为平台拥有者和平台固件之间建立可信关系。平台拥有者将PK的公钥部分PKpub注册到平台固件中，平台拥有者可以使用PK的私有部分PKpriv来改变平台的拥有权或者注册KEK密钥。\\n', '密钥交换密钥\\tKey exchange key\\tKEK\\tKEK为平台固件和OS之间创建可信关系。每一个操作系统和与平台固件通信的第三方应用在平台固件中注册KEK密钥的公共部分KEKpub。\\n', '签名数据库\\tDatabase white list\\tDB\\t存储验证shim、grub、vmlinuz等组件的密钥。\\n', '签名吊销数据库\\tDatabase black list\\tDBx\\t存储吊销的密钥。\\n', '功能说明\\n', '本次实现的虚拟机安全启动特性基于edk开源项目。非安全启动模式下，Linux基本流程如下：\\n', '\\n', '图 1 系统启动流程图\\n', '\\n', '\\n', '\\n', '安全启动模式下UEFI BIOS启动后加载的首个组件是系统镜像中的shim，shim与UEFI BIOS进行交互获取存储在UEFI BIOS变量db里面的密钥对grub进行验证，加载grub后同样调用密钥和认证接口对kernel进行验证。Linux启动流程如下：\\n', '\\n', '图 2 安全启动流程图\\n', '\\n', '\\n', '\\n', '从整体处理流程上来看，安全启动特性包含多个关键场景，根据场景分析和系统分解，安全启动特性涉及以下几个子系统：UEFI BIOS校验shim，shim校验grub，grub校验kernel。UEFI BIOS对shim进行验证，验证通过则启动shim，不通过则提示错误，无法启动。Shim需要在镜像编译制作过程中使用私钥进行签名，公钥证书导入UEFI BIOS变量区DB中。Shim启动后验证启动grub，验证通过则启动grub，不通过则提示错误，无法启动。Grub需要在镜像编译制作过程中进行签名，使用和shim一样的公私钥对。Grub启动后检查调用shim注册在UEFI BIOS的认证接口和密钥对kernel进行验证，通过则启动内核，不通过则提示错误，grub需要在镜像编译制作过程中进行签名，使用和shim一样的公私钥对。\\n', '\\n', '约束限制\\n', '在不支持安全启动的UEFI BIOS上运行，对现有功能没有影响，业务无感知。\\n', '安全启动特性依赖UEFI BIOS，必须在UEFI支持此功能的条件下才能发挥作用。\\n', '在UEFI BIOS开启安全启动的情况下，如果相关部件没有签名或签名不正确，则无法正常启动系统。\\n', '在UEFI BIOS关闭安全启动的情况下，启动过程的验证功能都会被关闭。\\n', '安全启动验证链后半段，即shim->grub->kernel引导内核启动这部分的验证链由操作系统镜像实现，若操作系统不支持引导内核安全启动过程，则虚拟机安全启动失败。\\n', '当前不提供x86架构使用nvram文件配置虚拟机安全启动\\n', '安全启动实践\\n', '虚拟机安全启动依赖于UEFI BIOS的实现，UEFI BIOS镜像通过edk rpm包安装，本节以AArch64为例对虚拟机安全启动进行配置。\\n', '\\n', '虚拟机配置\\n', 'edk rpm包中的组件安装于/usr/share/edk2/aarch64目录下，包括QEMU_EFI-pflash.raw和vars-template-pflash.raw。虚拟机启动UEFI BIOS部分xml配置如下：\\n', '\\n', '<os>\\n', \"    <type arch='aarch64' machine='virt'>hvm</type>\\n\", \"    <loader readonly='yes' type='pflash'>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw</loader>\\n\", \"    <nvram template='/usr/share/edk2/aarch64/vars-template-pflash.raw'>/path/to/QEMU-VARS.fd</nvram>\\n\", '</os>\\n', '其中/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw为UEFI BIOS镜像路径。/usr/share/edk2/aarch64/vars-template-pflash.raw为nvram镜像模板路径，/path/to/QEMU-VARS.fd为当前虚拟机nvram镜像文件路径，用于保存UEFI BIOS系统中的环境变量。\\n', '\\n', '证书导入\\n', '虚拟机安全启动时的证书从BIOS界面导入，在证书导入前需要将证书文件导入到虚拟机中。可以通过挂载磁盘的方式将证书文件所在目录挂载到虚拟机中，例如制作包含证书的镜像，并在虚拟机的配置文件xml中配置挂载该镜像：\\n', '\\n', '制作证书文件镜像\\n', '\\n', \"dd of='/path/to/data.img' if='/dev/zero' bs=1M count=64\\n\", 'mkfs.vfat -I /path/to/data.img\\n', 'mkdir /path/to/mnt\\n', 'mount path/to/data.img /path/to/mnt/\\n', 'cp -a /path/to/certificates/* /path/to/mnt/\\n', 'umount /path/to/mnt/\\n', '其中，/path/to/certificates/为证书文件所在路径，/path/to/data.img为证书文件镜像所在路径，/path/to/mnt/为镜像挂载路径。\\n', '\\n', '在虚拟机xml文件中配置挂载该镜像\\n', '\\n', '<devices>\\n', \"\\t<disk type='file' device='disk'>\\n\", \"\\t\\t<driver name='qemu' type='raw' cache='none' io='native'/>\\n\", \"\\t\\t<source file='/path/to/data.img'/>\\n\", \"\\t\\t<target dev='sdc' bus='scsi'/>\\n\", \"\\t\\t<boot order='2'/>\\n\", '\\t\\t<readonly/>\\n', '\\t</disk>\\n', '</devices>\\n', '启动虚拟机，导入PK证书，流程如下(KEK证书，DB证书导入方式相同)：\\n', '\\n', '虚拟机启动后，点击F2进入bios界面\\n', '\\n', '图 1 进入bios界面\\n', '\\n', '\\n', '\\n', '图 2 进入Device Manager\\n', '\\n', '\\n', '\\n', '图 3 进入Custom Secure Boot Options\\n', '\\n', '\\n', '\\n', '图 4 进入PK Options\\n', '\\n', '\\n', '\\n', '图 5 Enroll PK\\n', '\\n', '\\n', '\\n', '在File Explorer界面可以看到很多磁盘目录，其中包括我们通过磁盘挂载的证书文件目录\\n', '\\n', '图 6 File Explorer\\n', '\\n', '\\n', '\\n', '在磁盘目录中选择要导入的PK证书\\n', '\\n', '图 7 进入证书所在磁盘\\n', '\\n', '\\n', '\\n', '图 8 选择Commit Changes and Exit保存导入证书\\n', '\\n', '\\n', '\\n', '导入证书后，UEFI BIOS将证书信息以及安全启动属性写入nvram配置文件/path/to/QEMU-VARS.fd中，虚拟机下一次启动时会从/path/to/QEMU-VARS.fd文件中读取相关配置并初始化证书信息以及安全启动属性，自动导入证书并开启安全启动。同样，我们可以将/path/to/QEMU-VARS.fd作为其他相同配置虚拟机的UEFI BIOS启动配置模板文件，通过修改nvram template字段使其他虚拟机启动时自动导入证书并开启安全启动选项，虚拟机xml配置修改如下：\\n', '\\n', '<os>\\n', \"    <type arch='aarch64' machine='virt'>hvm</type>\\n\", \"    <loader readonly='yes' type='pflash'>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw</loader>\\n\", \"    <nvram template='/path/to/QEMU-VARS.fd'></nvram>\\n\", '</os>\\n', '安全启动观测\\n', '正确配置虚拟机并导入PK、KEK、DB证书后，虚拟机将以安全启动的方式运行。可以通过在虚拟机配置文件xml中配置串口日志文件观测虚拟机是否为安全启动，串口日志文件的配置方式如：\\n', '\\n', \"<serial type='file'>\\n\", \"\\t<source path='/path/to/log_file' append='on'/>\\n\", '</serial>\\n', '虚拟机加载系统镜像成功后，当串口日志文件中出现\"UEFI Secure Boot is enabled\"信息时，表明虚拟机当前为安全启动。\\n', '\\n', '\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理虚拟机可维护性.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7.html", "text_entry": "['管理虚拟机可维护性\\n', '虚拟机NMI Watchdog\\n', '概述\\n', 'NMI Watchdog是一种用来检测Linux出现hardlockup（硬死锁）的机制。通过产生NMI不可屏蔽中断，从而在Linux内核关闭中断的代码区间也能打断代码的执行，进一步检测内核是否出现硬死锁。当前ARM架构不支持原生NMI中断，通过使能基于中断优先级的Pseudo-NMI，将PMI（Performance Monitoring Interrupt）中断配置为NMI中断，实现NMI Watchdog（即PMU Watchdog）。\\n', '\\n', '注意事项\\n', '虚拟机内部OS需要支持Pseudo-NMI并配置相应内核参数\\n', '虚拟机上PMU Watchdog的配置方式与host上相同，无需对xml文件进行其他配置\\n', '同样作为NMI Watchdog，SDEI Watchdog的优先级高于PMU Watchdog，因此要禁用SDEI Watchdog才会使能PMU Watchdog；虚拟机不支持SDEI Watchdog，因此要注意通过配置内核参数将其禁用\\n', '操作步骤\\n', '针对ARM架构虚拟机配置NMI Watchdog的操作步骤如下：\\n', '\\n', '在虚拟机的引导配置文件grub.cfg中添加如下参数：nmi_watchdog=1 pmu_nmi_enable hardlockup_cpu_freq=auto irqchip.gicv3_pseudo_nmi=1 disable_sdei_nmi_watchdog\\n', '检查虚拟机内部PMU Watchdog是否加载成功，如果加载成功，内核dmesg日志打印类似如下内容\\n', '[2.1173222] NMI watchdog: CPU0 freq probed as 2399999942 HZ.\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理设备.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87.html", "text_entry": "['管理设备\\n', '管理设备\\n', '配置虚拟机PCIe控制器\\n', '管理虚拟磁盘\\n', '管理虚拟网卡\\n', '配置虚拟串口\\n', '管理设备直通\\n', 'PCI直通\\n', 'SR-IOV直通\\n', '管理虚拟机USB\\n', '配置USB控制器\\n', '配置USB直通设备\\n', '管理快照\\n', '配置磁盘IO悬挂\\n', '总体介绍\\n', '概述\\n', '应用场景\\n', '注意事项和约束限制\\n', '磁盘IO悬挂配置\\n', 'Qemu命令行配置\\n', 'xml配置方式\\n', '配置虚拟机PCIe控制器\\n', '概述\\n', '虚拟机内部的网卡、磁盘控制器、PCIe直通设备都需要挂接到PCIe Root Port下面，每个Root Port对应一个PCIe插槽。Root Port的下挂设备支持热插拔，但是Root Port本身不支持热插拔，因此需要用户考虑设备热插的需求，规划虚拟机需要预留的最大PCIe Root Port数量，在虚拟机启动之前完成Root Port的静态配置。\\n', '\\n', '配置PCIe Root、PCIe Root Port和PCIe-PCI-Bridge\\n', '虚拟机PCIe控制器通过XML文件进行配置，PCIe Root、PCIe Root Port和PCIe-PCI-Bridge对应XML中的model分别为pcie-root、pcie-root-port、pcie-to-pci-bridge。\\n', '\\n', '简化配置方法\\n', '\\n', '在虚拟机的XML文件中写入以下内容，controller的其他属性由libvirt自动填充：\\n', '\\n', \"  <controller type='pci' index='0' model='pcie-root'/>\\n\", \"  <controller type='pci' index='1' model='pcie-root-port'/>\\n\", \"  <controller type='pci' index='2' model='pcie-to-pci-bridge'/>\\n\", \"  <controller type='pci' index='3' model='pcie-root-port'/>\\n\", \"  <controller type='pci' index='4' model='pcie-root-port'/>\\n\", \"  <controller type='pci' index='5' model='pcie-root-port'/>\\n\", '其中：由于pcie-root和pcie-to-pci-bridge分别占用1个index，因此最终的index等于需要的Root Port数量+1。\\n', '\\n', '完整配制方法\\n', '\\n', '在虚拟机的XML文件中写入以下内容：\\n', '\\n', \"  <controller type='pci' index='0' model='pcie-root'/>\\n\", \"  <controller type='pci' index='1' model='pcie-root-port'>\\n\", \"    <model name='pcie-root-port'/>\\n\", \"    <target chassis='1' port='0x8'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0' multifunction='on'/>\\n\", '  </controller>\\n', \"  <controller type='pci' index='2' model='pcie-to-pci-bridge'>\\n\", \"    <model name='pcie-pci-bridge'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>\\n\", '  </controller>\\n', \"  <controller type='pci' index='3' model='pcie-root-port'>\\n\", \"    <model name='pcie-root-port'/>\\n\", \"    <target chassis='3' port='0x9'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>\\n\", '  </controller>\\n', \"  <controller type='pci' index='3' model='pcie-root-port'>\\n\", '其中：\\n', '\\n', 'Root Port的chassis和port属性必须依次递增，由于中间插入一个PCIe-PCI-Bridge，chassis编号跳过2，但是port编号仍然连续。\\n', 'Root Port的address function的取值范围为0x0~0x7。\\n', '每个slot最多下挂8个function，挂满之后需要递增slot编号。\\n', '由于完整配置方法相对复杂，建议采用简化配置方法。\\n', '\\n', '管理虚拟磁盘\\n', '概述\\n', '虚拟磁盘类型主要包含virtio-blk、virtio-scsi、vhost-scsi等。virtio-blk模拟的是一种block设备，virtio-scsi和vhost-scsi模拟的是一种scsi设备。\\n', '\\n', 'virtio-blk：普通系统盘和数据盘可用，该种配置下虚拟磁盘在虚拟机内部呈现为vd[a-z]或vd[a-z][a-z]。\\n', 'virtio-scsi：普通系统盘和数据盘建议选用，该种配置下虚拟磁盘在虚拟机内部呈现为sd[a-z]或sd[a-z][a-z]。\\n', 'vhost-scsi：对性能要求高的虚拟磁盘建议选用，该种配置下虚拟磁盘在虚拟机内部呈现为sd[a-z]或sd[a-z][a-z]。\\n', '操作步骤\\n', '虚拟磁盘的配置步骤，请参见“虚拟机配置 > 存储设备”。本节以virtio-scsi磁盘为例，介绍挂载和卸载虚拟磁盘的简单方法。\\n', '\\n', '挂载virtio-scsi磁盘：\\n', '\\n', '使用virsh attach-device命令挂载virtio-scsi虚拟磁盘：\\n', '\\n', ' $ virsh attach-device <VMInstance> <attach-device.xml>\\n', '上述命令可以为虚拟机在线挂载磁盘，其中磁盘信息由attach-device.xml文件指定。下面是一个attach-device.xml文件的例子：\\n', '\\n', '### attach-device.xml ###\\n', \"    <disk type='file' device='disk'>\\n\", \"      <driver name='qemu' type='qcow2' cache='none' io='native'/>\\n\", \"      <source file='/path/to/another/qcow2-file'/>\\n\", '      <backingStore/>\\n', \"      <target dev='sdb' bus='scsi'/>\\n\", \"      <address type='drive' controller='0' bus='0' target='1' unit='0'/>\\n\", '    </disk>\\n', '通过上述命令挂载的磁盘，在虚拟机关机重启后失效。如果需要为虚拟机持久化挂载虚拟磁盘，需要使用带–config参数的virsh attach-device命令。\\n', '\\n', '卸载virtio-scsi磁盘：\\n', '\\n', '通过在线挂载的磁盘，如果不需要再使用，可以通过virsh detach命令动态卸载：\\n', '\\n', ' $ virsh detach-device <VMInstance> <detach-device.xml>\\n', '其中，detach-device.xml指定了需要卸载的磁盘的XML信息，与动态挂载时的XML信息保持一致。\\n', '\\n', '管理虚拟网卡\\n', '概述\\n', '虚拟网卡类型主要包含virtio-net、vhost-net、vhost-user等。用户在创建虚拟机后，可能会有挂载或者卸载虚拟网卡的需求。openEuler提供了网卡热插拔的功能，通过网卡热插拔，能够改变网络的吞吐量，提高系统的灵活性和扩展性。\\n', '\\n', '操作步骤\\n', '虚拟网卡的配置步骤，请参见“虚拟机配置 > 网络设备”。本节以vhost-net网卡为例，介绍挂载和卸载虚拟网卡的简单方法。\\n', '\\n', '挂载vhost-net网卡：\\n', '\\n', '使用virsh attach-device命令挂载vhost-net虚拟网卡：\\n', '\\n', ' $ virsh attach-device <VMInstance> <attach-device.xml>\\n', '上述命令可以为虚拟机在线挂载vhost-net网卡，其中网卡信息由attach-device.xml文件指定。下面是一个attach-device.xml文件的例子：\\n', '\\n', '### attach-device.xml ###\\n', \"    <interface type='bridge'>\\n\", \"      <mac address='52:54:00:76:f2:bb'/>\\n\", \"      <source bridge='br0'/>\\n\", \"      <virtualport type='openvswitch'/>\\n\", \"      <model type='virtio'/>\\n\", \"      <driver name='vhost' queues='2'/>\\n\", '    </interface>\\n', '通过上述命令挂载的vhost-net网卡，在虚拟机关机重启后失效。如果需要为虚拟机持久化挂载虚拟网卡，需要使用带–config参数的virsh attach-device命令。\\n', '\\n', '卸载vhost-net网卡：\\n', '\\n', '通过在线挂载的网卡，如果不需要再使用，可以通过virsh detach命令动态卸载：\\n', '\\n', ' $ virsh detach-device <VMInstance> <detach-device.xml>\\n', '其中，detach-device.xml指定了需要卸载虚拟网卡的XML信息，与动态挂载时的XML信息保持一致。\\n', '\\n', '配置虚拟串口\\n', '概述\\n', '在虚拟化环境下，由于管理和业务的需求，虚拟机与宿主机需要互相通信。但在云管理系统复杂的网络架构下，运行在管理平面的服务与运行在业务平面的虚拟机之间，不能简单的进行三层网络互相通信，导致服务部署和信息收集不够快速。因此需要提供虚拟串口，来达到虚拟机与宿主机之间互相通信的目的。 通过在虚拟机的XML配置文件中增加相应串口的配置项，可以实现虚拟机与宿主机之间的互相通信。\\n', '\\n', '操作步骤\\n', 'Linux虚拟机串口控制台，即虚拟机串口连接到宿主机的一个伪终端设备，通过宿主机的设备间接实现对虚拟机的交互式操作。在该场景下串口需配置为pty类型，本节介绍pty型串口的配置方法。\\n', '\\n', '在虚拟机的XML配置文件中\"devices\"节点下添加如下所示的虚拟串口配置项：\\n', '\\n', \"    <serial type='pty'>\\n\", '    </serial>\\n', \"    <console type='pty'>\\n\", \"      <target type='serial'/>\\n\", '    </console>\\n', '使用virsh console命令连接到正在运行的虚拟机的pty串口。\\n', '\\n', '$ virsh console <VMInstance>\\n', '如果要确保没有遗漏任何串口消息，请在启动虚拟机时使用–console选项连接到串口。\\n', '\\n', '$ virsh start --console <VMInstance>\\n', '管理设备直通\\n', '设备直通技术是指将host上的物理设备直接呈现给一台虚拟机，虚拟机可以直接访问该设备资源的一种使用方式。使用设备直通的方式可以让虚拟机获得良好的I/O性能。\\n', '\\n', '当前设备直通使用的是VFIO方式，按照直通的设备类型可以分为PCI直通和SR-IOV直通两种类型。\\n', '\\n', 'PCI直通\\n', 'PCI直通是指将host上的物理PCI设备直接呈现给一台虚拟机，供虚拟机直接访问的一种使用方式。PCI直通使用了vfio设备直通方式，为虚拟机配置PCI直通的xml配置如下：\\n', '\\n', \"<hostdev mode='subsystem' type='pci' managed='yes'>   \\n\", \"    <driver name='vfio'/> \\n\", '    <source>\\n', \"        <address domain='0x0000' bus='0x04' slot='0x10' function='0x01'/>\\n\", '    </source>\\n', \"    <rom bar='off'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>\\n\", '</hostdev>\\n', '表 1 PCI直通设备配置项\\n', '\\n', '\\n', '参数名\\n', '\\n', '说明\\n', '\\n', '取值\\n', '\\n', 'hostdev.source.address.domain\\n', '\\n', 'host OS上的PCI设备的domain号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.source.address.bus\\n', '\\n', 'host OS上的PCI设备bus号。\\n', '\\n', '>=1\\n', '\\n', 'hostdev.source.address.slot\\n', '\\n', 'host OS上的PCI设备的device号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.source.address.function\\n', '\\n', 'host OS上的PCI设备的function号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.driver.name\\n', '\\n', '可选配置项，指定PCI直通的后端驱动。\\n', '\\n', 'vfio（默认配置项）\\n', '\\n', 'hostdev.rom\\n', '\\n', '直通设备的ROM是否呈现给虚拟机。\\n', '\\n', '可以配置为“on/off”，默认为“on”。\\n', '\\n', 'on：表示直通设备的ROM呈现给虚拟机，例如：直通网卡虚拟机需要从该网卡的PXE启动时，可以将该选项配置为“on”，HBA卡直通虚拟机需要从ROM中启动时可以将该选项配置为“on”。\\n', 'off：表示直通设备的ROM不呈现给虚拟机。\\n', 'hostdev.address type\\n', '\\n', 'PCI设备呈现的Guest内bdf号。\\n', '\\n', '[0x03-0x1e](./slot范围)\\n', '\\n', '说明：\\n', '\\n', 'domain为域信息，bus为总线号，slot为插槽号，function为功能\\n', '除了slot插槽号，这里其余均默认为0。\\n', '第一个slot插槽号0x00被系统占用，第二个slot号0x01被IDE控制器和USB控制器占用，第三个slot号0x02被video占用。\\n', '最后一个slot号0x1f被pvchannel占用。\\n', ' 说明：\\n', 'VFIO直通方式的最小直通单位是iommu_group，host根据硬件上的ACS位，来划分iommu_group。同一个iommu_group中的设备只允许直通给同一台虚拟机（一个PCI设备上的若干个function，如果属于同一个iommu_group，只允许直通给一个虚拟机使用）。\\n', '\\n', 'SR-IOV直通\\n', '概述\\n', 'SR-IOV（Single Root I/O Virtualizaiton）是一种基于硬件的虚拟化解决方案，通过SR-IOV技术可以将一个PF（Physical Function）虚拟成多个VF（Virtual Function），每个VF都可以单独被直通给一个虚拟机，极大地提升了硬件资源利用率和虚拟机的I/O性能。一种典型的应用场景就是网卡SR-IOV设备直通，利用SR-IOV技术可以将一个物理网卡（PF）虚拟成多个VF网卡，再把VF直通给虚拟机使用。\\n', '\\n', ' 说明：\\n', '\\n', 'SR-IOV需要物理硬件支持，使用SR-IOV前请确保要直通的硬件设备支持该能力，并且Host侧的设备驱动程序工作在SR-IOV模式下。\\n', '查询网卡具体型号的办法如下：\\n', '例如下述回显，第一列为网卡的PCI号，19e5:1822为网卡的厂商号设备号。\\n', '# lspci | grep Ether  \\n', '05:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '07:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '09:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '0b:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '81:00.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)  \\n', '81:00.1 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)  \\n', '操作方法\\n', '请使用root用户按照如下操作步骤配置SR-IOV直通网卡：\\n', '\\n', '开启网卡的SR-IOV模式。\\n', '\\n', '请确保Guest OS有网卡供应商提供的VF驱动支持，否则Guest OS内VF无法正常工作。\\n', '\\n', '在host OS的BIOS中开启SMMU/IOMMU的支持。不同厂家服务器的开启方式可能不同，请参考各服务器的帮助文档。\\n', '\\n', 'HOST驱动配置，开启SR-IOV的VF模式。这里以Hi1822网卡为例，开启16个VF。\\n', '\\n', 'echo 16 > /sys/class/net/ethX/device/sriov_numvfs\\n', '获取PF和VF的PCI BDF信息。\\n', '\\n', '获取当前单板上的网卡资源列表，参考命令如下：\\n', '\\n', '# lspci | grep Eth\\n', '03:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '04:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '05:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '06:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '7d:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Device a222 (rev 20)\\n', '7d:00.1 Ethernet controller: Huawei Technologies Co., Ltd. Device a222 (rev 20)\\n', '7d:00.2 Ethernet controller: Huawei Technologies Co., Ltd. Device a221 (rev 20)\\n', '7d:00.3 Ethernet controller: Huawei Technologies Co., Ltd. Device a221 (rev 20)\\n', '查看VF的PCI BDF信息，参考命令如下：\\n', '\\n', '# lspci | grep \"Virtual Function\"\\n', '03:00.1 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.2 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.3 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.4 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.5 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.6 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.7 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:01.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:01.1 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:01.2 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '选择一个可用的VF，根据其BDF信息将其配置写入虚拟机的配置文件中。以03:00.1设备为例，对应的bus号是03，slot号是00，function号是1。\\n', '\\n', '识别和管理PF/VF对应关系。\\n', '\\n', '识别PF对应的VF关系，以PF 03.00.0为例：\\n', '\\n', '# ls -l /sys/bus/pci/devices/0000\\\\:03\\\\:00.0/\\n', '可下显示如下的软链接信息，根据信息可以获得其对应的VF编号（virtfnX）和PCI BDF号。\\n', '\\n', '识别VF对应的PF关系，以VF 03:00.1为例：\\n', '\\n', '# ls -l /sys/bus/pci/devices/0000\\\\:03\\\\:00.1/\\n', '可显示下述软连接信息，即可获得其对应PF的PCI BDF号。\\n', '\\n', 'lrwxrwxrwx 1 root root       0 Mar 28 22:44 physfn -> ../0000:03:00.0\\n', '获知PF/VF对应的网卡设备名称，例如：\\n', '\\n', '# ls /sys/bus/pci/devices/0000:03:00.0/net\\n', 'eth0\\n', '设置VF的mac/vlan/qos信息，确保VF在直通之前处于UP状态。以VF 03:00.1为例，假设PF为eth0，VF编号为0。\\n', '\\n', '# ip link set eth0 vf 0 mac 90:E2:BA:21:XX:XX    # 设置mac地址\\n', '# ifconfig eth0 up\\n', '# ip link set eth0 vf 0 rate 100                 # 设置VF出口速率，单位Mbps\\n', '# ip link show eth0                              # 查看mac/vlan/qos信息，确认设置成功\\n', '挂载SR-IOV网卡到虚拟机中。\\n', '\\n', '创建虚拟机时，在虚拟机配置文件中增加SR-IOV直通的配置项。\\n', '\\n', \"<interface type='hostdev' managed='yes'> \\n\", \"    <mac address='fa:16:3e:0a:xx:xx'/>\\n\", '    <source> \\n', \"        <address type='pci' domain='0x0000' bus='0x06' slot='0x11' function='0x6'/>\\n\", '    </source> \\n', '    <vlan>\\n', \"        <tag id='1'/>\\n\", '    </vlan>\\n', '</interface>\\n', '表 1 SR-IOV配置选项说明\\n', '\\n', '\\n', '参数名\\n', '\\n', '说明\\n', '\\n', '取值\\n', '\\n', 'hostdev.managed\\n', '\\n', 'libvirt处理PCI设备的两种模式。\\n', '\\n', 'no：默认配置，表示直通设备由用户自行管理。\\n', '\\n', 'yes：表示直通设备由libvirt管理。SR-IOV直通场景需要配置为yes。\\n', '\\n', 'hostdev.source.address.bus\\n', '\\n', 'host OS上的PCI设备bus号。\\n', '\\n', '>=1\\n', '\\n', 'hostdev.source.address.slot\\n', '\\n', 'host OS上的PCI设备device号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.source.address.function\\n', '\\n', 'host OS上的PCI设备function号。\\n', '\\n', '>=0\\n', '\\n', ' 说明：\\n', '关闭SR-IOV功能。\\n', '在虚拟机使用完毕后（虚拟机关机，所有的VF均没有在使用中的时候），若要关闭SR-IOV功能。执行操作如下：\\n', '这里以Hi1822网卡（eth0对应PF的网口名称）为例：\\n', '\\n', 'echo 0 > /sys/class/net/eth0/device/sriov_numvfs  \\n', 'HPRE加速器SR-IOV直通\\n', '加速器引擎是TaiShan 200服务器基于Kunpeng 920处理器提供的硬件加速解决方案。HPRE加速器用于加速SSL/TLS应用，可以显著降低处理器消耗，提高处理器效率。\\n', '在鲲鹏服务器上，需要把主机Host上的HPRE加速器的VF直通给虚拟机，供虚拟机内部业务使用。\\n', '\\n', '表 1 HPRE加速器说明\\n', '\\n', '项目\\t说明\\n', '设备名称\\tHi1620 on-chip RSA/DH security algorithm accelerator (HPRE engine)\\n', '功能\\t模幂运算、RSA密钥对运算、DH计算、部分大数辅助运算(模幂、模乘、取模、乘法、模逆、素数测试、互质测试)\\n', 'VendorID\\t0x19E5\\n', 'PF DeviceID\\t0xA258\\n', 'VF DeviceID\\t0xA259\\n', '最大VF数量\\t一个HPRE PF最多支持创建63个VF\\n', ' 说明：\\n', '当虚拟机正在使用VF设备时，不允许卸载Host上的驱动，加速器不支持热插拔。\\n', 'VF操作(VFNUMS为0表示关闭VF，hpre_num用来标识具体的加速器设备)：\\n', '\\n', 'echo $VFNUMS > /sys/class/uacce/hisi_hpre-$hpre_num/device/sriov_numvfs\\n', '管理虚拟机USB\\n', '为了方便在虚拟机内部使用USBkey设备、USB海量存储设备等USB设备，openEuler提供了USB设备直通的功能。用户可以通过USB直通和热插拔相关接口给虚拟机配置直通USB设备、或者在虚拟机处于运行的状态下热插/热拔USB设备。\\n', '\\n', '配置USB控制器\\n', '概述\\n', 'USB控制器是为虚拟机上的USB设备提供具体USB功能的虚拟控制器设备，在虚拟机内部使用USB设备必须给虚拟机配置USB控制器。当前openEuler支持如下三种USB控制器：\\n', '\\n', 'UHCI（Universal Host Controller Interface）：通用主机控制器接口，也称为USB 1.1主机控制器规范。\\n', 'EHCI（Enhanced Host Controller）：增强主机控制器接口，也称为USB 2.0主机控制器规范。\\n', 'xHCI（eXtensible Host Controller Interface）：可扩展主机控制器接口，也称为USB 3.0主机控制器规范。\\n', '注意事项\\n', '主机服务器上需存在支持USB 1.1、USB 2.0和USB 3.0标准的USB控制器硬件和模块。\\n', '为虚拟机配置USB控制器时，请按照USB 1.1、USB 2.0到USB 3.0的顺序来配置。\\n', '一个xHCI控制器有8个端口，最多可以挂载4个USB 3.0设备和4个USB 2.0设备。一个EHCI控制器有6个端口，最多可以挂载6个USB2.0设备。一个UHCI控制器有2个端口，最多可以挂载2个USB 1.1设备。\\n', '每台虚拟机最多支持配置一个相同类型的USB控制器。\\n', '不支持热插拔USB控制器。\\n', '若虚拟机没有安装USB 3.0的驱动，可能无法识别xHCI控制器，USB 3.0驱动下载和安装方法请参见对应OS发行商官方说明。\\n', '为了不影响操作系统的兼容性，为虚拟机配置USB接口的tablet设备时，请指定USB控制器bus号为0（默认挂载到USB 1.1控制器上）。\\n', '配置方法\\n', '这里介绍为虚拟机配置USB控制器的配置内容说明。建议同时配置USB 1.1、USB 2.0和USB 3.0，做到同时兼容三种设备。\\n', '\\n', 'USB 1.1控制器（UHCI）的XML配置项为：\\n', '\\n', \"<controller type='usb' index='0' model='piix3-uhci'>\\n\", '</controller>\\n', 'USB 2.0控制器（EHCI）的XML配置为：\\n', '\\n', \"<controller type='usb' index='1' model='ehci'>\\n\", '</controller>\\n', 'USB 3.0控制器（xHCI）的XML配置为：\\n', '\\n', \"<controller type='usb' index='2' model='nec-xhci'>\\n\", '</controller>\\n', '配置USB直通设备\\n', '概述\\n', '当虚拟机配置好USB控制器后，就可以通过设备直通的方式将主机上的物理USB设备挂载到虚拟机内部供虚拟机使用。在虚拟化场景下，除了支持静态配置以外还同时支持USB设备的热插/拔操作，即在虚拟机处于运行状态的时候挂载/卸载USB设备。\\n', '\\n', '注意事项\\n', '一个USB设备只能直通给一台虚拟机使用\\n', '配置了直通USB设备的虚拟机不支持热迁移\\n', '虚拟机配置文件中直通的USB设备不存在时，虚拟机会创建失败\\n', '对一个正在读写的USB存储设备进行强制热拔操作有可能会损坏USB设备内的文件\\n', '配置说明\\n', '这里介绍为虚拟机配置USB设备的配置内容说明。\\n', '\\n', 'USB设备的XML描述：\\n', '\\n', \"<hostdev mode='subsystem' type='usb' managed='yes'>\\n\", '    <source>        \\n', \"        <address bus='m' device='n'/>\\n\", '    </source>\\n', \"    <address type='usb' bus='x' port='y'/>\\n\", '</hostdev>\\n', \"<address bus='m' device='n'/>，其中，m表示该USB设备在主机上的bus地址，n表示device ID编号。\\n\", \"<address type='usb' bus='x' port='y'/> 表示该USB设备要挂载到虚拟机指定的USB控制器。其中x表示控制器ID，与虚拟机所配置的USB控制器index编号相对应，y表示port地址。用户配置直通USB设备的时候需要配置这个字段，确保设备挂载的控制器与预期相符。\\n\", '配置方法\\n', '配置USB直通的步骤如下：\\n', '\\n', '为虚拟机配置USB控制器，配置方法请参见“虚拟机配置 > 配置USB控制器”。\\n', '\\n', '查询主机上的USB设备信息。\\n', '\\n', '通过lsusb命令（需要安装usbutils软件包）查询主机上的USB设备信息，包含bus地址、device地址、设备厂商ID、设备ID和产品描述信息等。例如：\\n', '\\n', '$ lsusb\\n', 'Bus 008 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\\n', 'Bus 007 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\\n', 'Bus 006 Device 002: ID 0bda:0411 Realtek Semiconductor Corp. \\n', 'Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\\n', 'Bus 005 Device 003: ID 136b:0003 STEC \\n', 'Bus 005 Device 002: ID 0bda:5411 Realtek Semiconductor Corp. \\n', 'Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 001 Device 003: ID 12d1:0003 Huawei Technologies Co., Ltd. \\n', 'Bus 001 Device 002: ID 0bda:5411 Realtek Semiconductor Corp. \\n', 'Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\\n', '准备USB设备的XML描述文件，注意在设备热拔之前，请确保USB设备当前不在使用当中，否则可能造成数据丢失。\\n', '\\n', '执行热插、热拔命令。\\n', '\\n', '假设虚拟机名称为openEulerVM，对应的配置文件为usb.xml。\\n', '\\n', '热插USB设备，只对当前运行的虚拟机有效，虚拟机冷重启后需要重新配置。\\n', '\\n', '$ virsh attach-device openEulerVM usb.xml --live\\n', '热插USB设备，持久化该配置，即该虚拟机重启后该设备会自动直通给该虚拟机使用。\\n', '\\n', '$ virsh attach-device openEulerVM usb.xml --config\\n', '热拔USB设备，只对当前运行的虚拟机有效，持久化配置的USB设备在虚拟机重启后USB设备会自动直通给该虚拟机。\\n', '\\n', '$ virsh detach-device openEulerVM usb.xml --live\\n', '热拔USB设备，持久化该配置。\\n', '\\n', '$ virsh detach-device openEulerVM usb.xml --config\\n', '管理快照\\n', '概述\\n', '虚拟机在使用过程中可能由于病毒对系统的破坏、系统文件被误删除或误格式化等原因造成虚拟机系统损坏导致系统无法启动。为了使损坏的系统快速恢复，openEuler提供了存储快照功能。openEuler可以在用户不感知的情况下制作虚拟机在某一时刻的快照（制作通常指需要几秒钟），该快照能帮助用户将磁盘快速恢复到某一时刻的状态，例如系统损坏后能快速恢复系统，从而提升系统可靠性。\\n', '\\n', ' 说明：\\n', '当前存储快照只支持raw、qcow2格式镜像，不支持block块设备。\\n', '\\n', '操作步骤\\n', '制作虚拟机存储快照的操作步骤如下：\\n', '\\n', '登录主机，通过virsh domblklist命令查询虚拟机使用的磁盘。\\n', '\\n', '$ virsh domblklist openEulerVM\\n', '  Target   Source\\n', ' ---------------------------------------------\\n', '  vda      /mnt/openEuler-image.qcow2\\n', '创建虚拟机磁盘快照_openEuler-snapshot1.qcow2_，命令及回显如下：\\n', '\\n', '$ virsh snapshot-create-as --domain openEulerVM --disk-only --diskspec vda,snapshot=external,file=/mnt/openEuler-snapshot1.qcow2 --atomic\\n', 'Domain snapshot 1582605802 created\\n', '磁盘快照查询操作。\\n', '\\n', '$ virsh snapshot-list openEulerVM\\n', ' Name         Creation Time               State\\n', '---------------------------------------------------------\\n', ' 1582605802   2020-02-25 12:43:22 +0800   disk-snapshot\\n', '总体介绍\\n', '概述\\n', '存储故障（比如存储断链）场景下，物理磁盘的IO错误，通过虚拟化层传给虚拟机前端，虚拟机内部收到IO错误，可能导致虚拟机内部的用户文件系统变成read-only状态，需要重启虚拟机或者用户手动恢复，这给用户带来额外的工作量。\\n', '\\n', '这种情况下，虚拟化平台提供了一种磁盘IO悬挂的能力，即当存储故障时，虚拟机IO下发到主机侧时将IO悬挂住，在悬挂时间内不对虚拟机内部返回IO错误，这样虚拟机内部的文件系统就不会因为IO错误而变为只读状态，而是呈现为Hang住；同时虚拟机后端按指定的悬挂间隔对IO进行重试。如果存储故障在悬挂时间内恢复正常，悬挂住的IO即可恢复落盘，虚拟机内部文件系统自动恢复运行，不需要重启虚拟机；如果存储故障在悬挂时间内未能恢复正常，则上报错误给虚拟机内部，通知给用户。\\n', '\\n', '应用场景\\n', '使用可能会发生存储面链路断链的云盘作为虚拟磁盘后端的场景。\\n', '\\n', '注意事项和约束限制\\n', '磁盘IO悬挂仅支持virtio-blk或virtio-scsi类型的虚拟磁盘。\\n', '\\n', '磁盘IO悬挂的虚拟磁盘后端一般为可能会发生存储面链路断链的云盘。\\n', '\\n', '磁盘IO悬挂可对读写IO错误分别使能，同一磁盘的读写IO错误重试间隔和超时时间使用相同配置。\\n', '\\n', '磁盘IO悬挂重试间隔不包含主机侧实际读写IO的开销，即两次IO重试操作实际间隔会大于配置的IO错误重试间隔。\\n', '\\n', '磁盘IO悬挂无法区分IO错误的具体类型（如存储断链、扇区坏道、预留冲突等），只要硬件返回IO错误，都会进行悬挂处理。\\n', '\\n', '磁盘IO悬挂时，虚拟机内部IO不会返回，fdisk等访问磁盘的系统命令会卡住，虚拟机内部依赖该命令返回的业务也会一直卡住。\\n', '\\n', '磁盘IO悬挂时，IO无法正常落盘，可能会导致虚拟机无法优雅关机，需要强制关机。\\n', '\\n', '磁盘IO悬挂时，无法读取磁盘数据，会造成虚拟机无法正常重启，需要先将虚拟机强制关机，等待存储故障恢复后在重新启动虚拟机。\\n', '\\n', '存储故障发生后，虽然存在磁盘IO悬挂，依然解决不了以下问题：\\n', '\\n', '存储相关高级特性执行失败\\n', '\\n', '高级特性包括：虚拟磁盘热插、虚拟磁盘热拔、创建虚拟磁盘、虚拟机启动、虚拟机关机、虚拟机强制关机、虚拟机休眠、虚拟机唤醒、虚拟机存储热迁移、虚拟机存储热迁移取消、虚拟机创建存储快照、虚拟机存储快照合并、查询虚拟机磁盘容量、磁盘在线扩容、插入虚拟光驱、弹出虚拟机光驱。\\n', '\\n', '虚拟机生命周期执行失败\\n', '\\n', '配置了磁盘IO悬挂的虚拟机发起热迁移时，应该在目的端磁盘的XML配置中带上与源端相同的磁盘IO悬挂配置。\\n', '\\n', '磁盘IO悬挂配置\\n', 'Qemu命令行配置\\n', '磁盘IO悬挂功能通过在虚拟磁盘设备上指定werror=retry rerror=retry进行使能，使用retry_interval和retry_timeout进行重试策略的配置。retry_interval为IO错误重试的间隔，配置范围为0-MAX_LONG，单位为毫秒，未配置时使用默认值1000ms；retry_timeout为IO错误重试超时时间，配置范围为0-MAX_LONG，0值表示不会发生超时，单位为毫秒，未配置时使用默认值0。\\n', '\\n', 'virtio-blk磁盘的磁盘IO悬挂配置如下：\\n', '\\n', '-drive file=/path/to/your/storage,format=raw,if=none,id=drive-virtio-disk0,cache=none,aio=native \\\\\\n', '-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x6,\\\\\\n', 'drive=drive-virtio-disk0,id=virtio-disk0,write-cache=on,\\\\\\n', 'werror=retry,rerror=retry,retry_interval=2000,retry_timeout=10000\\n', 'virtio-scsi磁盘的磁盘IO悬挂配置如下：\\n', '\\n', '-drive file=/path/to/your/storage,format=raw,if=none,id=drive-scsi0-0-0-0,cache=none,aio=native \\\\\\n', '-device scsi-hd,bus=scsi0.0,channel=0,scsi-id=0,lun=0,\\\\\\n', 'device_id=drive-scsi0-0-0-0,drive=drive-scsi0-0-0-0,id=scsi0-0-0-0,write-cache=on,\\\\\\n', 'werror=retry,rerror=retry,retry_interval=2000,retry_timeout=10000\\n', 'xml配置方式\\n', \"磁盘IO悬挂功能通过在磁盘xml配置中指定error_policy='retry' rerror_policy='retry'进行使能。主要是配置上retry_interval和retry_timeout的值。retry_interval为IO错误重试的间隔，配置范围为0-MAX_LONG，单位为毫秒，未配置时使用默认值1000ms；retry_timeout为IO错误重试超时时间，配置范围为0-MAX_LONG，0值表示不会发生超时，单位为毫秒，未配置时使用默认值0。\\n\", '\\n', 'virtio-blk磁盘的磁盘IO悬挂xml配置如下：\\n', '\\n', \"<disk type='block' device='disk'>\\n\", \"  <driver name='qemu' type='raw' cache='none' io='native' error_policy='retry' rerror_policy='retry' retry_interval='2000' retry_timeout='10000'/>\\n\", \"  <source dev='/path/to/your/storage'/>\\n\", \"  <target dev='vdb' bus='virtio'/>\\n\", '  <backingStore/>\\n', '</disk>\\n', 'virtio-scsi磁盘的磁盘IO悬挂xml配置如下：\\n', '\\n', \"<disk type='block' device='disk'>\\n\", \"  <driver name='qemu' type='raw' cache='none' io='native' error_policy='retry' rerror_policy='retry' retry_interval='2000' retry_timeout='10000'/>\\n\", \"  <source dev='/path/to/your/storage'/>\\n\", \"  <target dev='sdb' bus='scsi'/>\\n\", '  <backingStore/>\\n', \"  <address type='drive' controller='0' bus='0' target='0' unit='0'/>\\n\", '</disk>\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_Docker容器_安装配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-3.html", "text_entry": "['安装配置\\n', '本章节主要介绍和开源容器Docker安装相关的重要配置。\\n', '\\n', '安装配置\\n', '注意事项\\n', '基本安装配置\\n', '配置daemon参数\\n', 'daemon运行目录配置\\n', 'daemon自带网络配置\\n', 'daemon umask配置\\n', 'daemon启动时间\\n', '关联组件journald\\n', '关联组件firewalld\\n', '关联组件iptables\\n', '关联组件audit\\n', '安全配置seccomp\\n', '禁止修改docker daemon的私有目录\\n', '普通用户大量部署容器场景下的配置注意事项\\n', '存储驱动配置\\n', '配置overlay2存储驱动\\n', '配置devicemapper存储驱动\\n', '强制退出docker相关后台进程的影响\\n', '信号量残留\\n', '网卡残留\\n', '重启容器失败\\n', '服务无法正常重启\\n', '系统掉电影响\\n', '注意事项\\n', 'Docker容器的安装需要使用root权限。\\n', 'docker-engine rpm包与containerd rpm包、runc rpm包、podman rpm包不能同时安装。因为docker-engine rpm包中已经包含Docker运行所需的所有组件，其中包括containerd、runc、docker二进制，且containerd、runc和podman rpm包也分别提供了对应的二进制，所以重复安装时会出现软件包冲突。\\n', '基本安装配置\\n', '配置daemon参数\\n', '可以通过在/etc/docker/daemon.json文件中添加配置项自定义配置参数，相关配置项以及如何使用可以通过dockerd –help查看。配置示例如下：\\n', '\\n', 'cat /etc/docker/daemon.json \\n', '{        \\n', '    \"debug\": true,        \\n', '    \"storage-driver\": \"overlay2\",        \\n', '    \"storage-opts\": [\"overlay2.override_kernel_check=true\"] \\n', '}\\n', 'daemon运行目录配置\\n', '用户需要明白重新指定各种运行目录和文件（包括–graph、–exec-root等），可能会存在目录冲突，或文件属性变换，对应用的正常使用造成影响。\\n', '\\n', ' 须知：\\n', '用户指定的目录或文件应为docker专用，避免冲突导致的文件属性变化带来安全问题。\\n', '\\n', '以–graph为例，当我们使用/new/path/作为daemon新的Root Dir时，如果/new/path/下已经存在文件，且目录或文件名与docker需要使用的目录或文件名冲突（例如： containers、hooks、tmp等目录）时，docker可能会更新原有目录或文件的属性，包括属主、权限等为自己的属主和权限。\\n', ' 须知：\\n', '从docker-17.05开始，–graph参数被标记为Deprecated，用新的参数–data-root替代。\\n', '\\n', 'daemon自带网络配置\\n', 'Docker daemon使用–bip参数指定docker0网桥的网段之后，如果在下一次重启的时候去掉–bip参数，docker0网桥会沿用上一次的–bip配置，即使重启之前已经删除docker0网桥。原因是docker会保存网络配置并在下一次重启的时候默认恢复上一次配置。\\n', 'Docker network create 并发创建网络的时候，可以创建具有相同名字的两个网络。原因是docker network是通过id来区分的，name只是个便于识别的别名而已，不保证唯一性。\\n', 'Docker在桥接bridge网络模式下，Docker容器是通过宿主机上的NAT模式，建立与宿主机之外世界的通信。Docker Daemon在启动一个容器时，每在宿主机上映射一个端口都会启动一个docker-proxy进程来实现访问代理。建议用户在使用这种userland-proxy时，只映射必须的端口，减少docker-proxy进行端口映射所消耗的资源。\\n', 'daemon-umask配置\\n', '容器主进程和exec进程的默认umask为0022，为了满足安全性需求，避免容器受到攻击，修改runc的实现，将默认umask修改为0027。修改后others群组将无法访问新建文件或目录。\\n', '\\n', 'docker启动容器时的默认umask值为0027，可以在dockerd启动时，使用–exec-opt native.umask=normal参数将容器启动时的umask修改为0022。\\n', '\\n', ' 须知：\\n', '如果docker create/run也配置了native.umask参数，则以docker create/run中的配置为准。\\n', '\\n', '详细的配置见docker create和docker run章节的参数说明。\\n', '\\n', 'daemon启动时间\\n', 'Docker服务由systemd管理，systemd对各个服务的启动时间有限制，如果指定时间内docker服务未能成功启动，则可能由以下原因导致：\\n', '\\n', '如果使用devicemapper且为第一次启动，docker daemon需要对该设备做文件系统初始化操作，而该操作会进行大量磁盘IO操作，在磁盘性能不佳或存在大量IO竞争时，很可能会导致docker daemon启动超时。devicemapper设备只需要初始化一次，后续docker daemon启动时不再需要重复初始化。\\n', '如果当前系统资源占用太高，导致系统卡顿，系统所有的操作都会变慢，也可能会出现docker服务启动超时的情况。\\n', 'daemon重启过程中，需要遍历并读取docker工作目录下每一个容器的配置文件、容器init层和可写层的配置，如果当前系统存在过多容器（包含created和exited的容器），并且磁盘读写性能受限，也会出现daemon遍历文件过久导致docker服务启动超时的情况。\\n', '  \\n', '\\n', '出现服务启动超时情况，建议对以下两种情况进行排查调整：\\n', '\\n', '容器编排层定期清理不需要的容器，尤其是exited的容器。\\n', '结合解决方案的性能要求场景，调整编排层的清理周期和docker服务的启动时间。\\n', '关联组件journald\\n', '重启systemd-journald后需要重启docker daemon。journald通过pipe获取docker daemon的日志，如果journald服务重启，会导致该pipe被关闭，docker的日志写入操作便会触发SIGPIPE信号，该错误信号会导致docker daemon crash。由于忽略该信号影响严重，可能导致后续docker daemon的日志无法记录，因此建议用户在重启journald服务或者journald 异常后主动去重启docker daemon，保证docker日志能够被正常记录，避免daemon crash导致的状态异常。\\n', '\\n', '关联组件firewalld\\n', '需要在重启或拉起firewalld之后重启docker服务，保证docker服务在firewalld之后启动。\\n', '\\n', 'firewalld服务启动会清空当前系统的iptables规则，所以在启动docker daemon过程中，重启firewalld可能会导致docker服务插入iptables规则失败，从而导致docker服务启动失败。\\n', 'docker服务启动后重启firewalld服务，或者状态发生了变化（从启动到停止，或者从停止到启动），会导致docker的iptables规则被删除，创建带端口映射的容器失败。\\n', '关联组件iptables\\n', 'docker使用–icc=false选项时，可以限制容器之间互通，但若os自带某些规则，可以造成限制容器之间互通失效，例如：\\n', '\\n', 'Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) \\n', '... \\n', '0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0 \\n', '... \\n', '0     0 DROP       all  --  docker0 docker0  0.0.0.0/0            0.0.0.0/0\\n', '...\\n', '在Chain FORWARD中，DROP上面多出了一条ACCEPT icmp的规则，造成加了–icc=false后，容器之间也能ping通，但容器之间如果使用udp/tcp协议，对端仍然是不可达的。\\n', '\\n', '因此，在容器os中使用docker，如果需要使用–icc=false选项时，建议先在host上清理一下iptables相关的规则。\\n', '\\n', '关联组件audit\\n', 'docker支持配置audit，但不是强制的。例如：\\n', '\\n', '-w /var/lib/docker -k docker \\n', '-w /etc/docker -k docker \\n', '-w /usr/lib/systemd/system/docker.service -k docker \\n', '-w /usr/lib/systemd/system/docker.socket -k docker \\n', '-w /etc/sysconfig/docker -k docker \\n', '-w /usr/bin/docker-containerd -k docker \\n', '-w /usr/bin/docker-runc -k docker \\n', '-w /etc/docker/daemon.json -k docker\\n', '配置docker的audit，好处在于可以记录更多信息便于审计，但从安全角度来看，它对防攻击并没有实质性的作用。另一方面，audit配置会导致严重的效率问题，可能导致系统卡顿，生产环境中请谨慎使用。\\n', '\\n', '下面以“-w /var/lib/docker -k docker”为例，演示docker audit的配置：\\n', '\\n', '[root@localhost signal]# cat /etc/audit/rules.d/audit.rules | grep docker -w /var/lib/docker/  -k docker \\n', '[root@localhost signal]# auditctl -R /etc/audit/rules.d/audit.rules | grep docker \\n', '[root@localhost signal]# auditctl -l | grep docker -w /var/lib/docker/ -p rwxa -k docker\\n', ' 说明：\\n', '-p [r|w|x|a] 和-w一起使用，观察用户对这个目录的读、写、执行或者属性变化（如时间戳变化）。这样的话，在/var/lib/docker目录下的任何文件、目录操作，都会打印日志到audit.log中，从而会有太多的日志往audit.log中记录，会严重地影响auditd， 比如内存、cpu占用等，进而影响os的运行。例如：每次执行\"ls /var/lib/docker/containers\"都会有类似如下日志记录到/var/log/audit/audit.log中。\\n', '\\n', 'type=SYSCALL msg=audit(1517656451.457:8097): arch=c000003e syscall=257 success=yes exit=3 a0=ffffffffffffff9c a1=1b955b0 a2=90800 a3=0 items=1 ppid=17821 pid=1925 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts6 ses=4 comm=\"ls\" exe=\"/usr/bin/ls\" subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key=\"docker\"type=CWD msg=audit(1517656451.457:8097):  cwd=\"/root\"type=PATH msg=audit(1517656451.457:8097): item=0 name=\"/var/lib/docker/containers\" inode=1049112 dev=fd:00 mode=040700 ouid=0 ogid=0 rdev=00:00 obj=unconfined_u:object_r:container_var_lib_t:s0 objtype=NORMAL \\n', '  \\n', '\\n', '安全配置seccomp\\n', '在做容器网络性能测试时发现，Docker相对于原生内核namespace性能有所下降，经分析开启seccomp后，系统调用（如：sendto）不会通过system_call_fastpath进行，而是调用tracesys，这会带来性能大幅下降。因此，建议在有高性能要求的业务的容器场景下关闭seccomp，示例如下：\\n', '\\n', 'docker run -itd --security-opt seccomp=unconfined busybox:latest\\n', '禁止修改docker-daemon的私有目录\\n', '不允许对Docker用的根目录（默认/var/lib/docker）和运行时目录（默认/run/docker）以及其文件作任何修改，包括在该目录下删除文件，添加文件，对目录或者文件做软/硬链接，修改文件的属性/权限，修改文件的内容等，如果确实需要做修改，后果自负。\\n', '\\n', '普通用户大量部署容器场景下的配置注意事项\\n', '普通用户在OS主机上能创建的进程数的上限，例如：可以在系统中创建配置文件“/etc/security/limits.d/20-nproc.conf”限制；类似的，普通用户在容器里也能创建的进程数的上限，由容器镜像中“/etc/security/limits.d/20-nproc.conf”文件对应的值决定，如下所示：\\n', '\\n', 'cat /etc/security/limits.conf \\n', '*       soft    nproc   4096\\n', '当普通用户大量部署容器，导致容器内进程过多资源不够出现报错时，需要把容器镜像“/etc/security/limits.d/20-nproc.conf”文件中如上所示的4096配置值加大。\\n', '\\n', '可配置的最大值请参考内核的最大能力，如下：\\n', '\\n', '[root@localhost ~]# sysctl -a | grep pid_max \\n', 'kernel.pid_max = 32768\\n', '存储驱动配置\\n', '本发行版docker支持overlay2和devicemapper两种存储驱动。由于overlay2较devicemapper而言，拥有更好的性能，建议用户在生产环境中优先考虑。\\n', '\\n', '配置overlay2存储驱动\\n', '配置方法\\n', 'docker默认为使用overlay2存储驱动，也可以通过如下两种方式显示指定。\\n', '\\n', '编辑/etc/docker/daemon.json，通过storage-driver字段显示指定。\\n', '\\n', 'cat /etc/docker/daemon.json\\n', '{\\n', '    \"storage-driver\": \"overlay2\"\\n', '}\\n', '编辑/etc/sysconfig/docker-storage，通过docker deamon启动参数显示指定。\\n', '\\n', 'cat /etc/sysconfig/docker-storage \\n', 'DOCKER_STORAGE_OPTIONS=\"--storage-driver=overlay2\"\\n', '注意事项\\n', '部分容器生命周期管理的操作会报找不到相应的rootfs或者相关的可执行文件。\\n', '\\n', '如果容器的健康检查配置的是执行容器内的可执行文件，也会报错，导致容器的健康检查失败。\\n', '\\n', '如果将overlay2作为graphdriver，在容器中第一次修改镜像中的文件时，若该文件的大小大于系统剩余的空间，修改将会失败。因为即使修改很小，也要把这个文件完整的拷贝到上层，剩余空间不足导致失败。\\n', '\\n', 'overlay2文件系统相比普通文件系统天然存在一些行为差异，归纳如下：\\n', '\\n', '内核版本\\n', '\\n', 'overlay2只兼容原生4.0以上内核，建议配合使用ext4文件系统。\\n', '\\n', 'Copy-UP性能问题\\n', '\\n', '修改lower层文件会触发文件复制到upper层，其中数据块复制和fsync比较耗时。\\n', '\\n', 'rename目录问题\\n', '\\n', '只有源路径和目标路径都在merged层时，才允许rename系统调用，否则rename系统调用会报错-EXDEV。\\n', '\\n', '内核4.10引入了redirect dir特性来修复rename问题，对应内核选项为CONFIG_OVERLAY_FS_REDIRECT_DIR。\\n', '\\n', '在使用overlay2场景下，对文件系统目录进行重命名时，如果系统配置文件/sys/module/overlay/parameters/redirect_dir中配置的特性开关为关闭状态，则会导致使用失败；如果用户要使用相关特性，需要用户手动设置/sys/module/overlay/parameters/redirect_dir为“Y”。\\n', '\\n', 'Hard link break问题\\n', '\\n', '当lower层目录中有多个硬链接，在merged层写入数据会触发Copy-UP，导致硬链接断开。\\n', '内核4.13引入了index feature来修复这个问题，对应内核选项为 CONFIG_OVERLAY_FS_INDEX。注意这个选项没有前向兼容性，不支持热升级。\\n', 'st_dev和st_ino变化\\n', '\\n', '触发Copy-UP之后，用户只能看到merged层中的新文件，inode会变化。虽然attr和xattr可以复制，但st_dev和st_ino具有唯一性，不可复制。这会导致stat和ls查看 到相应的变化。\\n', '\\n', 'fd变化\\n', '\\n', 'Copy-UP之前，以只读模式打开文件得到描述符fd1，Copy-UP之后，打开同名文件得到文件描述符fd2， 二者实际指向不同的文件。向fd2写入的数据不会在fd1中体现。\\n', '\\n', '异常场景\\n', '容器使用配置了overlay2存储驱动的过程中，可能出现挂载点被覆盖的异常情况。例如\\n', '\\n', '  \\n', '\\n', '异常场景-挂载点被覆盖\\n', '挂载关系：在问题容器的挂载点的下面，存在一个/var/lib/docker/overlay2的挂载点：\\n', '\\n', '[root@localhost ~]# mount -l | grep overlay \\n', 'overlay on /var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/merged type overlay (rw,relatime,seclabel,lowerdir=/var/lib/docker/overlay2/l/JL5PZQLNDCIBU3ZOG3LPPDBHIJ:/var/lib/docker/overlay2/l/ELRPYU4JJG4FDPRLZJCZZE4UO6,upperdir=/var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/diff,workdir=/var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785/work) \\n', '/dev/mapper/dm-root on /var/lib/docker/overlay2 type ext4 (rw,relatime,seclabel,data=ordered)\\n', '执行部分docker命令会遇到错误，比如：\\n', '\\n', '[root@localhost ~]# docker rm 1348136d32\\n', 'docker rm: Error response from daemon: driver \"overlay2\" failed to remove root filesystem for 1348136d32: error while removing /var/lib/docker/overlay2/844fd3bca8e616572935808061f009d106a8748dfd29a0a4025645457fa21785: invalid argument\\n', '此时，在主机侧可以发现对应容器的rootfs找不到，但这并不意味着rootfs丢失，只是被/var/lib/docker/overlay2挂载点覆盖，业务仍然可以正常运行，不受影响。修复方案可以参考如下：\\n', '\\n', '修复方案一\\n', '\\n', '确定当前docker所使用graphdriver：\\n', '\\n', 'docker info | grep \"Storage Driver\"\\n', '  \\n', '\\n', '查询当前的挂载点：\\n', '\\n', 'Devicemapper: mount -l | grep devicemapper \\n', 'Overlay2: mount -l | grep overlay2\\n', '输出格式为： A on B type C (D)\\n', '\\n', 'A：块设备名称或overlay\\n', 'B：挂载点\\n', 'C：文件系统类型\\n', 'D：挂载属性\\n', '从下往上逐一umount这些挂载点B。\\n', '\\n', '然后全部docker restart这些容器，或者删除所有容器。\\n', '\\n', '重启docker。\\n', '\\n', 'systemctl restart docker\\n', '修复方案二\\n', '\\n', '业务迁移\\n', '节点重启\\n', '配置devicemapper存储驱动\\n', '用户如果需要使用devicemapper存储驱动，可以通过如下两种方式显示指定。\\n', '\\n', '编辑/etc/docker/daemon.json，通过storage-driver字段显示指定。\\n', '\\n', 'cat /etc/docker/daemon.json\\n', '{\\n', '    \"storage-driver\": \"devicemapper\"\\n', '}\\n', '编辑/etc/sysconfig/docker-storage，通过docker deamon启动参数显示指定。\\n', '\\n', 'cat /etc/sysconfig/docker-storage \\n', 'DOCKER_STORAGE_OPTIONS=\"--storage-driver=devicemapper\"\\n', '注意事项\\n', '使用devicemapper必须使用devicemapper+direct-lvm的方式，配置的方法可以参考 https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#configure-direct-lvm-mode-for-production 。\\n', '\\n', '配置devicemapper时，如果系统上没有足够的空间给thinpool做自动扩容，请禁止自动扩容功能。\\n', '\\n', '禁止把/etc/lvm/profile/docker-thinpool.profile中如下两个值都改成100。\\n', '\\n', 'activation {   \\n', '  thin_pool_autoextend_threshold=80   \\n', '  thin_pool_autoextend_percent=20 \\n', '}\\n', '使用devicemapper时推荐加上–storage-opt dm.use_deferred_deletion=true –storage-opt dm.use_deferred_removal=true。\\n', '\\n', '使用devicemapper时，容器文件系统推荐使用ext4，需要在docker daemon的配置参数中加 上–storage-opt dm.fs=ext4。\\n', '\\n', '当graphdriver为devicemapper时，如果metadata文件损坏且不可恢复，需要人工介入恢复。禁止直接操作或篡改daemon存储devicemapper的元数据。\\n', '\\n', '使用devicemapper lvm时，异常掉电导致的devicemapper thinpool损坏，无法保证thinpool损坏后可以修复，也不能保证数据的完整性，需重建thinpool。\\n', '\\n', 'docker daemon开启了user namespace特性，切换devicemapper存储池时的注意事项\\n', '\\n', '一般启动容器时，deviceset-metadata文件为：/var/lib/docker/devicemapper/metadata/deviceset-metadata。\\n', '使用了user namespace场景下，deviceset-metadata文件使用的是：/var/lib/docker/{userNSUID.GID}/devicemapper/metadata/deviceset-metadata。\\n', '使用devicemapper存储驱动，容器在user namespace场景和普通场景之间切换时，需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空；针对thinpool扩容或者重建的场景下，也同样的需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空，否则docker服务会重启失败。\\n', '信号量残留\\n', '使用devicemapper作为graphdriver时，强制退出强制退出可能导致信号量残留。docker在操作dm的过程中会创建信号量，如果在释放信号量前，daemon被强制退出，可能导致该信号量无法释放，一次强制退出最多泄露一个信号量，泄露概率低。而linux系统有信号量上限限制，当信号量泄露次数达到上线值时将无法创建新的信号量，进而导致docker daemon启动失败。排查方法如下：\\n', '\\n', '首先查看系统上残留的信号量\\n', '\\n', '$ ipcs \\n', '------ Message Queues -------- \\n', 'key        msqid      owner      perms      used-bytes   messages \\n', '------ Shared Memory Segments -------- \\n', 'key        shmid      owner      perms      bytes      nattch     status \\n', '------ Semaphore Arrays -------- \\n', 'key        semid      owner      perms      nsems \\n', '0x0d4d3358 238977024  root       600        1 \\n', '0x0d4d0ec9 270172161  root       600        1 \\n', '0x0d4dc02e 281640962  root       600        1\\n', '接着用dmsetup查看devicemapper创建的信号量，该信号量集合是上一步中查看到的系统信号量的子集\\n', '\\n', '$ dmsetup udevcookies \\n', '最后查看内核信号量设置上限，第四个值就是当前系统的信号量使用上限\\n', '\\n', '$ cat /proc/sys/kernel/sem \\n', '250     32000   32      128\\n', '如果步骤1中残留的信号量数量与步骤3中看到的信号量上限相等，则是达到上限，此时docker daemon无法正常启动。可以使用下述命令增加信号量使用上限值来让docker恢复启动\\n', '\\n', '$ echo 250 32000  32  1024 > /proc/sys/kernel/sem\\n', '也可以手动清理devicemapper残留的信号量（下面是清理一分钟以前申请的dm相关信号量）\\n', '\\n', '$ dmsetup udevcomplete_all 1 \\n', 'This operation will destroy all semaphores older than 1 minutes with keys that have a prefix 3405 (0xd4d). \\n', 'Do you really want to continue? [y/n]: y \\n', '0 semaphores with keys prefixed by 3405 (0xd4d) destroyed. 0 skipped.\\n', '网卡残留\\n', '使用bridge模式启动容器的过程中，强制退出daemon可能导致网卡残留。使用bridge网络模式，当docker创建容器时，会先在host上创建一对veth，然后再把该网卡信息存到数据库中，如果在创建完成，存到docker的数据库之前，daemon被强制退出，那么该网卡无法被docker关联，下次启动也无法删除（docker本身会清理自己数据库中不用的网卡），从而造成网卡残留。\\n', '\\n', '重启容器失败\\n', '容器hook耗时较长，且启动阶段遇到containerd被强制退出，再次执行容器start操作可能失败。容器启动阶段遇到containerd被强制退出，docker start操作直接返回错误；containerd被重新拉起后，上次启动可能仍处于runc create执行阶段（执行用户自定义hook，可能耗时较长），此时再次下发docker start命令启动该容器，可能提示以下错误：\\n', '\\n', 'Error response from daemon: oci runtime error: container with id exists: xxxxxx\\n', '该错误是由runc create一个已经存在（创建中）的容器导致，等第一次start对应的runc操作结束后再次执行docker start便可以成功。\\n', '\\n', '由于hook的执行不受docker控制，这种场景下尝试回收该容器有可能导致containerd进程启动卡死（执行未知hook程序），且问题的风险可控（短期影响当前容器的创建）：\\n', '\\n', '问题出现后等待第一次操作结束可以再次成功启动该容器。\\n', '一般是在容器启动失败后创建新的容器，不复用已经失败的容器。\\n', '综上，该问题暂时作为场景约束。\\n', '\\n', '服务无法正常重启\\n', '短时间内频繁重启docker服务导致该服务无法正常重启。docker系统服务由systemd负责监控，如果docker服务在10s内重启次数超过5次，systemd服务就会监控到该异常行为，因此会禁止docker服务启动。只有等到下一个10s周期开始后，docker服务才能响应重启命令正常重启。\\n', '\\n', '系统掉电影响\\n', '主机意外掉电或系统panic等场景下，由于docker daemon的状态无法及时刷新到磁盘，导致重启后docker daemon状态不正常，可能出现的问题有（包括但不限于）：\\n', '\\n', '掉电前创建的容器，重启后docker ps -a看不到，该问题是因为该容器的状态文件没有刷新到磁盘，从而导致重启后daemon无法获取到该容器的状态（镜像、卷、网络等也可能会有类似问题）。\\n', '掉电前某个文件正处于写入状态，尚未完全写入，重启后daemon重新加载该文件发现文件格式不正常或内容不完整，导致重启加载出错。\\n', '针对掉电时会破坏docker DB的情况，在重启节点时会清理data-root下面的db文件。因此重启前创建的如下信息在重启后会被删除：\\n', 'network，用docker network创建的资源会在重启后清除。\\n', '\\n', 'volume，用 docker volume创建的资源会在重启后删除。\\n', '\\n', '构建缓存，构建缓存信息会在重启后删除。\\n', '\\n', 'containerd保存的元数据，由于启动容器会重建containerd元数据，重启节点会清理containerd中保存的元数据。\\n', '\\n', ' 说明：\\n', '用户若选择采用手动清理恢复环境的方式，可通过配置环境变量“DISABLE_CRASH_FILES_DELETE=true”屏蔽daemon掉电重启时db文件清理功能。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_部署控制面组件.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E9%83%A8%E7%BD%B2%E6%8E%A7%E5%88%B6%E9%9D%A2%E7%BB%84%E4%BB%B6.html", "text_entry": "['部署控制面组件\\n', '准备所有组件的 kubeconfig\\n', 'kube-proxy\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://192.168.122.154:6443 --kubeconfig=kube-proxy.kubeconfig\\n', '$ kubectl config set-credentials system:kube-proxy --client-certificate=/etc/kubernetes/pki/kube-proxy.pem --client-key=/etc/kubernetes/pki/kube-proxy-key.pem --embed-certs=true --kubeconfig=kube-proxy.kubeconfig\\n', '$ kubectl config set-context default --cluster=openeuler-k8s --user=system:kube-proxy --kubeconfig=kube-proxy.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig\\n', 'kube-controller-manager\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://127.0.0.1:6443 --kubeconfig=kube-controller-manager.kubeconfig\\n', '$ kubectl config set-credentials system:kube-controller-manager --client-certificate=/etc/kubernetes/pki/kube-controller-manager.pem --client-key=/etc/kubernetes/pki/kube-controller-manager-key.pem --embed-certs=true --kubeconfig=kube-controller-manager.kubeconfig\\n', '$ kubectl config set-context default --cluster=openeuler-k8s --user=system:kube-controller-manager --kubeconfig=kube-controller-manager.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=kube-controller-manager.kubeconfig\\n', 'kube-scheduler\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://127.0.0.1:6443 --kubeconfig=kube-scheduler.kubeconfig\\n', '$ kubectl config set-credentials system:kube-scheduler --client-certificate=/etc/kubernetes/pki/kube-scheduler.pem --client-key=/etc/kubernetes/pki/kube-scheduler-key.pem --embed-certs=true --kubeconfig=kube-scheduler.kubeconfig\\n', '$ kubectl config set-context default  --cluster=openeuler-k8s --user=system:kube-scheduler --kubeconfig=kube-scheduler.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=kube-scheduler.kubeconfig\\n', 'admin\\n', '$ kubectl config set-cluster openeuler-k8s --certificate-authority=/etc/kubernetes/pki/ca.pem --embed-certs=true --server=https://127.0.0.1:6443 --kubeconfig=admin.kubeconfig\\n', '$ kubectl config set-credentials admin --client-certificate=/etc/kubernetes/pki/admin.pem --client-key=/etc/kubernetes/pki/admin-key.pem --embed-certs=true --kubeconfig=admin.kubeconfig\\n', '$ kubectl config set-context default --cluster=openeuler-k8s --user=admin --kubeconfig=admin.kubeconfig\\n', '$ kubectl config use-context default --kubeconfig=admin.kubeconfig\\n', '获得相关 kubeconfig 配置文件\\n', 'admin.kubeconfig kube-proxy.kubeconfig  kube-controller-manager.kubeconfig  kube-scheduler.kubeconfig\\n', '生成密钥提供者的配置\\n', 'api-server 启动时需要提供一个密钥对--encryption-provider-config=/etc/kubernetes/pki/encryption-config.yaml，本文通过 urandom 生成一个：\\n', '\\n', '$ cat generate.bash\\n', '#!/bin/bash\\n', '\\n', 'ENCRYPTION_KEY=$(head -c 32 /dev/urandom | base64)\\n', '\\n', 'cat > encryption-config.yaml <<EOF\\n', 'kind: EncryptionConfig\\n', 'apiVersion: v1\\n', 'resources:\\n', '  - resources:\\n', '      - secrets\\n', '    providers:\\n', '      - aescbc:\\n', '          keys:\\n', '            - name: key1\\n', '              secret: ${ENCRYPTION_KEY}\\n', '      - identity: {}\\n', 'EOF\\n', '# api-server启动配置 --encryption-provider-config=/etc/kubernetes/pki/encryption-config.yaml\\n', '拷贝证书\\n', '本文把所有组件使用的证书、密钥以及配置统一放到/etc/kubernetes/pki/目录下。\\n', '\\n', '# 准备证书目录\\n', '$ mkdir -p /etc/kubernetes/pki/\\n', '$ ls /etc/kubernetes/pki/\\n', 'admin-key.pem  encryption-config.yaml              kube-proxy-key.pem     kubernetes.pem             service-account-key.pem\\n', 'admin.pem      kube-controller-manager-key.pem     kube-proxy.kubeconfig  kube-scheduler-key.pem     service-account.pem\\n', 'ca-key.pem     kube-controller-manager.kubeconfig  kube-proxy.pem         kube-scheduler.kubeconfig\\n', 'ca.pem         kube-controller-manager.pem         kubernetes-key.pem     kube-scheduler.pem\\n', '部署 admin 角色的 RBAC\\n', '使能 admin role\\n', '\\n', '$ cat admin_cluster_role.yaml\\n', 'apiVersion: rbac.authorization.k8s.io/v1\\n', 'kind: ClusterRole\\n', 'metadata:\\n', '  annotations:\\n', '    rbac.authorization.kubernetes.io/autoupdate: \"true\"\\n', '  labels:\\n', '    kubernetes.io/bootstrapping: rbac-defaults\\n', '  name: system:kube-apiserver-to-kubelet\\n', 'rules:\\n', '  - apiGroups:\\n', '      - \"\"\\n', '    resources:\\n', '      - nodes/proxy\\n', '      - nodes/stats\\n', '      - nodes/log\\n', '      - nodes/spec\\n', '      - nodes/metrics\\n', '    verbs:\\n', '      - \"*\"\\n', '\\n', '# 使能admin role \\n', '$ kubectl apply --kubeconfig admin.kubeconfig -f admin_cluster_role.yaml\\n', '绑定 admin role\\n', '\\n', '$ cat admin_cluster_rolebind.yaml\\n', 'apiVersion: rbac.authorization.k8s.io/v1\\n', 'kind: ClusterRoleBinding\\n', 'metadata:\\n', '  name: system:kube-apiserver\\n', '  namespace: \"\"\\n', 'roleRef:\\n', '  apiGroup: rbac.authorization.k8s.io\\n', '  kind: ClusterRole\\n', '  name: system:kube-apiserver-to-kubelet\\n', 'subjects:\\n', '  - apiGroup: rbac.authorization.k8s.io\\n', '    kind: User\\n', '    name: kubernetes\\n', '\\n', '# 绑定admin role\\n', '$ kubectl apply --kubeconfig admin.kubeconfig -f admin_cluster_rolebind.yaml\\n', '部署 api server 服务\\n', '修改 apiserver 的 etc 配置文件：\\n', '\\n', '$ cat /etc/kubernetes/apiserver\\n', 'KUBE_ADVERTIS_ADDRESS=\"--advertise-address=192.168.122.154\"\\n', 'KUBE_ALLOW_PRIVILEGED=\"--allow-privileged=true\"\\n', 'KUBE_AUTHORIZATION_MODE=\"--authorization-mode=Node,RBAC\"\\n', 'KUBE_ENABLE_ADMISSION_PLUGINS=\"--enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota\"\\n', 'KUBE_SECURE_PORT=\"--secure-port=6443\"\\n', 'KUBE_ENABLE_BOOTSTRAP_TOKEN_AUTH=\"--enable-bootstrap-token-auth=true\"\\n', 'KUBE_ETCD_CAFILE=\"--etcd-cafile=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_ETCD_CERTFILE=\"--etcd-certfile=/etc/kubernetes/pki/kubernetes.pem\"\\n', 'KUBE_ETCD_KEYFILE=\"--etcd-keyfile=/etc/kubernetes/pki/kubernetes-key.pem\"\\n', 'KUBE_ETCD_SERVERS=\"--etcd-servers=https://192.168.122.154:2379,https://192.168.122.155:2379,https://192.168.122.156:2379\"\\n', 'KUBE_CLIENT_CA_FILE=\"--client-ca-file=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_KUBELET_CERT_AUTH=\"--kubelet-certificate-authority=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_KUBELET_CLIENT_CERT=\"--kubelet-client-certificate=/etc/kubernetes/pki/kubernetes.pem\"\\n', 'KUBE_KUBELET_CLIENT_KEY=\"--kubelet-client-key=/etc/kubernetes/pki/kubernetes-key.pem\"\\n', 'KUBE_KUBELET_HTTPS=\"--kubelet-https=true\"\\n', 'KUBE_PROXY_CLIENT_CERT_FILE=\"--proxy-client-cert-file=/etc/kubernetes/pki/kube-proxy.pem\"\\n', 'KUBE_PROXY_CLIENT_KEY_FILE=\"--proxy-client-key-file=/etc/kubernetes/pki/kube-proxy-key.pem\"\\n', 'KUBE_TLS_CERT_FILE=\"--tls-cert-file=/etc/kubernetes/pki/kubernetes.pem\"\\n', 'KUBE_TLS_PRIVATE_KEY_FILE=\"--tls-private-key-file=/etc/kubernetes/pki/kubernetes-key.pem\"\\n', 'KUBE_SERVICE_CLUSTER_IP_RANGE=\"--service-cluster-ip-range=10.32.0.0/16\"\\n', 'KUBE_SERVICE_ACCOUNT_ISSUER=\"--service-account-issuer=https://kubernetes.default.svc.cluster.local\"\\n', 'KUBE_SERVICE_ACCOUNT_KEY_FILE=\"--service-account-key-file=/etc/kubernetes/pki/service-account.pem\"\\n', 'KUBE_SERVICE_ACCOUNT_SIGN_KEY_FILE=\"--service-account-signing-key-file=/etc/kubernetes/pki/service-account-key.pem\"\\n', 'KUBE_SERVICE_NODE_PORT_RANGE=\"--service-node-port-range=30000-32767\"\\n', 'KUB_ENCRYPTION_PROVIDER_CONF=\"--encryption-provider-config=/etc/kubernetes/pki/encryption-config.yaml\"\\n', 'KUBE_REQUEST_HEADER_ALLOWED_NAME=\"--requestheader-allowed-names=front-proxy-client\"\\n', 'KUBE_REQUEST_HEADER_EXTRA_HEADER_PREF=\"--requestheader-extra-headers-prefix=X-Remote-Extra-\"\\n', 'KUBE_REQUEST_HEADER_GROUP_HEADER=\"--requestheader-group-headers=X-Remote-Group\"\\n', 'KUBE_REQUEST_HEADER_USERNAME_HEADER=\"--requestheader-username-headers=X-Remote-User\"\\n', 'KUBE_API_ARGS=\"\"\\n', '所有apiserver的配置都/etc/kubernetes/config文件中定义，然后在后面的service文件中直接使用即可。\\n', '\\n', '大部分配置都是比较固定的，部分需要注意：\\n', '\\n', '--service-cluster-ip-range该地址需要和后面的设置的clusterDNS需要一致；\\n', '编写 apiserver 的 systemd 配置\\n', 'cat /usr/lib/systemd/system/kube-apiserver.service\\n', '[Unit]\\n', 'Description=Kubernetes API Server\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-apiserver/\\n', 'After=network.target\\n', 'After=etcd.service\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/apiserver\\n', 'ExecStart=/usr/bin/kube-apiserver \\\\\\n', '\\t    $KUBE_ADVERTIS_ADDRESS \\\\\\n', '\\t    $KUBE_ALLOW_PRIVILEGED \\\\\\n', '\\t    $KUBE_AUTHORIZATION_MODE \\\\\\n', '\\t    $KUBE_ENABLE_ADMISSION_PLUGINS \\\\\\n', ' \\t    $KUBE_SECURE_PORT \\\\\\n', '\\t    $KUBE_ENABLE_BOOTSTRAP_TOKEN_AUTH \\\\\\n', '\\t    $KUBE_ETCD_CAFILE \\\\\\n', '\\t    $KUBE_ETCD_CERTFILE \\\\\\n', '\\t    $KUBE_ETCD_KEYFILE \\\\\\n', '\\t    $KUBE_ETCD_SERVERS \\\\\\n', '\\t    $KUBE_CLIENT_CA_FILE \\\\\\n', '\\t    $KUBE_KUBELET_CERT_AUTH \\\\\\n', '\\t    $KUBE_KUBELET_CLIENT_CERT \\\\\\n', '\\t    $KUBE_KUBELET_CLIENT_KEY \\\\\\n', '\\t    $KUBE_PROXY_CLIENT_CERT_FILE \\\\\\n', '\\t    $KUBE_PROXY_CLIENT_KEY_FILE \\\\\\n', '\\t    $KUBE_TLS_CERT_FILE \\\\\\n', '\\t    $KUBE_TLS_PRIVATE_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_CLUSTER_IP_RANGE \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_ISSUER \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_SIGN_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_NODE_PORT_RANGE \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    $KUBE_API_PORT \\\\\\n', '\\t    $KUBELET_PORT \\\\\\n', '\\t    $KUBE_ALLOW_PRIV \\\\\\n', '\\t    $KUBE_SERVICE_ADDRESSES \\\\\\n', '\\t    $KUBE_ADMISSION_CONTROL \\\\\\n', '\\t    $KUB_ENCRYPTION_PROVIDER_CONF \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_ALLOWED_NAME \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_EXTRA_HEADER_PREF \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_GROUP_HEADER \\\\\\n', '\\t    $KUBE_REQUEST_HEADER_USERNAME_HEADER \\\\\\n', '\\t    $KUBE_API_ARGS\\n', 'Restart=on-failure\\n', 'Type=notify\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '部署 controller-manager 服务\\n', '修改 controller-manager 配置文件：\\n', '\\n', '$ cat /etc/kubernetes/controller-manager\\n', 'KUBE_BIND_ADDRESS=\"--bind-address=127.0.0.1\"\\n', 'KUBE_CLUSTER_CIDR=\"--cluster-cidr=10.200.0.0/16\"\\n', 'KUBE_CLUSTER_NAME=\"--cluster-name=kubernetes\"\\n', 'KUBE_CLUSTER_SIGNING_CERT_FILE=\"--cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_CLUSTER_SIGNING_KEY_FILE=\"--cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem\"\\n', 'KUBE_KUBECONFIG=\"--kubeconfig=/etc/kubernetes/pki/kube-controller-manager.kubeconfig\"\\n', 'KUBE_LEADER_ELECT=\"--leader-elect=true\"\\n', 'KUBE_ROOT_CA_FILE=\"--root-ca-file=/etc/kubernetes/pki/ca.pem\"\\n', 'KUBE_SERVICE_ACCOUNT_PRIVATE_KEY_FILE=\"--service-account-private-key-file=/etc/kubernetes/pki/service-account-key.pem\"\\n', 'KUBE_SERVICE_CLUSTER_IP_RANGE=\"--service-cluster-ip-range=10.32.0.0/24\"\\n', 'KUBE_USE_SERVICE_ACCOUNT_CRED=\"--use-service-account-credentials=true\"\\n', 'KUBE_CONTROLLER_MANAGER_ARGS=\"--v=2\"\\n', '编写 controller-manager 的 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kube-controller-manager.service\\n', '[Unit]\\n', 'Description=Kubernetes Controller Manager\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-controller-manager/\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/controller-manager\\n', 'ExecStart=/usr/bin/kube-controller-manager \\\\\\n', '\\t    $KUBE_BIND_ADDRESS \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    $KUBE_CLUSTER_CIDR \\\\\\n', '\\t    $KUBE_CLUSTER_NAME \\\\\\n', '\\t    $KUBE_CLUSTER_SIGNING_CERT_FILE \\\\\\n', '\\t    $KUBE_CLUSTER_SIGNING_KEY_FILE \\\\\\n', '\\t    $KUBE_KUBECONFIG \\\\\\n', '\\t    $KUBE_LEADER_ELECT \\\\\\n', '\\t    $KUBE_ROOT_CA_FILE \\\\\\n', '\\t    $KUBE_SERVICE_ACCOUNT_PRIVATE_KEY_FILE \\\\\\n', '\\t    $KUBE_SERVICE_CLUSTER_IP_RANGE \\\\\\n', '\\t    $KUBE_USE_SERVICE_ACCOUNT_CRED \\\\\\n', '\\t    $KUBE_CONTROLLER_MANAGER_ARGS\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '部署 scheduler 服务\\n', '修改 scheduler 配置文件：\\n', '\\n', '$ cat /etc/kubernetes/scheduler\\n', 'KUBE_CONFIG=\"--kubeconfig=/etc/kubernetes/pki/kube-scheduler.kubeconfig\"\\n', 'KUBE_AUTHENTICATION_KUBE_CONF=\"--authentication-kubeconfig=/etc/kubernetes/pki/kube-scheduler.kubeconfig\"\\n', 'KUBE_AUTHORIZATION_KUBE_CONF=\"--authorization-kubeconfig=/etc/kubernetes/pki/kube-scheduler.kubeconfig\"\\n', 'KUBE_BIND_ADDR=\"--bind-address=127.0.0.1\"\\n', 'KUBE_LEADER_ELECT=\"--leader-elect=true\"\\n', 'KUBE_SCHEDULER_ARGS=\"\"\\n', '编写 scheduler 的 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kube-scheduler.service\\n', '[Unit]\\n', 'Description=Kubernetes Scheduler Plugin\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-scheduler/\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/scheduler\\n', 'ExecStart=/usr/bin/kube-scheduler \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    $KUBE_CONFIG \\\\\\n', '\\t    $KUBE_AUTHENTICATION_KUBE_CONF \\\\\\n', '\\t    $KUBE_AUTHORIZATION_KUBE_CONF \\\\\\n', '\\t    $KUBE_BIND_ADDR \\\\\\n', '\\t    $KUBE_LEADER_ELECT \\\\\\n', '\\t    $KUBE_SCHEDULER_ARGS\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '使能各组件\\n', '$ systemctl enable kube-controller-manager kube-scheduler kube-proxy\\n', '$ systemctl restart kube-controller-manager kube-scheduler kube-proxy\\n', '基本功能验证\\n', '$ curl --cacert /etc/kubernetes/pki/ca.pem https://192.168.122.154:6443/version\\n', '{\\n', '  \"major\": \"1\",\\n', '  \"minor\": \"20\",\\n', '  \"gitVersion\": \"v1.20.2\",\\n', '  \"gitCommit\": \"faecb196815e248d3ecfb03c680a4507229c2a56\",\\n', '  \"gitTreeState\": \"archive\",\\n', '  \"buildDate\": \"2021-03-02T07:26:14Z\",\\n', '  \"goVersion\": \"go1.15.7\",\\n', '  \"compiler\": \"gc\",\\n', '  \"platform\": \"linux/arm64\"\\n', '}']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建web服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BAweb%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建web服务器\\n', '搭建web服务器\\n', 'Apache服务器\\n', '概述\\n', '管理httpd\\n', '配置文件说明\\n', '管理模块和SSL\\n', '验证web服务是否搭建成功\\n', 'Nginx服务器\\n', '概述\\n', '安装\\n', '管理nginx\\n', '配置文件说明\\n', '管理模块\\n', '验证web服务是否搭建成功\\n', 'Apache服务器\\n', '概述\\n', 'Web（World Wide Web）是目前最常用的Internet协议之一。目前在Unix-Like系统中的web服务器主要通过Apache服务器软件实现。为了实现运营动态网站，产生了LAMP（Linux + Apache +MySQL + PHP）。web服务可以结合文字、图形、影像以及声音等多媒体，并支持超链接（Hyperlink）的方式传输信息。\\n', '\\n', 'openEuler系统中的web服务器版本是Apache HTTP服务器2.4版本，即httpd，一个由Apache软件基金会发展而来的开源web服务器。\\n', '\\n', '管理httpd\\n', '概述\\n', '通过systemctl工具，可以对httpd服务进行管理，包括启动、停止、重启服务，以及查看服务状态等。本章介绍Apache HTTP服务的管理操作，以指导用户使用。\\n', '\\n', '前提条件\\n', '为了能够使用Apache HTTP服务，请确保您的系统中已经安装httpd服务的rpm包。在root权限下执行如下命令进行安装：\\n', '\\n', '# dnf install httpd\\n', '更多关于管理服务的内容，请参见管理服务。\\n', '\\n', '启动、停止和重启httpd服务，需要使用root权限。\\n', '\\n', '启动服务\\n', '启动并运行httpd服务，命令如下：\\n', '\\n', '# systemctl start httpd\\n', '假如希望在系统启动时，httpd服务自动启动，则命令和回显如下：\\n', '\\n', '# systemctl enable httpd\\n', 'Created symlink /etc/systemd/system/multi-user.target.wants/httpd.service → /usr/lib/systemd/system/httpd.service.\\n', ' 说明：\\n', '假如正在运行的Apache HTTP服务器作为一个安全服务器，系统开机启动后需要密码，这个密码使用的是加密的私有SSL密钥。\\n', '\\n', '停止服务\\n', '停止运行的httpd服务，命令如下：\\n', '\\n', '# systemctl stop httpd\\n', '如果希望防止服务在系统开机阶段自动开启，命令和回显如下：\\n', '\\n', '# systemctl disable httpd\\n', 'Removed /etc/systemd/system/multi-user.target.wants/httpd.service.\\n', '重启服务\\n', '重启服务有三种方式：\\n', '\\n', '完全重启服务\\n', '\\n', '# systemctl restart httpd\\n', '该命令会停止运行的httpd服务并且立即重新启动它。一般在服务安装以后或者去除一个动态加载的模块（例如PHP）时使用这个命令。\\n', '\\n', '重新加载配置\\n', '\\n', '# systemctl reload httpd\\n', '该命令会使运行的httpd服务重新加载它的配置文件。任何当前正在处理的请求将会被中断，从而造成客户端浏览器显示一个错误消息或者重新渲染部分页面。\\n', '\\n', '重新加载配置而不影响激活的请求\\n', '\\n', '# apachectl graceful\\n', '该命令会使运行的httpd服务重新加载它的配置文件。任何当前正在处理的请求将会继续使用旧的配置文件。\\n', '\\n', '验证服务状态\\n', '验证httpd服务是否正在运行\\n', '\\n', '$ systemctl is-active httpd\\n', '回显为“active”说明服务处于运行状态。\\n', '\\n', '配置文件说明\\n', '当httpd服启动后，默认情况下它会读取如表1所示的配置文件。\\n', '\\n', '表 1 配置文件说明\\n', '\\n', '\\n', '文件\\n', '\\n', '说明\\n', '\\n', '/etc/httpd/conf/httpd.conf\\n', '\\n', '主要的配置文件\\n', '\\n', '/etc/httpd/conf.d\\n', '\\n', '配置文件的辅助目录，这些配置文件也被包含在主配置文件当中\\n', '\\n', '一个配置文件的辅助目录被包含在主要的配置文件中\\n', '\\n', '虽然默认配置可以适用于多数情况，但是用户至少需要熟悉里面的一些重要配置项。配置文件修改完成后，可以在root权限下使用如下命令检查配置文件可能出现的语法错误。\\n', '\\n', '# apachectl configtest\\n', '如果回显如下，说明配置文件语法正确。\\n', '\\n', 'Syntax OK\\n', ' 说明：\\n', '\\n', '在修改配置文件之前，请先备份原始文件，以便出现问题时能够快速恢复配置文件。\\n', '需要重启web服务，才能使修改后的配置文件生效。\\n', '管理模块和SSL\\n', '概述\\n', 'httpd服务是一个模块化的应用，它和许多动态共享对象DSO（Dynamic Shared Objects）一起分发。动态共享对象DSO，在必要情况下，可以在运行时被动态加载或卸载。服务器操作系统中这些模块位于/usr/lib64/httpd/modules/目录下。本节介绍如何加载和写入模块。\\n', '\\n', '加载模块\\n', '为了加载一个特殊的DSO模块，在配置文件中使用加载模块指示。独立软件包提供的模块一般在/etc/httpd/conf.modules.d目录下有他们自己的配置文件。\\n', '\\n', '例如，加载asis DSO模块的操作步骤如下：\\n', '\\n', '在/etc/httpd/conf.modules.d/00-optional.conf文件中，使用root权限取消注释如下配置行。\\n', '\\n', 'LoadModule asis_module modules/mod_asis.so\\n', '加载完成后，请使用root权限重启httpd服务以便于重新加载配置文件。\\n', '\\n', '# systemctl restart httpd\\n', '加载完成后，在root权限下使用httpd -M的命令查看是否已经加载了asis DSO模块。\\n', '\\n', '# httpd -M | grep asis\\n', '回显如下，说明asis DSO模块加载成功。\\n', '\\n', 'asis_module (shared)\\n', ' 说明：\\n', 'httpd 的常用命令\\n', '\\n', 'httpd -v : 查看httpd的版本号。\\n', 'httpd -l：查看编译进httpd程序的静态模块。\\n', 'httpd -M：查看已经编译进httpd程序的静态模块和已经加载的动态模块。\\n', 'SSL介绍\\n', '安全套接层SSL（Secure Sockets Layer）是一个允许服务端和客户端之间进行安全通信的加密协议。其中，传输层安全性协议TLS（Transport Layer Security）为网络通信提供了安全性和数据完整性保障。openEuler支持Mozilla NSS（Network Security Services）作为安全性协议TLS进行配置。加载SSL的操作步骤如下：\\n', '\\n', '在root权限下安装mod_ssl的rpm包。\\n', '\\n', '# dnf install mod_ssl\\n', '安装完成后，请在root权限下重启httpd服务以便于重新加载配置文件。\\n', '\\n', '# systemctl restart httpd\\n', '加载完成后，在root权限下使用httpd -M的命令查看是否已经加载了SSL。\\n', '\\n', '# httpd -M | grep ssl\\n', '回显如下，说明SSL已加载成功。\\n', '\\n', 'ssl_module (shared)\\n', '验证web服务是否搭建成功\\n', 'Web服务器搭建完成后，可以通过如下方式验证是否搭建成功。\\n', '\\n', '在root权限下查看服务器的IP地址，命令如下：\\n', '\\n', '# ifconfig\\n', '回显信息如下，说明服务器IP为 192.168.1.60。\\n', '\\n', 'enp3s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'inet 192.168.1.60  netmask 255.255.255.0  broadcast 192.168.1.255\\n', 'inet6 fe80::5054:ff:fe95:499f  prefixlen 64  scopeid 0x20<link>\\n', 'ether 52:54:00:95:49:9f  txqueuelen 1000  (Ethernet)\\n', 'RX packets 150713207  bytes 49333673733 (45.9 GiB)\\n', 'RX errors 0  dropped 43  overruns 0  frame 0\\n', 'TX packets 2246438  bytes 203186675 (193.7 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'enp4s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'ether 52:54:00:7d:80:9e  txqueuelen 1000  (Ethernet)\\n', 'RX packets 149937274  bytes 44652889185 (41.5 GiB)\\n', 'RX errors 0  dropped 1102561  overruns 0  frame 0\\n', 'TX packets 0  bytes 0 (0.0 B)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\\n', 'inet 127.0.0.1  netmask 255.0.0.0\\n', 'inet6 ::1  prefixlen 128  scopeid 0x10<host>\\n', 'loop  txqueuelen 1000  (Local Loopback)\\n', 'RX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'RX errors 0  dropped 0  overruns 0  frame 0\\n', 'TX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '在root权限下配置防火墙：\\n', '\\n', '# firewall-cmd --add-service=http --permanent\\n', 'success\\n', '# firewall-cmd --reload\\n', 'success\\n', '验证web服务器是否搭建成功，用户可选择Linux或Windows系统进行验证。\\n', '\\n', '使用Linux系统验证\\n', '\\n', '执行如下命令，查看是否可以访问网页信息，服务搭建成功时，该网页可以正常访问。\\n', '\\n', '$ curl http://192.168.1.60\\n', '执行如下命令，查看命令返回值是否为0，返回值为0，说明httpd服务器搭建成功。\\n', '\\n', '$ echo $?\\n', '使用Windows系统验证\\n', '\\n', '打开浏览器，在地址栏输入如下地址，如果能正常访问网页，说明httpd服务器搭建成功。\\n', '\\n', 'http://192.168.1.60\\n', '\\n', '如果修改了端口号，输入地址格式如下：\\n', '\\n', 'http://192.168.1.60:端口号\\n', '\\n', 'Nginx服务器\\n', '概述\\n', 'Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，其特点是占有内存少，并发能力强，支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能，并且支持很多第三方的模块扩展。\\n', '\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装nginx服务。\\n', '\\n', '# dnf install nginx\\n', '查看安装后的rpm包。\\n', '\\n', '$ dnf list all | grep nginx\\n', '管理nginx\\n', '概述\\n', '通过systemctl工具，可以对nginx服务进行管理，包括启动、停止、重启服务，以及查看服务状态等。本章介绍nginx服务的管理操作，以指导用户使用。\\n', '\\n', '前提条件\\n', '为了能够使用nginx服务，请确保您的系统中已经安装nginx服务。若未安装，可参考安装进行安装。\\n', '\\n', '更多关于管理服务的内容，请参见管理服务。\\n', '\\n', '启动、停止和重启nginx服务，需要使用root权限。\\n', '\\n', '启动服务\\n', '启动并运行nginx服务，命令如下：\\n', '\\n', '# systemctl start nginx\\n', '假如希望在系统启动时，nginx服务自动启动，则命令和回显如下：\\n', '\\n', '# systemctl enable nginx\\n', 'Created symlink /etc/systemd/system/multi-user.target.wants/nginx.service → /usr/lib/systemd/system/nginx.service.\\n', ' 说明：\\n', '假如正在运行的nginx服务器作为一个安全服务器，系统开机启动后需要密码，这个密码使用的是加密的私有SSL密钥。\\n', '\\n', '停止服务\\n', '停止运行的nginx服务，命令如下：\\n', '\\n', '# systemctl stop nginx\\n', '如果希望防止服务在系统开机阶段自动开启，命令和回显如下：\\n', '\\n', '# systemctl disable nginx\\n', 'Removed /etc/systemd/system/multi-user.target.wants/nginx.service.\\n', '重启服务\\n', '重启服务有三种方式：\\n', '\\n', '完全重启服务\\n', '\\n', '# systemctl restart nginx\\n', '该命令会停止运行的nginx服务并且立即重新启动它。一般在服务安装以后或者去除一个动态加载的模块（例如PHP）时使用这个命令。\\n', '\\n', '重新加载配置\\n', '\\n', '# systemctl reload nginx\\n', '该命令会使运行的nginx服务重新加载它的配置文件。任何当前正在处理的请求将会被中断，从而造成客户端浏览器显示一个错误消息或者重新渲染部分页面。\\n', '\\n', '平滑重启nginx\\n', '\\n', '# kill -HUP 主进程ID\\n', '该命令会使运行的nginx服务重新加载它的配置文件。任何当前正在处理的请求将会继续使用旧的配置文件。\\n', '\\n', '验证服务状态\\n', '验证nginx服务是否正在运行\\n', '\\n', '$ systemctl is-active nginx\\n', '回显为“active”说明服务处于运行状态。\\n', '\\n', '配置文件说明\\n', '当nginx服启动后，默认情况下它会读取如表2所示的配置文件。\\n', '\\n', '表 2 配置文件说明\\n', '\\n', '\\n', '文件\\n', '\\n', '说明\\n', '\\n', '/etc/nginx/nginx.conf\\n', '\\n', '主要的配置文件\\n', '\\n', '/etc/nginx/conf.d\\n', '\\n', '配置文件的辅助目录，这些配置文件也被包含在主配置文件当中\\n', '\\n', '一个配置文件的辅助目录被包含在主要的配置文件中\\n', '\\n', '虽然默认配置可以适用于多数情况，但是用户至少需要熟悉里面的一些重要配置项。配置文件修改完成后，可以在root权限下使用如下命令检查配置文件可能出现的语法错误。\\n', '\\n', '# nginx -t\\n', '如果回显信息中有“syntax is ok”，说明配置文件语法正确。\\n', '\\n', ' 说明：\\n', '\\n', '在修改配置文件之前，请先备份原始文件，以便出现问题时能够快速恢复配置文件。\\n', '需要重启web服务，才能使修改后的配置文件生效。\\n', '管理模块\\n', '概述\\n', 'nginx服务是一个模块化的应用，它和许多动态共享对象DSO（Dynamic Shared Objects）一起分发。动态共享对象DSO，在必要情况下，可以在运行时被动态加载或卸载。服务器操作系统中这些模块位于/usr/lib64/nginx/modules/目录下。本节介绍如何加载和写入模块。\\n', '\\n', '加载模块\\n', '为了加载一个特殊的DSO模块，在配置文件中使用加载模块指示。独立软件包提供的模块一般在/usr/share/nginx/modules目录下有他们自己的配置文件。\\n', '\\n', '因openEuler操作系统中使用dnf install nginx安装nginx是会自动加载DSO。\\n', '\\n', '验证web服务是否搭建成功\\n', 'Web服务器搭建完成后，可以通过如下方式验证是否搭建成功。\\n', '\\n', '在root权限下查看服务器的IP地址，命令如下：\\n', '\\n', '# ifconfig\\n', '回显信息如下，说明服务器IP为 192.168.1.60。\\n', '\\n', 'enp3s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'inet 192.168.1.60  netmask 255.255.255.0  broadcast 192.168.1.255\\n', 'inet6 fe80::5054:ff:fe95:499f  prefixlen 64  scopeid 0x20<link>\\n', 'ether 52:54:00:95:49:9f  txqueuelen 1000  (Ethernet)\\n', 'RX packets 150713207  bytes 49333673733 (45.9 GiB)\\n', 'RX errors 0  dropped 43  overruns 0  frame 0\\n', 'TX packets 2246438  bytes 203186675 (193.7 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'enp4s0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\\n', 'ether 52:54:00:7d:80:9e  txqueuelen 1000  (Ethernet)\\n', 'RX packets 149937274  bytes 44652889185 (41.5 GiB)\\n', 'RX errors 0  dropped 1102561  overruns 0  frame 0\\n', 'TX packets 0  bytes 0 (0.0 B)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '\\n', 'lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536\\n', 'inet 127.0.0.1  netmask 255.0.0.0\\n', 'inet6 ::1  prefixlen 128  scopeid 0x10<host>\\n', 'loop  txqueuelen 1000  (Local Loopback)\\n', 'RX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'RX errors 0  dropped 0  overruns 0  frame 0\\n', 'TX packets 37096  bytes 3447369 (3.2 MiB)\\n', 'TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\\n', '在root权限下配置防火墙：\\n', '\\n', '# firewall-cmd --add-service=http --permanent\\n', 'success\\n', '# firewall-cmd --reload\\n', 'success\\n', '验证web服务器是否搭建成功，用户可选择Linux或Windows系统进行验证。\\n', '\\n', '使用Linux系统验证\\n', '\\n', '执行如下命令，查看是否可以访问网页信息，服务搭建成功时，该网页可以正常访问。\\n', '\\n', '$ curl http://192.168.1.60\\n', '执行如下命令，查看命令返回值是否为0，返回值为0，说明nginx服务器搭建成功。\\n', '\\n', '$ echo $?\\n', '使用Windows系统验证\\n', '\\n', '打开浏览器，在地址栏输入如下地址，如果能正常访问网页，说明nginx服务器搭建成功。\\n', '\\n', 'http://192.168.1.60\\n', '\\n', '如果修改了端口号，输入地址格式如下：\\n', '\\n', 'http://192.168.1.60:端口号']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_环境变量持久化.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%8C%81%E4%B9%85%E5%8C%96.html", "text_entry": "['环境变量持久化\\n', '功能描述\\n', '系统容器支持通过指定–env-target-file接口参数将env变量持久化到容器rootfs目录下的配置文件中。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--env-target-file\\n', '\\n', '字符串变量。\\n', 'env持久化文件必须在rootfs目录下，且配置为绝对路径。\\n', '约束限制\\n', '–env-target-file指定的目标文件如果存在的话，大小不能超过10MB。\\n', '–env-target-file指定的参数为rootfs目录下的绝对路径。\\n', '如果–env和目标文件里面的env出现冲突，以–env指定值的参数为准。\\n', '使用示例\\n', '启动系统容器，指定env环境变量和–env-target-file参数：\\n', '\\n', '[root@localhost ~]# isula run -tid -e abc=123 --env-target-file /etc/environment --system-container --external-rootfs /root/myrootfs none init\\n', 'b75df997a64da74518deb9a01d345e8df13eca6bcc36d6fe40c3e90ea1ee088e\\n', '[root@localhost ~]# isula exec b7 cat /etc/environment\\n', 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\\n', 'TERM=xterm\\n', 'abc=123\\n', '可以看到容器的env变量（abc=123）已经持久化到/etc/environment配置文件中。']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_StratoVirt VFIO 使用说明.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/StratoVirt-VFIO-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html", "text_entry": "['管理设备直通\\n', '虚拟化平台使用设备直通，可以使虚拟机直接使用相关硬件设备，提升虚拟机性能。本章介绍 StratoVirt 支持的设备直通特性。\\n', '\\n', '前提条件\\n', '使用设备直通，主机需要满足如下条件：\\n', '\\n', '开启 IOMMU 功能\\n', '\\n', 'IOMMU 全称是 Input/Output Memory Management Unit，该技术可以让 PCI/PCIe 设备的资源直接分配给虚拟机。\\n', '\\n', '在主机上执行如下命令，查看 IOMMU 是否已经开启。\\n', '\\n', '# dmesg | grep iommu\\n', '若已开启，回显如下：\\n', '\\n', 'iommu: Default domain type: Translated\\n', 'hibmc-drm 0000:0a:00.0: Adding to iommu group 0\\n', 'ehci-pci 0000:7a:01.0: Adding to iommu group 1\\n', 'ehci-pci 0000:ba:01.0: Adding to iommu group 2\\n', 'ohci-pci 0000:7a:00.0: Adding to iommu group 3\\n', 'ohci-pci 0000:ba:00.0: Adding to iommu group 4\\n', 'xhci_hcd 0000:7a:02.0: Adding to iommu group 5\\n', '......\\n', '若未开启，则没有回显或只显示如下信息：\\n', '\\n', 'iommu: Default domain type: Translated\\n', '开启IOMMU：\\n', '\\n', '1.为linux内核增加启动参数: intel_iommu=on iommu=pt;\\n', '\\n', 'vim /boot/grub2/grub.cfg\\n', 'linux /vmlinuz-5.15.0+ root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root rd.lvm.lv=openeuler/swap crashkernel=512M intel_iommu=on iommu=pt\\n', '2.重启Host OS;\\n', '\\n', '加载 vfio-pci 内核模块\\n', '\\n', '# modprobe vfio-pci\\n', '# lsmod | grep vfio_pci\\n', '成功加载 vfio-pci 模块，则回显如下：\\n', '\\n', 'vfio_pci              327680  0\\n', 'vfio_virqfd           327680  1 vfio_pci\\n', 'vfio                  327680  2 vfio_iommu_type1,vfio_pci\\n', '将 PCI 设备从主机解绑，重新绑定到 vfio-pci 驱动\\n', '\\n', '假设使用 VFIO 直通 Hi1822 网卡设备，首先查看网卡设备对应的 PCI 设备信息：\\n', '\\n', '# lspci -v | grep \"Eth\" | grep 1822\\n', '03:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '04:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '05:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '06:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '选择其中 bus 号 03，slot 号 00，function 号 0 的设备，即上述的 03:00.0。然后将该 PCI 设备从主机上解绑\\n', '\\n', '# echo 0000:03:00.0 > /sys/bus/pci/devices/0000:03:00.0/driver/unbind\\n', '最后将该 PCI 设备重新绑定到 vfio-pci 驱动。\\n', '\\n', 'lspci -ns 0000:03:00.0 |awk -F\\':| \\' \\'{print 5\" \"6}\\' > /sys/bus/pci/drivers/vfio-pci/new_id\\n', '将网卡绑定到 vfio-pci 驱动后，在主机上无法查询到对应网卡信息，只能查询到对应的 PCI 设备信息。\\n', '\\n', 'VFIO 设备直通\\n', '简介\\n', 'VFIO(Virtual Function I/O) 是内核提供的一种用户态设备驱动方案。VFIO 驱动可以安全地把设备 I/O，中断，DMA 等能力呈现给用户空间。StratoVirt 虚拟化平台使用 VFIO 设备直通方案后，在虚拟机可以极大限度地提升 I/O 性能。\\n', '\\n', '使用 VFIO 直通\\n', 'StratoVirt 支持 libvirt 管理，可以使用 XML 文件配置虚拟机。以下内容介绍通过修改虚拟机 XML 文件的方式，使用 VFIO 设备直通功能。\\n', '\\n', '一、修改 XML 文件\\n', '\\n', '在主机上执行如下命令，查询 CPU 架构信息\\n', '\\n', '# uname -m\\n', 'aarch64 和 x86_64 架构分别下载 StratoVirt 自带的 XML 文件 stratovirt_aarch64.xml 或 stratovirtvirt_x86.xml，并存放到任一目录，例如 /home：\\n', '\\n', '# cp stratovirt/docs/stratovirt_$arch.xml /home\\n', '根据实际需求，修改XML文件中的VFIO配置。 bus，slot，function 为上述绑定到 vfio-pci 驱动的 PCI 设备。相关配置如下：\\n', '\\n', '<!-- vfio -->\\n', \"<hostdev mode='subsystem' type='pci' managed='yes'>\\n\", \"<driver name='vfio'/>\\n\", '<source>\\n', \"    <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>\\n\", '</source>\\n', '</hostdev>\\n', \"上例中，设备类型为 PCI 设备，managed='yes' 表示 libvirt 将把 PCI 设备从主机解绑，并重新绑定到 vfio-pci 驱动。source 项配置了需要作为 VFIO 直通设备的 domain，bus，slot，function 信息。\\n\", '\\n', '二、使用 libvirt 命令行创建并登陆虚拟机\\n', '\\n', '# virsh create stratovirt_$arch.xml\\n', '# virsh list --all\\n', 'Id \\tName \\t\\tState\\n', '--------------------\\n', '1 \\tStratoVirt \\trunning\\n', '# virsh console 1\\n', '三、在虚拟机内查看并使用 VFIO 直通网卡。\\n', '\\n', '配置前查看网卡信息\\n', '\\n', '# ip a\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '\\tlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '\\tinet 127.0.0.1/8 scope host lo\\n', '     valid_lft forever preferred_lft forever\\n', '2: enp1s0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000\\n', '\\tlink/ether 72:b8:51:9d:d1:27 brd ff:ff:ff:ff:ff:ff\\n', '动态配置网卡的 IP 地址\\n', '\\n', '# dhclient\\n', '查询 IP 是否配置成功\\n', '\\n', '# ip a\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '\\tlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '\\tinet 127.0.0.1/8 scope host lo\\n', '     valid_lft forever preferred_lft forever\\n', '2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n', '\\tlink/ether 72:b8:51:9d:d1:27 brd ff:ff:ff:ff:ff:ff\\n', '\\tinet 192.168.1.3/16 brd 192.168.255.255 scope global dynamic enp1s0\\n', '     valid_lft 86453sec preferred_lft 86453sec\\n', '如上回显可知，成功分配了 IP 地址 192.168.1.3，虚拟机可以直接使用配置的网卡\\n', '\\n', '说明：使用的直通网卡如果没有连接物理网络，将获取不到网络信息。\\n', '\\n', '解绑 VFIO 驱动\\n', '如果需要将直通给虚拟机使用的网卡解除绑定，可以登录主机，执行如下命令，将网卡设备重新绑定到主机上。其中，hinic是对应网卡设备驱动的类型：\\n', '\\n', '# echo 0000:03:00.0 > /sys/bus/pci/drivers/vfio-pci/unbind\\n', '# echo 0000:03:00.0 > /sys/bus/pci/drivers/hinic/bind\\n', '说明：绑定 VFIO 驱动前，可以再主机上执行 ethtool -i enp0 命令，获取网卡设备驱动类型。enp0 为对应网卡名称。\\n', '\\n', 'SR-IOV 直通\\n', '简介\\n', '使用 VFIO 设备直通时，虚拟机能直接访问硬件，但每个设备只能被一个虚拟机独占。SR-IOV 直通技术支持将一个 PF(Physical Function) 虚拟出多个 VF (Virtual Function)，并直通给不同虚拟机，解决了设备直通的独占问题，增加可用的设备。\\n', '\\n', '操作步骤\\n', '创建多个 VF：\\n', '\\n', 'sriov_numvfs 文件用于描述 SR-IOV 提供的 VF 个数，存放在 /sys/bus/pci/devices/domain:bus:slot.function/ 路径下，例如上述例子中的 bus 号 03，slot 号 00，function 号 0 的设备，可以使用如下命令创建4个 VF：\\n', '\\n', '# echo 4 > /sys/bus/pci/devices/0000\\\\:03\\\\:00.0/sriov_numvfs\\n', '确认 VF 设备创建成功\\n', '\\n', '# lspci -v | grep \"Eth\" | grep 1822\\n', '回显如下，说明成功创建了4个 VF 03:00.1、03:00.2、03:00.3、03:00.4：\\n', '\\n', '03:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '03:00.1 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.2 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.3 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.4 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '上述创建的 VF 设备均可以直通给虚拟机，使用 SR-IOV 设备的方法与普通 PCI 设备的直通方法相同。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_Docker容器_镜像管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86-3.html", "text_entry": "['镜像管理\\n', '镜像管理\\n', '创建镜像\\n', '查看镜像\\n', '删除镜像\\n', '创建镜像\\n', 'docker pull、docker build、docker commit、docker import、docker load都可以创建一个新的镜像，关于这些命令的使用详见命令行参考镜像管理。\\n', '\\n', '注意事项\\n', '避免并发docker load和docker rmi操作。 如果同时满足如下两个条件，可能导致并发性问题：\\n', '\\n', '某个镜像存在于系统中。\\n', '同时对该镜像进行docker rmi和docker load操作。\\n', '所以使用时应该避免这种场景（注：所有的镜像创建操作如tag，build，load和rmi并发都有可能会导致类似的错误，应该尽量避免这类操作与rmi的并发）。\\n', '\\n', '如果Docker操作镜像时系统掉电，可能导致镜像损坏，需要手动恢复。\\n', '\\n', '由于Docker在操作镜像（pull/load/rmi/build/combine/commit/import等）时,镜像数据的操作是异步的、镜像元数据是同步的。所以如果在镜像数据未全部刷到磁盘时掉电，可能导致镜像数据和元数据不一致。对用户的表现是镜像可以看到(有可能是none 镜像)，但是无法启动容器，或者启动后的容器有异常。这种情况下应该先使用docker rmi删除该镜像，然后重新进行之前的操作，系统可以恢复。\\n', '\\n', '生产环境节点应避免存留超大数量镜像，请及时清理不使用的镜像。\\n', '\\n', '镜像数目过多会导致docker image等命令执行过慢，从而导致docker build/docker commit等相关命令执行失败，并可能导致内存堆积。在生产环境中，请及时清理不再使用的镜像和中间过程镜像。\\n', '\\n', '使用--no-parent参数build镜像时，如果有多个build操作同时进行，并且Dockerfile里 FROM的镜像相同，则可能会残留镜像，分为以下两种情况：\\n', '\\n', 'FROM的镜像不是完整镜像，则有可能会残留FROM的镜像运行时生成的镜像。残留的镜像名类似base_v1.0.0-app_v2.0.0，或者残留<none>镜像。\\n', '如果Dockerfile里的前几条指令相同，则有可能会残留<none>镜像。\\n', '可能会产生none镜像场景\\n', 'none镜像是指没有tag的最顶层镜像，比如ubuntu的imageID，只有一个tag是ubuntu，如果这个tag没了，但是imageID还在，那么这个imageID就变成了none镜像。\\n', 'Save镜像的过程中因为要把镜像的数据导出来，所以对image进行保护，但是如果这个时候来一个删除操作，可能会untag成功，删除镜像ID失败，造成该镜像变成none镜像。\\n', '执行docker pull时掉电，或者系统panic，可能出现none镜像，为保证镜像完整性，此时可通过docker rmi 删除镜像后重新拉取。\\n', '执行docker save保存镜像时，如果指定的名字为镜像ID，则load后的镜像也没有tag，其镜像名为none。\\n', 'build镜像的同时删除该镜像，有极低概率导致镜像build失败\\n', '目前的build镜像的过程是通过引用计数来保护的，当build完一个镜像后，紧接着就给该镜像的引用计数加1（holdon操作），一旦holdon操作成功，该镜像就不会被删除了，但是在holdon之前，有极低的概率，还是可以删除成功，导致build镜像失败。\\n', '\\n', '查看镜像\\n', '查看本地镜像列表：\\n', '\\n', 'docker images\\n', '删除镜像\\n', '注意事项\\n', '禁止使用docker rmi –f XXX删除镜像。如果使用强制删除，docker rmi会忽略过程中的错误，可能导致容器或者镜像关元数据残留。如果使用普通删除，如果删除过程出错，则会删除失败，不会导致元数据残留。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_配置网络.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C.html", "text_entry": "['配置网络\\n', '配置网络\\n', '配置 IP\\n', '使用nmcli命令\\n', '使用ip命令\\n', '通过ifcfg文件配置网络\\n', '配置主机名\\n', '简介\\n', '使用hostnamectl配置主机名\\n', '使用nmcli配置主机名\\n', '配置网络绑定\\n', '使用nmcli\\n', '使用命令行\\n', 'IPv6使用差异说明（vs IPv4）\\n', '约束限制\\n', '配置说明\\n', 'FAQ\\n', '配置 IP\\n', '使用nmcli命令\\n', ' 说明：\\n', '使用nmcli命令配置的网络配置可以立即生效且系统重启后配置也不会丢失。\\n', '\\n', 'nmcli介绍\\n', 'nmcli是NetworkManager的一个命令行工具，它提供了使用命令行配置由NetworkManager管理网络连接的方法。nmcli命令的基本格式为：\\n', '\\n', ' nmcli [OPTIONS] OBJECT { COMMAND | help }\\n', '其中，OBJECT选项可以是general、networking、radio、connection或device等。在日常使用中，最常使用的是-t, --terse（用于脚本）、-p, --pretty选项（用于用户）及-h, --help选项，用户可以使用“ nmcli help”获取更多参数及使用信息。\\n', '\\n', '$ nmcli help\\n', '常用命令使用举例如下：\\n', '\\n', '显示NetworkManager状态：\\n', '\\n', '$ nmcli general status\\n', '显示所有连接：\\n', '\\n', '$ nmcli connection show\\n', '只显示当前活动连接，如下所示添加 -a, --active：\\n', '\\n', '$ nmcli connection show --active\\n', '显示由NetworkManager识别到设备及其状态：\\n', '\\n', '$ nmcli device status\\n', '使用nmcli工具启动和停止网络接口，在root权限下执行如下命令：\\n', '\\n', '# nmcli connection up id enp3s0\\n', '# nmcli device disconnect enp3s0\\n', '设备管理\\n', '连接到设备\\n', '使用如下命令，NetworkManager将连接到对应网络设备，尝试找到合适的连接配置，并激活配置。\\n', '\\n', '$nmcli device connect \"$IFNAME\"  \\n', '如果不存在相应的配置连接，NetworkManager将创建并激活具有默认设置的新配置文件。\\n', '\\n', '断开设备连接\\n', '使用如下命令，NetworkManager将断开设备连接，并防止设备自动激活。\\n', '\\n', '$nmcli device disconnect \"$IFNAME\"  \\n', '设置网络连接\\n', '列出目前可用的网络连接：\\n', '\\n', '$ nmcli con show\\n', '\\n', '\\n', 'NAME    UUID                                  TYPE      DEVICE\\n', 'enp4s0  5afce939-400e-42fd-91ee-55ff5b65deab  ethernet  enp4s0\\n', 'enp3s0  c88d7b69-f529-35ca-81ab-aa729ac542fd  ethernet  enp3s0\\n', 'virbr0  ba552da6-f014-49e3-91fa-ec9c388864fa  bridge    virbr0\\n', ' 说明：\\n', '输出结果中的NAME字段代表连接ID（名称）。\\n', '\\n', '添加一个网络连接会生成相应的配置文件，并与相应的设备关联。检查可用的设备，方法如下：\\n', '\\n', '$ nmcli dev status\\n', '\\n', 'DEVICE      TYPE      STATE      CONNECTION\\n', 'enp3s0      ethernet  connected  enp3s0\\n', 'enp4s0      ethernet  connected  enp4s0\\n', 'virbr0      bridge    connected  virbr0\\n', 'lo          loopback  unmanaged  --\\n', 'virbr0-nic  tun       unmanaged  --\\n', '配置动态IP连接\\n', '配置IP\\n', '要使用 DHCP 分配网络时，可以使用动态IP配置添加网络配置文件，命令格式如下：\\n', '\\n', 'nmcli connection add type ethernet con-name connection-name ifname interface-name\\n', '例如创建名为net-test的动态连接配置文件，在root权限下使用以下命令：\\n', '\\n', '# nmcli connection add type ethernet con-name net-test ifname enp3s0\\n', \"Connection 'net-test' (a771baa0-5064-4296-ac40-5dc8973967ab) successfully added.\\n\", 'NetworkManager 会将参数 connection.autoconnect 设定为 yes，并将设置保存到 “/etc/sysconfig/network-scripts/ifcfg-net-test”文件中，在该文件中会将 ONBOOT 设置为 yes。\\n', '\\n', '激活连接并检查状态\\n', '在root权限下使用以下命令激活网络连接：\\n', '\\n', '# nmcli con up net-test \\n', 'Connection successfully activated (D-Bus active path:/org/freedesktop/NetworkManager/ActiveConnection/5)\\n', '检查这些设备及连接的状态，使用以下命令：\\n', '\\n', '$ nmcli device status\\n', '\\n', 'DEVICE      TYPE      STATE      CONNECTION\\n', 'enp4s0      ethernet  connected  enp4s0\\n', 'enp3s0      ethernet  connected  net-test\\n', 'virbr0      bridge    connected  virbr0\\n', 'lo          loopback  unmanaged  --\\n', 'virbr0-nic  tun       unmanaged  --\\n', '配置静态IP连接\\n', '配置IP\\n', '添加静态 IPv4 配置的网络连接，可使用以下命令：\\n', '\\n', 'nmcli connection add type ethernet con-name connection-name ifname interface-name ip4 address gw4 address\\n', ' 说明：\\n', '如果要添加 IPv6 地址和网关信息，使用 ip6 和 gw6 选项。\\n', '\\n', '例如创建名为 net-static的静态连接配置文件，在root权限下使用以下命令：\\n', '\\n', '# nmcli con add type ethernet con-name net-static ifname enp3s0 ip4 192.168.0.10/24 gw4 192.168.0.254\\n', '还可为该设备同时指定 IPv6 地址和网关，示例如下：\\n', '\\n', '# nmcli con add type ethernet con-name test-lab ifname enp3s0 ip4 192.168.0.10/24 gw4 192.168.0.254 ip6 abbe::**** gw6 2001:***::*\\n', \"Connection 'net-static' (63aa2036-8665-f54d-9a92-c3035bad03f7) successfully added.\\n\", 'NetworkManager 会将其内部参数 ipv4.method 设定为 manual，将 connection.autoconnect 设定为yes，并将设置写入 /etc/sysconfig/network-scripts/ifcfg-my-office 文件，其中会将对应 BOOTPROTO 设定为 none，将 ONBOOT 设定为 yes。\\n', '\\n', '设定两个 IPv4 DNS 服务器地址，在root权限下使用以下命令：\\n', '\\n', '# nmcli con mod net-static ipv4.dns \"*.*.*.* *.*.*.*\"\\n', '设置两个 IPv6 DNS 服务器地址，在root权限下使用以下命令：\\n', '\\n', '# nmcli con mod net-static ipv6.dns \"2001:4860:4860::**** 2001:4860:4860::****\"\\n', '激活连接并检查状态\\n', '激活新的网络连接，在root权限下使用以下命令：\\n', '\\n', '# nmcli con up net-static ifname enp3s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/6)\\n', '检查这些设备及连接的状态，使用以下命令：\\n', '\\n', '$ nmcli device status\\n', '\\n', 'DEVICE      TYPE      STATE      CONNECTION\\n', 'enp4s0      ethernet  connected  enp4s0\\n', 'enp3s0      ethernet  connected  net-static\\n', 'virbr0      bridge    connected  virbr0\\n', 'lo          loopback  unmanaged  --\\n', 'virbr0-nic  tun       unmanaged  --\\n', '查看配置的连接详情，使用以下命令（使用 -p, --pretty 选项在输出结果中添加标题和分段）：\\n', '\\n', '$ nmcli -p con show net-static \\n', '===============================================================================\\n', 'Connection profile details (net-static )\\n', '===============================================================================\\n', 'connection.id:                          net-static\\n', 'connection.uuid:                        b9f18801-6084-4aee-af28-c8f0598ff5e1\\n', 'connection.stable-id:                   --\\n', 'connection.type:                        802-3-ethernet\\n', 'connection.interface-name:              enp3s0\\n', 'connection.autoconnect:                 yes\\n', 'connection.autoconnect-priority:        0\\n', 'connection.autoconnect-retries:         -1 (default)\\n', 'connection.multi-connect:               0 (default)\\n', 'connection.auth-retries:                -1\\n', 'connection.timestamp:                   1578988781\\n', 'connection.read-only:                   no\\n', 'connection.permissions:                 --\\n', 'connection.zone:                        --\\n', 'connection.master:                      --\\n', 'connection.slave-type:                  --\\n', 'connection.autoconnect-slaves:          -1 (default)\\n', 'connection.secondaries:                 --\\n', 'connection.gateway-ping-timeout:        0\\n', 'connection.metered:                     unknown\\n', 'connection.lldp:                        default\\n', 'connection.mdns:                        -1 (default)\\n', 'connection.llmnr:                       -1 (default)\\n', '添加 Wi-Fi 连接\\n', '有两种方式添加Wi-Fi 连接。\\n', '\\n', '方法1，通过网络接口连接wifi\\n', '\\n', '连接到由SSID或BSSID指定的wifi网络。命令如下，该命令找到匹配的连接或创建一个连接，然后在设备上激活它。\\n', '\\n', '$ nmcli device wifi connect \"$SSID\" password \"$PASSWORD\" ifname \"$IFNAME\"  \\n', '$ nmcli --ask device wifi connect \"$SSID\" \\n', '方法2，通过配置文件连接Wi-Fi\\n', '\\n', '1，使用以下命令查看可用 Wi-Fi 访问点：\\n', '\\n', '$ nmcli dev wifi list\\n', '2，使用以下命令生成使用的静态 IP 配置，但允许自动 DNS 地址分配的 Wi-Fi 连接：\\n', '\\n', '$ nmcli con add con-name Wifi ifname wlan0 type wifi ssid MyWifi ip4 192.168.100.101/24 gw4 192.168.100.1\\n', '3，请使用以下命令设定 WPA2 密码，例如 “answer”：\\n', '\\n', '$ nmcli con modify Wifi wifi-sec.key-mgmt wpa-psk\\n', '$ nmcli con modify Wifi wifi-sec.psk answer\\n', '4，使用以下命令更改 Wi-Fi 状态：\\n', '\\n', '$ nmcli radio wifi [ on | off ]\\n', '更改属性\\n', '请使用以下命令检查具体属性，比如 mtu：\\n', '\\n', \"$ nmcli connection show id 'Wifi ' | grep mtu\\n\", '802-11-wireless.mtu: auto\\n', '使用如下命令更改设置的属性：\\n', '\\n', \"$ nmcli connection modify id 'Wifi ' 802-11-wireless.mtu 1350\\n\", '使用如下命令确认更改：\\n', '\\n', \"$ nmcli connection show id 'Wifi ' | grep mtu\\n\", '802-11-wireless.mtu: 1350\\n', '配置静态路由\\n', '使用nmcli命令为网络连接配置静态路由，使用命令如下：\\n', '\\n', '$ nmcli connection modify enp3s0 +ipv4.routes \"192.168.122.0/24 10.10.10.1\"\\n', '使用编辑器配置静态路由，使用如下命令：\\n', '\\n', '$ nmcli con edit type ethernet con-name enp3s0\\n', '===| nmcli interactive connection editor |===\\n', \"Adding a new '802-3-ethernet' connection\\n\", \"Type 'help' or '?' for available commands.\\n\", \"Type 'describe [<setting>.<prop>]' for detailed property description.\\n\", 'You may edit the following settings: connection, 802-3-ethernet (ethernet), 802-1x, ipv4, ipv6, dcb\\n', 'nmcli> set ipv4.routes 192.168.122.0/24 10.10.10.1\\n', 'nmcli>\\n', 'nmcli> save persistent\\n', \"Saving the connection with 'autoconnect=yes'. That might result in an immediate activation of the connection.\\n\", 'Do you still want to save? [yes] yes\\n', \"Connection 'enp3s0' (1464ddb4-102a-4e79-874a-0a42e15cc3c0) successfully saved.\\n\", 'nmcli> quit\\n', '使用ip命令\\n', ' 说明：\\n', '使用ip命令配置的网络配置可以立即生效但系统重启后配置会丢失。\\n', '\\n', '配置IP地址\\n', '使用ip命令为接口配置地址，命令格式如下，其中 interface-name 为网卡名称。\\n', '\\n', 'ip addr [ add | del ] address dev interface-name\\n', '配置静态地址\\n', '在root权限下，配置设置IP地址，使用示例如下：\\n', '\\n', '# ip address add 192.168.0.10/24 dev enp3s0\\n', '查看配置结果，在root权限使用如下命令：\\n', '\\n', '# ip addr show dev enp3s0\\n', '2: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\\n', '    link/ether 52:54:00:aa:ad:4a brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.202.248/16 brd 192.168.255.255 scope global dynamic noprefixroute enp3s0\\n', '       valid_lft 9547sec preferred_lft 9547sec\\n', '    inet 192.168.0.10/24 scope global enp3s0\\n', '       valid_lft forever preferred_lft forever\\n', '    inet6 fe80::32e8:cc22:9db2:f4d4/64 scope link noprefixroute\\n', '       valid_lft forever preferred_lft forever\\n', '配置多个地址\\n', 'ip 命令支持为同一接口分配多个地址，可在root权限下重复多次使用 ip 命令实现分配多个地址。使用示例如下：\\n', '\\n', '# ip address add 192.168.2.223/24 dev enp4s0\\n', '# ip address add 192.168.4.223/24 dev enp4s0\\n', '# ip addr\\n', '\\n', '3: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\\n', '    link/ether 52:54:00:aa:da:e2 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.203.12/16 brd 192.168.255.255 scope global dynamic noprefixroute enp4s0\\n', '       valid_lft 8389sec preferred_lft 8389sec\\n', '    inet 192.168.2.223/24 scope global enp4s0\\n', '       valid_lft forever preferred_lft forever\\n', '    inet 192.168.4.223/24 scope global enp4s0\\n', '       valid_lft forever preferred_lft forever\\n', '    inet6 fe80::1eef:5e24:4b67:f07f/64 scope link noprefixroute\\n', '       valid_lft forever preferred_lft forever\\n', '配置静态路由\\n', '如果需要静态路由，可使用 ip route add 命令在路由表中添加，使用 ip route del 命令删除。最常使用的 ip route 命令格式如下：\\n', '\\n', 'ip route [ add | del | change | append | replace ] destination-address\\n', '在root权限下使用 ip route 命令显示当前的 IP 路由表。示例如下：\\n', '\\n', '# ip route\\n', '\\n', 'default via 192.168.0.1 dev enp3s0 proto dhcp metric 100\\n', 'default via 192.168.0.1 dev enp4s0 proto dhcp metric 101\\n', '192.168.0.0/16 dev enp3s0 proto kernel scope link src 192.168.202.248 metric 100\\n', '192.168.0.0/16 dev enp4s0 proto kernel scope link src 192.168.203.12 metric 101\\n', '192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 linkdown\\n', '在主机地址中添加一个静态路由，在 root 权限下，使用以下命令格式：\\n', '\\n', 'ip route add 192.168.2.1 via 10.0.0.1 [dev interface-name]\\n', '其中 192.168.2.1 是用点分隔的十进制符号中的 IP 地址，10.0.0.1 是下一个跃点，interface-name 是进入下一个跃点的退出接口。\\n', '\\n', '要在网络中添加一个静态路由，即代表 IP 地址范围的 IP 地址，请在root权限下运行以下命令格式：\\n', '\\n', 'ip route add 192.168.2.0/24 via 10.0.0.1 [dev interface-name]\\n', '其中 192.168.2.1 是目标网络的 IP 地址，10.0.0.1 是网络前缀，interface-name 为网卡名称。\\n', '\\n', '通过ifcfg文件配置网络\\n', ' 说明：\\n', '通过ifcfg文件配置的网络配置不会立即生效，需要在root权限下执行systemctl reload NetworkManager命令以重启网络服务后才生效。\\n', '\\n', '配置静态网络\\n', '以enp4s0网络接口进行静态网络设置为例，通过在root权限下修改ifcfg文件实现，在/etc/sysconfig/network-scripts/目录中生成名为ifcfg-enp4s0的文件中，修改参数配置，示例如下：\\n', '\\n', 'TYPE=Ethernet\\n', 'PROXY_METHOD=none\\n', 'BROWSER_ONLY=no\\n', 'BOOTPROTO=none\\n', 'IPADDR=192.168.0.10\\n', 'PREFIX=24\\n', 'DEFROUTE=yes\\n', 'IPV4_FAILURE_FATAL=no\\n', 'IPV6INIT=yes\\n', 'IPV6_AUTOCONF=yes\\n', 'IPV6_DEFROUTE=yes\\n', 'IPV6_FAILURE_FATAL=no\\n', 'IPV6_ADDR_GEN_MODE=stable-privacy\\n', 'NAME=enp4s0static\\n', 'UUID=08c3a30e-c5e2-4d7b-831f-26c3cdc29293\\n', 'DEVICE=enp4s0\\n', 'ONBOOT=yes\\n', '配置动态网络\\n', '要通过ifcfg文件为em1接口配置动态网络，请按照如下操作在/etc/sysconfig/network-scripts/目录中生成名为 ifcfg-em1 的文件，示例如下：\\n', '\\n', 'DEVICE=em1\\n', 'BOOTPROTO=dhcp\\n', 'ONBOOT=yes\\n', '要配置一个向DHCP服务器发送不同的主机名的接口，请在ifcfg文件中新增一行内容，如下所示：\\n', '\\n', 'DHCP_HOSTNAME=hostname\\n', '要配置忽略由DHCP服务器发送的路由，防止网络服务使用从DHCP服务器接收的DNS服务器更新/etc/resolv.conf。请在ifcfg文件中新增一行内容，如下所示：\\n', '\\n', 'PEERDNS=no\\n', '要配置一个接口使用具体DNS服务器，请将参数PEERDNS=no，并在ifcfg文件中添加以下行：\\n', '\\n', 'DNS1=ip-address\\n', 'DNS2=ip-address\\n', '其中ip-address是DNS服务器的地址。这样就会让网络服务使用指定的DNS服务器更新/etc/resolv.conf。\\n', '\\n', '配置默认网关\\n', '在确定默认网关时，首先解析 /etc/sysconfig/network 文件，然后解析 ifcfg 文件 ，将最后读取的 GATEWAY 的取值作为路由表中的默认路由。\\n', '\\n', '在动态网络环境中，使用 NetworkManager 管理主机时，建议设置为由 DHCP 来分配。\\n', '\\n', '配置主机名\\n', '简介\\n', 'hostname有三种类型：static、transient和pretty。\\n', '\\n', 'static：静态主机名，可由用户自行设置，并保存在/etc/hostname 文件中。\\n', 'transient：动态主机名，由内核维护，初始是 static 主机名，默认值为“localhost”。可由DHCP或mDNS在运行时更改。\\n', 'pretty：灵活主机名，允许使用自由形式（包括特殊/空白字符）进行设置。静态/动态主机名遵从域名的通用限制。\\n', ' 说明：\\n', 'static和transient主机名只能包含a-z、A-Z、0-9、“-”、“_”和“.”，不能在开头或结尾处使用句点，不允许使用两个相连的句点，大小限制为 64 个字符。\\n', '\\n', '使用hostnamectl配置主机名\\n', '查看所有主机名\\n', '查看当前的主机名，使用如下命令：\\n', '\\n', '$ hostnamectl status\\n', ' 说明：\\n', '如果命令未指定任何选项，则默认使用status选项。\\n', '\\n', '设定所有主机名\\n', '在root权限下，设定系统中的所有主机名，使用如下命令：\\n', '\\n', '# hostnamectl set-hostname name\\n', '设定特定主机名\\n', '在root权限下，通过不同的参数来设定特定主机名，使用如下命令：\\n', '\\n', '# hostnamectl set-hostname name [option...]\\n', '其中option可以是--pretty、--static、--transient中的一个或多个选项。\\n', '\\n', '如果--static或--transient与--pretty选项一同使用时，则会将static和transient主机名简化为pretty主机名格式，使用“-”替换空格，并删除特殊字符。\\n', '\\n', '当设定pretty主机名时，如果主机名中包含空格或单引号，需要使用引号。命令示例如下：\\n', '\\n', '# hostnamectl set-hostname \"Stephen\\'s notebook\" --pretty\\n', '清除特定主机名\\n', '要清除特定主机名，并将其还原为默认形式，在root权限下，使用如下命令：\\n', '\\n', '# hostnamectl set-hostname \"\" [option...]\\n', '其中 \"\" 是空白字符串，option是--pretty、--static和--transient中的一个或多个选项。\\n', '\\n', '远程更改主机名\\n', '在远程系统中运行hostnamectl命令时，要使用-H，--host 选项，在root权限下使用如下命令：\\n', '\\n', '# hostnamectl set-hostname -H [username]@hostname new_hostname\\n', '其中hostname是要配置的远程主机，username为自选项，new_hostname为新主机名。hostnamectl会通过SSH连接到远程系统。\\n', '\\n', '使用nmcli配置主机名\\n', '查询static主机名，使用如下命令：\\n', '\\n', '$ nmcli general hostname\\n', '在root权限下，将static主机名设定为host-server，使用如下命令：\\n', '\\n', '# nmcli general hostname host-server\\n', '要让系统hostnamectl感知到static主机名的更改，在root权限下，重启hostnamed服务，使用如下命令：\\n', '\\n', '# systemctl restart systemd-hostnamed\\n', '配置网络绑定\\n', '使用nmcli\\n', '创建名为mybond0的绑定，使用示例如下：\\n', '\\n', '$ nmcli con add type bond con-name mybond0 ifname mybond0 mode active-backup\\n', '添加从属接口，使用示例如下：\\n', '\\n', '$ nmcli con add type bond-slave ifname enp3s0 master mybond0\\n', '要添加其他从属接口，重复上一个命令，并在命令中使用新的接口，使用示例如下：\\n', '\\n', '$ nmcli con add type bond-slave ifname enp4s0 master mybond0\\n', \"Connection 'bond-slave-enp4s0' (05e56afc-b953-41a9-b3f9-0791eb49f7d3) successfully added.\\n\", '要启动绑定，则必须首先启动从属接口，使用示例如下：\\n', '\\n', '$ nmcli con up bond-slave-enp3s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/14)\\n', '$ nmcli con up bond-slave-enp4s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/15)\\n', '现在可以启动绑定，使用示例如下：\\n', '\\n', '$ nmcli con up mybond0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/16)\\n', '使用命令行\\n', '检查是否已安装Bonding内核模块\\n', '在系统中默认已加载相应模块。要载入绑定模块，可在root权限下使用如下命令：\\n', '\\n', '# modprobe --first-time bonding\\n', '显示该模块的信息，可在root权限下使用如下命令：\\n', '\\n', '# modinfo bonding\\n', '更多命令请在root权限下使用modprobe --help查看。\\n', '\\n', '创建频道绑定接口\\n', '要创建绑定接口，可在root权限下通过在 /etc/sysconfig/network-scripts/ 目录中创建名为 ifcfg-bondN 的文件（使用接口号码替换 N，比如 0）。\\n', '\\n', '根据要绑定接口类型的配置文件来编写相应的内容，比如网络接口。接口配置文件示例如下：\\n', '\\n', 'DEVICE=bond0\\n', 'NAME=bond0\\n', 'TYPE=Bond\\n', 'BONDING_MASTER=yes\\n', 'IPADDR=192.168.1.1\\n', 'PREFIX=24\\n', 'ONBOOT=yes\\n', 'BOOTPROTO=none\\n', 'BONDING_OPTS=\"bonding parameters separated by spaces\"\\n', '创建从属接口\\n', '创建频道绑定接口后，必须在从属接口的配置文件中添加 MASTER 和 SLAVE 指令。\\n', '\\n', '例如将两个网络接口enp3s0 和 enp4s0 以频道方式绑定，其配置文件示例分别如下：\\n', '\\n', 'TYPE=Ethernet\\n', 'NAME=bond-slave-enp3s0\\n', 'UUID=3b7601d1-b373-4fdf-a996-9d267d1cac40\\n', 'DEVICE=enp3s0\\n', 'ONBOOT=yes\\n', 'MASTER=bond0\\n', 'SLAVE=yes\\n', 'TYPE=Ethernet\\n', 'NAME=bond-slave-enp4s0\\n', 'UUID=00f0482c-824f-478f-9479-abf947f01c4a\\n', 'DEVICE=enp4s0\\n', 'ONBOOT=yes\\n', 'MASTER=bond0\\n', 'SLAVE=yes\\n', '激活频道绑定\\n', '要激活绑定，则需要启动所有从属接口。请在root权限下，运行以下命令：\\n', '\\n', '# ifup enp3s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)\\n', '# ifup enp4s0\\n', 'Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/8)\\n', ' 说明：\\n', '对于已经处于“up”状态的接口，请首先使用“ifdown enp3s0 ”命令修改状态为down，其中 enp3s0 为实际网卡名称。\\n', '\\n', '完成后，启动所有从属接口以便启动绑定（不将其设定为 “down”）。\\n', '\\n', '要让 NetworkManager 感知到系统所做的修改，在每次修改后，请在root权限下，运行以下命令：\\n', '\\n', '# nmcli con load /etc/sysconfig/network-scripts/ifcfg-device\\n', '查看绑定接口的状态，请在root权限下运行以下命令：\\n', '\\n', '# ip link show\\n', '\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\\n', '    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '2: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\\n', '    link/ether 52:54:00:aa:ad:4a brd ff:ff:ff:ff:ff:ff\\n', '3: enp4s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000\\n', '    link/ether 52:54:00:aa:da:e2 brd ff:ff:ff:ff:ff:ff\\n', '4: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000\\n', '    link/ether 86:a1:10:fb:ef:07 brd ff:ff:ff:ff:ff:ff\\n', '5: virbr0-nic: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel master virbr0 state DOWN mode DEFAULT group default qlen 1000\\n', '    link/ether 52:54:00:29:35:4c brd ff:ff:ff:ff:ff:ff\\n', '创建多个绑定\\n', '系统会为每个绑定创建一个频道绑定接口，包括 BONDING_OPTS 指令。使用这个配置方法可让多个绑定设备使用不同的配置。请按照以下操作创建多个频道绑定接口：\\n', '\\n', '创建多个 ifcfg-bondN 文件，文件中包含 BONDING_OPTS 指令，让网络脚本根据需要创建绑定接口。\\n', '创建或编辑要绑定的现有接口配置文件，添加 SLAVE 指令。\\n', '使用 MASTER 指令工具在频道绑定接口中分配要绑定的接口，即从属接口。\\n', '以下是频道绑定接口配置文件示例：\\n', '\\n', 'DEVICE=bondN\\n', 'NAME=bondN\\n', 'TYPE=Bond\\n', 'BONDING_MASTER=yes\\n', 'IPADDR=192.168.1.1\\n', 'PREFIX=24\\n', 'ONBOOT=yes\\n', 'BOOTPROTO=none\\n', 'BONDING_OPTS=\"bonding parameters separated by spaces\"\\n', '在这个示例中，使用绑定接口的号码替换 N。例如要创建两个接口，则需要使用正确的 IP 地址创建两个配置文件 ifcfg-bond0 和 ifcfg-bond1。\\n', '\\n', 'IPv6使用差异说明（vs IPv4）\\n', '约束限制\\n', 'chrony支持全局地址（global address），不支持链路本地地址（link-local address）。\\n', 'Firefox支持通过http/https协议访问全局地址（global address），不支持链路本地地址（link-local address）。\\n', '配置说明\\n', '设置接口设备MTU值\\n', '概述\\n', 'IPv6场景中会发现整个路由路径中的最小mtu的值作为当前链接的PMTU的值，源端根据PMTU的值确定是否进行分片发送，而在整个路径中的其它设备将不再需要进行分片处理，从而可以降低中间路由设备的负载大小。其中IPv6 PMTU设置的最小值为1280。\\n', '\\n', '设置接口设备的mtu\\n', '如果在配置了IPv6地址的接口上设置mtu的值小于1280（IPv6 PMTU设置的最小值），则会导致该接口的IPv6地址被删除。并且无法再次添加IPv6地址。所以在IPv6场景中，对接口设备的mtu的配置一定要大于等于1280。 请在root权限下运行如下命令查看具体现象：\\n', '\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38663sec preferred_lft 38663sec\\n', '    inet6 2001:222::2/64 scope global\\n', '       valid_lft forever preferred_lft forever\\n', '# ip link set dev enp3s0 mtu 1200\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1200 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38642sec preferred_lft 38642sec\\n', '# ip addr add 2001:222::2/64 dev enp3s0\\n', 'RTNETLINK answers: No buffer space available\\n', '# ip link set dev enp3s0 mtu 1500\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38538sec preferred_lft 38538sec\\n', '# ip addr add 2001:222::2/64 dev enp3s0\\n', '# ip addr show enp3s0\\n', '3: enp3s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\\n', '    link/ether 52:54:00:62:xx:xx brd ff:ff:ff:ff:xx:xx\\n', '    inet 10.41.125.236/16 brd 10.41.255.255 scope global noprefixroute dynamic enp3s0\\n', '       valid_lft 38531sec preferred_lft 38531sec\\n', '    inet6 2001:222::2/64 scope global\\n', '       valid_lft forever preferred_lft forever\\n', '有状态自动配置IPv6地址\\n', '概述\\n', 'IPv6与IPv4都可以在root权限下通过DHCP的方式获得IP地址。IPv6地址有两种配置方式：无状态自动配置和有状态自动配置。\\n', '\\n', '无状态自动配置\\n', '\\n', '不需要DHCP服务进行管理，设备根据网络RA（路由公告）获得网络前缀，或者link-local地址为固定fe80::。而接口ID则根据ifcfg配置IPV6_ADDR_GEN_MODE的具体设置来进行自动获得：\\n', '\\n', 'IPv6_ADDR_GEN_MODE=“stable-privacy” 则根据设备及网络环境来确定一个随机接口ID。\\n', 'IPv6_ADDR_GEN_MODE=“EUI64” 则根据设备MAC地址来确定接口ID。\\n', '有状态自动配置：需要DHCP服务器进行管理分配，服从DHCPv6协议来从DHCPv6服务器端租赁IPv6地址。\\n', '\\n', '在有状态自动配置IPv6地址时，DHCPv6服务端可以通过客户端设置的vendor class将客户端进行分类，不同类别分配不同地址段的IPv6地址。在IPv4场景中，客户端可以直接用dhclient的-V选项来设置vendor-class-identifier，DHCP服务端在配置文件中根据vendor-class-identifier来对客户端进行分类处理。而IPv6场景中，如果使用同样的方法对客户端分类，则分类并不会生效。\\n', '\\n', 'dhclient -6 <interface> -V <vendor-class-identifier string> <interface>\\n', '这是由于DHCPv6和DHCP协议存在较大差异，DHCPv6的可选项中使用vendor-class-option替代了DHCP中的vendor-class-identifier。而dhclient的-V选项并不能设置vendor-class-option。\\n', '\\n', '有状态自动配置IPv6地址时dhclient设置vendor class方法\\n', '在客户端使用配置文件方式添加对vendor class的设置，使用方法如下：\\n', '\\n', '客户端配置文件（/etc/dhcp/dhclient6.conf），文件位置可以自定义，在使用时需要通过dhclient -cf选项来指定配置文件：\\n', '\\n', 'option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};\\n', 'interface \"enp3s0\" {\\n', '        send dhcp6.vendor-class <Enterprise-ID number> <vendor class string length> <vendor class string>;\\n', '}\\n', ' 说明：\\n', '\\n', '<Enterprise-ID number>，32位整型数字，企业标识号，企业通过IANA注册。\\n', '<vendor class string length>，16位整型数字，vendor class字符串长度。\\n', '<vendor class string>，要设置的vendor class字符串，例如：“HWHW”。\\n', '客户端使用方法：\\n', '\\n', 'dhclient -6 <interface> -cf /etc/dhcp/dhclient6.conf\\n', 'DHCPv6服务端配置文件（/etc/dhcp/dhcpd6.conf），需要dhcpd -cf选项来指定该配置文件：\\n', '\\n', 'option dhcp6.vendor-class code 16 = {integer 32, integer 16, string};\\n', 'subnet6 fc00:4:12:ffff::/64 {\\n', '        class \"hw\" {\\n', '                match if substring ( option dhcp6.vendor-class, 6, 10 ) = \"HWHW\";\\n', '        }\\n', '        pool6 {\\n', '                allow members of \"hw\";\\n', '                range6 fc00:4:12:ffff::ff10 fc00:4:12:ffff::ff20;\\n', '        }\\n', '        pool6 {\\n', '                allow unknown clients;\\n', '                range6 fc00:4:12:ffff::100 fc00:4:12:ffff::120;\\n', '        }\\n', '}\\n', ' 说明：\\n', 'substring ( option dhcp6.vendor-class, 6, 10 ) 其中子字符串的开始位置为6，因为前面包含4个字节的<Enterprise-ID number>和2个字节的<string length>。而子字符串的结束位置位：6+<vendor class string length>。这里vendor class string为“HWHW”，字符串的长度为4，所以子字符串的结束位置为6+4=10。用户可以根据实际需要来确定<vendor class string>及相应的<vendor class string length>。\\n', '\\n', '服务端使用方法：\\n', '\\n', 'dhcpd -6 -cf /etc/dhcp/dhcpd6.conf <interface>\\n', '内核支持socket相关系统调用\\n', '概述\\n', 'IPv6地址长度扩展到128比特，所以有足够的IPv6地址可供分配使用。同时IPv6头相比IPv4头进行了简化，并增强了IPv6的自动配置功能。IPv6地址分为单播地址，组播地址和任意播地址。常用的单播地址又包含：链路本地地址（link-local address），唯一本地地址（Unique local address）和全局地址（global address）。由于IPv6的全局地址十分充足，唯一本地地址一般不被使用（其前身为站点本地地址（site-local address），已于2004年被废弃）。当前主要使用的单播地址为：链路本地地址（link-local address）和全局地址（global address）。当前内核支持socket系统调用，在使用单播地址的链路本地地址和全局地址时存在差异。\\n', '\\n', 'link-local地址和global地址在socket调用时的差异\\n', 'RFC 2553： Basic Socket Interface Extensions for IPv6 定义sockaddr_in6的数据结构如下；\\n', '\\n', 'struct sockaddr_in6 {     \\n', '    uint8_t         sin6_len;       /* length of this struct */     \\n', '    sa_family_t     sin6_family;    /* AF_INET6 */     \\n', '    in_port_t       sin6_port;      /* transport layer port # */     \\n', '    uint32_t        sin6_flowinfo;  /* IPv6 flow information */     \\n', '    struct in6_addr sin6_addr;      /* IPv6 address */     \\n', '    uint32_t        sin6_scope_id;  /* set of interfaces for a scope */ \\n', '}; \\n', ' 说明：\\n', 'sin6_scope_id： 32位整型，对于链路本地地址（link-local address），对于链路范围的sin6_addr，它可以用来标识指定的接口索引号。如果是站点范围的sin6_addr，则用来作为站点的标识符（站点本地地址已被抛弃）。\\n', '\\n', '在使用link-local地址进行socket通信时，在构造目的地址时，需要制定该地址所对应的接口索引号。一般可以通过if_nametoindex函数将接口名转化为接口索引号。具体方式如下，\\n', '\\n', 'int port = 1234;\\n', 'int sk_fd;\\n', 'int iff_index = 0;\\n', 'char iff_name[100] = \"enp3s0\";\\n', 'char * ll_addr[100] = \"fe80::123:456:789\";\\n', 'struct sockaddr_in6 server_addr;\\n', '\\n', 'memset(&server_addr,0,sizeof(structsockaddr_in6));\\n', 'iff_index=if_nametoindex(iff_name);\\n', '\\n', 'server_addr.sin6_family=AF_INET6;\\n', 'server_addr.sin6_port=htons(port);\\n', 'server_addr.sin6_scope_id=iff_index;\\n', 'inet_pton(AF_INET6, ll_addr, &(server_addr.sin6_addr));\\n', '\\n', 'sk_fd=socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);\\n', 'connect(sk_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr_in6));\\n', 'IPv4的dhclient守护进程持久化配置\\n', '概述\\n', '通过NetworkManager服务来管理网络服务时，如果接口ifcfg-<interface-name>配置文件中配置了DHCP方式获得IP地址，则相应地NetworkManager服务会拉起dhclient守护进程来通过DHCP协议方式来从DHCP服务器获取IP地址。\\n', '\\n', 'dhclient提供了\"-1\"选项来决定dhclient进程在未获得DHCP服务响应时，是会不断持久化尝试请求地址还是会尝试时间超时后退出。针对IPv4的dhclient守护进程，可以在ifcfg-<interface-name>配置文件中设置PERSISTENT_DHCLIENT来决定是否设置IPv4的dhclient进程的持久化。\\n', '\\n', '约束限制\\n', '当dhclient进程在运行中被杀死，network服务无法自动将其拉起，可靠性需要用户自己保障。\\n', '配置了持久化选项PERSISTENT_DHCLIENT，需要确保有相应的DHCP服务器。如果在拉起network时无可用DHCP服务器，dhclient进程不断尝试发送请求包但无回应，则会导致network服务卡死直到network服务超时失败。由于network服务在拉起多个网卡的IPv4 dhclient进程时，是通过串行的方式来拉起的。如果有网卡配置了持久化而DHCP服务器没有准备好，则会导致network服务在给该网卡获取IPv4地址超时卡死，进而导致后续网卡无法获得IPv4/IPv6地址。\\n', '以上两种约束限制是特殊的应用场景，需要用户自己进行可靠性保障。\\n', '\\n', 'IPv4 DHCP和IPv6 DHCPv6方式获取地址的配置差异\\n', '可以通过配置接口ifcfg-<interface-name>参数来分别实现IPv4和IPv6通过DHCP/DHCPv6协议来动态获取IP地址，具体配置说明如下；\\n', '\\n', 'BOOTPROTO=none|bootp|dhcp\\n', 'DHCPV6C=yes|no\\n', 'PERSISTENT_DHCLIENT=yes|no|1|0\\n', 'BOOTPROTO： none表示静态配置IPv4地址，bootp|dhcp则会拉起DHCP dhclient来动态获取IPv4地址。\\n', '\\n', 'DHCPV6C： no表示静态配置IPv6地址，yes则会拉起DHCPv6 dhclient来动态获取IPv6地址。\\n', '\\n', 'PERSISTENT_DHCLIENT：no|0表示IPv4的dhclient进程配置为“非持久化”，当dhclient向DHCP服务器发送一次请求报文而无响应，则会间隔一段时间后退出，退出值为2。yes|1则表示IPv4的dhclient进程配置为“持久化”，dhclient会向DHCP服务器反复发送请求报文。如果没有配置PERSISTENT_DHCLIENT项，则IPv4的dhclient会默认设置为“持久化”。\\n', '\\n', ' 说明：\\n', 'PERSISTENT_DHCLIENT配置只针对IPv4生效，对IPv6相关dhclient -6进程不生效，IPv6默认不进行持久化配置。\\n', '\\n', 'iproute相关命令配置IPv4与IPv6时的差异说明\\n', '概述\\n', '由于IPv4和IPv6是两个不同的协议标准，iproute相关命令在使用方法上存在一定的差异。本章节主要梳理iproute包中用户经常使用到命令在IPv4和IPv6使用方面的差异，从而可以更好地指导用户使用iproute包中相关命令。\\n', '\\n', 'iproute相关命令均需要在root权限下运行。\\n', '\\n', 'IPv6地址的生命周期\\n', '\\n', 'IPv6状态\\n', '\\n', '解释\\n', '\\n', 'tentative\\n', '\\n', '临时状态：刚添加地址还处于地址重复检测DAD过程\\n', '\\n', 'preferred\\n', '\\n', '首选状态：完成DAD过程，没有收到相应的NA报文，表示该地址没有冲突。\\n', '\\n', 'deprecated\\n', '\\n', '弃用状态：地址有一定的使用时限（valid_lft和preferred_lft），preferred_lft到期后地址会变化deprecated状态。\\n', '\\n', '该状态下的地址不能用于创建新的连接，但是原有的连接可以继续使用。\\n', '\\n', 'invalid\\n', '\\n', '无效状态：使用时限超过preferred_lft一段时间后仍然没有成功进行租约续约，则valid_lft时间到后地址状态会被设置为invalid，表示该地址不可以再被使用。\\n', '\\n', '其它说明：\\n', '\\n', 'preferred_lft：preferred lifetime，地址为首选状态的寿命，preferred_lft没有到期的地址可以用于正常通信使用，若有多个preferred地址则按照内核具体机制选择地址。\\n', 'valid_lft： valid lifetime，地址有效的寿命，在[preferred_lft, valid_lft]时间段内该地址不能被用于新建连接，已经创建的连接继续有效。\\n', 'ip link 命令\\n', '命令：\\n', '\\n', 'ip link set IFNAME mtu MTU\\n', 'IPv6中PMTU的最小值为1280，如果mtu值设置小于1280则会导致IPv6地址丢失。其它设备无法ping通该IPv6地址。\\n', '\\n', 'ip addr命令\\n', '命令：\\n', '\\n', 'ip [-6] addr add IFADDR dev IFNAME\\n', '添加IPv6地址可以选择添加-6选项也可以不添加，ip addr命令会根据具体地址类型来判断是ipv4地址还是IPv6地址。\\n', '\\n', '如果指定“-6”选项，但是IFADDR 是ipv4地址则会有错误返回。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] addr add IFADDR  dev IFNAME [home|nodad]\\n', '[home|nodad] 选项只针对IPv6地址有效。\\n', '\\n', 'home：将该地址指定为RFC 6275中定义的家庭地址。（这是移动节点从家庭链路获取的地址， 是移动节点的永久地址，如果移动节点保持在相同的归属链路中，则各种实体之间的通信照常进行。）\\n', 'nodad：配置该项（仅限IPv6）添加此地址时不执行重复地址检测DAD（RFC 4862）。如果一台设备上多个接口通过nodad配置了多个相同的IPv6地址，则会按照接口顺序使用该IPv6地址。同一个接口上不能添加一个nodad一个非nodad的相同IPv6地址。因为两个地址是一样的，所以会报“RTNETLINK answers: File exists”。\\n', '命令：\\n', '\\n', 'ip [-6] addr del IFADDR dev IFNAME\\n', '删除IPv6地址可以选择添加-6选项也可以不添加，ip addr del命令会根据具体地址类型来判断是ipv4地址还是IPv6地址。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] addr show dev IFNAME [tentative|-tentative|deprecated|-deprecated|dadfailed|-dadfailed|temporary]\\n', '不指定-6选项，则会同时打印IPv4和IPv6地址。指定-6选项则只打印IPv6地址。\\n', '[tentative|-tentative|deprecated|-deprecated|dadfailed|-dadfailed|temporary]，这些选项只针对IPv6，可以根据IPv6地址状态对地址进行筛选查看。\\n', 'tentative：（仅限IPv6）仅列出尚未通过重复地址检测的地址。\\n', '-tentative：（仅限IPv6）仅列出当前未处于重复地址检测过程中的地址。\\n', 'deprecated：（仅限IPv6）仅列出已弃用的地址。\\n', '-deprecated：（仅限IPv6）仅列出未弃用的地址。\\n', 'dadfailed：（仅限IPv6）仅列出重复地址检测失败的地址。\\n', '-dadfailed：（仅限IPv6）仅列出未重复地址检测失败的地址。\\n', 'temporary：（仅限IPv6）仅列出临时地址\\n', 'ip route命令\\n', '命令：\\n', '\\n', 'ip [-6] route add ROUTE [mtu lock MTU]\\n', '-6选项：添加IPv6路由可以选择添加-6选项也可以不添加，ip route命令会根据具体地址类型来判断是IPv4地址还是IPv6地址。\\n', '\\n', 'mtu lock MTU：锁定路由的MTU值。如果不锁定MTU，则MTU的值则可能在PMTUD过程中被内核改变。如果锁定MTU，则不会尝试PMTUD，所有IPv4包都将不设置DF位发出，IPv6包则会按照MTU进行分段处理。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] route del ROUTE\\n', '删除IPv6路由可以选择添加-6选项也可以不添加，ip route命令会根据具体地址类型来判断是IPv4地址还是IPv6地址。\\n', '\\n', 'ip rule命令\\n', '命令：\\n', '\\n', 'ip [-6] rule list\\n', '-6选项：设置-6选项打印IPv6的策略路由，不设置-6选项打印IPv4的策略路由。所以需要根据具体协议类型来配置-6选项。\\n', '\\n', '命令：\\n', '\\n', 'ip [-6] rule [add|del] [from|to] ADDR table TABLE pref PREF\\n', '-6选项：IPv6相关的策略路由表项需要设置-6选项，否则会报错：“Error: Invalid source address.”。相应地，IPv4相关的策略路由表项不可以设置-6选项，否则会报错：“Error: Invalid source address.”。\\n', '\\n', 'NetworkManager服务配置差异说明\\n', '概述\\n', 'NetworkManager服务使用ifup/ifdown的逻辑接口定义进行高级网络设置。其参数大多数都是在/etc/sysconfig/network和/etc/sysconfig/network-scripts/ifcfg-<interface-name>两个配置文件设置。前者为全局设置，后者为指定网卡的设置，当两者有冲突时，后者生效。\\n', '\\n', '配置差异说明\\n', '其中在/etc/sysconfig/network下的配置差异有：\\n', '\\n', '\\n', 'IPv4\\n', '\\n', 'IPv6\\n', '\\n', '含义说明\\n', '\\n', 'NA\\n', '\\n', 'IPV6FORWARDING=yes|no\\n', '\\n', 'IPv6转发，默认不转发。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_AUTOCONF=yes|no\\n', '\\n', 'IPv6转发打开是no，否则是yes。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_ROUTER=yes|no\\n', '\\n', 'IPv6转发打开是yes，否则是no。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_AUTOTUNNEL=yes|no\\n', '\\n', '指定Tunnel为自动隧道模式，默认是no。\\n', '\\n', 'GATEWAY\\n', '\\n', 'IPV6_DEFAULTGW=<IPv6 address[%interface]> (optional)\\n', '\\n', '在IPv6中设置默认网关。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_DEFAULTDEV=<interface> (optional)\\n', '\\n', '指定默认转发的网卡。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_RADVD_PIDFILE=<pid-file> (optional)\\n', '\\n', '默认ipv6_radvd_pid路径：/var/run/radvd/radvd.pid。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_RADVD_TRIGGER_ACTION=startstop|reload|restart|SIGHUP (optional)\\n', '\\n', 'radvd默认触发动作。\\n', '\\n', '而在/etc/sysconfig/network-scripts/ifcfg-<interface-name>下的差异主要有：\\n', '\\n', '\\n', 'IPv4\\n', '\\n', 'IPv6\\n', '\\n', '含义说明\\n', '\\n', 'IPADDRn\\n', '\\n', 'IPV6ADDR=<IPv6 address>[/<prefix length>]\\n', '\\n', 'ip地址。\\n', '\\n', 'PREFIXn\\n', '\\n', 'NA\\n', '\\n', '网络前缀，网络别名和ppp无效，优先级高于NETMASK。\\n', '\\n', 'NETMASKn\\n', '\\n', 'NA\\n', '\\n', '子网掩码，仅用于别名和ppp。\\n', '\\n', 'GATEWAY\\n', '\\n', 'IPV6_DEFAULTGW=<IPv6 address[%interface]> (optional)\\n', '\\n', '默认网关。\\n', '\\n', 'MTU\\n', '\\n', 'IPV6_MTU=<MTU of link> (optional)\\n', '\\n', '默认MTU。\\n', '\\n', 'IPV4_FAILURE_FATAL=yes|no\\n', '\\n', 'IPV6_FAILURE_FATAL\\n', '\\n', '默认值是no。若设置为yes，dhclient失败ifup-eth会直接退出。\\n', '\\n', 'NA\\n', '\\n', 'IPV6_PRIVACY=rfc3041\\n', '\\n', '默认禁用。\\n', '\\n', 'NA\\n', '\\n', 'IPV6INIT=yes|no\\n', '\\n', '默认开启IPv6。\\n', '\\n', 'NA\\n', '\\n', 'IPV6FORWARDING=yes|no\\n', '\\n', '默认关闭，已废弃。\\n', '\\n', 'FAQ\\n', 'iscsi-initiator-utils不支持登录fe80 IPv6地址\\n', '问题现象\\n', '客户端通过IPv6登录iscsi服务端时，使用如“iscsiadm -m node -p ipv6address -l”的命令格式登录，如果是全局地址（global address），直接替换将命令范例中的“ipv6address”替换为全局地址即可；但如果是链路本地地址（link-local address，fe80开头的IPv6地址）则无法使用，因为iscsi-initiator-utils目前机制还不支持用链路本地地址（link-local address）地址登录iscsi服务端。\\n', '\\n', '原因分析\\n', '如果使用格式如“iscsiadm -m node -p fe80::xxxx -l”登录，会登录超时返回，这是因为使用链路本地地址必须指定接口，否则使用iscsi_io_tcp_connect函数调用connect函数会失败，并且产生标准错误码22。\\n', '\\n', '如果使用格式如“iscsiadm -m node -p fe80::xxxx%enp3s0 -l”登录时，iscsi_addr_match函数会将地址“fe80::xxxx%enp3s0”与服务端返回的node信息中的地址“fe80::xxxx”对比，对比结果不匹配，导致登录失败。\\n', '\\n', '因此，iscsi-initiator-utils目前机制还不支持用链路本地地址（link-local address）登录iscsi服务端。\\n', '\\n', '网卡down掉之后，IPv6地址丢失\\n', '问题现象\\n', '通过ip link down+up网卡或ifconfig down+up网卡命令，将网卡down掉之后再上线，查看网卡上配置的ip地址，发现ipv4地址不丢失，而配置的IPv6地址丢失。\\n', '\\n', '原因分析\\n', '内核中的处理逻辑为如果网卡设置为down状态，会清空所有IPv4及IPv6地址，将网卡重新up之后，ipv4地址自动恢复，网卡上自动配置的IPv6链路本地地址也会恢复，但是其他IPv6地址默认会丢失。如果需要保留这些IPv6地址，可以通过“sysctl -w net.ipv6.conf.<网卡名>.keep_addr_on_down=1”来实现。\\n', '\\n', 'bond口已具有多个IPv6地址时，添加或删除IPv6地址耗时过久\\n', '问题现象\\n', '下列方式配置或删除（包括flush）IPv6地址方式，X为动态变化的低16位，并且配置在bond口时，耗时会随已配置的IPv6地址数量成数倍增加。例如由4个物理网卡组成的bond口添加IPv6地址时，单线程添加删除3000 IPv6地址均需大概5分钟，而普通物理网卡耗时在10秒内。\\n', '\\n', 'ip a add/del 192:168::18:X/64 dev DEVICE\\n', '原因分析\\n', 'bond口在添加IPv6地址时，会生成IPv6组播地址，并进行同步到所有的物理网卡上，此耗时会随IPv6数量增加而增加，导致耗时过长。\\n', '\\n', '解决方法\\n', 'IPv6的组播地址是由IPv6地址的低24位与33-33-ff组合生成，组播地址过多会导致添加删除耗时增加，如果生成的组播地址为少量，耗时不会受此影响。\\n', '\\n', '建议添加IPv6地址时，可保持低24位一致，保持高位变动，单网卡中仅需一个网段的一个地址即可与外部正常通信，此配置更符合常规使用。\\n', '\\n', 'Rsyslog在IPv4和IPv6混合使用场景中日志传输延迟\\n', '问题现象\\n', 'rsyslog客户端配置文件同时配置IPv4和IPv6地址，且端口配置相同的情况下，服务端收集log时会概率性出现日志打印延迟。\\n', '\\n', '原因分析\\n', '延迟是因为rsyslog内部存在缓冲队列机制，默认情况下需要缓冲区队列达到一定数量才会写入文件。\\n', '\\n', '解决方法\\n', '可在root权限下通过配置Direct模式，关闭缓冲队列机制解决该问题。在rsyslog远程传输服务端的/etc/rsyslog.d目录下新增的远程传输配置文件中，最开头增加如下配置：\\n', '\\n', '$ActionQueueType Direct\\n', '$MainMsgQueueType Direct\\n', ' 说明：\\n', '\\n', 'Direct模式减少队列大小为1，所以在队列中会保留1条日志到下次日志打印；\\n', 'Direct模式会降低服务器端的rsyslog性能。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_自动部署集群_拆除集群.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/eggo%E6%8B%86%E9%99%A4%E9%9B%86%E7%BE%A4.html", "text_entry": "['拆除集群\\n', '当业务需求下降，不需要原有数量的节点时，可以通过删除集群中的节点，节省系统资源，从而降低成本。当业务不需要集群时，也可以直接删除整个集群。\\n', '\\n', '删除节点\\n', '可以使用命令行删除集群中的节点。例如，删除 k8s-cluster 集群中 IP 地址为 192.168.0.5 和 192.168.0.6 所有节点类型，参考命令如下：\\n', '\\n', '$ eggo -d delete --id k8s-cluster 192.168.0.5 192.168.0.6\\n', '删除整个集群\\n', '说明\\n', '\\n', '删除集群会删除整个集群的数据，且无法恢复，请谨慎操作。\\n', '当前，拆除集群不会清理容器和容器镜像，但若部署 Kubernetes 集群时，配置了需要安装容器引擎，则会清除容器引擎，这可能导致容器运行异常。\\n', '拆除集群过程中可能会打印一些错误信息，一般是由于清理过程中操作集群时反馈了错误的结果导致，集群仍然能够正常拆除\\n', '可以使用命令行方式删除整个集群。例如，删除 k8s-cluster 集群的参考命令如下：\\n', '\\n', '$ eggo -d cleanup --id k8s-cluster\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_操作系统加固概述.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA%E6%A6%82%E8%BF%B0.html", "text_entry": "['操作系统加固概述\\n', '介绍对openEuler系统进行加固的目的和加固方案。\\n', '\\n', '操作系统加固概述\\n', '加固目的\\n', '加固方案\\n', '加固影响\\n', '须知\\n', '由于安全加固对系统至关重要，因此只有root用户允许修改并应用安全加固策略。\\n', '\\n', '加固目的\\n', '操作系统作为信息系统的核心，承担着管理硬件资源和软件资源的重任，是整个信息系统安全的基础。操作系统之上的各种应用，要想获得信息的完整性、机密性、可用性和可控性，必须依赖于操作系统。脱离了对操作系统的安全保护，仅依靠其他层面的防护手段来阻止黑客和病毒等对网络信息系统的攻击，是无法满足安全需求的。\\n', '\\n', '因此，需要对操作系统进行安全加固，构建动态、完整的安全体系，增强产品的安全性，提升产品的竞争力。\\n', '\\n', '加固方案\\n', '本章描述openEuler的安全加固方案，包括加固方式和加固内容。\\n', '\\n', '加固方式\\n', '用户可以通过手动修改加固配置或执行相关命令对系统进行加固，也可以通过加固工具批量修改加固项。openEuler的安全加固工具security tool以openEuler-security.service服务的形式运行。系统首次启动时会自动运行该服务去执行默认加固策略，且自动设置后续开机不启动该服务。\\n', '\\n', '用户可以通过修改security.conf，使用安全加固工具实现个性化安全加固的效果。\\n', '\\n', '加固内容\\n', 'openEuler系统加固内容主要分为以下5个部分：\\n', '\\n', '系统服务\\n', '文件权限\\n', '内核参数\\n', '授权认证\\n', '账号口令\\n', '加固影响\\n', '对文件权限、帐户口令等安全加固，可能造成用户使用习惯变更，从而影响系统的易用性。影响系统易用性的常见加固项请参见表1。\\n', '\\n', '表 1 加固影响说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '建议加固\\n', '\\n', '易用性影响\\n', '\\n', 'openEuler默认是否设置了该加固项\\n', '\\n', '字符界面等待超时限制\\n', '\\n', '当字符界面长时间处在空闲状态，字符界面会自动退出。\\n', '\\n', '说明：\\n', '当用户通过SSH登录，超时时间由/etc/profile文件的TMOUT字段和/etc/ssh/sshd_config文件的ClientAliveInterval字段两个值中较小的值决定。建议加固为300秒。\\n', '\\n', '用户长时间不操作字符界面，字符界面会自动退出。\\n', '\\n', '否\\n', '\\n', '口令复杂度限制\\n', '\\n', '口令长度最小为8位，口令至少包含大写字母、小写字母、数字和特殊字符中的3种。\\n', '\\n', '系统中所有用户不能设置简单的口令，口令必须符合复杂度要求。\\n', '\\n', '否\\n', '\\n', '限定登录失败时的尝试次数\\n', '\\n', '当用户登录系统时，口令连续输错3次，帐户将被锁定60秒，锁定期间不能登录系统。\\n', '\\n', '用户不能随意登录系统，帐户被锁定后必须等待60秒。\\n', '\\n', '是\\n', '\\n', '用户默认umask值限制\\n', '\\n', '设置所有用户的默认umask值为077，使用户创建文件的默认权限为600、目录权限为700。\\n', '\\n', '用户需要按照需求修改指定文件或目录的权限。\\n', '\\n', '是\\n', '\\n', '口令有效期\\n', '\\n', '口令有效期的设置通过修改/etc/login.defs文件实现，加固默认值为口令最大有效期90天，两次修改口令的最小间隔时间为0，口令过期前开始提示天数为7。\\n', '\\n', '口令过期后用户重新登录时，提示口令过期并强制要求修改，不修改则无法进入系统。\\n', '\\n', '否\\n', '\\n', 'su权限限制\\n', '\\n', 'su命令用于在不同帐户之间切换。为了增强系统安全性，有必要对su命令的使用权进行控制，只允许root和wheel群组的帐户使用su命令，限制其他帐户使用。\\n', '\\n', '普通帐户执行su命令失败，必须加入wheel群组才可以su成功。\\n', '\\n', '是\\n', '\\n', '禁止root帐户直接SSH登录系统\\n', '\\n', '设置/etc/ssh/sshd_config文件的PermitRootLogin字段的值为no，用户无法使用root帐户直接SSH登录系统。\\n', '\\n', '用户需要先使用普通帐户SSH登录后，再切换至root帐户。\\n', '\\n', '否\\n', '\\n', 'SSH强加密算法\\n', '\\n', 'SSH服务的MACs和Ciphers配置，禁止对CBC、MD5、SHA1算法的支持，修改为CTR、SHA2算法。\\n', '\\n', '当前Windows下使用的部分低版本的Xshell、PuTTY不支持aes128-ctr、aes192-ctr、aes256-ctr、hmac-sha2-256、hmac-sha2-512算法，可能会出现无法通过SSH登录系统的情况，请使用最新的PuTTY（0.63版本以上）、Xshell（5.0版本及以上版本）登录。\\n', '\\n', '是']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_为安全容器配置网络.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E4%B8%BA%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C.html", "text_entry": "['为安全容器配置网络\\n', 'tap设备网络支持\\n', '安全容器技术是基于Qemu VM实现的，对于物理机系统来说，安全容器就相当于是一个VM，所以安全容器可以在Neutron网络中将VM通过TAP技术接入外部网络。我们这里不需要关心TAP设备的创建和网桥对接等问题，只需要将指定的TAP设备（host已经存在）热插进pause容器的VM，并更新网卡信息即可。\\n', '\\n', '相关命令行如下：\\n', '\\n', '为已经启动的容器添加一个tap网卡（interface）\\n', '\\n', '$ cat ./test-iface.json | kata-runtime kata-network add-iface 6ec7a98 -\\n', '其中：6ec7a98是容器ID的截断,test-infs.json是描述网卡信息的文件，举例如下：\\n', '\\n', '{\\n', '    \"device\": \"tap-test\", \\n', '    \"name\": \"eth-test\", \\n', '    \"IPAddresses\": [\\n', '        {\\n', '            \"address\": \"172.16.0.3\", \\n', '            \"mask\": \"16\"\\n', '        }\\n', '    ], \\n', '    \"hwAddr\":\"02:42:20:6f:a3:69\",\\n', '    \"mtu\": 1500,\\n', '    \"vhostUserSocket\":\"/usr/local/var/run/openvswitch/vhost-user1\",\\n', '    \"queues\":5\\n', '}\\n', '上述json文件中各个字段的含义说明如下：\\n', '\\n', '\\n', '字段\\n', '\\n', '是否可选\\n', '\\n', '说明\\n', '\\n', 'device\\n', '\\n', '必选\\n', '\\n', '设置网卡的主机端名字。支持字母、数字、下划线“\\\\_”、“-” 以及“.”字符，必须以字母开头，且长度不超过15。需要确保同一个宿主机上device不能重复。\\n', '\\n', 'name\\n', '\\n', '必选\\n', '\\n', '设置网卡的容器内名称。支持字母、数字、下划线“\\\\_”、“-” 以及“.”字符，必须以字母开头，且长度不超过15。需要确保同一个Sandbox内name不能重复。\\n', '\\n', 'IPAddresses\\n', '\\n', '可选\\n', '\\n', '设置网卡的IP地址。暂时支持一张网卡配置一个IP，如果不配置IP，则不会在容器内部配置IP。\\n', '\\n', 'hwAddr\\n', '\\n', '必选\\n', '\\n', '设置网卡的mac地址值。\\n', '\\n', 'mtu\\n', '\\n', '必选\\n', '\\n', '设置网卡的mtu值。允许范围为[46, 9600]之间\\n', '\\n', 'vhostUserSocket\\n', '\\n', '可选\\n', '\\n', '设置dpdk轮询socket路径。路径最大长度128字节，命名规则支持数字、字母、“-”。必须以字母开头。\\n', '\\n', 'queues\\n', '\\n', '可选\\n', '\\n', '设置网卡多队列的队列数目。如果不配置，默认为0。\\n', '\\n', 'kata-runtime kata-network add-iface添加网卡命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式插入网卡的信息，json格式内容和传入的网卡信息相同。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-iface <container-id> net.json \\n', '{\"device\":\"tap_test\",\"name\":\"eth-test\",\"IPAddresses\":[{\"Family\":2,\"Address\":\"173.85.100.1\",\"Mask\":\"24\"}],\"mtu\":1500,\"hwAddr\":\"02:42:20:6e:03:01\",\"pciAddr\":\"01.0/00\"}\\n', '命令执行失败：从命令的标准输出返回字符串null。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-iface <container-id> netbad.json 2>/dev/null\\n', 'null\\n', ' 说明：\\n', '当网卡添加成功时，如果为其指定了IP地址，则kata会为新添加的网卡添加一条destination为同网段地址的默认路由，如上例中添加网卡之后容器内有如下路由被添加：\\n', '\\n', '[root@6ec7a98 /]# ip route  \\n', '172.16.0.0/16 dev eth-test proto kernel scope link src 172.16.0.3  \\n', '列出已经添加的网卡\\n', '\\n', '$ kata-runtime kata-network list-ifaces 6ec7a98\\n', '[{\"name\":\"eth-test\",\"mac\":\"02:42:20:6f:a3:69\",\"ip\":[\"172.16.0.3/16\"],\"mtu\":1500}]\\n', '可以查询到我们刚才添加的网卡信息。\\n', '\\n', 'kata-runtime kata-network list-ifaces列出已添加网卡命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式的Pod中所有插入网卡的信息。\\n', '\\n', '如果Pod中插入了多个网卡设备，返回的是一个json数组格式的网卡信息\\n', '\\n', '$ kata-runtime kata-network list-ifaces <container-id>\\n', '[{\"name\":\"container_eth\",\"mac\":\"02:42:20:6e:a2:59\",\"ip\":[\"172.17.25.23/8\"],\"mtu\":1500},{\"name\":\"container_eth_2\",\"mac\":\"02:90:50:6b:a2:29\",\"ip\":[\"192.168.0.34/24\"],\"mtu\":1500}]\\n', '如果Pod中没有插入任何网卡设备，从命令的标准输出返回字符串null。\\n', '\\n', '$ kata-runtime kata-network list-ifaces <container-id>\\n', 'null\\n', '命令执行失败：从命令的标准输出返回字符串null，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network list-ifaces <container-id>\\n', 'null\\n', '为指定网卡添加一条路由\\n', '\\n', '$ cat ./test-route.json | kata-runtime kata-network add-route 6ec7a98 -\\n', '[{\"dest\":\"default\",\"gateway\":\"172.16.0.1\",\"device\":\"eth-test\"}]\\n', 'kata-runtime kata-network add-route为指定网卡添加一条路由命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式的添加的路由信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-route <container-id> route.json \\n', '[{\"dest\":\"177.17.0.0/24\",\"gateway\":\"177.17.25.1\",\"device\":\"netport_test_1\"}]\\n', '命令执行失败：从命令的标准输出返回字符串null，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network add-route <container-id> routebad.json 2>/dev/null\\n', 'null\\n', '字段说明如下：\\n', '\\n', 'dest：设置路由对应的网段。格式为<ip>/<mask>，<ip>必选。分如下3种情况：\\n', '\\n', '配置<ip>/<mask>；\\n', '只配置<ip>，则默认掩码为32；\\n', '若配置了\"dest\":“default”，默认无dest，需传入gateway。\\n', 'gateway：设置路由的下一跳网关。设置\"dest\":“default\"时，gateway必选；其他情况可选。\\n', '\\n', 'device：必选。设置路由对应的网卡名称，最长支持15字符。\\n', '\\n', ' 说明：\\n', '如果为容器内的回环设备lo添加路由时，路由配置文件中的\"device\"字段对应的设备名称为\"lo”。\\n', '\\n', '删除指定路由\\n', '\\n', '$ cat ./test-route.json | kata-runtime kata-network del-route 6ec7a98 -\\n', 'test-route.json字段与添加路由输入json文件的字段相同。\\n', '\\n', 'kata-runtime kata-network del-route删除指定路由命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令的标准输出返回json格式的添加的路由信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-route <container-id> route.json \\n', '[{\"dest\":\"177.17.0.0/24\",\"gateway\":\"177.17.25.1\",\"device\":\"netport_test_1\"}]\\n', '命令执行失败：从命令的标准输出返回字符串null，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-route <container-id> routebad.json 2>/dev/null\\n', 'null\\n', ' 说明：\\n', '\\n', '输入字段中dest为必选，device/gateway均为可选。kata根据不同字段进行模糊匹配，删除对应的路由规则。例如指定了dest为某个IP，则所有该IP的规则都会被删除。\\n', '如果删除的是容器内回环设备lo的路由时，路由配置文件中的\"device\"字段对应的设备名称为\"lo\"。\\n', '删除已经添加的网卡\\n', '\\n', '$ cat ./test-iface.json | kata-runtime kata-network del-iface 6ec7a98 -\\n', ' 说明：\\n', '删除网卡时，仅根据网卡容器内名称（name字段）来删除。即便填写其他字段，kata也不会使用。\\n', '\\n', 'kata-runtime kata-network del-iface删除网卡命令执行返回结果说明：\\n', '\\n', '命令执行成功：从命令标准输出返回null字符串。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-iface <container-id> net.json\\n', 'null\\n', '命令执行失败：从命令标准输出返回删除失败网卡json格式的信息，从命令的标准错误输出返回错误描述信息。\\n', '\\n', '例如：\\n', '\\n', '$ kata-runtime kata-network del-iface <container-id> net.json\\n', '{\"device\":\"tapname_fun_012\",\"name\":\"netport_test_1\",\"IPAddresses\":[{\"Family\":0,\"Address\":\"177.17.0.1\",\"Mask\":\"8\"}],\"mtu\":1500,\"hwAddr\":\"02:42:20:6e:a2:59\",\"linkType\":\"tap\"}\\n', '以上为常用场景和命令行示例，具体命令行接口“附录 > 接口列表”。\\n', '\\n', 'kata IPVS子系统\\n', '安全容器提供添加ipvs命令的接口，支持对容器设置ipvs规则。功能包含对虚拟服务的添加/编辑/删除、对真实服务器的添加/编辑/删除、查询ipvs服务信息、设置连接超时、清理系统连接缓存，并支持对规则的批量导入。\\n', '\\n', '为容器添加一个虚拟服务地址\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--add-service --tcp-service 172.17.0.7:80 --scheduler rr --persistent 3000\" <container-id>\\n', '修改容器虚拟服务参数\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--edit-service --tcp-service 172.17.0.7:80 --scheduler rr --persistent 5000\" <container-id>\\n', '删除容器虚拟服务地址\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--delete-service --tcp-service 172.17.0.7:80\" <container-id>\\n', '为虚拟服务地址添加一个真实服务器\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--add-server --tcp-service 172.17.0.7:80 --real-server 172.17.0.4:80 --weight 100\" <container-id>\\n', '修改容器真实服务器参数\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--edit-server --tcp-service 172.17.0.7:80 --real-server 172.17.0.4:80 --weight 200\" <container-id>\\n', '删除容器真实服务器\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--delete-server --tcp-service 172.17.0.7:80 --real-server 172.17.0.4:80\" <container-id>\\n', '查询服务信息\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--list\" <container-id>\\n', '逐条导入耗时太久，可将规则写入文件后，批量导入\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --restore -  <  <规则文件路径> <container-id>\\n', ' 说明：\\n', '单条添加时默认使用NAT模式，批量导入时添加真实服务器需手动添加-m参数使用NAT模式。\\n', '规则文件内容示例：\\n', '-A -t 10.10.11.12:100 -s rr -p 3000\\n', '-a -t 10.10.11.12:100 -r 172.16.0.1:80 -m\\n', '-a -t 10.10.11.12:100 -r 172.16.0.1:81 -m\\n', '-a -t 10.10.11.12:100 -r 172.16.0.1:82 -m\\n', '\\n', '清理系统连接缓存\\n', '\\n', 'kata-runtime kata-ipvs cleanup --parameters \"--orig-dst 172.17.0.4 --protonum tcp\" <container-id>\\n', '为tcp/tcpfin/udp连接设置超时\\n', '\\n', 'kata-runtime kata-ipvs ipvsadm --parameters \"--set 100 100 200\" <container-id>\\n', ' 说明：\\n', '\\n', '每个容器支持iptables规则数量最大为20000条（5k service，3个server/service），add-service和add-server都算作规则。\\n', '批量导入前需清空已有规则。\\n', '不存在并发测试场景。\\n', '以上为常用命令示例，具体命令行接口请参见“附录 > 接口列表”。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_本地卷管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%9C%AC%E5%9C%B0%E5%8D%B7%E7%AE%A1%E7%90%86.html", "text_entry": "['本地卷管理\\n', '本地卷管理\\n', '概述\\n', '注意事项\\n', '使用方法\\n', '使用-v参数挂载数据\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '使用–mount参数挂载数据\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '复用其他容器中的挂载配置\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '使用镜像中的匿名卷\\n', '卷的查询\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '卷的删除\\n', '命令格式\\n', '功能描述\\n', '参数说明\\n', '示例\\n', '注意事项\\n', '冲突合并规则\\n', 'iSula和Docker的差异\\n', '概述\\n', 'iSula 管理的容器销毁后，容器内自身所有的数据都会被销毁。如果用户希望容器销毁后依然保留数据，则需要有一种持久化数据的机制。iSula 允许将主机上的文件、目录或卷在容器运行时挂载到容器内。用户可以将需要持久化的数据写入容器内的挂载点。则容器销毁后，主机上的文件、目录、卷依然保留。如果用户需要销毁主机上的文件、目录、卷，可以手动删除文件、目录或者执行 iSula 的相关命令删除卷。对于卷的管理目前 iSula 只支持本地卷，本地卷又分为有名卷和匿名卷。由用户指定名称生产的卷叫有名卷，用户没有指定卷名称，由 iSula 自动生成卷名（一个64位的随机数）的卷为匿名卷。\\n', '\\n', '本章介绍通过 iSula 管理本地卷的使用方法。\\n', '\\n', '注意事项\\n', '卷名称长度2-64个字符，符合正则表达式：^[a-zA-Z0-9][a-zA-Z0-9_.-]{1,63}$，即卷名称首字符必须为字母或者数字，从第二个字符开始可以为字母、数字或者\"_\"、\".\"、\"-“这几个字符。\\n', '创建容器时，如果卷对应的容器内的挂载点存在数据，则默认会拷贝到卷里。如果拷贝过程中出现了 iSula 崩溃重启或者系统掉电之类的异常，则卷内的数据可能是不完整的，这时需要手动删除卷或者卷内数据，确保数据的正确完整。\\n', '使用方法\\n', '使用-v参数挂载数据\\n', '命令格式\\n', 'isula run -v [SRC:]DST[:MODE,MODE...] IMAGE\\n', '功能描述\\n', '使用 create / run 创建并运行容器时，使用 -v/–volume 参数将主机上的文件、目录或者卷挂载到容器内用于数据持久化。\\n', '\\n', '参数说明\\n', 'SRC: 用于挂载的文件、目录或者卷在主机上的路径，当值为绝对路径时，表示挂载主机上的文件或者文件夹。当值为卷名时，表示挂载卷。当省略该项时，表示挂载匿名卷。当文件夹或者卷不存在时，iSula会先创建一个新的文件夹/卷，再进行挂载操作。\\n', 'DST: 容器内的挂载路径，必须为绝对路径。\\n', 'MODE: 当挂载的源是目录或者文件时，合法的参数是ro/rw/z/Z/private/rprivate/slave/rslave/shared/rshared。同类型的参数只能配置一个。当挂载的源是卷时，合法的参数是ro/rw/z/Z/nocopy，同类型的参数只能配置一个。多个属性之间使用”,“连接。参数含义如下：\\n', '参数\\t参数含义\\n', 'ro\\t容器内挂载点挂载为只读属性\\n', 'rw\\t容器内挂载点挂载为读写属性\\n', 'z\\t如果开启了SELinux，则挂载时添加SELinux共享标签\\n', 'Z\\t如果开启了SELinux，则挂载时添加SELinux私有标签\\n', 'private\\t容器内挂载点挂载为私有传播属性\\n', 'rprivate\\t容器内挂载点递归挂载为私有传播属性\\n', 'slave\\t容器内挂载点挂载为从属传播属性\\n', 'rslave\\t容器内挂载点递归挂载为从属传播属性\\n', 'shared\\t容器内挂载点挂载为共享传播属性\\n', 'rshared\\t容器内挂载点递归挂载为共享传播属性\\n', 'nocopy\\t不拷贝挂载点内的数据，该参数不进行配置时默认会拷贝数据。另外，如果卷里已经有数据了，也不会进行拷贝\\n', '示例\\n', '基于 busybox 运行容器并创建/挂载名称为 vol 的卷到容器的 /vol 目录，同时配置挂载点为只读，并且如果容器中对应挂载点有数据也不进行拷贝。\\n', '\\n', 'isula run -v vol:/vol:ro,nocopy busybox\\n', '使用–mount参数挂载数据\\n', '命令格式\\n', 'isula run --mount [type=TYPE,][src=SRC,]dst=DST[,KEY=VALUE] busybox\\n', '功能描述\\n', '使用 create / run 创建并运行容器时，使用 –mount 参数将主机上的文件、目录、卷或者文件系统挂载到容器内用于数据持久化。\\n', '\\n', '参数说明\\n', 'type: 挂载到容器中的数据的类型，类型可以是 bind、volume、squashfs, 省略该项时默认为volume类型。\\n', 'src: 用于挂载的文件、目录或者卷在主机上的路径。当值为绝对路径时，表示挂载主机上的文件或者目录。当值为卷名时，表示挂载卷。当省略该项时，表示匿名卷。当文件夹或者卷不存在时，iSula会先创建一个新的文件/卷，再进行挂载操作。该项的关键字 src 也可以写成 source。\\n', 'dst: 容器内的挂载路径，必须为绝对路径。该项的关键字 dst 也可以写成 destination 或者 target。\\n', 'KEY=VALUE: 表示 –mount 的参数，可以取如下值：\\n', 'KEY 值\\tVALUE\\n', 'selinux-opts/bind-selinux-opts\\tz或者Z。z表示如果开启了SElinux，则挂载时添加SElinux共享标签；Z表示如果开启了SElinux，则挂载时添加SElinux私有标签\\n', 'ro/readonly\\t0/false 表示挂载成读写属性，1/true 表示挂载成只读属性。该项的值可以省略表示挂载成只读。该项只在 type=bind 时支持配置该参数\\n', 'volume-nocopy\\t不拷贝挂载点内的数据，该参数不进行配置时默认会拷贝数据。另外，如果卷里已经有数据了，也不会进行拷贝。只在 type=volume 时支持该参数\\n', '示例\\n', '基于 busybox 运行容器并创建/挂载名称为 vol 的卷到容器的 /vol 目录，同时配置挂载点为只读，并且如果容器中对应挂载点有数据也不进行拷贝。\\n', '\\n', 'isula run --mount type=volume,src=vol,dst=/vol,ro=true,volume-nocopy=true busybox\\n', '复用其他容器中的挂载配置\\n', '命令格式\\n', 'isula run --volumes-from CON1[:MODE] busybox\\n', '功能描述\\n', '使用 create / run 创建并运行容器时，使用 –volumes-from 参数表示挂载点配置包括CON1容器的挂载点配置。可以配置多个 –volumes-from 参数。\\n', '\\n', '参数说明\\n', 'CON1: 被复用挂载点的容器的名称或者ID。\\n', 'MODE: 值为ro表示复用的挂载点挂载为只读属性，值为rw表示复用的挂载点挂载为读写属性。\\n', '示例\\n', '假设已经有名称为 container1 的容器配置了卷 vol1 到容器目录 /vol1，名称为 container2 的容器配置了卷 vol2 到容器目录 /vol2。现在运行一个新的容器复用 container1 和 container2 的挂载配置，即卷 vol1 挂载到容器的 /vol1 目录，vol2 挂载到容器的 /vol2 目录。\\n', '\\n', 'isula run --volumes-from container1 --volumes-from container2 busbyox\\n', '使用镜像中的匿名卷\\n', '使用镜像中的匿名卷不需要用户做任何配置。如果镜像中配置了匿名卷，则在运行容器时 iSula 会自动创建一个匿名卷并挂载到镜像中指定的路径供用户使用。用户可以往容器中的匿名卷挂载点写入数据进行数据持久化。\\n', '\\n', '卷的查询\\n', '命令格式\\n', 'isula volume ls [OPTIONS]\\n', '功能描述\\n', '查询 iSula 管理的所有卷。\\n', '\\n', '参数说明\\n', 'OPTIONS 可选参数：\\n', '\\n', '-q,–quit: 如果不加这个参数，默认只会查询到卷的驱动信息和卷的名称，添加该参数表示只查询卷的名称。\\n', '示例\\n', '查询 iSula 管理的所有卷，只返回卷名称。\\n', '\\n', 'isula volume ls -q\\n', '卷的删除\\n', '命令格式\\n', 'isula volume rm [OPTIONS] VOLUME [VOLUME...]\\n', 'isula volume prune [OPTIONS]\\n', '功能描述\\n', 'rm 命令：删除指定的卷，如果卷被容器使用了，则会删除失败。\\n', 'prune 命令：删除所有未被容器使用的卷。\\n', '参数说明\\n', 'prune 命令的 OPTIONS 可选参数:\\n', '\\n', '-f,–force: 表示不弹出“确认是否要删除”的提示，默认会有风险提示，需要输入 y 才能继续执行。\\n', '示例\\n', '删除卷 vol1 和卷 vol2\\n', '\\n', 'isula volume rm vol1 vol2\\n', '删除所有未被使用的卷，不弹出风险提示，格式如下：\\n', '\\n', 'isula volume prune -f\\n', '注意事项\\n', '冲突合并规则\\n', '如果卷的挂载点有冲突，则按照如下规则处理：\\n', '\\n', '-v 和 –mount 的配置冲突，则返回失败。\\n', '–volumes-from 里获取的配置，如果和 -v/–mount 配置有冲突，则丢弃。\\n', '镜像中的匿名卷配置，如果和 -v/–mount/–volumes-from 配置有冲突，则丢弃。\\n', 'iSula和Docker的差异\\n', 'iSula行为\\tDocker行为\\n', '卷名称最长64个字符\\t卷名称长度没有限制\\n', '–mount 参数，如果挂载的源不存在，则会创建\\t–mount 参数，如果挂载的源不存在，则会报错\\n', '–mount 参数，支持 bind-selinux-opts 和 selinux-opts 参数配置 z/Z\\t–mount 参数，不支持 bind-selinux-opts 和 selinux-opts 参数\\n', '挂载点冲突合并规则，不做特殊处理\\t挂载点冲突合并规则，将 -v 指定的匿名卷当成镜像中的匿名卷一样处理\\n', 'volume prune 命令，提示回收了多少空间\\tvolume prune 命令，不会提示回收了多少空间\\n', '-v/–mount/–volumes-from 配置在 hostconfig 中，匿名卷配置在 config 中\\t-v 配置的匿名卷放在 config 配置中，其他配置在 hostconfig 中\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_StratoVirt介绍.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/StratoVirt%E4%BB%8B%E7%BB%8D.html", "text_entry": "['StratoVirt介绍\\n', '概述\\n', 'StratoVirt是计算产业中面向云数据中心的企业级虚拟化平台，实现了一套架构统一支持虚拟机、容器、Serverless三种场景。StratoVirt在轻量低噪、软硬协同、Rust语言级安全等方面具备核心竞争力，在架构设计上预留了组件化拼装的能力和接口，可以按需灵活组装高级特性直至演化到支持标准虚拟化，在特性需求、应用场景和轻快灵巧之间达到平衡。\\n', '\\n', '架构说明\\n', 'StratoVirt核心架构自顶向下分为三层：\\n', '\\n', '外部接口：兼容QMP（QEMU Monitor Protocol）协议，具有完备的OCI兼容能力，同时支持对接libvirt。\\n', 'BootLoader：轻量化场景下抛弃传统BIOS+GRUB的启动模式实现快速启动，同时标准虚拟化场景下支持UEFI启动。\\n', '模拟主板：\\n', 'microvm: 充分利用软硬协同能力，精简化设备模型，低时延资源伸缩能力。\\n', '标准机型：提供ACPI表实现UEFI启动，支持添加virtio-pci以及VFIO直通设备等，极大提高虚拟机的I/O性能。\\n', '整体架构视图如图1所示。\\n', '\\n', '图1 StratoVirt整体架构图\\n', '\\n', '\\n', '\\n', '特性\\n', '基于硬件的高隔离能力；\\n', '快速冷启动：得益于极简设计，StratoVirt可以在50ms内启动microvm机型；\\n', '低内存开销： StratoVirt的内存占用小于4MB ；\\n', 'IO增强： StratoVirt提供普通IO能力与极简IO设备仿真；\\n', 'OCI兼容性：StratoVirt与isula和kata容器配合使用，可以完美融入Kubernetes生态系统；\\n', '多平台支持：全面支持Intel和ARM平台；\\n', '可扩展性：StratoVirt保留接口和设计，用于导入更多特性，甚至扩展到标准虚拟化支持；\\n', '安全性：运行时系统调用数小于46；\\n', '实现\\n', '运行架构\\n', 'StratoVirt虚拟机是Linux中一个独立的进程。进程有三种线程：主线程、VCPU线程、I/O线程：\\n', '主线程是异步收集和处理来自外部模块（如VCPU线程）的事件的循环；\\n', '每个VCPU都有一个线程处理本VCPU的trap事件；\\n', '可以为I/O设备配置iothread提升I/O性能；\\n', '约束\\n', '仅支持Linux操作系统，推荐内核版本为4.19, 5.10；\\n', '虚拟机操作系统仅支持Linux，内核版本建议为4.19, 5.10；\\n', '最大支持254个CPU；\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_安装 Kubernetes 软件包.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%AE%89%E8%A3%85Kubernetes%E8%BD%AF%E4%BB%B6%E5%8C%85.html", "text_entry": "['安装 Kubernetes 软件包\\n', '$ dnf install -y docker conntrack-tools socat\\n', 'EPOL 之后，可以直接通过 dnf 安装 K8S\\n', '\\n', '$ rpm -ivh kubernetes*.rpm']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_安全加固工具.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%E5%B7%A5%E5%85%B7.html", "text_entry": "['安全加固工具\\n', '安全加固工具\\n', '加固操作\\n', '加固生效\\n', '加固操作\\n', '概述\\n', '安全加固工具会根据usr-security.conf设置加固策略，使用加固工具设置加固策略需要用户修改usr-security.conf。本节介绍usr-security.conf的修改规则。用户可配置的加固项请参见加固指导对应内容。\\n', '\\n', '注意事项\\n', '修改配置后，需要重启安全加固服务使配置生效。重启方法请参见加固生效对应内容。\\n', '用户修改加固配置时，仅修改/etc/openEuler_security/usr-security.conf文件，不建议修改/etc/openEuler_security/security.conf。security.conf中为基本加固项，仅运行一次。\\n', '当重启安全加固服务使配置生效后，在usr-security.conf中删除对应加固项并重启安全加固服务并不能清除之前的配置。\\n', '安全加固操作记录在日志文件/var/log/openEuler-security.log中。\\n', '配置格式\\n', 'usr-security.conf中的每一行代表一项配置，根据配置内容的不同有不同配置格式，这里给出各类配置的格式说明。\\n', '\\n', ' 说明：\\n', '\\n', '所有配置项以执行ID开头，执行ID仅为了方便用户识别配置内容，取值为正整数，由用户自行定义。\\n', '配置项的各内容之间使用@作为分隔符。\\n', '若实际配置内容中包含@，需要使用@@表示以和分隔符区分，例如实际内容为xxx@yyy，则配置为xxx@@yyy。目前不支持@位于配置内容的开头和结尾。\\n', 'd：注释\\n', '\\n', '格式：执行ID@d@对象文件@匹配项\\n', '\\n', '功能：将对象文件中以匹配项开头（行首可以有空格）的行注释（在行首添加#）。\\n', '\\n', '示例：执行ID为401，注释/etc/sudoers文件中以%wheel开头的行。\\n', '\\n', '401@d@/etc/sudoers@%wheel\\n', 'm：替换\\n', '\\n', '格式：执行ID@m@对象文件@匹配项@替换目标值\\n', '\\n', '功能：将对象文件中以匹配项开头（行首可以有空格）的行替换为“匹配项加替换目标值 ”。若匹配行开头有空格，替换后将删除这些空格。\\n', '\\n', '示例：执行ID为101，将/etc/ssh/sshd_config文件中以Protocol 开头的行替换为Protocol 2。匹配和替换时也会考虑Protocol后的空格。\\n', '\\n', '101@m@/etc/ssh/sshd_config@Protocol @2\\n', 'sm：精确修改\\n', '\\n', '格式：执行ID@sm@对象文件@匹配项@替换目标值\\n', '\\n', '功能：将对象文件中以匹配项开头（行首可以有空格）的行替换为“匹配项加替换目标值 ”。若匹配行开头有空格，替换后将保留这些空格，这是sm和m的区别。\\n', '\\n', '示例：执行ID为201，将/etc/audit/hzqtest文件中以size开头的行替换为size 2048。\\n', '\\n', '201@sm@/etc/audit/hzqtest@size@ 2048\\n', 'M：修改子项\\n', '\\n', '格式：执行ID@M@对象文件@匹配项@匹配子项[@匹配子项的值]\\n', '\\n', '功能：匹配对象文件中以匹配项开头（行首可以有空格）的行，并将该行中以匹配子项开始的内容替换为“匹配子项和匹配子项的值”，其中匹配子项的值可选。\\n', '\\n', '示例：执行ID为101，找到file文件中以key开头的行，并将这些行中以key2开始的内容替换为key2value2。\\n', '\\n', '101@M@file@key@key2@value2\\n', 'systemctl：管理服务\\n', '\\n', '格式：执行ID@systemctl@对象服务@具体操作\\n', '\\n', '功能：使用systemctl管理对象服务，具体操作可取值为start、stop、restart、disable等systemctl所有可用的命令。\\n', '\\n', '示例：执行ID为218，停止cups.service服务，等同于systemctl stop cups.service的配置行。\\n', '\\n', '218@systemctl@cups.service@stop\\n', '其他命令\\n', '\\n', '格式：执行ID@命令@对象文件\\n', '\\n', '功能：执行对应命令，即执行命令行“命令 对象文件”。\\n', '\\n', '示例一：执行ID为402，使用rm -f命令删除文件/etc/pki/ca-trust/extracted/pem/email-ca-bundle.pem。\\n', '\\n', '402@rm -f @/etc/pki/ca-trust/extracted/pem/email-ca-bundle.pem\\n', '示例二：执行ID为215，使用touch命令创建文件/etc/cron.allow。\\n', '\\n', '215@touch @/etc/cron.allow\\n', '示例三：执行ID为214，使用chown命令将文件/etc/at.allow的属主改为root:root。\\n', '\\n', '214@chown root:root @/etc/at.allow\\n', '示例四：执行ID为214，使用chmod命令去除文件/etc/at.allow属主所在群组及其他非属主用户的rwx权限。\\n', '\\n', '214@chmod og-rwx @/etc/at.allow\\n', '加固生效\\n', '完成修改usr-security.conf文件后，请运行如下命令使新添加的配置生效。\\n', '\\n', 'systemctl restart openEuler-security.service\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_基础配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html", "text_entry": "['基础配置\\n', '基础配置\\n', '设置语言环境\\n', '显示当前语言环境状态\\n', '列出可用的语言环境\\n', '设置语言环境\\n', '设置键盘\\n', '显示当前设置\\n', '列出可用的键盘布局\\n', '设置键盘布局\\n', '设置日期和时间\\n', '使用timedatectl命令设置\\n', '使用date命令设置\\n', '使用hwclock命令设置\\n', '设置kdump\\n', '设置kdump预留内存\\n', '预留内存推荐值\\n', '禁用网络相关驱动\\n', '设置磁盘调度算法\\n', '临时修改调度策略\\n', '永久设置调度策略\\n', '设置语言环境\\n', '您可以通过localectl修改系统的语言环境，对应的参数设置保存在/etc/locale.conf文件中。这些参数会在系统启动过程中被systemd的守护进程读取。\\n', '\\n', '显示当前语言环境状态\\n', '显示当前语言环境，命令如下：\\n', '\\n', '$ localectl status\\n', '例如显示系统当前的设置，命令和输出如下：\\n', '\\n', '$ localectl status\\n', '   System Locale: LANG=zh_CN.UTF-8\\n', '       VC Keymap: cn\\n', '      X11 Layout: cn\\n', '列出可用的语言环境\\n', '显示当前可用的语言环境，命令如下：\\n', '\\n', '$ localectl list-locales\\n', '例如显示当前系统中所有可用的中文环境，命令和输出如下：\\n', '\\n', '$ localectl list-locales | grep zh\\n', 'zh_CN.UTF-8\\n', '设置语言环境\\n', '要设置语言环境，在root权限下执行如下命令，其中 locale 是您要设置的语言类型，取值范围可通过localectl list-locales获取，请根据实际情况修改。\\n', '\\n', '# localectl set-locale LANG=locale\\n', '例如设置为简体中文语言环境，在root权限下执行如下命令：\\n', '\\n', '# localectl set-locale LANG=zh_CN.UTF-8\\n', ' 说明：\\n', '修改后需要重新登录或者在root权限下执行source /etc/locale.conf命令刷新配置文件，使修改生效。\\n', '\\n', '设置键盘\\n', '您可以通过localectl修改系统的键盘设置，对应的参数设置保存在/etc/locale.conf文件中。这些参数，会在系统启动的早期被systemd的守护进程读取。\\n', '\\n', '显示当前设置\\n', '显示当前键盘设置，命令如下：\\n', '\\n', '$ localectl status\\n', '例如显示系统当前的设置，命令和输出如下：\\n', '\\n', '$ localectl status\\n', '   System Locale: LANG=zh_CN.UTF-8\\n', '       VC Keymap: cn\\n', '      X11 Layout: cn\\n', '列出可用的键盘布局\\n', '显示当前可用的键盘布局，命令如下：\\n', '\\n', '$ localectl list-keymaps\\n', '例如显示系统当前的中文键盘布局，命令和输出如下：\\n', '\\n', '$ localectl list-keymaps | grep cn\\n', 'cn\\n', '设置键盘布局\\n', '设置键盘布局，在root权限下执行如下命令，其中 map 是您想要设置的键盘类型，取值范围可通过localectl list-keymaps获取，请根据实际情况修改：\\n', '\\n', '# localectl set-keymap map\\n', '此时设置的键盘布局同样也会应用到图形界面中。\\n', '\\n', '设置完成后，查看当前状态：\\n', '\\n', '$ localectl status\\n', '   System Locale: LANG=zh_CN.UTF-8\\n', '       VC Keymap: cn\\n', '      X11 Layout: us\\n', '设置日期和时间\\n', '本节介绍如何通过timedatectl、date、hwclock命令来设置系统的日期、时间和时区等。\\n', '\\n', '使用timedatectl命令设置\\n', '显示日期和时间\\n', '显示当前的日期和时间，命令如下：\\n', '\\n', '$ timedatectl\\n', '例如显示系统当前的日期和时间，命令和输出如下：\\n', '\\n', '$ timedatectl\\n', '               Local time: Mon 2019-09-30 04:05:00 EDT\\n', '           Universal time: Mon 2019-09-30 08:05:00 UTC\\n', '                 RTC time: Mon 2019-09-30 08:05:00\\n', '                Time zone: America/New_York (EDT, -0400)\\n', 'System clock synchronized: no\\n', '              NTP service: inactive\\n', '          RTC in local TZ: no\\n', '通过远程服务器进行时间同步\\n', '您可以启用NTP远程服务器进行系统时钟的自动同步。是否启用NTP，可在root权限下执行如下命令进行设置。其中 boolean 可取值yes和no，分别表示启用和不启用NTP进行系统时钟自动同步，请根据实际情况修改。\\n', '\\n', ' 说明：\\n', '若启用了NTP远程服务器进行系统时钟自动同步，则不能手动修改日期和时间。若需要手动修改日期或时间，则需确保已经关闭NTP系统时钟自动同步。可执行timedatectl set-ntp no命令进行关闭。\\n', '\\n', '# timedatectl set-ntp boolean\\n', '例如开启自动远程时间同步，命令如下：\\n', '\\n', '# timedatectl set-ntp yes\\n', '修改日期\\n', ' 说明：\\n', '修改日期前，请确保已经关闭NTP系统时钟自动同步。\\n', '\\n', '修改当前的日期，在root权限下执行如下命令，其中 YYYY 代表年份，MM 代表月份，DD 代表某天，请根据实际情况修改：\\n', '\\n', '# timedatectl set-time YYYY-MM-DD\\n', '例如修改当前的日期为2019年8月14号，命令如下：\\n', '\\n', \"# timedatectl set-time '2019-08-14'\\n\", '修改时间\\n', ' 说明：\\n', '修改时间前，请确保已经关闭NTP系统时钟自动同步。\\n', '\\n', '修改当前的时间，在root权限下执行如下命令，其中 HH 代表小时，MM 代表分钟，SS 代表秒，请根据实际情况修改：\\n', '\\n', '# timedatectl set-time HH:MM:SS\\n', '例如修改当前的时间为15点57分24秒，命令如下：\\n', '\\n', '# timedatectl set-time 15:57:24\\n', '修改时区\\n', '显示当前可用时区，命令如下：\\n', '\\n', '$ timedatectl list-timezones\\n', '要修改当前的时区，在root权限下执行如下命令，其中 time_zone 是您想要设置的时区，请根据实际情况修改：\\n', '\\n', '# timedatectl set-timezone time_zone\\n', '例如修改当前的时区，首先查询所在地域的可用时区，此处以Asia为例：\\n', '\\n', '# timedatectl list-timezones | grep Asia\\n', 'Asia/Aden\\n', 'Asia/Almaty\\n', 'Asia/Amman\\n', 'Asia/Anadyr\\n', 'Asia/Aqtau\\n', 'Asia/Aqtobe\\n', 'Asia/Ashgabat\\n', 'Asia/Baghdad\\n', 'Asia/Bahrain\\n', '……\\n', '\\n', 'Asia/Seoul\\n', 'Asia/Shanghai\\n', 'Asia/Singapore\\n', 'Asia/Srednekolymsk\\n', 'Asia/Taipei\\n', 'Asia/Tashkent\\n', 'Asia/Tbilisi\\n', 'Asia/Tehran\\n', 'Asia/Thimphu\\n', 'Asia/Tokyo\\n', '然后修改当前的时区为“Asia/Shanghai”，命令如下：\\n', '\\n', '# timedatectl set-timezone Asia/Shanghai\\n', '使用date命令设置\\n', '显示当前的日期和时间\\n', '显示当前的日期和时间，命令如下：\\n', '\\n', '$ date\\n', '默认情况下，date命令显示本地时间。要显示UTC时间，添加--utc或-u参数：\\n', '\\n', '$ date --utc\\n', '要自定义对应的输出信息格式，添加 +“format” 参数：\\n', '\\n', '$ date +\"format\"\\n', '表 1 参数说明\\n', '\\n', '\\n', '格式参数\\n', '\\n', '说明\\n', '\\n', '%H\\n', '\\n', '小时以HH格式（例如 17）。\\n', '\\n', '%M\\n', '\\n', '分钟以MM格式（例如 37）。\\n', '\\n', '%S\\n', '\\n', '秒以SS格式（例如 25）。\\n', '\\n', '%d\\n', '\\n', '日期以DD格式（例如 15）。\\n', '\\n', '%m\\n', '\\n', '月份以MM格式（例如 07）。\\n', '\\n', '%Y\\n', '\\n', '年份以YYYY格式（例如 2019）。\\n', '\\n', '%Z\\n', '\\n', '时区缩写（例如CEST）。\\n', '\\n', '%F\\n', '\\n', '日期整体格式为YYYY-MM-DD（例如 2019-7-15），等同%Y-%m-%d。\\n', '\\n', '%T\\n', '\\n', '时间整体格式为HH:MM:SS（例如 18:30:25），等同%H:%M:%S。\\n', '\\n', '实际使用示例如下：\\n', '\\n', '显示当前的日期和本地时间。\\n', '\\n', '$ date \\n', '2019年 08月 17日 星期六 17:26:34 CST\\n', '显示当前的日期和UTC时间。\\n', '\\n', '$ date --utc\\n', '2019年 08月 17日 星期六 09:26:18 UTC\\n', '自定义date命令的输出。\\n', '\\n', '$ date +\"%Y-%m-%d %H:%M\"\\n', '2019-08-17 17:24\\n', '修改时间\\n', '要修改当前的时间，添加--set或者-s参数。在root权限下执行如下命令，其中 HH 代表小时，MM 代表分钟，SS 代表秒，请根据实际情况修改：\\n', '\\n', '# date --set HH:MM:SS\\n', '默认情况下， date命令设置本地时间。要设置UTC时间，添加--utc或-u参数：\\n', '\\n', '# date --set HH:MM:SS --utc\\n', '例如修改当前的时间为23点26分00秒，在root权限下执行如下命令：\\n', '\\n', '# date --set 23:26:00\\n', '修改日期\\n', '修改当前的日期，添加--set或者-s参数。在root权限下执行如下命令，其中 YYYY 代表年份，MM 代表月份，DD 代表某天，请根据实际情况修改：\\n', '\\n', '# date --set YYYY-MM-DD\\n', '例如修改当前的日期为2019年11月2日，命令如下：\\n', '\\n', '# date --set 2019-11-02\\n', '使用hwclock命令设置\\n', '可以使用 hwclock 命令设置硬件时钟RTC (Real Time Clock) 。\\n', '\\n', '硬件时钟和系统时钟\\n', 'Linux 将时钟分为：\\n', '\\n', '系统时钟 (System Clock) ：当前Linux Kernel中的时钟。\\n', '硬件时钟 RTC：主板上由电池供电的主板硬件时钟，该时钟可以在BIOS的 “Standard BIOS Feature” 项中进行设置。\\n', '当Linux启动时，会读取硬件时钟，并根据硬件时间来设置系统时间。\\n', '\\n', '显示日期和时间\\n', '显示当前硬件的日期和时间，在root权限下执行如下命令：\\n', '\\n', '# hwclock\\n', '例如显示当前硬件的日期和时间，命令和输出如下：\\n', '\\n', '# hwclock\\n', '2019-08-26 10:18:42.528948+08:00\\n', '设置日期和时间\\n', '修改当前硬件的日期和时间，在root权限下执行如下命令，其中 dd 表示日，mm 表示月份，yyyy 表示年份，HH 表示小时，MM 表示分钟，请根据实际情况修改：\\n', '\\n', '# hwclock --set --date \"dd mm yyyy HH:MM\"\\n', '例如修改当前的时间为2019年10月21日21点17分，命令如下：\\n', '\\n', '# hwclock --set --date \"21 Oct 2019 21:17\" --utc\\n', '设置kdump\\n', '本节介绍如何设置kdump预留内存及修改kdump配置文件参数。\\n', '\\n', '设置kdump预留内存\\n', '预留内存参数格式\\n', 'kdump预留内存参数必须添加到内核启动参数中，配置文件为/boot/efi/EFI/openEuler/grub.cfg(UEFI引导模式)或/boot/grub2/grub.cfg(legacy引导模式)，openEuler发布版本中默认已经添加，可以根据实际使用情况调整。添加和修改启动参数后，重启系统生效。kdump预留内存参数格式如下：\\n', '\\n', '内核启动参数\\t描述\\t默认值\\t备注\\n', 'crashkernel=x\\t在4G以下的物理内存预留x大小的内存给kdump使用。\\tx86版本默认配置512M\\t该配置方法只在4G以下内存预留，必须保证4G以下连续可用内存足够预留。\\n', 'crashkernel=x@y\\t在y起始地址预留x大小的内存给kdump使用。\\t未使用\\t需要确保y起始地址的x大小的内存未被其他模块预留。\\n', 'crashkernel=x,high\\t在4G以下的物理内存中预留256M内存，在4G以上预留x大小内存给kdump使用。\\tarm64版本默认配置1024M,high\\t需要确保4G以下有256M连续可用的物理内存，4G以上有连续的x大小的连续物理内存。实际预留内存大小为256M+x。\\n', 'crashkernel=x,low crashkernel=y,high\\t在4G以下的物理内存中预留x大小，在4G以上预留y大小内存给kdump使用。\\t未使用\\t需要确保4G以下有连续的x大小物理内存，4G以上有连续的y大小物理内存。\\n', '预留内存推荐值\\n', '推荐方案\\t预留参数\\t参数说明\\n', '通用方案\\tcrashkernel=2048M,high\\t4G以下预留256M，4G以上预留2048M内存给kdump使用。共256+2048M。\\n', '经济方案\\tcrashkernel=1024M,high\\t4G以下预留256M，4G以上预留1024M内存给kdump使用。共256+1024M。 推荐系统512G内存以内的场景，并不使用网络转储kdump文件。对于虚拟机场景，可以适当减少内存预留值，推荐虚拟机设置为crashkernel=512M或者crashkernel=256M,high\\n', ' 说明：\\n', '不通过网络转储kdump文件时，需要设置kdump文件系统不打包网络相关驱动。网络驱动加载需要申请较大内存，可能导致预留内存不足，kdump失败。因此建议禁用网络相关驱动。\\n', '\\n', '禁用网络相关驱动\\n', 'kdump配置文件（/etc/kdump.conf）中，dracut参数可以设置裁剪的驱动模块，可以将网络驱动配置到裁剪驱动列表中，让kdump文件系统中不加载该驱动，修改配置文件后，重启kdump服务生效。dracut参数配置如下所示：\\n', '\\n', 'dracut_args --omit-drivers \"mdio-gpi usb_8dev et1011c rt2x00usb bcm-phy-lib mac80211_hwsim rtl8723be rndis_host hns3_cae amd vrf rtl8192cu mt76x02-lib int51x1 ppp_deflate team_mode_loadbalance smsc911x aweth bonding mwifiex_usb hnae dnet rt2x00pci vaser_pci hdlc_ppp marvell rtl8xxxu mlxsw_i2c ath9k_htc rtl8150 smc91x cortina at803x rockchip cxgb4 spi_ks8995 mt76x2u smsc9420 mdio-cavium bnxt_en ch9200 dummy macsec ice mt7601u rtl8188ee ixgbevf net1080 liquidio_vf be2net mlxsw_switchx2 gl620a xilinx_gmii2rgmii ppp_generic rtl8192de sja1000_platform ath10k_core cc770_platform realte igb c_can_platform c_can ethoc dm9601 smsc95xx lg-vl600 ifb enic ath9 mdio-octeon ppp_mppe ath10k_pci cc770 team_mode_activebackup marvell10g hinic rt2x00lib mlx4_en iavf broadcom igc c_can_pci alx rtl8192se rtl8723ae microchip lan78xx atl1c rtl8192c-common almia ax88179_178a qed netxen_nic brcmsmac rt2800usb e1000 qla3xxx mdio-bitbang qsemi mdio-mscc-miim plx_pci ipvlan r8152 cx82310_eth slhc mt76x02-usb ems_pci xen-netfront usbnet pppoe mlxsw_minimal mlxsw_spectrum cdc_ncm rt2800lib rtl_usb hnae3 ath9k_common ath9k_hw catc mt76 hns_enet_drv ppp_async huawei_cdc_ncm i40e rtl8192ce dl2 qmi_wwan mii peak_usb plusb can-dev slcan amd-xgbe team_mode_roundrobin ste10Xp thunder_xcv pptp thunder_bgx ixgbe davicom icplus tap tun smsc75xx smsc dlci hns_dsaf mlxsw_core rt2800mmi softing uPD60620 vaser_usb dp83867 brcmfmac mwifiex_pcie mlx4_core micrel team macvlan bnx2 virtio_net rtl_pci zaurus hns_mdi libcxgb hv_netvsc nicvf mt76x0u teranetics mlxfw cdc_eem qcom-emac pppox mt76-usb sierra_net i40evf bcm87xx mwifiex pegasus rt2x00mmi sja1000 ena hclgevf cnic cxgb4vf ppp_synctty iwlmvm team_mode_broadcast vxlan vsockmon hdlc_cisc rtl8723-common bsd_comp fakelb dp83822 dp83tc811 cicada fm10 8139t sfc hs geneve hclge xgene-enet-v2 cdc_mbim hdlc asix netdevsim rt2800pci team_mode_random lxt ems_usb mlxsw_pci sr9700 mdio-thunder mlxsw_switchib macvtap atlantic cdc_ether mcs7830 nicpf mdi peak_pci atl1e cdc_subset ipvtap btcoexist mt76x0-common veth slip iwldvm bcm7xxx vitesse netconsole epic100 myri10ge r8169 qede microchip_t1 liquidi bnx2x brcmutil mwifiex_sdi mlx5_core rtlwifi vmxnet3 nlmon hns3 hdlc_raw esd_usb2 atl2 mt76x2-common iwlwifi mdio-bcm-unimac national ath rtwpci rtw88 nfp rtl8821ae fjes thunderbolt-net 8139cp atl1 mscc vcan dp83848 dp83640 hdlc_fr e1000e ipheth net_failover aquantia rtl8192ee igbvf rocker intel-xway tg3\" --omit \"ramdisk network ifcfg qemu-net\" --install \"chmod\" --nofscks\\n', '\\n', '设置磁盘调度算法\\n', '本节介绍如何设置磁盘调度算法。\\n', '\\n', '临时修改调度策略\\n', '例如将所有IO调度算法修改为mq-deadline，此修改重启后会失效。\\n', '\\n', 'echo mq-deadline > /sys/block/sd*/queue/scheduler\\n', '永久设置调度策略\\n', '可以通过在内核启动配置文件grub.cfg中的kernel行追加：elevator=mq-deadline，重启后生效。\\n', '\\n', 'linux   /vmlinuz-4.19.90-2003.4.0.0036.oe1.x86_64 root=/dev/mapper/openeuler-root ro resume=/dev/mapper/openeuler-swap rd.lvm.lv=openeuler/root']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_cgroup路径可配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/cgroup%E8%B7%AF%E5%BE%84%E5%8F%AF%E9%85%8D%E7%BD%AE.html", "text_entry": "['cgroup路径可配置\\n', '功能描述\\n', '系统容器提供在宿主机上进行容器资源隔离和预留的能力。通过--cgroup-parent参数，可以将容器使用的cgroup目录指定到某个特定目录下，从而达到灵活分配宿主机资源的目的。例如可以设置容器a、b、c的cgroup父路径为/lxc/cgroup1，容器d、e、f的cgroup父路径为/lxc/cgroup2，这样通过cgroup路径将容器分为两个group，实现容器cgroup组层面的资源隔离。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--cgroup-parent\\n', '\\n', '字符串变量。\\n', '指定容器cgroup父路径。\\n', '除了通过命令行指定单个系统容器对应的cgroup父路径外，还可通过修改iSulad容器引擎启动配置文件，指定所有容器的cgroup路径。\\n', '\\n', '\\n', '配置文件路径\\n', '\\n', '配置项\\n', '\\n', '配置项说明\\n', '\\n', '/etc/isulad/daemon.json\\n', '\\n', '--cgroup-parent\\n', '\\n', '字符串变量。\\n', '指定容器默认cgroup父路径。\\n', '配置示例：\"cgroup-parent\": \"/lxc/mycgroup\"\\n', '约束限制\\n', '如果daemon端和客户端都设置了cgroup parent参数，最终以客户端指定的--cgroup-parent生效。\\n', '如果已启动容器A，然后启动容器B，容器B的cgroup父路径指定为容器A的cgroup路径，在删除容器的时候需要先删除容器B再删除容器A，否则会导致cgroup资源残留。\\n', '使用示例\\n', '启动系统容器，指定–cgroup-parent参数：\\n', '\\n', '[root@localhost ~]# isula run -tid --cgroup-parent /lxc/cgroup123 --system-container --external-rootfs /root/myrootfs none init\\n', '115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '查看容器init进程的cgroup信息：\\n', '\\n', '[root@localhost ~]# isula inspect -f \"{{json .State.Pid}}\" 11\\n', '22167\\n', '[root@localhost ~]# cat /proc/22167/cgroup\\n', '13:blkio:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '12:perf_event:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '11:cpuset:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '10:pids:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '9:rdma:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '8:devices:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '7:hugetlb:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '6:memory:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '5:net_cls,net_prio:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '4:cpu,cpuacct:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '3:files:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '2:freezer:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '1:name=systemd:/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e/init.scope\\n', '0::/lxc/cgroup123/115878a4dfc7c5b8c62ef8a4b44f216485422be9a28f447a4b9ecac4609f332e\\n', '可以看到容器的cgroup父路径被设置为/sys/fs/cgroup/<controller>/lxc/cgroup123\\n', '\\n', '同时，对于所有容器cgroup父路径的设置可以配置一下容器daemon文件，例如：\\n', '\\n', '{\\n', '         \"cgroup-parent\": \"/lxc/cgroup123\",\\n', '}\\n', '然后重启容器引擎，配置生效。']"}
{"index": {"_index": "new-open", "_id": "openEuler_KubeEdge部署指南_KubeEdge部署指南.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KubeEdge/KubeEdge%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97.html", "text_entry": "['KubeEdge 部署指南\\n', '介绍\\n', 'KubeEdge\\n', 'KubeEdge 是一个致力于解决边缘场景问题的开源系统，它将容器化应用程序编排和设备管理的能力扩展到边缘设备。基于 Kubernetes，KubeEdge 为网络、应用程序部署以及云侧与边缘侧之间的元数据同步提供核心基础设施支持。KubeEdge 支持 MQTT，并允许开发人员编写自定义逻辑，在边缘上启用资源受限的设备通信。KubeEdge 由云部分和边缘部分组成，目前均已开源。\\n', '\\n', 'https://kubeedge.io/\\n', '\\n', 'iSulad\\n', 'iSulad 是一个轻量级容器 runtime 守护程序，专为 IOT 和 Cloud 基础设施而设计，具有轻便、快速且不受硬件规格和体系结构限制的特性，可以被更广泛地应用在云、IoT、边缘计算等多个场景。\\n', '\\n', 'https://gitee.com/openeuler/iSulad\\n', '\\n', '集群概览\\n', '组件版本\\n', '组件\\t版本\\n', 'OS\\topenEuler 22.03\\n', 'Kubernetes\\t1.20.2-4\\n', 'iSulad\\t2.0.11\\n', 'KubeEdge\\tv1.8.0\\n', '节点规划（示例）\\n', '节点名\\t位置\\t组件\\n', 'cloud.kubeedge\\t云侧（cloud）\\tk8s（master）、isulad、cloudcore\\n', 'edge.kubeedge\\t边缘侧（edge）\\tisulad、edgecore\\n', '提示：云侧和边缘侧的主机名可以使用 hostnamectl set-hostname [cloud,edge].kubeedge 命令提前设置好\\n', '\\n', '准备\\n', '下载工具包\\n', 'kubeedge-tools 工具包提供了完备的离线安装包以及部署脚本，降低了部署复杂度并且支持在节点无法访问外网的条件下快速搭建 KubeEdge 集群。\\n', '\\n', '# 下载 kubeedge-tools 工具包并解压（包括云侧和边缘侧）\\n', '$ wget -O kubeedge-tools.zip https://gitee.com/Poorunga/kubeedge-tools/repository/archive/master.zip\\n', '$ unzip kubeedge-tools.zip\\n', '\\n', '# 进入 kubeedge-tools 工具包目录（后续所有操作基于此目录）\\n', '$ cd kubeedge-tools-master\\n', '部署 k8s\\n', '以下操作仅在云侧执行\\n', '\\n', '初始化云侧环境\\n', '$ ./setup-cloud.sh\\n', '参考 部署 k8s\\n', '提示：在云侧节点可以访问外网的条件下建议优先选用 kubeadm 工具部署 k8s，示例：\\n', '\\n', '$ kubeadm init --apiserver-advertise-address=云侧IP --kubernetes-version v1.20.15 --pod-network-cidr=10.244.0.0/16 --upload-certs --cri-socket=/var/run/isulad.sock\\n', '...\\n', 'Your Kubernetes control-plane has initialized successfully!\\n', '...\\n', '\\n', '# 成功安装 k8s 后还需根据最后的提示将指定文件复制到指定目录：\\n', '#   mkdir -p $HOME/.kube\\n', '#   sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\\n', '#   sudo chown $(id -u):$(id -g) $HOME/.kube/config\\n', '安装云侧容器网络\\n', '目前有丰富的 cni 软件可以为 k8s 节点提供容器网络功能，比如 flannel、calico、cilium 等，如果你暂时不明确选用哪款 cni 软件，可以使用下方命令安装云侧容器网络：\\n', '\\n', '$ ./install-flannel-cloud.sh\\n', '检查部署情况\\n', '# 查看节点状态（Ready 即正常）\\n', '$ kubectl get nodes\\n', 'NAME             STATUS   ROLES                  AGE   VERSION\\n', 'cloud.kubeedge   Ready    control-plane,master   12m   v1.20.2\\n', '\\n', '# 查看所有 k8s 组件运行状态（Running 即正常）\\n', '$ kubectl get pods -n kube-system\\n', 'NAME                                     READY   STATUS    RESTARTS   AGE\\n', 'coredns-74ff55c5b-4ptkh                  1/1     Running   0          15m\\n', 'coredns-74ff55c5b-zqx5n                  1/1     Running   0          15m\\n', 'etcd-cloud.kubeedge                      1/1     Running   0          15m\\n', 'kube-apiserver-cloud.kubeedge            1/1     Running   0          15m\\n', 'kube-controller-manager-cloud.kubeedge   1/1     Running   0          15m\\n', 'kube-flannel-cloud-ds-lvh4n              1/1     Running   0          13m\\n', 'kube-proxy-2tcnn                         1/1     Running   0          15m\\n', 'kube-scheduler-cloud.kubeedge            1/1     Running   0          15m\\n', '部署\\n', '部署 cloudcore\\n', '以下操作仅在云侧执行\\n', '\\n', '初始化集群\\n', '# --advertise-address 填写云侧节点的主机 IP 地址\\n', '$ keadm init --advertise-address=\"云侧IP\" --kubeedge-version=1.8.0\\n', '...\\n', 'CloudCore started\\n', '调整 cloudcore 配置\\n', '$ ./patch-cloud.sh\\n', '检查部署情况\\n', '# active (running)即正常\\n', '$ systemctl status cloudcore | grep running\\n', '     Active: active (running) since Fri 2022-03-04 10:54:30 CST; 5min ago\\n', '至此，云侧的 cloudcore 已部署完成，接下来部署边缘侧 edgecore。\\n', '\\n', '部署 edgecore\\n', '以下命令如无特殊说明则仅在边缘侧执行\\n', '\\n', '初始化边缘侧环境\\n', '$ ./setup-edge.sh\\n', '纳管边缘节点\\n', '# keadm gettoken 命令需要在云侧执行\\n', '$ keadm gettoken\\n', '96058ab80ffbeb87fe58a79bfb19ea13f9a5a6c3076a17c00f80f01b406b4f7c.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDY0NDg4NzF9.1mJegWB7SUVjgf-OvAqILgbZXeMHR9eOzMxpNFc42SI\\n', '# 记录并保存此 token 值，后续步骤需要使用\\n', '\\n', '\\n', '# keadm join 命令在边缘侧执行\\n', '# --cloudcore-ipport 填写云侧节点的主机 IP 地址:10000，--token 填写上方 token 值\\n', '$ keadm join --cloudcore-ipport=云侧IP:10000 --kubeedge-version=1.8.0 --token=96058ab80ffbeb87fe58a79bfb19ea13f9a5a6c3076a17c00f80f01b406b4f7c.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NDY0NDg4NzF9.1mJegWB7SUVjgf-OvAqILgbZXeMHR9eOzMxpNFc42SI\\n', '...\\n', 'KubeEdge edgecore is running...\\n', '调整 edgecore 配置\\n', '$ ./patch-edge.sh\\n', '安装边缘侧容器网络\\n', '如果你暂时不明确选用哪款 cni 软件，可以使用下方命令安装边缘侧容器网络：\\n', '\\n', '# 下方命令需要在云侧执行\\n', '$ ./install-flannel-edge.sh\\n', '检查边缘节点是否纳管成功\\n', '# 下方命令需要在云侧执行（发现已经有了边缘节点）\\n', '$ kubectl get nodes\\n', 'NAME             STATUS   ROLES                  AGE     VERSION\\n', 'cloud.kubeedge   Ready    control-plane,master   1h      v1.20.2\\n', 'edge.kubeedge    Ready    agent,edge             10m     v1.19.3-kubeedge-v1.8.0\\n', '至此，KubeEdge 集群部署完成，接下来我们测试一下从云侧下发应用到边缘侧。\\n', '\\n', '部署应用\\n', '以下命令在云侧执行\\n', '\\n', '部署nginx\\n', '$ kubectl apply -f yamls/nginx-deployment.yaml\\n', 'deployment.apps/nginx-deployment created\\n', '\\n', '# 查看应用是否部署到了边缘侧（Running 即正常）\\n', '$ kubectl get pod -owide | grep nginx\\n', 'nginx-deployment-84b99f4bf-jb6sz   1/1     Running   0          30s   10.244.1.2   edge.kubeedge   <none>           <none>\\n', '测试功能\\n', '# 进入边缘侧节点，访问 nginx 应用\\n', '$ curl 10.244.1.2:80\\n', '<!DOCTYPE html>\\n', '<html>\\n', '<head>\\n', '<title>Welcome to nginx!</title>\\n', '<style>\\n', 'html { color-scheme: light dark; }\\n', 'body { width: 35em; margin: 0 auto;\\n', 'font-family: Tahoma, Verdana, Arial, sans-serif; }\\n', '</style>\\n', '</head>\\n', '<body>\\n', '<h1>Welcome to nginx!</h1>\\n', '<p>If you see this page, the nginx web server is successfully installed and\\n', 'working. Further configuration is required.</p>\\n', '\\n', '<p>For online documentation and support please refer to\\n', '<a href=\"http://nginx.org/\">nginx.org</a>.<br/>\\n', 'Commercial support is available at\\n', '<a href=\"http://nginx.com/\">nginx.com</a>.</p>\\n', '\\n', '<p><em>Thank you for using nginx.</em></p>\\n', '</body>\\n', '</html>\\n', '至此，KubeEdge 部署已经全流程打通。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_使用DNF管理软件包.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8DNF%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E5%8C%85.html", "text_entry": "['使用DNF管理软件包\\n', 'DNF是一款Linux软件包管理工具，用于管理RPM软件包。DNF可以查询软件包信息，从指定软件库获取软件包，自动处理依赖关系以安装或卸载软件包，以及更新系统到最新可用版本。\\n', '\\n', ' 说明：\\n', '\\n', 'DNF与YUM完全兼容，提供了YUM兼容的命令行以及为扩展和插件提供的API。\\n', '使用DNF需要管理员权限，本章所有命令需要在管理员权限下执行。\\n', '使用DNF管理软件包\\n', '配置DNF\\n', 'DNF配置文件\\n', '创建本地软件源仓库\\n', '添加、启用和禁用软件源\\n', '管理软件包\\n', '搜索软件包\\n', '列出软件包清单\\n', '显示RPM包信息\\n', '安装RPM包\\n', '下载软件包\\n', '删除软件包\\n', '管理软件包组\\n', '列出软件包组清单\\n', '显示软件包组信息\\n', '安装软件包组\\n', '删除软件包组\\n', '检查并更新\\n', '检查更新\\n', '升级\\n', '更新所有的包和它们的依赖\\n', '配置DNF\\n', 'DNF配置文件\\n', 'DNF 的主要配置文件是 /etc/dnf/dnf.conf，该文件包含两部分：\\n', '\\n', '“main”部分保存着DNF的全局设置。\\n', '\\n', '“repository”部分保存着软件源的设置，可以有一个或多个“repository”。\\n', '\\n', '另外，在/etc/yum.repos.d 目录中保存着一个或多个repo源相关文件，它们也可以定义不同的“repository”。\\n', '\\n', '所以openEuler软件源的配置一般有两种方式，一种是直接配置/etc/dnf/dnf.conf文件中的“repository”部分，另外一种是在/etc/yum.repos.d目录下增加.repo文件。\\n', '\\n', '配置main部分\\n', '/etc/dnf/dnf.conf 文件包含的“main”部分，配置示例如下：\\n', '\\n', '[main]\\n', 'gpgcheck=1\\n', 'installonly_limit=3\\n', 'clean_requirements_on_remove=True\\n', 'best=True\\n', 'skip_if_unavailable=False\\n', '常用选项说明：\\n', '\\n', '表 1 main参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'cachedir\\n', '\\n', '缓存目录，该目录用于存储RPM包和数据库文件。\\n', '\\n', 'keepcache\\n', '\\n', '可选值是1和0，表示是否要缓存已安装成功的那些RPM包及头文件，默认值为0，即不缓存。\\n', '\\n', 'debuglevel\\n', '\\n', '设置dnf生成的debug信息。取值范围：[0-10]，数值越大会输出越详细的debug信息。默认值为2，设置为0表示不输出debug信息。\\n', '\\n', 'clean_requirements_on_remove\\n', '\\n', '删除在dnf remove期间不再使用的依赖项，如果软件包是通过DNF安装的，而不是通过显式用户请求安装的，则只能通过clean_requirements_on_remove删除软件包，即它是作为依赖项引入的。 默认值为True。\\n', '\\n', 'best\\n', '\\n', '升级包时，总是尝试安装其最高版本，如果最高版本无法安装，则提示无法安装的原因并停止安装。默认值为True。\\n', '\\n', 'obsoletes\\n', '\\n', '可选值1和0，设置是否允许更新陈旧的RPM包。默认值为1，表示允许更新。\\n', '\\n', 'gpgcheck\\n', '\\n', '可选值1和0，设置是否进行gpg校验。默认值为1，表示需要进行校验。\\n', '\\n', 'plugins\\n', '\\n', '可选值1和0，表示启用或禁用dnf插件。默认值为1，表示启用dnf插件。\\n', '\\n', 'installonly_limit\\n', '\\n', '设置可以同时安装“installonlypkgs”指令列出包的数量。默认值为3，不建议降低此值。\\n', '\\n', '配置repository部分\\n', 'repository部分允许您定义定制化的openEuler软件源仓库，各个仓库的名称不能相同，否则会引起冲突。配置repository部分有两种方式，一种是直接配置/etc/dnf/dnf.conf文件中的“repository”部分，另外一种是配置/etc/yum.repos.d目录下的.repo文件。\\n', '\\n', '直接配置/etc/dnf/dnf.conf文件中的“repository”部分\\n', '\\n', '下面是[repository]部分的一个最小配置示例：\\n', '\\n', '[repository]\\n', 'name=repository_name\\n', 'baseurl=repository_url\\n', ' 说明：\\n', 'openEuler提供在线的镜像源，地址：https://repo.openeuler.org/。以 openEuler 21.03的aarch64版本为例，baseurl可配置为https://repo.openeuler.org/openEuler-21.03/OS/aarch64/。\\n', '\\n', '选项说明：\\n', '\\n', '表 2 repository参数说明\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'name=repository_name\\n', '\\n', '软件仓库（repository ）描述的字符串。\\n', '\\n', 'baseurl=repository_url\\n', '\\n', '软件仓库（repository ）的地址。\\n', '\\n', '使用http协议的网络位置：例如 http://path/to/repo\\n', '使用ftp协议的网络位置：例如 ftp://path/to/repo\\n', '本地位置：例如 file:///path/to/local/repo\\n', '配置/etc/yum.repos.d目录下的.repo文件\\n', '\\n', 'openEuler提供了多种repo源供用户在线使用，各repo源含义可参考系统安装。使用root权限添加openEuler repo源，示例如下：\\n', '\\n', '# vi /etc/yum.repos.d/openEuler.repo\\n', '[OS]\\n', 'name=openEuler-$releasever - OS\\n', 'baseurl=https://repo.openeuler.org/openEuler-21.03/OS/$basearch/\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=https://repo.openeuler.org/openEuler-21.03/OS/$basearch/RPM-GPG-KEY-openEuler\\n', ' 说明：\\n', '\\n', 'enabled为是否启用该软件源仓库，可选值为1和0。默认值为1，表示启用该软件源仓库。\\n', 'gpgkey为验证签名用的公钥。\\n', '显示当前配置\\n', '要显示当前的配置信息：\\n', '\\n', 'dnf config-manager --dump\\n', '要显示相应软件源的配置，首先查询repo id：\\n', '\\n', 'dnf repolist\\n', '然后执行如下命令，显示对应id的软件源配置，其中 repository 为查询得到的repo id：\\n', '\\n', 'dnf config-manager --dump repository\\n', '您也可以使用一个全局正则表达式，来显示所有匹配部分的配置：\\n', '\\n', 'dnf config-manager --dump glob_expression\\n', '创建本地软件源仓库\\n', '要建立一个本地软件源仓库，请按照下列步骤操作。\\n', '\\n', '安装createrepo软件包。在root权限下执行如下命令：\\n', '\\n', 'dnf install createrepo\\n', '将需要的软件包复制到一个目录下，如/mnt/local_repo/ 。\\n', '\\n', '创建软件源，执行以下命令：\\n', '\\n', 'createrepo /mnt/local_repo\\n', '添加、启用和禁用软件源\\n', '本节将介绍如何通过“dnf config-manager”命令添加、启用和禁用软件源仓库。\\n', '\\n', '添加软件源\\n', '要定义一个新的软件源仓库，您可以在 /etc/dnf/dnf.conf 文件中添加“repository”部分，或者在/etc/yum.repos.d/目录下添加“.repo”文件进行说明。建议您通过添加“.repo”的方式，每个软件源都有自己对应的“.repo”文件，以下介绍该方式的操作方法。\\n', '\\n', '要在您的系统中添加一个这样的源，请在root权限下执行如下命令，执行完成之后会在/etc/yum.repos.d/目录下生成对应的repo文件。其中 repository_url 为repo源地址，详情请参见表2。\\n', '\\n', 'dnf config-manager --add-repo repository_url\\n', '启用软件源\\n', '要启用软件源，请在root权限下执行如下命令，其中 repository 为新增.repo文件中的repo id（可通过dnf repolist查询）：\\n', '\\n', 'dnf config-manager --set-enable repository\\n', '您也可以使用一个全局正则表达式，来启用所有匹配的软件源。其中 glob_expression 为对应的正则表达式，用于同时匹配多个repo id：\\n', '\\n', 'dnf config-manager --set-enable glob_expression\\n', '禁用软件源\\n', '要禁用软件源，请在root权限下执行如下命令：\\n', '\\n', 'dnf config-manager --set-disable repository\\n', '同样的，您也可以使用一个全局正则表达式来禁用所有匹配的软件源：\\n', '\\n', 'dnf config-manager --set-disable glob_expression\\n', '管理软件包\\n', '使用dnf能够让您方便的进行查询、安装、删除软件包等操作。\\n', '\\n', '搜索软件包\\n', '您可以使用rpm包名称、缩写或者描述搜索需要的RPM包，使用命令如下：\\n', '\\n', 'dnf search term\\n', '示例如下：\\n', '\\n', '$   dnf search httpd\\n', '========================================== N/S matched: httpd ==========================================\\n', 'httpd.aarch64 : Apache HTTP Server\\n', 'httpd-devel.aarch64 : Development interfaces for the Apache HTTP server\\n', 'httpd-manual.noarch : Documentation for the Apache HTTP server\\n', 'httpd-tools.aarch64  : Tools for use with the Apache HTTP Server\\n', 'libmicrohttpd.aarch64  : Lightweight library for embedding a webserver in applications\\n', 'mod_auth_mellon.aarch64  : A SAML 2.0 authentication module for the Apache Httpd Server\\n', 'mod_dav_svn.aarch64  : Apache httpd module for Subversion server\\n', '列出软件包清单\\n', '要列出系统中所有已安装的以及可用的RPM包信息，使用命令如下：\\n', '\\n', 'dnf list all\\n', '要列出系统中特定的RPM包信息，使用命令如下：\\n', '\\n', 'dnf list glob_expression...\\n', '示例如下：\\n', '\\n', '$ dnf list httpd\\n', 'Available Packages\\n', 'httpd.aarch64              2.4.34-8.h5.oe1           Local\\n', '显示RPM包信息\\n', '要显示一个或者多个RPM包信息，使用命令如下：\\n', '\\n', 'dnf info package_name...\\n', '例如搜索，命令如下：\\n', '\\n', '$ dnf info httpd\\n', 'Available Packages\\n', 'Name        : httpd\\n', 'Version     : 2.4.34\\n', 'Release     : 8.h5.oe1\\n', 'Arch        : aarch64\\n', 'Size        : 1.2 M\\n', 'Repo        : Local\\n', 'Summary     : Apache HTTP Server\\n', 'URL         : http://httpd.apache.org/\\n', 'License     : ASL 2.0\\n', 'Description : The Apache HTTP Server is a powerful, efficient, and extensible\\n', '            : web server.\\n', '安装RPM包\\n', '要安装一个软件包及其所有未安装的依赖，请在root权限下执行如下命令：\\n', '\\n', 'dnf install package_name\\n', '您也可以通过添加软件包名字同时安装多个软件包。配置文件/etc/dnf/dnf.conf添加参数strict=False，运行dnf命令参数添加--setopt=strict=0。请在root权限下执行如下命令：\\n', '\\n', 'dnf install package_name package_name... --setopt=strict=0\\n', '示例如下：\\n', '\\n', '# dnf install httpd\\n', ' 说明：\\n', '\\n', '安装RPM包过程中，若出现安装失败，可参考安装时出现软件包冲突、文件冲突或缺少软件包导致安装失败。\\n', '请勿安装install-scipts软件包，该包仅用于imageTailor工具裁剪ISO时使用，若在openEuler系统上安装该软件包会导致系统无法启动。\\n', '下载软件包\\n', '使用dnf下载软件包，请在root权限下输入如下命令：\\n', '\\n', 'dnf download package_name\\n', '如果需要同时下载未安装的依赖，则加上--resolve，使用命令如下：\\n', '\\n', 'dnf download --resolve package_name\\n', '示例如下：\\n', '\\n', '# dnf download --resolve httpd\\n', '删除软件包\\n', '要卸载软件包以及相关的依赖软件包，请在root权限下执行如下命令：\\n', '\\n', 'dnf remove package_name...\\n', '示例如下：\\n', '\\n', '# dnf remove totem\\n', '管理软件包组\\n', '软件包集合是服务于一个共同的目的一组软件包，例如系统工具集等。使用dnf可以对软件包组进行安装/删除等操作，使相关操作更高效。\\n', '\\n', '列出软件包组清单\\n', '使用summary参数，可以列出系统中所有已安装软件包组、可用的组，可用的环境组的数量，命令如下：\\n', '\\n', 'dnf groups summary\\n', '使用示例如下：\\n', '\\n', '# dnf groups summary\\n', 'Last metadata expiration check: 0:11:56 ago on Sat 17 Aug 2019 07:45:14 PM CST.\\n', 'Available Groups: 8\\n', '要列出所有软件包组和它们的组ID ，命令如下：\\n', '\\n', 'dnf group list\\n', '使用示例如下：\\n', '\\n', '# dnf group list\\n', 'Last metadata expiration check: 0:10:32 ago on Sat 17 Aug 2019 07:45:14 PM CST.\\n', 'Available Environment Groups:\\n', '   Minimal Install\\n', '   Custom Operating System\\n', '   Server\\n', 'Available Groups:\\n', '   Development Tools\\n', '   Graphical Administration Tools\\n', '   Headless Management\\n', '   Legacy UNIX Compatibility\\n', '   Network Servers\\n', '   Scientific Support\\n', '   Security Tools\\n', '   System Tools\\n', '\\n', '显示软件包组信息\\n', '要列出包含在一个软件包组中必须安装的包和可选包，使用命令如下：\\n', '\\n', 'dnf group info glob_expression...\\n', '例如显示Development Tools信息，示例如下：\\n', '\\n', '# dnf group info \"Development Tools\"\\n', 'Last metadata expiration check: 0:14:54 ago on Wed 05 Jun 2019 08:38:02 PM CST.\\n', '\\n', 'Group: Development Tools\\n', ' Description: A basic development environment.\\n', ' Mandatory Packages:\\n', '   binutils\\n', '   glibc-devel\\n', '   make\\n', '   pkgconf\\n', '   pkgconf-m4\\n', '   pkgconf-pkg-config\\n', '   rpm-sign\\n', ' Optional Packages:\\n', '   expect\\n', '安装软件包组\\n', '每一个软件包组都有自己的名称以及相应的ID（groupid），您可以使用软件包组名称或它的ID进行安装。\\n', '\\n', '要安装一个软件包组，请在root权限下执行如下命令：\\n', '\\n', 'dnf group install group_name\\n', 'dnf group install groupid\\n', '例如安装Development Tools相应的软件包组，命令如下：\\n', '\\n', '# dnf group install \"Development Tools\"\\n', '# dnf group install development\\n', '删除软件包组\\n', '要卸载软件包组，您可以使用软件包组名称或它的ID，在root权限下执行如下命令：\\n', '\\n', 'dnf group remove group_name\\n', 'dnf group remove groupid\\n', '例如删除Development Tools相应的软件包组，命令如下：\\n', '\\n', '# dnf group remove \"Development Tools\"\\n', '# dnf group remove development\\n', '检查并更新\\n', 'dnf可以检查您的系统中是否有软件包需要更新。您可以通过dnf列出需要更新的软件包，并可以选择一次性全部更新或者只对指定包进行更新。\\n', '\\n', '检查更新\\n', '如果您需要显示当前系统可用的更新，使用命令如下：\\n', '\\n', 'dnf check-update\\n', '使用实例如下：\\n', '\\n', '# dnf check-update\\n', 'Last metadata expiration check: 0:02:10 ago on Sun 01 Sep 2019 11:28:07 PM  CST.\\n', '\\n', 'anaconda-core.aarch64       19.31.123-1.14             updates\\n', 'anaconda-gui.aarch64        19.31.123-1.14             updates\\n', 'anaconda-tui.aarch64        19.31.123-1.14             updates\\n', 'anaconda-user-help.aarch64  19.31.123-1.14             updates\\n', 'anaconda-widgets.aarch64    19.31.123-1.14             updates\\n', 'bind-libs.aarch64           32:9.9.4-29.3              updates\\n', 'bind-libs-lite.aarch64      32:9.9.4-29.3              updates\\n', 'bind-license.noarch         32:9.9.4-29.3              updates\\n', 'bind-utils.aarch64          32:9.9.4-29.3              updates\\n', '...\\n', '升级\\n', '如果您需要升级单个软件包，在root权限下执行如下命令：\\n', '\\n', 'dnf update package_name\\n', '例如升级rpm包，示例如下：\\n', '\\n', '# dnf update anaconda-gui.aarch64\\n', 'Last metadata expiration check: 0:02:10 ago on Sun 01 Sep 2019 11:30:27 PM  CST.\\n', 'Dependencies Resolved\\n', '================================================================================\\n', ' Package                  Arch         Version              Repository     Size\\n', '================================================================================\\n', 'Updating:\\n', ' anaconda-gui             aarch64      19.31.123-1.14       updates       461 k\\n', ' anaconda-core            aarch64      19.31.123-1.14       updates       1.4 M\\n', ' anaconda-tui             aarch64      19.31.123-1.14       updates       274 k\\n', ' anaconda-user-help       aarch64      19.31.123-1.14       updates       315 k\\n', ' anaconda-widgets         aarch64      19.31.123-1.14       updates       748 k\\n', '\\n', 'Transaction Summary\\n', '================================================================================\\n', 'Upgrade  5 Package\\n', '\\n', 'Total download size: 3.1 M\\n', 'Is this ok [y/N]:\\n', '类似的，如果您需要升级软件包组，在root权限下执行如下命令：\\n', '\\n', 'dnf group update group_name\\n', '更新所有的包和它们的依赖\\n', '要更新所有的包和它们的依赖，在root权限下执行如下命令：\\n', '\\n', 'dnf update']"}
{"index": {"_index": "new-open", "_id": "openEuler_内核热升级指南_安装部署.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KernelLiveUpgrade/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2.html", "text_entry": "['安装与部署\\n', '本章介绍如何安装和部署内核热升级工具。\\n', '\\n', '安装与部署\\n', '软硬件要求\\n', '硬件要求\\n', '软件要求\\n', '环境准备\\n', '安装内核热升级工具\\n', '部署内核热升级工具\\n', '配置介绍\\n', '使能内核热升级工具\\n', '软硬件要求\\n', '硬件要求\\n', '当前仅支持arm64架构\\n', '软件要求\\n', '操作系统：openEuler 22.03 LTS\\n', '环境准备\\n', '安装openEuler系统，安装方法参考 《openEuler 22.03 LTS 安装指南》\\n', '\\n', '安装内核热升级工具需要使用root权限\\n', '\\n', '安装内核热升级工具\\n', '本章介绍内核热升级工具的安装方法\\n', '\\n', '安装内核热升级工具的操作步骤如下：\\n', '\\n', '挂载openEuler的iso文件\\n', '\\n', '# mount openEuler-22.03-LTS-aarch64-dvd.iso /mnt\\n', '配置本地yum源\\n', '\\n', '# vim /etc/yum.repos.d/local.repo\\n', '配置内容如下所示：\\n', '\\n', '[local]\\n', 'name=local\\n', 'baseurl=file:///mnt\\n', 'gpgcheck=1\\n', 'enabled=1\\n', '将RPM数字签名的GPG公钥导入系统\\n', '\\n', '# rpm --import /mnt/RPM-GPG-KEY-openEuler\\n', '安装内核热升级工具\\n', '\\n', '# yum install nvwa -y\\n', '验证是否安装成功。命令和回显如下表示安装成功\\n', '\\n', '# rpm -qa | grep nvwa\\n', 'nvwa-xxx\\n', '部署内核热升级工具\\n', '本章介绍内核热升级工具的配置部署：\\n', '\\n', '配置介绍\\n', '内核热升级工具的配置文件位于/etc/nvwa，配置文件包括:\\n', '\\n', 'nvwa-restore.yaml\\n', '\\n', '该配置文件用于指导内核热升级工具在内核热升级过程中如何保存和恢复现场，具体配置如下:\\n', '\\n', 'pids\\n', '\\n', 'pids用于指明nvwa热升级过程中需要保留和恢复的进程，此处的进程通过进程号(pid)进行标识，需要注意的是，nvwa管理的进程在nvwa服务启动后，会被自动恢复。\\n', '\\n', 'services\\n', '\\n', 'services用于指明nvwa热升级过程中需要保留和恢复的服务。与pids的区别在于，内核热升级工具可以直接保存和恢复进程的状态，对于服务，内核热升级工具则需要依赖systemd进行相关操作。此处的服务名称，应该使用systemd中使用的服务名称。需要注意的是，对于nvwa管理的服务，是否要在nvwa启动时自动恢复，取决于systemd中有没有使能该服务，且当前支持的服务类型只有notify和oneshot。\\n', '\\n', 'restore_net\\n', '\\n', 'restore_net用于指明是否需要内核热升级工具保存和恢复网络配置，如果网络配置有误，有可能导致恢复后网络不可用，默认关闭。\\n', '\\n', 'enable_quick_kexec\\n', '\\n', 'enable_quick_kexec用于指明是否需要使能quick kexec特性，quick kexec是nvwa社区推出的，加速内核重启过程的一个特性。使用该特性，需要在cmdline中，加入\"quickkexec=128M\"。128指分配给quick kexec特性的内存大小，该内存将用于在升级过程中加载kernel和initramfs，因此大小需要大于升级过程中涉及到的kernel，initramfs大小之和。该特性默认关闭。\\n', '\\n', 'enable_pin_memory\\n', '\\n', 'enable_pin_memory用于指明是否需要使能pin memory特性，pin memory是nvwa社区推出的，加速进程保存恢复过程的一个特性。使用该特性，需要在cmdline中，加入\"max_pin_pid_num=10 redirect_space_size=2M pinmemory=200M@0x640000000\"。\\n', '\\n', '其中，max_pin_pid_num代表支持pin memory恢复的最大进程数目，redirect_space_size代表pin memory过程中重定向物理页所需要的预留内存空间，建议配置为pin memory总预留内存的1/100，pinmemory指明这段内存的起点和大小。从0x640000000开始的200M空间，是pin memory使用的全部内存空间，这段空间不应该被其他程序使用。\\n', '\\n', 'nvwa-restore.yaml的配置示例\\n', '\\n', 'pids:\\n', '  - 14109\\n', 'services:\\n', '  - redis\\n', 'restore_net: false\\n', 'enable_quick_kexec: true\\n', 'enable_pin_memory: true\\n', 'nvwa-server.yaml\\n', '\\n', '该文件包含了内核热升级工具运行过程中，需要使用到的配置信息，具体如下：\\n', '\\n', 'criu_dir\\n', '\\n', '用于指明内核热升级工具在保存现场过程中，存储产生的信息文件夹路径。需要注意的是，这些信息可能会占用较大的磁盘空间。\\n', '\\n', 'criu_exe\\n', '\\n', '用于指明内核热升级工具使用的criu可执行文件路径，除非是对criu进行调测，一般不建议修改。\\n', '\\n', 'kexec_exe\\n', '\\n', '用于指明内核热升级工具使用的kexec可执行文件路径，除非是对kexec进行调测，一般不建议修改。\\n', '\\n', 'systemd_etc\\n', '\\n', '用于指明覆盖systemd配置过程中，使用到的文件夹路径。该路径由systemd决定，一般不需要修改。\\n', '\\n', 'log_dir\\n', '\\n', '存放内核热升级工具产生的log信息，log模块当前未启用。内核热升级工具日志信息的查看，参考其他章节«使用方法»\\n', '\\n', 'nvwa-server.yaml的配置示例\\n', '\\n', 'criu_dir: /var/nvwa/running/\\n', 'criu_exe: /usr/sbin/criu\\n', 'kexec_exe: /usr/sbin/kexec\\n', 'systemd_etc: /etc/systemd/system/\\n', 'log_dir: /etc/nvwa/log/\\n', '使能内核热升级工具\\n', '内核热升级工具的运行依赖配置文件，配置文件修改后应该重新运行内核热升级工具程序。\\n', '\\n', '安装成功后，可以通过systemd的相关命令来操作内核热升级工具\\n', '\\n', '使能nvwa\\n', '\\n', 'systemctl enable nvwa\\n', '\\n', '启动nvwa\\n', '\\n', 'systemctl start nvwa\\n', '\\n', '查看nvwa日志\\n', '\\n', 'service nvwa status\\n', '\\n', '更多用法参考systemd用法\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_FAQ.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/FAQ-54.html", "text_entry": "['FAQ\\n', 'FAQ\\n', '使用systemctl和top命令查询libvirtd服务占用内存不同\\n', '设置RAID0卷，参数stripsize设置为4时出错\\n', '使用rpmbuild编译mariadb失败\\n', '使用默认配置启动SNTP服务失败\\n', '安装时出现软件包冲突、文件冲突或缺少软件包导致安装失败\\n', 'libiscsi降级失败\\n', 'xfsprogs降级失败\\n', 'cpython/Lib发现CVE-2019-9674:Zip炸弹漏洞\\n', '不合理使用glibc正则表达式引起ReDoS攻击\\n', '使用systemctl和top命令查询libvirtd服务占用内存不同\\n', '问题描述\\n', '使用systemctl和systemd-cgtop命令查询libvirtd服务占用内存超1.5G，而使用top命令查询libvirtd服务占用内存仅70M左右。\\n', '\\n', '原因分析\\n', 'systemd管理的服务（包括systemctl和systemd-cgtop）中显示的内存通过查询CGroup对应的memory.usage_in_bytes得到。top是直接统计/proc下内存相关信息计算得出。两者的统计方法不同，不能直接比较。\\n', '\\n', '一般来说，业务进程使用的内存主要有以下几种情况：\\n', '\\n', 'anon_rss：用户空间的匿名映射页（Anonymous pages in User Mode address spaces），比如调用malloc分配的内存，以及使用MAP_ANONYMOUS的mmap。当系统内存不够时，内核可以将这部分内存交换出去。\\n', 'file_rss：用户空间的文件映射页（Mapped pages in User Mode address spaces），包含map file和map tmpfs，前者比如指定文件的mmap，后者比如IPC共享内存。当系统内存不够时，内核可以回收这些页，但回收之前可能需要与文件同步数据。\\n', 'file_cache：文件缓存（page in page cache of disk file），普通读写（read/write）文件时产生的文件缓存。当系统内存不够时，内核可以回收这些页，但回收之前可能需要与文件同步数据。\\n', 'buffer pages：属于page cache，比如读取块设备文件时的相关缓存。\\n', '其中anon_rss和file_rss属于进程的RSS，file_cache和buffer pages属于page cache。简单来说：\\n', '\\n', 'top里的RSS = anon_rss + file_rss，SHR = file_rss。\\n', '\\n', 'CGroup里的memory.usage_in_bytes = cache + RSS + swap。\\n', '\\n', '由上可知，syestemd相关命令和top命令的内存占用率含义不同，所以查询结果不同。\\n', '\\n', '设置RAID0卷，参数stripsize设置为4时出错\\n', '问题现象\\n', '设置RAID0卷，参数stripsize设置为4时出错。\\n', '\\n', '原因分析\\n', '64K页表开启只能支持64K场景。\\n', '\\n', '解决方法\\n', '不需要修改配置文件，openeuler执行lvcreate命令时，条带化规格支持的stripesize最小值为64KB，将参数stripesize设置为64。\\n', '\\n', '使用rpmbuild编译mariadb失败\\n', '问题描述\\n', '如果使用root账号登录系统，并在该账号下使用rpmbuild命令编译mariadb源代码，会出现编译失败现象，提示：\\n', '\\n', \"+ echo 'mysql can'\\\\''t run test as root'\\n\", \"mysql can't run test as root\\n\", '+ exit 1\\n', '原因分析\\n', 'mariadb数据库不允许使用root权限的账号进行测试用例执行，所以会阻止编译过程（编译过程中会自动执行测试用例）。\\n', '\\n', '解决方案\\n', '使用vi等文本编辑工具，修改mariadb.spec文件中runtest变量的值。\\n', '\\n', '修改前：\\n', '\\n', '%global runtest 1\\n', '修改后：\\n', '\\n', '%global runtest 0\\n', '该修改关闭了编译阶段执行测试用例的功能，但不会影响编译和编译后的RPM包内容。\\n', '\\n', '使用默认配置启动SNTP服务失败\\n', '问题现象\\n', '默认配置情况下SNTP服务启动失败。\\n', '\\n', '原因分析\\n', '默认配置中未添加授时服务器域名。\\n', '\\n', '解决方案\\n', '修改/etc/sysconfig/sntp文件 ，在文件中添加中国NTP快速授时服务器域名：0.generic.pool.ntp.org。\\n', '\\n', '安装时出现软件包冲突、文件冲突或缺少软件包导致安装失败\\n', '问题现象\\n', '安装软件包过程中，可能出现软件包冲突、文件冲突或缺少软件包，从而导致升安装被中断，最终安装失败。软件包冲突、文件冲突和缺少软件包的报错信息分别如下所示。\\n', '\\n', '软件包冲突报错信息示例（以 libev-libevent-devel-4.24-11.oe1.aarch64与libevent-devel-2.1.11-2.oe1.aarch64冲突为例）：\\n', '\\n', 'package libev-libevent-devel-4.24-11.oe1.aarch64 conflicts with libevent-devel provided by libevent-devel-2.1.11-2.oe1.aarch64  \\n', ' - cannot install the best candidate for the job  \\n', ' - conflicting requests\\n', '文件冲突报错信息示例（以/usr/bin/containerd文件冲突为例）：\\n', '\\n', 'Error: Transaction test error:  \\n', ' file /usr/bin/containerd from install of containerd-1.2.0-101.oe1.aarch64 conflicts with file from package docker-engine-18.09.0-100.aarch64  \\n', ' file /usr/bin/containerd-shim from install of containerd-1.2.0-101.oe1.aarch64 conflicts with file from package docker-engine-18.09.0-100.aarch64\\n', '缺少软件包的报错信息示例（以缺失blivet-data软件包为例）：\\n', '\\n', 'Error:  \\n', '  Problem: cannot install both blivet-data-1:3.1.1-6.oe1.noarch and blivet-data-1:3.1.1-5.noarch  \\n', '   - package python2-blivet-1:3.1.1-5.noarch requires blivet-data = 1:3.1.1-5, but none of the providers can be installed  \\n', '   - cannot install the best update candidate for package blivet-data-1:3.1.1-5.noarch  \\n', \"   - problem with installed package python2-blivet-1:3.1.1-5.noarch(try to add '--allowerasing' to command line to replace conflicting packages or '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages)\\n\", '原因分析\\n', 'openEuler提供的软件包中，有些软件包虽然名称不同，但功能相同，导致两个软件包无法同时安装。\\n', 'openEuler提供的软件包中，有些软件包虽然名称不同，但功能相同，导致安装时安装后的文件相同，从而产生了文件冲突。\\n', '有些软件包，因在升级安装前被其他软件包所依赖，一旦该软件包升级后，可能导致依赖它的软件包因缺少软件包而不能安装。\\n', '解决方案\\n', '若为软件包冲突，则按如下步骤进行处理（以问题现象中示例的软件包冲突为例）：\\n', '\\n', '根据安装过程中的软件包冲突报错信息，确定与待安装的 libev-libevent-devel-4.24-11.oe1.aarch64软件包冲突的软件包为libevent-devel-2.1.11-2.oe1.aarch64。\\n', '\\n', '执行dnf remove命令将与待安装软件包冲突的软件包单独卸载。\\n', '\\n', '# dnf remove libevent-devel-2.1.11-2.oe1.aarch64\\n', '重新进行安装操作。\\n', '\\n', '若为文件冲突，则按如下步骤进行处理（以问题现象中示例的文件冲突为例）：\\n', '\\n', '根据安装过程中的文件冲突报错信息，确定导致文件冲突的软件包名称为containerd-1.2.0-101.oe1.aarch64和docker-engine-18.09.0-100.aarch64。\\n', '\\n', '将不需要安装的软件包名称记录下来，以不需要安装docker-engine-18.09.0-100.aarch64为例。\\n', '\\n', '执行dnf remove命令将不需要安装的软件包单独卸载。\\n', '\\n', '# dnf remove docker-engine-18.09.0-100.aarch64\\n', '重新进行安装操作。\\n', '\\n', '若为缺少软件包，则按如下步骤进行处理（以问题现象中示例的缺少软件包为例）：\\n', '\\n', '根据升级安装过程中的缺少软件包报错信息，确定待升级的软件包名称blivet-data-1:3.1.1-5.noarch及依赖它的软件包名称python2-blivet-1:3.1.1-5.noarch。\\n', '\\n', '执行dnf remove命令将依赖待升级包才能安装的软件包单独卸载或在升级软件包时加上--allowerasing参数。\\n', '\\n', '执行dnf remove命令将依赖blivet-data-1:3.1.1-5.noarch软件包才能安装的软件包单独卸载。\\n', '\\n', '# dnf remove python2-blivet-1:3.1.1-5.noarch\\n', '升级软件包时加上--allowerasing参数。\\n', '\\n', '# yum update blivet-data-1:3.1.1-5.noarch -y --allowerasing\\n', '重新进行升级操作。\\n', '\\n', '安装冲突实例\\n', '文件冲突\\n', '\\n', 'python3-edk2-devel.noarch 与 build.noarch 因文件名重复存在冲突。\\n', '\\n', '# yum install python3-edk2-devel.noarch build.noarch\\n', '...\\n', 'Error: Transaction test error:\\n', 'file /usr/bin/build conflicts between attempted installs of python3-edk2-devel-202002-3.oe1.noarch and build-20191114-324.4.oe1.noarch\\n', 'libiscsi降级失败\\n', '问题现象\\n', 'libiscsi-1.19.4 版本及以上降级到 libiscsi-1.19.3 及以下版本时失败。\\n', '\\n', 'Error:\\n', 'Problem: problem with installed package libiscsi-utils-1.19.0-4.oe1.x86_64\\n', '- package libiscsi-utils-1.19.0-4.oe1.x86_64 requires libiscsi(x86-64) = 1.19.0-4.oe1, but none of the providers can be installed\\n', '- cannot install both libiscsi-1.19.0-3.oe1.x86_64 and libiscsi-1.19.0-4.oe1.x86_64\\n', '- cannot install both libiscsi-1.19.0-4.oe1.x86_64 and libiscsi-1.19.0-3.oe1.x86_64\\n', '- conflicting requests\\n', \"(try to add '--allowerasing' to command line to replace conflicting packages or '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages)\\n\", '原因分析\\n', 'libiscsi-1.19.3 之前的版本把 iscsi-xxx 等二进制文件打包进了主包 libiscsi，而这些二进制文件引入了不合理的依赖 CUnit, 为了解决这种不合理的依赖，在 libiscsi-1.19.4 版本把这些二进制文件单独拆分出来一个子包 libiscsi-utils，主包弱依赖于子包，产品可以根据自己的需求在做镜像时是否集成该子包；不集成或卸载子包不会影响 libiscsi 主包的功能。 如果系统中安装了 libiscsi-utils 子包，libiscsi-1.19.4 及以上版本降级到 libiscsi-1.19.3 及以下版本时，由于 libiscsi-1.19.3 及以下版本无法提供对应的 libiscsi-utils，因此 libiscsi-utils 不会降级，但 libiscsi-utils 依赖于降级前的 libiscsi 主包，导致依赖问题无法解决，最终导致降级失败。\\n', '\\n', '解决方案\\n', '执行以下命令，卸载 libiscsi-utils 子包，卸载成功后再进行降级操作。\\n', '\\n', 'yum remove libiscsi-utils\\n', 'xfsprogs降级失败\\n', '问题现象\\n', 'xfsprogs-5.6.0-2 及以上版本降级到 xfsprogs-5.6.0-1 及以下版本时失败。\\n', '\\n', 'Error:\\n', 'Problem: problem with installed package xfsprogs-xfs_scrub-5.6.0-2.oe1.x86_64\\n', '- package xfsprogs-xfs_scrub-5.6.0-2.oe1.x86_64 requires xfsprogs = 5.6.0-2.oe1, but none of the providers can be installed\\n', '- cannot install both xfsprogs-5.6.0-1.oe1.x86_64 and xfsprogs-5.6.0-2.oe1.x86_64\\n', '- cannot install both xfsprogs-5.6.0-2.oe1.x86_64 and xfsprogs-5.6.0-1.oe1.x86_64\\n', '- conflicting requests\\n', '原因分析\\n', '在 xfsprogs-5.6.0-2 版本中，为了减少 xfsprogs 主包的不合理依赖，同时将实验性质的命令从主包中分来，我们将 xfs_scrub* 命令拆分到单独的 xfsprogs-xfs_scrub 子包中。而 xfsprogs 主包弱依赖于 xfsprogs-xfs_scrub 子包，所以产品可以根据自己的需求在做镜像时是否集成该子包，或者是否卸载该子包。不集成或卸载该子包不会影响 xfsprogs 主包功能。\\n', '\\n', '如果系统中安装了 xfsprogs-xfs_scrub 子包，从 xfsprogs-5.6.0-2 及以上版本降级到 xfsprogs-5.6.0-1 及以下版本时，由于 xfsprogs-5.6.0-1 及以下版本无法提供对应的 xfsprogs-xfs_scrub，因此 xfsprogs-xfs_scrub 不会降级，但 xfsprogs-xfs_scrub 依赖于降级前的 xfsprogs 主包，导致依赖问题无法解决，最终导致降级失败。\\n', '\\n', '解决方案\\n', '执行以下命令，卸载 xfsprogs-xfs_scrub 子包，卸载成功后再进行降级操作。\\n', '\\n', 'yum remove xfsprogs-xfs_scrub\\n', 'cpython/Lib发现CVE-2019-9674:Zip炸弹漏洞\\n', '问题现象\\n', 'Python 3.7.2 及以下版本中的 Lib/zipfile.py 允许远程攻击者通过 zip 炸弹制造拒绝服务请求，从而导致资源消耗过大。\\n', '\\n', '原因分析\\n', '远程攻击者通过 zip 炸弹导致拒绝服务，影响目标系统业务甚至达到使系统崩溃的结果。zip 炸弹就是一个高压缩比的 zip 文件，它本身可能只有几M或几十M的大小，但是解压缩之后会产生巨大的数据量，产生巨大的资源消耗。\\n', '\\n', '解决方案\\n', '在 zipfile 文档中添加告警信息： https://github.com/python/cpython/blob/3.7/Doc/library/zipfile.rst。\\n', '\\n', '不合理使用glibc正则表达式引起ReDoS攻击\\n', '问题现象\\n', '使用glibc的regcomp/regexec接口编程，或者grep/sed等应用glibc正则表达式的shell命令，不合理的正则表达式或输入会造成ReDoS攻击（CVE-2019-9192/CVE-2018-28796）。 典型正则表达式pattern为“反向引用”（\\\\1表示）与“*”（匹配零次或多次）、“+”（匹配一次或多次）、“{m,n}”（最小匹配m次，最多匹配n次）的组合，或者配合超长字符串输入，示例如下：\\n', '\\n', '# echo D | grep -E \"$(printf \\'(\\\\0|)(\\\\\\\\1\\\\\\\\1)*\\')\"Segmentation fault (core dumped)\\n', '# grep -E \"$(printf \\'(|)(\\\\\\\\1\\\\\\\\1)*\\')\"\\n', 'Segmentation fault (core dumped)\\n', \"# echo A | sed '/\\\\(\\\\)\\\\(\\\\1\\\\1\\\\)*/p'\\n\", 'Segmentation fault (core dumped)\\n', '# time python -c \\'print \"a\"*40000\\' | grep -E \"a{1,32767}\"\\n', 'Segmentation fault (core dumped)\\n', '# time python -c \\'print \"a\"*40900\\' | grep -E \"(a)\\\\\\\\1\"\\n', 'Segmentation fault (core dumped)\\n', '原因分析\\n', '使用正则表达式的进程coredump。具体原因为glibc正则表达式的实现为NFA/DFA混合算法，内部原理是使用贪婪算法进行递归查找，目的是尽可能匹配更多的字符串，贪婪算法在处理递归正则表达式时会导致ReDoS。\\n', '\\n', '解决方案\\n', '需要对用户做严格的权限控制，减少攻击面。\\n', '用户需保证正则表达式的正确性，不输入无效正则表达式，或者超长字符串配合正则的“引用” “*”等容易触发无限递归的组合。\\n', '# ()(\\\\1\\\\1)*\\n', '# \"a\"*400000\\n', '用户程序在检测到进程异常之后，通过重启进程等手段恢复业务，提升程序的可靠性。\\n', '安装卸载httpd-devel和apr-util-devel软件包，其中的依赖包gdbm-devel安装、卸载有报错\\n', '问题现象\\n', 'gdbm-devel-1.18.1-1包安装、卸载有报错；\\n', '问题1修复后，gdbm和gdbm-devel包更新到1.18.1-2版本，但在安装httpd-devel、apr-util-devel等包（依赖关系中有gdbm-devel软件包）时，默认安装的gdbm-devel还是1.18.1-1旧版本，导致问题报错依然存在。\\n', '原因分析\\n', 'gdbm-devel-1.18.1-1包中缺少提供info信息的help软件包，导致单独安装gdbm-devel并不能将help包引入进来，所以出现了如下告警信息。 install-info: 没有那个文件或目录 for /usr/share/info/gdbm.info.gz\\n', '由于系统默认安装的gdbm主包是1.18.1-1版本，而没有安装gdbm-devel包。依赖gdbm-devel包的相关软件包在安装gdbm-devel包的过程中，仍会匹配gdbm的主包版本，故而依然安装了gdbm-devel的旧版本1.18.1-1,导致警告信息依然存在。\\n', '解决方案\\n', '单包升级gdbm，安装使用gdbm-1.18.1-2版本相关软件包后，告警信息消失；\\n', '在单包升级gdbm后，再进行安装依赖的gdbm-devel软件包安装，让其依赖高版本gdbm软件包，告警信息消失。\\n', '系统reboot后，执行yum/dnf 等命令报错，提示rpmdb error\\n', '问题现象\\n', 'reboot系统，重启后，执行rpm相关命令(yum/dnf)提示：\\n', 'error: db5 error(-30973) from dbenv->open: BDB0087 DB_RUNRECOVERY: Fatal error, run database recovery\\n', 'error: cannot open Packages index using db5 - (-30973)\\n', 'error: cannot open Packages database in /var/lib/rpm\\n', 'Error: Error: rpmdb open failed\\n', '原因分析\\n', '执行安装升级动作过程中，会对/var/lib/rpm/__db.00*文件进行读写操作，如果在运行中出现强制下电、磁盘空间满或者 ‘kill -9’ 等异常中断操作，会导致对应_db文件损坏，后续执行rpm相关命令（dnf/yum）会发生报错\\n', '解决方案\\n', '步骤1 使用 ‘kill -9’ 停止所有正在运行的rpm命令。\\n', '步骤2 删除所有的/var/lib/rpm/__db.00*文件。\\n', '步骤3 执行 ‘rpmdb –rebuilddb’ 命令，重建rpm db后即可。\\n', '\\n', '执行 rpmrebuild -d /home/test filesystem对filesystem包rebuild时，rebuild失败\\n', '问题现象\\n', \"执行 rpmrebuild –comment-missing=y –keep-perm -b -d /home/test filesystem-3.16-3.oe1.aarch64对filesystem包rebuild时，rebuild失败. /usr/lib/rpmrebuild/rpmrebuild.sh:Error:(RpmBuild) Package 'filesystem-3.16-3.oe1.aarch64' build failed. /usr/lib/rpmrebuild/rpmrebuild.sh:Error: RpmBuild\\n\", '\\n', '原因分析\\n', '软件包在%pretrans -p阶段创建目录，并在%ghost阶段对该目录进行修饰，如果用户在该目录下创建目录或文件，执行rpmrebuild对该包进行打包，发现创建的目录或文件也会打包到该包中。\\n', '\\n', '上述问题的根本原因是因为filesystem在%pretrans阶段创建了/proc目录，并在%ghost阶段对该目录进行了修饰，但是该目录在系统运行时会动态的创建一些微量进程，这些进程非目录也非文件，在执行rpmrebuild的时无法对这些进程进行打包，所以rebuild失败。\\n', '\\n', '解决方案\\n', '暂时不使用rpmrebuild命令对filesystem进行rebuild。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建数据库服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建数据库服务器\\n', '搭建数据库服务器\\n', 'PostgreSql服务器\\n', '软件介绍\\n', '配置环境\\n', '安装、运行和卸载\\n', '管理数据库角色\\n', '管理数据库\\n', 'Mariadb服务器\\n', '软件介绍\\n', '配置环境\\n', '安装、运行和卸载\\n', '管理数据库用户\\n', '管理数据库\\n', 'MySQL服务器\\n', '软件介绍\\n', '配置环境\\n', '安装、运行和卸载\\n', '管理数据库用户\\n', '管理数据库\\n', 'PostgreSql服务器\\n', '软件介绍\\n', 'PostgreSQL的架构如图1所示，主要进程说明如表1所示。\\n', '\\n', '图 1 PostgreSql架构\\n', '\\n', '\\n', '表 1 PostgreSql中的主要进程说明\\n', '\\n', '\\n', '进程类别\\n', '\\n', '进程名称\\n', '\\n', '说明\\n', '\\n', '主进程\\n', '\\n', 'Postmaster\\n', '\\n', 'Postmaster是整个数据库实例的总控进程，负责启动和关闭该数据库实例。\\n', '\\n', '常驻进程\\n', '\\n', 'Postgres（常驻进程）\\n', '\\n', '管理后端的常驻进程，也称为“postmaster”。其默认侦听UNIXDomain Socket和TCP/IP（Windows等，一部分的平台只侦听TCP/IP）的5432端口，等待来自前端的的连接处理。侦听的端口号可以在PostgreSql的设置文件postgresql.conf中修改。\\n', '\\n', '子进程\\n', '\\n', 'Postgres（子进程）\\n', '\\n', '子进程根据pg_hba.conf定义的安全策略来判断是否允许进行连接，根据策略，会拒绝某些特定的IP及网络，或者也可以只允许某些特定的用户或者对某些数据库进行连接。\\n', '\\n', 'Postgres会接受前端过来的查询，然后对数据库进行检索，最后把结果返回，有时也会对数据库进行更新。更新的数据同时还会记录在事务日志里面（PostgreSQL称为WAL日志）。这个主要是当停电、服务器宕机、重新启动的时候进行恢复处理的时候使用。另外，把日志归档保存起来，可在需要进行恢复的时候使用。在PostgreSQL 9.0以后，通过把WAL日志传送其他的postgreSQL，可以实时的进行数据库复制，这就是所谓的“数据库复制”功能。\\n', '\\n', '辅助进程\\n', '\\n', 'SysLogger（系统日志）\\n', '\\n', '需要在Postgres.conf中logging_collection设置为on，此时主进程才会启动Syslogger辅助进程。\\n', '\\n', 'BgWriter（后台写）\\n', '\\n', '把共享内存中的脏页写到磁盘上的进程。主要是为了提高插入、更新和删除数据的性能。\\n', '\\n', 'WALWriter（预写式日志）\\n', '\\n', '在修改数据之前把修改操作记录到磁盘中，以便后面更新实时数据时就不需要数据持久化到文件中。\\n', '\\n', 'PgArch（归档）\\n', '\\n', 'WAL日志会被循环使用，PgArch在归档前会把WAL日志备份出来。通过PITY（Point in Time Recovery）技术，可以对数据库进行一次全量备份后，该技术将备份时间点之后的WAL日志通过归档进行备份，使用数据库的全量备份再加上后面产生的WAL日志，即可把数据库向前推到全量备份后的任意一个时间点。\\n', '\\n', 'AutoVacuum（系统自动清理）\\n', '\\n', '在PostgreSQL数据库中，对表进行DELETE操作后，旧的数据并不会立即被删除，并且，在更新数据时，也并不会在旧的数据上做更新，而是新生成一行数据。旧的数据只是被标识为删除状态，只有在没有并发的其他事务读到这些就数据时，它们才会被清除。这个清除工作就由AutoVacuum进程完成。\\n', '\\n', 'PgStat（统计收集）\\n', '\\n', '做数据的统计收集工作。主要用于查询优化时的代价估算，包括一个表和索引进行了多少次的插入、更新、删除操作，磁盘块读写的次数、行的读次数。pg_statistic中存储了PgStat收集的各类信息。\\n', '\\n', 'CheckPoint（检查点）\\n', '\\n', '检查点是系统设置的事务序列点，设置检查点保证检查点前的日志信息刷到磁盘中。\\n', '\\n', '配置环境\\n', ' 说明：\\n', '以下环境配置仅为参考示例，具体配置视实际需求做配置\\n', '\\n', '关闭防火墙并取消开机自启动\\n', ' 说明：\\n', '测试环境下通常会关闭防火墙以避免部分网络因素影响，视实际需求做配置。\\n', '\\n', '在root权限下停止防火墙。\\n', '\\n', '# systemctl stop firewalld\\n', '在root权限下关闭防火墙。\\n', '\\n', '# systemctl disable firewalld\\n', ' 说明：\\n', '执行disable命令关闭防火墙的同时，也取消了开机自启动。\\n', '\\n', '修改SELINUX为disabled\\n', '在root权限下修改配置文件。\\n', '\\n', \"# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\\n\", '创建组和用户\\n', ' 说明：\\n', '服务器环境下，为了系统安全，通常会为进程分配单独的用户，以实现权限隔离。本章节创建的组和用户都是操作系统层面的，不是数据库层面的。\\n', '\\n', '在root权限下创建PostgreSQL用户（组）。\\n', '\\n', '# groupadd  postgres\\n', '# useradd  -g postgres postgres\\n', '在root权限下设置postgres用户密码（重复输入密码）。\\n', '\\n', '# passwd postgres\\n', '搭建数据盘\\n', ' 说明：\\n', '\\n', '测试极限性能时，建议单独挂载IO性能更优的NVME SSD存储介质创建PostgreSQL测试实例，避免磁盘IO对性能测试结果的影响，本文以单独挂载NVME SSD为例，参考步骤1~步骤4。\\n', '非性能测试时，在root权限下执行以下命令，创建数据目录即可。然后跳过本小节：\\n', '# mkdir /data\\n', '在root权限下创建文件系统（以xfs为例，根据实际需求创建文件系统），若磁盘之前已做过文件系统，执行此命令会出现报错，可使用-f参数强制创建文件系统。\\n', '\\n', '# mkfs.xfs /dev/nvme0n1\\n', '在root权限下创建数据目录。\\n', '\\n', '# mkdir /data\\n', '在root权限下挂载磁盘。\\n', '\\n', '# mount -o noatime,nobarrier /dev/nvme0n1 /data\\n', '数据目录授权\\n', '在root权限下修改目录权限。\\n', '\\n', '# chown -R postgres:postgres /data/\\n', '安装、运行和卸载\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装PostgreSQL服务器。\\n', '\\n', '# dnf install postgresql-server\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep postgresql\\n', '运行\\n', '初始化数据库\\n', ' 须知：\\n', '此步骤在postgres用户下操作。\\n', '\\n', '切换到已创建的PostgreSQL用户。\\n', '\\n', '# su - postgres\\n', '初始化数据库，其中命令中的/usr/bin是命令initdb所在的目录。\\n', '\\n', '$ /usr/bin/initdb -D /data/\\n', '启动数据库\\n', '启动PostgreSQL数据库。\\n', '\\n', '$ /usr/bin/pg_ctl -D /data/ -l /data/logfile start\\n', '确认PostgreSQL数据库进程是否正常启动。\\n', '\\n', '$ ps -ef | grep postgres\\n', '命令执行后，打印信息如下图所示，PostgreSQL相关进程已经正常启动了。\\n', '\\n', '\\n', '\\n', '登录数据库\\n', '登录数据库。\\n', '\\n', '$ /usr/bin/psql -U postgres\\n', '\\n', '\\n', ' 说明：\\n', '初次登录数据库，无需密码。\\n', '\\n', '配置数据库账号密码\\n', '登录后，设置postgres密码。\\n', '\\n', \"postgres=#alter user postgres with password '123456';\\n\", '\\n', '\\n', '退出数据库\\n', '执行\\\\q退出数据库。\\n', '\\n', 'postgres=#\\\\q\\n', '停止数据库\\n', '停止PostgreSQL数据库。\\n', '\\n', '$ /usr/bin/pg_ctl -D /data/ -l /data/logfile stop\\n', '卸载\\n', '在postgres用户下停止数据库。\\n', '\\n', '$ /usr/bin/pg_ctl -D /data/ -l /data/logfile stop\\n', '在root用户下执行dnf remove postgresql-server卸载PostgreSQL数据库。\\n', '\\n', '# dnf remove postgresql-server\\n', '管理数据库角色\\n', '创建角色\\n', '可以使用CREATE ROLE语句或createuser来创建角色。createuser是对CREATE ROLE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', 'CREATE ROLE rolename [ [ WITH ] option [ ... ] ];\\n', 'createuser rolename\\n', '其中：\\n', '\\n', 'rolename：角色名。\\n', 'option为参数选项，常用的有：\\n', 'SUPERUSER | NOSUPERUSER：决定一个新角色是否为\"超级用户\"，若未指定，则默认为NOSUPERUSER，即不是超级用户。\\n', 'CREATEDB | NOCREATEDB：定义一个角色是否能创建数据库，若未指定，则默认为NOCREATEDB，即不能创建数据库。\\n', 'CREATEROLE | NOCREATEROLE：决定一个角色是否可以创建新角色，若未指定，则默认为NOCREATEROLE，即不能创建新角色。\\n', 'INHERIT | NOINHERIT：决定一个角色是否\"继承\"它所在组的角色的权限。一个带有 INHERIT 属性的角色可以自动使用已经赋与它直接或间接所在组的任何权限。若未指定，则默认为INHERIT。\\n', 'LOGIN | NOLOGIN：决定一个角色是否可以登录，一个拥有LOGIN属性的角色可以认为是一个用户，若无此属性的角色可以用于管理数据库权限，但是并不是用户，若未指定，则默认为NOLOGIN。但若创建角色是使用的是CREATE USER而不是CREATE ROLE，则默认是LOGIN属性。\\n', \"[ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'：设置角色的密码，密码只对那些拥有 LOGIN 属性的角色有意义。ENCRYPTED | UNENCRYPTED表示是否对密码进行加密，若未指定，则默认为ENCRYPTED，即加密。\\n\", \"VALID UNTIL 'timestamp'：角色的密码失效的时间戳，若为指定，则表示密码永久有效。\\n\", 'IN ROLE rolename1：列出一个或多个现有的角色，新角色rolename将立即加入这些角色，成为rolename1的成员。\\n', 'ROLE rolename2：列出一个或多个现有的角色，它们将自动添加为新角色rolename的成员，即新角色为\"组\"。\\n', '要使用这条命令，必须拥有 CREATEROLE 权限或者是数据库超级用户。\\n', '\\n', '示例\\n', '#创建一个可以登录的角色roleexample1。\\n', '\\n', 'postgres=# CREATE ROLE roleexample1 LOGIN;\\n', '#创建一个密码为123456的角色roleexample2。\\n', '\\n', \"postgres=# CREATE ROLE roleexample2 WITH LOGIN PASSWORD '123456';\\n\", '#创建角色名为roleexample3的角色。。\\n', '\\n', '[postgres@localhost ~]$ createuser roleexample3\\n', '查看角色\\n', '可以使用SELECT语句或psql的元命令\\\\du查看角色。\\n', '\\n', 'SELECT rolename FROM pg_roles;\\n', '\\\\du\\n', '其中：rolename：角色名。\\n', '\\n', '示例\\n', '#查看roleexample1角色。\\n', '\\n', 'postgres=# SELECT roleexample1 from pg_roles;\\n', '#查看现有角色。\\n', '\\n', 'postgres=# \\\\du\\n', '修改角色\\n', '修改用户名\\n', '可以使用ALTER ROLE语句修改一个已经存在的角色名。\\n', '\\n', 'ALTER ROLE oldrolername RENAME TO newrolename;\\n', '其中：\\n', '\\n', 'oldrolername：旧的角色名。\\n', 'newrolename：新的角色名。\\n', '修改用户示例\\n', '#将角色名roleexample1修改为roleexapme2。\\n', '\\n', 'postgres=# ALTER ROLE roleexample1 RENAME TO roleexample2;\\n', '修改用户密码\\n', '可以使用ALTER ROLE语句修改一个角色的登录密码。\\n', '\\n', \"ALTER ROLE rolename PASSWORD 'password'\\n\", '其中：\\n', '\\n', 'rolename：角色名。\\n', 'password：密码。\\n', '修改角色密码示例\\n', '#将roleexample1的密码修改为456789。\\n', '\\n', \"postgres=# ALTER ROLE roleexample1 WITH PASSWORD '456789';\\n\", '删除角色\\n', '可以使用DROP ROLE语句或dropuser来删除角色。dropuser是对DROP ROLE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', 'DROP ROLE rolename;\\n', 'dropuser rolename\\n', '其中：rolename：角色名。\\n', '\\n', '示例\\n', '#删除userexample1角色。\\n', '\\n', 'postgres=# DROP ROLE userexample1;\\n', '#删除userexample2角色。。\\n', '\\n', '[postgres@localhost ~]$ dropuser userexample2\\n', '角色授权\\n', '可以使用GRANT语句来对角色授权。\\n', '\\n', '对角色授予表的操作权限：\\n', '\\n', 'GRANT { { SELECT | INSERT | UPDATE | DELETE | REFERENCES | TRIGGER } [,...] | ALL [ PRIVILEGES ] } ON [ TABLE ] tablename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]\\n', '对角色授予序列的操作权限：\\n', '\\n', 'GRANT { { USAGE | SELECT | UPDATE } [,...] | ALL [ PRIVILEGES ] } ON SEQUENCE sequencename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ] \\n', '对角色授予数据库的操作权限：\\n', '\\n', 'GRANT { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] } ON DATABASE databasename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予函数的操作权限：\\n', '\\n', 'GRANT { EXECUTE | ALL [ PRIVILEGES ] } ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予过程语言的操作权限：\\n', '\\n', 'GRANT { USAGE | ALL [ PRIVILEGES ] } ON LANGUAGE langname [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予模式的操作权限：\\n', '\\n', 'GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] } ON SCHEMA schemaname [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ]  \\n', '对角色授予表空间的操作权限：\\n', '\\n', 'GRANT { CREATE | ALL [ PRIVILEGES ] } ON TABLESPACE tablespacename [, ...] TO { rolename | GROUP groupname | PUBLIC } [, ...] [ WITH GRANT OPTION ] \\n', '将角色rolename1的成员关系赋予角色rolename2：\\n', '\\n', 'GRANT rolename1 [, ...] TO rolename2 [, ...] [ WITH ADMIN OPTION ]\\n', '其中：\\n', '\\n', 'SELECT、INSERT、UPDATE、DELETE、REFERENCES、TRIGGER、USAGE、CREATE、CONNECT、TEMPORARY、TEMP、EXECUTE、ALL [ PRIVILEGES ]：用户的操作权限，ALL [ PRIVILEGES ]表示所有的权限，PRIVILEGES关键字在 PostgreSQL里是可选的，但是严格的SQL 要求有这个关键字。\\n', 'ON字句：用于指定权限授予的对象。\\n', 'tablename：表名。\\n', 'TO字句：用来指定被赋予权限的角色。\\n', 'rolename、rolename1、rolename2：角色名。\\n', 'groupname：角色组名。\\n', 'PUBLIC：表示该权限要赋予所有角色，包括那些以后可能创建的用户。\\n', 'WITH GRANT OPTION：表示权限的接收者也可以将此权限赋予他人，否则就不能授权他人。该选项不能赋予给PUBLIC。\\n', 'sequencename：序列名。\\n', 'databasename：数据库名。\\n', 'funcname ( [ [ argmode ] [ argname ] argtype [, …] ] )：函数名及其参数。\\n', 'langname：过程语言名。\\n', 'schemaname：模式名。\\n', 'tablespacename：表空间名。\\n', 'WITH ADMIN OPTION：表示成员随后就可以将角色的成员关系赋予其它角色，以及撤销其它角色的成员关系。\\n', '示例\\n', '#对userexample授予数据库database1的CREATE权限。\\n', '\\n', 'postgres=# GRANT CREATE ON DATABASE database1 TO userexample; \\n', '#对所有用户授予表table1的所有权限。\\n', '\\n', 'postgres=# GRANT ALL PRIVILEGES ON TABLE table1 TO PUBLIC; \\n', '删除用户权限\\n', '可以使用REVOKE语句来撤销以前赋予一个或多个角色的权限。\\n', '\\n', '撤销角色对表的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { SELECT | INSERT | UPDATE | DELETE | REFERENCES | TRIGGER } [,...] | ALL [ PRIVILEGES ] } ON [ TABLE ] tablename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...]\\n', '撤销角色对序列的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { USAGE | SELECT | UPDATE } [,...] | ALL [ PRIVILEGES ] } ON SEQUENCE sequencename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ]  \\n', '撤销角色对数据库的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { CREATE | CONNECT | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] } ON DATABASE databasename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '撤销角色对函数的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { EXECUTE | ALL [ PRIVILEGES ] } ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '撤销角色对过程语言的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { USAGE | ALL [ PRIVILEGES ] } ON LANGUAGE langname [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '撤销角色对模式的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] } ON SCHEMA schemaname [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ]  \\n', '撤销角色对表空间的操作权限：\\n', '\\n', 'REVOKE [ GRANT OPTION FOR ] { CREATE | ALL [ PRIVILEGES ] } ON TABLESPACE tablespacename [, ...] FROM { rolename | GROUP groupname | PUBLIC } [, ...] [ CASCADE | RESTRICT ] \\n', '删除rolename2的rolename1的成员关系：\\n', '\\n', 'REVOKE [ ADMIN OPTION FOR ] rolename1 [, ...] FROM rolename2 [, ...] [ CASCADE | RESTRICT ]\\n', '其中：\\n', '\\n', 'GRANT OPTION FOR：表示只是撤销对该权限的授权的权力，而不是撤销该权限本身。\\n', 'SELECT、INSERT、UPDATE、DELETE、REFERENCES、TRIGGER、USAGE、CREATE、CONNECT、TEMPORARY、TEMP、EXECUTE、ALL [ PRIVILEGES ]：用户的操作权限，ALL [ PRIVILEGES ]表示所有的权限，PRIVILEGES关键字在 PostgreSQL里是可选的，但是严格的SQL 要求有这个关键字。\\n', 'ON字句：用于指定撤销权限的对象。\\n', 'tablename：表名。\\n', 'FROM字句：用来指定被撤销权限的角色。\\n', 'rolename、rolename1、rolename2：角色名。\\n', 'groupname：角色组名。\\n', 'PUBLIC：表示撤销隐含定义的、拥有所有角色的组，但并不意味着所有角色都失去了权限，那些直接得到的权限以及通过一个组得到的权限仍然有效。\\n', 'sequencename：序列名。\\n', 'CASCADE：撤销所有依赖性权限。\\n', 'RESTRICT：不撤销所有依赖性权限。\\n', 'databasename：数据库名。\\n', 'funcname ( [ [ argmode ] [ argname ] argtype [, …] ] )：函数名及其参数。\\n', 'langname：过程语言名。\\n', 'schemaname：模式名。\\n', 'tablespacename：表空间名。\\n', 'ADMIN OPTION FOR：表示传递的授权不会自动收回。\\n', '示例\\n', '#对userexample授予数据库database1的CREATE权限。\\n', '\\n', 'postgres=# GRANT CREATE ON DATABASE database1 TO userexample; \\n', '#对所有用户授予表table1的所有权限。\\n', '\\n', 'postgres=# GRANT ALL PRIVILEGES ON TABLE table1 TO PUBLIC; \\n', '管理数据库\\n', '创建数据库\\n', '可以使用CREATE DATABASE语句或createdb来创建角色。createrdb是对CREATE DATABASE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', 'CREATE DATABASE databasename;\\n', 'createdb databasename\\n', '其中：databasename为数据库名。\\n', '\\n', '要使用这条命令，必须拥有CREATEDB权限。\\n', '\\n', '示例\\n', '#创建一个数据库database1。\\n', '\\n', 'postgres=# CREATE DATABASE database1;\\n', '选择数据库\\n', '可以使用\\\\c语句来选择数据库。\\n', '\\n', '\\\\c databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', '示例\\n', '#选择databaseexample数据库。\\n', '\\n', 'postgres=# \\\\c databaseexample;\\n', '查看数据库\\n', '可以使用\\\\l语句来查看数据库。\\n', '\\n', '\\\\l;\\n', '示例\\n', '#查看所有数据库。\\n', '\\n', 'postgres=# \\\\l;\\n', '删除数据库\\n', '可以使用DROP DATABASE语句或dropdb来删除数据库。dropdb是对DROP DATABASE命令的封装，需要在shell界面执行，而不是在数据库界面。\\n', '\\n', ' 注意：\\n', '删除数据库要谨慎操作，一旦删除，数据库中的所有表和数据都会删除。\\n', '\\n', 'DROP DATABASE databasename;\\n', 'dropdb databasename\\n', '其中：databasename为数据库名称。\\n', '\\n', 'DROP DATABASE会删除数据库的系统目录项并且删除包含数据的文件目录。\\n', '\\n', 'DROP DATABASE只能由超级管理员或数据库拥有者执行。\\n', '\\n', '示例\\n', '#删除databaseexample数据库。\\n', '\\n', 'postgres=# DROP DATABASE databaseexample;\\n', '备份数据库\\n', '可以使用pg_dump命令备份数据库，将数据库转储到一个脚本文件或其他归档文件中。\\n', '\\n', 'pg_dump [option]... [databasename] > outfile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。如果没有声明这个参数，那么使用环境变量 PGDATABASE 。如果那个环境变量也没声明，那么使用发起连接的用户名。\\n', 'outfile：数据库备份的文件。\\n', 'option：pg_dump命令参数选项，多个参数之间可以使用空格分隔。常用的pg_dump命令参数选项如下：\\n', '-f，--file= filename ：指输出到指定的文件。如果忽略，则使用标准输出。\\n', '-d，--dbname= databasename ：指定转储的数据库。\\n', '-h，--host= hostname ：指定主机名。\\n', '-p，--port= portnumber ：指定端口。\\n', '-U，--username= username ：指定连接的用户名。\\n', '-W，--password：强制口令提示（自动）。\\n', '示例\\n', '#备份主机为192.168.202.144，端口为3306，postgres用户下的database1数据库到db1.sql中。\\n', '\\n', '[postgres@localhost ~]$ pg_dump -h 192.168.202.144 -p 3306 -U postgres -W database1 > db1.sql\\n', '恢复数据库\\n', '可以使用psql命令恢复数据库。\\n', '\\n', 'psql [option]... [databasename [username]] < infile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。如果没有声明这个参数，那么使用环境变量 PGDATABASE 。如果那个环境变量也没声明，那么使用发起连接的用户名。\\n', 'username：用户名。\\n', 'infile：pg_dump命令中的outfile参数。\\n', 'option：psql命令参数选项，多个参数之间可以使用空格分隔。常用的psql命令参数选项如下：\\n', '-f，--file=filename：指输出到指定的文件。如果忽略，则使用标准输出。\\n', '-d，--dbname=databasename：指定转储的数据库。\\n', '-h，--host=hostname：指定主机名。\\n', '-p，--port=portnumber：指定端口。\\n', '-U，--username=username：指定连接的用户名。\\n', '-W，--password：强制口令提示（自动）。\\n', 'psql命令不会自动创建databasename数据库，所以在执行psql恢复数据库之前需要先创建databasename数据库。\\n', '\\n', '示例\\n', '#将db1.sql脚本文件导入到主机为192.168.202.144，端口为3306，postgres用户下newdb数据库中。\\n', '\\n', '[postgres@localhost ~]$ createdb newdb\\n', '[postgres@localhost ~]$ psql -h 192.168.202.144 -p 3306 -U postgres -W -d newdb < db1.sql\\n', 'Mariadb服务器\\n', '软件介绍\\n', 'MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品，MariaDB还提供了许多更好的新特性。\\n', '\\n', 'MariaDB的架构如图2所示。\\n', '\\n', '图 2 MariaDB逻辑架构\\n', '\\n', '\\n', '当Mariadb接受到Sql语句时，其详细的执行过程如下：\\n', '\\n', '当客户端连接到mariadb的时候，会认证客户端的主机名、用户、密码，认证功能可以做成插件。\\n', '如果登录成功，客户端发送sql命令到服务端。由解析器解析sql语句。\\n', '服务端检查客户端是否有权限去获取它想要的资源。\\n', '如果查询已经存储在query cache当中，那么结果立即返回。\\n', '优化器将会找出最快的执行策略，或者是执行计划，也就是说优化器可以决定什么表将会被读，以及哪些索引会被访问，哪些临时表会被使用，一个好的策略能够减少大量的磁盘访问和排序操作等。\\n', '存储引擎读写数据和索引文件，cache用来加速这些操作，其他的诸如事物和外键特性，都是在存储引擎层处理的。\\n', '存储引擎在物理层管控数据，它负责数据文件、数据、索引、cache等的管理，这使得管理和读取数据变得更高效，每一张表，都有一个.frm文件，这些文件包含着表的定义。\\n', '\\n', '每一个存储引擎管理、存储数据的方式都是不同的，所支持的特性和性能也不尽相同。例如：\\n', '\\n', 'MyISAM，适合读多写少的环境，且不支持事务，支持全文索引等。\\n', 'noDB，支持事务，支持行锁和外键等。\\n', 'MEMORY，将数据存储在内存当中。\\n', 'CSV，将数据存储为CSV格式。\\n', '配置环境\\n', ' 说明：\\n', '以下环境配置仅为参考示例，具体配置视实际需求做配置\\n', '\\n', '关闭防火墙并取消开机自启动\\n', ' 说明：\\n', '测试环境下通常会关闭防火墙以避免部分网络因素影响，视实际需求做配置。\\n', '\\n', '在root权限下停止防火墙。\\n', '\\n', '# systemctl stop firewalld\\n', '在root权限下关闭防火墙。\\n', '\\n', '# systemctl disable firewalld\\n', ' 说明：\\n', '执行disable命令关闭防火墙的同时，也取消了开机自启动。\\n', '\\n', '修改SELINUX为disabled\\n', '在root权限下修改配置文件。\\n', '\\n', \"# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\\n\", '创建组和用户\\n', ' 说明：\\n', '服务器环境下，为了系统安全，通常会为进程分配单独的用户，以实现权限隔离。本章节创建的组和用户都是操作系统层面的，不是数据库层面的。\\n', '\\n', '在root权限下创建MySQL用户（组）。\\n', '\\n', '# groupadd mysql\\n', '# useradd -g mysql mysql\\n', '在root权限下设置MySQL用户密码。\\n', '\\n', '# passwd mysql\\n', '重复输入密码（根据实际需求设置密码）。\\n', '\\n', '搭建数据盘\\n', ' 说明：\\n', '\\n', '进行性能测试时，数据目录使用单独硬盘，需要对硬盘进行格式化并挂载，参考方法一或者方法二\\n', '非性能测试时，在root权限下执行以下命令，创建数据目录即可。然后跳过本小节：\\n', '#mkdir /data\\n', '方法一：在root权限下使用fdisk进行磁盘管理\\n', '创建分区（以/dev/sdb为例，根据实际情况创建）\\n', '\\n', '# fdisk /dev/sdb\\n', '输入n，按回车确认。\\n', '\\n', '输入p，按回车确认。\\n', '\\n', '输入1，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '输入w，按回车保存。\\n', '\\n', '创建文件系统（以xfs为例，根据实际需求创建文件系统）\\n', '\\n', '# mkfs.xfs /dev/sdb1\\n', '挂载分区到“/data”以供操作系统使用。\\n', '\\n', '# mkdir /data\\n', '# mount /dev/sdb1 /data\\n', '执行命令“vi /etc/fstab\", 编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/nvme0n1p1为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '方法二：在root权限下使用LVM进行磁盘管理\\n', ' 说明：\\n', '此步骤需要安装镜像中的lvm2相关包，步骤如下：\\n', '\\n', '配置本地yum源，详细信息请参考搭建repo服务器。如果已经执行，则可跳过此步。\\n', '在root权限下执行命令安装lvm2。\\n', '# yum install lvm2\\n', '创建物理卷（sdb为硬盘名称，具体名字以实际为准）。\\n', '\\n', '# pvcreate /dev/sdb\\n', '创建物理卷组（其中datavg为创建的卷组名称，具体名字以实际规划为准）。\\n', '\\n', '# vgcreate datavg  /dev/sdb\\n', '创建逻辑卷（其中600G为规划的逻辑卷大小，具体大小以实际情况为准；datalv为创建的逻辑卷的名字，具体名称以实际规划为准。)。\\n', '\\n', '# lvcreate -L 600G -n datalv datavg\\n', '创建文件系统。\\n', '\\n', '# mkfs.xfs /dev/datavg/datalv\\n', '创建数据目录并挂载。\\n', '\\n', '# mkdir /data\\n', '# mount /dev/datavg/datalv /data\\n', '执行命令vi /etc/fstab，编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/datavg/datalv为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '创建数据库目录并且授权\\n', '在已创建的数据目录 /data 基础上，使用root权限继续创建进程所需的相关目录并授权MySQL用户（组）。\\n', '\\n', '# mkdir -p /data/mariadb\\n', '# cd /data/mariadb\\n', '# mkdir data tmp run log\\n', '# chown -R mysql:mysql /data\\n', '安装、运行和卸载\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装mariadb服务器。\\n', '\\n', '# dnf install mariadb-server\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep mariadb\\n', '运行\\n', '在root权限下开启mariadb服务器。\\n', '\\n', '# systemctl start mariadb\\n', '在root权限下初始化数据库。\\n', '\\n', '# /usr/bin/mysql_secure_installation\\n', '命令执行过程中需要输入数据库的root设置的密码，若没有密码则直接按“Enter”。然后根据提示及实际情况进行设置。\\n', '\\n', '登录数据库。\\n', '\\n', '$ mysql -u root -p\\n', '命令执行后提示输入密码。密码为2中设置的密码。\\n', '\\n', ' 说明：\\n', '执行 \\\\q 或者 exit 可退出数据库。\\n', '\\n', '卸载\\n', '在root权限下关闭数据库进程。\\n', '\\n', '$ ps -ef | grep mysql\\n', '# kill -9 进程ID\\n', '在root权限下执行dnf remove mariadb-server命令卸载mariadb。\\n', '\\n', '# dnf remove mariadb-server\\n', '管理数据库用户\\n', '创建用户\\n', '可以使用CREATE USER语句来创建一个或多个用户，并设置相应的口令。\\n', '\\n', \"CREATE USER 'username'@'hostname' IDENTIFIED BY 'password';\\n\", '其中：\\n', '\\n', 'username：用户名。\\n', 'host：主机名，即用户连接数据库时所在的主机的名字。若是本地用户可用localhost，若在创建的过程中，未指定主机名，则主机名默认为“%”，表示一组主机。\\n', 'password：用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器，但从安全的角度而言，不推荐这种做法。\\n', '使用CREATE USER语句必须拥有数据库的INSERT权限或全局CREATE USER权限。\\n', '\\n', '使用CREATE USER语句创建一个用户账号后，会在系统自身的数据库的user表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。\\n', '\\n', '新创建的用户拥有的权限很少，只允许进行不需要权限的操作，如使用SHOW语句查询所有存储引擎和字符集的列表等。\\n', '\\n', '示例\\n', '#创建密码为123456，用户名为userexample1的本地用户。\\n', '\\n', \"> CREATE USER 'userexample1'@'localhost' IDENTIFIED BY '123456';\\n\", '#创建密码为123456，用户名为userexample2，主机名为192.168.1.100的用户。\\n', '\\n', \"> CREATE USER 'userexample2'@'192.168.1.100' IDENTIFIED BY '123456';\\n\", '查看用户\\n', '可以使用SHOW GRANTS语句或SELECT语句查看一个或多个用户。\\n', '\\n', '查看特定用户：\\n', '\\n', \"SHOW GRANTS [FOR 'username'@'hostname'];\\n\", \"SELECT USER,HOST,PASSWORD FROM mysql.user WHERE USER='username';\\n\", '查看所有用户：\\n', '\\n', 'SELECT USER,HOST,PASSWORD FROM mysql.user;\\n', '其中：\\n', '\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '示例\\n', '#查看userexample1用户。\\n', '\\n', \"> SHOW GRANTS FOR 'userexample1'@'localhost';\\n\", '#查看mysql数据库中所有用户。\\n', '\\n', '> SELECT USER,HOST,PASSWORD FROM mysql.user;\\n', '修改用户\\n', '修改用户名\\n', '可以使用RENAME USER语句修改一个或多个已经存在的用户名。\\n', '\\n', \"RENAME USER 'oldusername'@'hostname' TO 'newusername'@'hostname';\\n\", '其中：\\n', '\\n', 'oldusername：旧的用户名。\\n', 'newusername：新的用户名。\\n', 'hostname：主机名。\\n', 'RENAME USER语句用于对原有的账号进行重命名。若系统中旧账号不存在或者新账号已存在，则该语句执行时会出现错误。\\n', '\\n', '使用RENAME USER语句，必须拥有数据库的UPDATE权限或全局CREATE USER权限。\\n', '\\n', '修改用户示例\\n', '#将用户名userexample1修改为userexapme2，主机名为locahost。\\n', '\\n', \"> RENAME USER 'userexample1'@'localhost' TO 'userexample2'@'localhost';\\n\", '修改用户密码\\n', '可以使用SET PASSWORD语句修改一个用户的登录密码。\\n', '\\n', \"SET PASSWORD FOR 'username'@'hostname' = PASSWORD('newpassword');\\n\", '其中：\\n', '\\n', \"FOR 'username'@'hostname'：FOR字句，可选项，指定欲修改密码的用户名及主机名。\\n\", \"PASSWORD('newpassword')：表示使用函数PASSWORD()设置新口令，即新口令必须传递到函数PASSWORD()中进行加密。\\n\", ' 注意：\\n', 'PASSWORD()函数为单向加密函数，一旦加密后不能解密出原明文。\\n', '\\n', '在SET PASSWORD语句中，若不加上FOR子句，表示修改当前用户的密码。\\n', '\\n', \"FOR字句中必须以'username'@'hostname'的格式给定，username为账户的用户名，hostname为账户的主机名。\\n\", '\\n', '欲修改密码的账号必须在系统中存在，否则语句执行时会出现错误。\\n', '\\n', '修改用户密码示例\\n', '#将用户名为userexample的密码修改为0123456，主机名为locahost。\\n', '\\n', \"> SET PASSWORD FOR 'userexample'@'localhost' = PASSWORD('0123456') ;\\n\", '删除用户\\n', '可以使用DROP USER语句来删除一个或多个用户账号以及相关的权限。\\n', '\\n', \"DROP USER 'username1'@'hostname1' [,'username2'@'hostname2']…;\\n\", ' 注意：\\n', '用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为数据库并不会记录创建了这些对象的账号。\\n', '\\n', 'DROP USER语句可用于删除一个或多个数据库账号，并删除其原有权限。\\n', '\\n', '使用DROP USER语句必须拥有数据库的DELETE权限或全局CREATE USER权限。\\n', '\\n', '在DROP USER语句的使用中，若没有明确地给出账号的主机名，则该主机名默认为“%”。\\n', '\\n', '示例\\n', '#删除用户名为userexample的本地用户。\\n', '\\n', \"> DROP USER 'userexample'@'localhost';\\n\", '用户授权\\n', '可以使用GRANT语句来对新建用户的授权。\\n', '\\n', \"GRANT privileges ON databasename.tablename TO 'username'@'hostname';\\n\", '其中：\\n', '\\n', 'ON字句：用于指定权限授予的对象和级别。\\n', 'privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所有的权限则使用ALL。\\n', 'databasename：数据库名。\\n', 'tablename：表名。\\n', 'TO字句：用来设定用户密码，以及指定被赋予权限的用户。\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*。\\n', '\\n', '如果在TO子句中给系统中存在的用户指定密码，则新密码会将原密码覆盖。\\n', '\\n', '如果权限被授予给一个不存在的用户，则会自动执行一条CREATE USER语句来创建这个用户，但同时必须为该用户指定密码。\\n', '\\n', '示例\\n', '#对本地用户userexample授予SELECT和INSERT权限。\\n', '\\n', \"> GRANT SELECT,INSERT ON *.* TO 'userexample'@'localhost'; \\n\", '删除用户权限\\n', '可以使用REVOKE语句来删除一个用户的权限，但此用户不会被删除。\\n', '\\n', \"REVOKE privilege ON databasename.tablename FROM 'username'@'hostname';\\n\", '其中REVOKE语句的参数与GRANT语句的参数含义相同。\\n', '\\n', '要使用 REVOKE 语句，必须拥有数据库的全局CREATE USER权限或UPDATE权限。\\n', '\\n', '示例\\n', '#删除本地用户userexample的INSERT权限。\\n', '\\n', \"> REVOKE INSERT ON *.* FROM 'userexample'@'localhost';\\n\", '管理数据库\\n', '创建数据库\\n', '可以使用CREATE DATABASE语句来创建数据库。\\n', '\\n', 'CREATE DATABASE databasename;\\n', '其中：databasename为数据库名称，且数据库名称不区分大小写。\\n', '\\n', '示例\\n', '#创建数据库名为databaseexample的数据库。\\n', '\\n', '> CREATE DATABASE databaseexample;\\n', '查看数据库\\n', '可以使用SHOW DATABASES语句来查看数据库。\\n', '\\n', 'SHOW DATABASES;\\n', '示例\\n', '#查看所有数据库。\\n', '\\n', '> SHOW DATABASES;\\n', '选择数据库\\n', '一般创建表，查询表等操作首先需要选择一个目标数据库。可以使用USE语句来选择数据库。\\n', '\\n', 'USE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', '示例\\n', '#选择databaseexample数据库。\\n', '\\n', '> USE databaseexample;\\n', '删除数据库\\n', '可以使用DROP DATABASE语句来删除数据库。\\n', '\\n', ' 注意：\\n', '删除数据库要谨慎操作，一旦删除，数据库中的所有表和数据都会删除。\\n', '\\n', 'DROP DATABASE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', 'DROP DATABASE命令用于删除创建过(已存在)的数据库，且会删除数据库中的所有表，但数据库的用户权限不会自动删除。\\n', '\\n', '要使用DROP DATABASE，您需要数据库的DROP权限。\\n', '\\n', 'DROP SCHEMA是DROP DATABASE的同义词。\\n', '\\n', '示例\\n', '#删除databaseexample数据库。\\n', '\\n', '> DROP DATABASE databaseexample;\\n', '备份数据库\\n', '可以在root权限下使用mysqldump命令备份数据库。\\n', '\\n', '备份一个或多个表：\\n', '\\n', 'mysqldump [options] databasename [tablename ...] > outfile\\n', '备份一个或多个库：\\n', '\\n', 'mysqldump [options] -databases databasename ... > outfile\\n', '备份所有库：\\n', '\\n', 'mysqldump [options] -all-databases > outputfile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。\\n', 'tablename：数据表名称。\\n', 'outfile：数据库备份的文件。\\n', 'options：mysqldump命令参数选项，多个参数之间可以使用空格分隔。常用的mysqldump命令参数选项如下：\\n', '-u, --user= username ：指定用户名。\\n', '-p, --password[= password]：指定密码。\\n', '-P, --port= portnumber ：指定端口。\\n', '-h, --host= hostname ：指定主机名。\\n', '-r, --result-file= filename ：将导出结果保存到指定的文件中，等同于“>”。\\n', '-t：只备份数据。\\n', '-d：只备份表结构。\\n', '示例\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的所有数据库到alldb.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --all-databases > alldb.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --databases db1 > db1.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的tb1表到db1tb1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 db1 tb1 > db1tb1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的表结构到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -d db1 > db1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的数据到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 > db1.sql\\n', '恢复数据库\\n', '可以在root权限下使用mysql命令恢复数据库。\\n', '\\n', '恢复一个或多个表：\\n', '\\n', 'mysql -h hostname -P portnumber -u username -ppassword databasename < infile\\n', '其中：\\n', '\\n', 'hostname：主机名。\\n', 'portnumber：端口号。\\n', 'username：用户名。\\n', 'password：密码。\\n', 'databasename：数据库名。\\n', 'infile：mysqldump命令中的outfile参数。\\n', '示例\\n', '#恢复数据库。\\n', '\\n', '# mysql -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 < db1.sql\\n', 'MySQL服务器\\n', '软件介绍\\n', 'MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于Oracle旗下产品。MySQL是业界最流行的RDBMS (Relational Database Management System，关系数据库管理系统)之一，尤其在WEB应用方面。\\n', '\\n', '关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就加快了速度并提高了灵活性。\\n', '\\n', 'MySQL所使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL软件采用了双授权模式，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择MySQL作为网站数据库。\\n', '\\n', '配置环境\\n', ' 说明：\\n', '以下环境配置仅为参考示例，具体配置视实际需求做配置\\n', '\\n', '关闭防火墙并取消开机自启动\\n', ' 说明：\\n', '测试环境下通常会关闭防火墙以避免部分网络因素影响，视实际需求做配置。\\n', '\\n', '在root权限下停止防火墙。\\n', '\\n', '# systemctl stop firewalld\\n', '在root权限下关闭防火墙。\\n', '\\n', '# systemctl disable firewalld\\n', ' 说明：\\n', '执行disable命令关闭防火墙的同时，也取消了开机自启动。\\n', '\\n', '修改SELINUX为disabled\\n', '在root权限下修改配置文件。\\n', '\\n', \"# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/sysconfig/selinux\\n\", '创建组和用户\\n', ' 说明：\\n', '服务器环境下，为了系统安全，通常会为进程分配单独的用户，以实现权限隔离。本章节创建的组和用户都是操作系统层面的，不是数据库层面的。\\n', '\\n', '在root权限下创建MySQL用户（组）。\\n', '\\n', '# groupadd mysql\\n', '# useradd -g mysql mysql\\n', '在root权限下设置MySQL用户密码。\\n', '\\n', '# passwd mysql\\n', '重复输入密码（根据实际需求设置密码）。\\n', '\\n', '搭建数据盘\\n', ' 说明：\\n', '\\n', '进行性能测试时，数据目录使用单独硬盘，需要对硬盘进行格式化并挂载，参考方法一或者方法二\\n', '非性能测试时，在root权限下执行以下命令，创建数据目录即可。然后跳过本小节：\\n', '# mkdir /data\\n', '方法一：在root权限下使用fdisk进行磁盘管理\\n', '创建分区（以/dev/sdb为例，根据实际情况创建）\\n', '\\n', '# fdisk /dev/sdb\\n', '输入n，按回车确认。\\n', '\\n', '输入p，按回车确认。\\n', '\\n', '输入1，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '采用默认配置，按回车确认。\\n', '\\n', '输入w，按回车保存。\\n', '\\n', '创建文件系统（以xfs为例，根据实际需求创建文件系统）\\n', '\\n', '# mkfs.xfs /dev/sdb1\\n', '挂载分区到“/data”以供操作系统使用。\\n', '\\n', '# mkdir /data\\n', '# mount /dev/sdb1 /data\\n', '执行命令“vi /etc/fstab\", 编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/nvme0n1p1为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '方法二：在root权限下使用LVM进行磁盘管理\\n', ' 说明：\\n', '此步骤需要安装镜像中的lvm2相关包，步骤如下：\\n', '\\n', '配置本地yum源，详细信息请参考搭建repo服务器。如果已经执行，则可跳过此步。\\n', '执行命令安装lvm2。\\n', '#yum install lvm2\\n', '创建物理卷（sdb为硬盘名称，具体名字以实际为准）。\\n', '\\n', '#pvcreate /dev/sdb\\n', '创建物理卷组（其中datavg为创建的卷组名称，具体名字以实际规划为准）。\\n', '\\n', '#vgcreate  datavg  /dev/sdb\\n', '创建逻辑卷（其中600G为规划的逻辑卷大小，具体大小以实际情况为准；datalv为创建的逻辑卷的名字，具体名称以实际规划为准。)。\\n', '\\n', '#lvcreate -L 600G -n datalv datavg\\n', '创建文件系统。\\n', '\\n', '#mkfs.xfs /dev/datavg/datalv\\n', '创建数据目录并挂载。\\n', '\\n', '#mkdir /data\\n', '#mount /dev/datavg/datalv /data\\n', '执行命令vi /etc/fstab，编辑“/etc/fstab”使重启后自动挂载数据盘。如下图中，添加最后一行内容。\\n', '\\n', '其中，/dev/datavg/datalv为示例，具体名称以实际情况为准。\\n', '\\n', '\\n', '\\n', '创建数据库目录并且授权\\n', '在已创建的数据目录 /data 基础上，使用root权限继续创建进程所需的相关目录并授权MySQL用户（组）。\\n', '\\n', '# mkdir -p /data/mysql\\n', '# cd /data/mysql\\n', '# mkdir data tmp run log\\n', '# chown -R mysql:mysql /data\\n', '安装、运行和卸载\\n', '安装\\n', '配置本地yum源，详细信息请参考搭建repo服务器章节。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装MySQL服务器。\\n', '\\n', '# dnf install mysql-server\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep mysql-server\\n', '运行\\n', '修改配置文件。\\n', '\\n', '在root权限下创建my.cnf文件，其中文件路径（包括软件安装路径basedir、数据路径datadir等）根据实际情况修改。\\n', '\\n', '# vi /etc/my.cnf\\n', '编辑my.cnf内容如下：\\n', '\\n', '[mysqld_safe]\\n', 'log-error=/data/mysql/log/mysql.log\\n', 'pid-file=/data/mysql/run/mysqld.pid\\n', '[mysqldump]\\n', 'quick\\n', '[mysql]\\n', 'no-auto-rehash\\n', '[client]\\n', 'default-character-set=utf8\\n', '[mysqld]\\n', 'basedir=/usr/local/mysql\\n', 'socket=/data/mysql/run/mysql.sock\\n', 'tmpdir=/data/mysql/tmp\\n', 'datadir=/data/mysql/data\\n', 'default_authentication_plugin=mysql_native_password\\n', 'port=3306\\n', 'user=mysql\\n', '确保my.cnf配置文件修改正确。\\n', '\\n', '$ cat /etc/my.cnf\\n', '\\n', '\\n', ' 注意：\\n', '其中basedir为软件安装路径，请根据实际情况修改。\\n', '\\n', '在root权限下修改/etc/my.cnf文件的组和用户为mysql:mysql\\n', '\\n', '# chown mysql:mysql /etc/my.cnf\\n', '配置环境变量。\\n', '\\n', '安装完成后，在root权限下将MySQL二进制文件路径到PATH。\\n', '\\n', '# echo export  PATH=$PATH:/usr/local/mysql/bin  >> /etc/profile\\n', ' 注意：\\n', '其中PATH中的“/usr/local/mysql/bin“路径，为MySQL软件安装目录下的bin文件的绝对路径。请根据实际情况修改。\\n', '\\n', '在root权限下使环境变量配置生效。\\n', '\\n', '# source /etc/profile\\n', '在root权限下初始化数据库。\\n', '\\n', ' 说明：\\n', '本步骤倒数第2行中有初始密码，请注意保存，登录数据库时需要使用。\\n', '\\n', '# mysqld --defaults-file=/etc/my.cnf --initialize\\n', '2020-03-18T03:27:13.702385Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.17) initializing of server in progress as process 34014\\n', '2020-03-18T03:27:24.112453Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: iNat=)#V2tZu\\n', '2020-03-18T03:27:28.576003Z 0 [System] [MY-013170] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.17) initializing of server has completed\\n', '查看打印信息，打印信息中包括“initializing of server has completed”表示初始化数据库完成，且打印信息中“A temporary password is generated for root@localhost: iNat=)#V2tZu”的“iNat=)#V2tZu”为初始密码。\\n', '\\n', '启动数据库。\\n', '\\n', ' 注意：\\n', '如果第一次启动数据库服务，以root用户启动数据库，则启动时会提示缺少mysql.log文件而导致失败。使用mysql用户启动之后，会在/data/mysql/log目录下生成mysql.log文件，再次使用root用户启动则不会报错。\\n', '\\n', '在root权限下修改文件权限。\\n', '\\n', '# chmod 777 /usr/local/mysql/support-files/mysql.server\\n', '在root权限下启动MySQL。\\n', '\\n', '# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql\\n', '# chkconfig mysql on\\n', '以mysql用户启动数据库。\\n', '\\n', '# su - mysql\\n', '$ service mysql start\\n', '登录数据库。\\n', '\\n', ' 说明：\\n', '\\n', '提示输入密码时，请输入3产生的初始密码。\\n', '如果采用官网RPM安装方式，则mysql文件在/usr/bin目录下。登录数据库的命令根据实际情况修改。\\n', '$ /usr/local/mysql/bin/mysql -uroot -p  -S /data/mysql/run/mysql.sock\\n', '\\n', '\\n', '配置数据库帐号密码。\\n', '\\n', '登录数据库以后，修改通过root用户登录数据库的密码。\\n', '\\n', 'mysql> alter user \\'root\\'@\\'localhost\\' identified by \"123456\";\\n', '创建全域root用户（允许root从其他服务器访问）。\\n', '\\n', \"mysql> create user 'root'@'%' identified by '123456';\\n\", '进行授权。\\n', '\\n', \"mysql> grant all privileges on *.* to 'root'@'%';\\n\", 'mysql> flush privileges;\\n', '\\n', '\\n', '退出数据库。\\n', '\\n', '执行 \\\\q 或者 exit 退出数据库。\\n', '\\n', 'mysql> exit\\n', '\\n', '\\n', '卸载\\n', '在root权限下关闭数据库进程。\\n', '\\n', '$ ps -ef | grep mysql\\n', '# kill -9 进程ID\\n', '在root权限下执行dnf remove mysql命令卸载MySQL。\\n', '\\n', '# dnf remove mysql\\n', '管理数据库用户\\n', '创建用户\\n', '可以使用CREATE USER语句来创建一个或多个用户，并设置相应的口令。\\n', '\\n', \"CREATE USER 'username'@'hostname' IDENTIFIED BY 'password';\\n\", '其中：\\n', '\\n', 'username：用户名。\\n', 'host：主机名，即用户连接数据库时所在的主机的名字。若是本地用户可用localhost，若在创建的过程中，未指定主机名，则主机名默认为“%”，表示一组主机。\\n', 'password：用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器，但从安全的角度而言，不推荐这种做法。\\n', '使用CREATE USER语句必须拥有数据库的INSERT权限或全局CREATE USER权限。\\n', '\\n', '使用CREATE USER语句创建一个用户账号后，会在系统自身的数据库的user表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。\\n', '\\n', '新创建的用户拥有的权限很少，只允许进行不需要权限的操作，如使用SHOW语句查询所有存储引擎和字符集的列表等。\\n', '\\n', '示例\\n', '#创建密码为123456，用户名为userexample1的本地用户。\\n', '\\n', \"> CREATE USER 'userexample1'@'localhost' IDENTIFIED BY '123456';\\n\", '#创建密码为123456，用户名为userexample2，主机名为192.168.1.100的用户。\\n', '\\n', \"> CREATE USER 'userexample2'@'192.168.1.100' IDENTIFIED BY '123456';\\n\", '查看用户\\n', '可以使用SHOW GRANTS语句或SELECT语句查看一个或多个用户。\\n', '\\n', '查看特定用户：\\n', '\\n', \"SHOW GRANTS [FOR 'username'@'hostname'];\\n\", \"SELECT USER,HOST,PASSWORD FROM mysql.user WHERE USER='username';\\n\", '查看所有用户：\\n', '\\n', 'SELECT USER,HOST FROM mysql.user;\\n', '其中：\\n', '\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '示例\\n', '#查看userexample1用户。\\n', '\\n', \"> SHOW GRANTS FOR 'userexample1'@'localhost';\\n\", '#查看mysql数据库中所有用户。\\n', '\\n', '> SELECT USER,HOST FROM mysql.user;\\n', '修改用户\\n', '修改用户名\\n', '可以使用RENAME USER语句修改一个或多个已经存在的用户名。\\n', '\\n', \"RENAME USER 'oldusername'@'hostname' TO 'newusername'@'hostname';\\n\", '其中：\\n', '\\n', 'oldusername：旧的用户名。\\n', 'newusername：新的用户名。\\n', 'hostname：主机名。\\n', 'RENAME USER语句用于对原有的账号进行重命名。若系统中旧账号不存在或者新账号已存在，则该语句执行时会出现错误。\\n', '\\n', '使用RENAME USER语句，必须拥有数据库的UPDATE权限或全局CREATE USER权限。\\n', '\\n', '修改用户示例\\n', '#将用户名userexample1修改为userexapme2，主机名为locahost。\\n', '\\n', \"> RENAME USER 'userexample1'@'localhost' TO 'userexample2'@'localhost';\\n\", '修改用户密码\\n', '可以使用SET PASSWORD语句修改一个用户的登录密码。\\n', '\\n', \"SET PASSWORD FOR 'username'@'hostname' = 'newpassword';\\n\", '其中：\\n', '\\n', \"FOR 'username'@'hostname'：FOR字句，可选项，指定欲修改密码的用户名及主机名。\\n\", \"'newpassword'：新密码。\\n\", '在SET PASSWORD语句中，若不加上FOR子句，表示修改当前用户的密码。\\n', '\\n', \"FOR字句中必须以'username'@'hostname'的格式给定，username为账户的用户名，hostname为账户的主机名。\\n\", '\\n', '欲修改密码的账号必须在系统中存在，否则语句执行时会出现错误。\\n', '\\n', '修改用户密码示例\\n', '#将用户名为userexample的密码修改为0123456，主机名为locahost。\\n', '\\n', \"> SET PASSWORD FOR 'userexample'@'localhost' = '0123456';\\n\", '删除用户\\n', '可以使用DROP USER语句来删除一个或多个用户账号以及相关的权限。\\n', '\\n', \"DROP USER 'username1'@'hostname1' [,'username2'@'hostname2']…;\\n\", ' 注意：\\n', '用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为数据库并不会记录创建了这些对象的账号。\\n', '\\n', 'DROP USER语句可用于删除一个或多个数据库账号，并删除其原有权限。\\n', '\\n', '使用DROP USER语句必须拥有数据库的DELETE权限或全局CREATE USER权限。\\n', '\\n', '在DROP USER语句的使用中，若没有明确地给出账号的主机名，则该主机名默认为“%”。\\n', '\\n', '示例\\n', '#删除用户名为userexample的本地用户。\\n', '\\n', \"> DROP USER 'userexample'@'localhost';\\n\", '用户授权\\n', '可以使用GRANT语句来对新建用户的授权。\\n', '\\n', \"GRANT privileges ON databasename.tablename TO 'username'@'hostname';\\n\", '其中：\\n', '\\n', 'ON字句：用于指定权限授予的对象和级别。\\n', 'privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所有的权限则使用ALL。\\n', 'databasename：数据库名。\\n', 'tablename：表名。\\n', 'TO字句：用来设定用户密码，以及指定被赋予权限的用户。\\n', 'username：用户名。\\n', 'hostname：主机名。\\n', '如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*。\\n', '\\n', '如果在TO子句中给系统中存在的用户指定密码，则新密码会将原密码覆盖。\\n', '\\n', '如果权限被授予给一个不存在的用户，则会自动执行一条CREATE USER语句来创建这个用户，但同时必须为该用户指定密码。\\n', '\\n', '示例\\n', '#对本地用户userexample授予SELECT和INSERT权限。\\n', '\\n', \"> GRANT SELECT,INSERT ON *.* TO 'userexample'@'localhost'; \\n\", '删除用户权限\\n', '可以使用REVOKE语句来删除一个用户的权限，但此用户不会被删除。\\n', '\\n', \"REVOKE privilege ON databasename.tablename FROM 'username'@'hostname';\\n\", '其中REVOKE语句的参数与GRANT语句的参数含义相同。\\n', '\\n', '要使用 REVOKE 语句，必须拥有数据库的全局CREATE USER权限或UPDATE权限。\\n', '\\n', '示例\\n', '#删除本地用户userexample的INSERT权限。\\n', '\\n', \"> REVOKE INSERT ON *.* FROM 'userexample'@'localhost';\\n\", '管理数据库\\n', '创建数据库\\n', '可以使用CREATE DATABASE语句来创建数据库。\\n', '\\n', 'CREATE DATABASE databasename;\\n', '其中：databasename为数据库名称，且数据库名称不区分大小写。\\n', '\\n', '示例\\n', '#创建数据库名为databaseexample的数据库。\\n', '\\n', '> CREATE DATABASE databaseexample;\\n', '查看数据库\\n', '可以使用SHOW DATABASES语句来查看数据库。\\n', '\\n', 'SHOW DATABASES;\\n', '示例\\n', '#查看所有数据库。\\n', '\\n', '> SHOW DATABASES;\\n', '选择数据库\\n', '一般创建表，查询表等操作首先需要选择一个目标数据库。可以使用USE语句来选择数据库。\\n', '\\n', 'USE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', '示例\\n', '#选择databaseexample数据库。\\n', '\\n', '> USE databaseexample;\\n', '删除数据库\\n', '可以使用DROP DATABASE语句来删除数据库。\\n', '\\n', ' 注意：\\n', '删除数据库要谨慎操作，一旦删除，数据库中的所有表和数据都会删除。\\n', '\\n', 'DROP DATABASE databasename;\\n', '其中：databasename为数据库名称。\\n', '\\n', 'DROP DATABASE命令用于删除创建过(已存在)的数据库，且会删除数据库中的所有表，但数据库的用户权限不会自动删除。\\n', '\\n', '要使用DROP DATABASE，您需要数据库的DROP权限。\\n', '\\n', 'DROP SCHEMA是DROP DATABASE的同义词。\\n', '\\n', '示例\\n', '#删除databaseexample数据库。\\n', '\\n', '> DROP DATABASE databaseexample;\\n', '备份数据库\\n', '可以在root权限下使用mysqldump命令备份数据库。\\n', '\\n', '备份一个或多个表：\\n', '\\n', 'mysqldump [options] databasename [tablename ...] > outfile\\n', '备份一个或多个库：\\n', '\\n', 'mysqldump [options] -databases databasename ... > outfile\\n', '备份所有库：\\n', '\\n', 'mysqldump [options] -all-databases > outputfile\\n', '其中：\\n', '\\n', 'databasename：数据库名称。\\n', 'tablename：数据表名称。\\n', 'outfile：数据库备份的文件。\\n', 'options：mysqldump命令参数选项，多个参数之间可以使用空格分隔。常用的mysqldump命令参数选项如下：\\n', '-u, --user= username ：指定用户名。\\n', '-p, --password[= password]：指定密码。\\n', '-P, --port= portnumber ：指定端口。\\n', '-h, --host= hostname ：指定主机名。\\n', '-r, --result-file= filename ：将导出结果保存到指定的文件中，等同于“>”。\\n', '-t：只备份数据。\\n', '-d：只备份表结构。\\n', '示例\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的所有数据库到alldb.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --all-databases > alldb.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 --databases db1 > db1.sql\\n', '#备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的tb1表到db1tb1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 db1 tb1 > db1tb1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的表结构到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -d db1 > db1.sql\\n', '#只备份主机为192.168.202.144，端口为3306，root用户下的db1数据库的数据到db1.sql中。\\n', '\\n', '# mysqldump -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 > db1.sql\\n', '恢复数据库\\n', '可以在root权限下使用mysql命令恢复数据库。\\n', '\\n', '恢复一个或多个表：\\n', '\\n', 'mysql -h hostname -P portnumber -u username -ppassword databasename < infile\\n', '其中：\\n', '\\n', 'hostname：主机名。\\n', 'portnumber：端口号。\\n', 'username：用户名。\\n', 'password：密码。\\n', 'databasename：数据库名。\\n', 'infile：mysqldump命令中的outfile参数。\\n', '示例\\n', '#恢复数据库。\\n', '\\n', '# mysql -h 192.168.202.144 -P 3306 -uroot -p123456 -t db1 < db1.sql']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_安装虚拟化.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E5%8C%96.html", "text_entry": "['安装虚拟化\\n', '本章介绍在openEuler中安装虚拟化组件的方法。\\n', '\\n', '安装虚拟化\\n', '最低硬件要求\\n', '安装虚拟化核心组件\\n', '安装方法\\n', '验证安装是否成功\\n', '最低硬件要求\\n', '在openEuler系统中安装虚拟化组件，最低硬件要求：\\n', '\\n', 'AArch64处理器架构：ARMv8以上并且支持虚拟化扩展\\n', 'x86_64处理器架构：支持VT-x\\n', '2核CPU\\n', '4GB的内存\\n', '16GB可用磁盘空间\\n', '安装虚拟化核心组件\\n', '安装方法\\n', '前提条件\\n', '已经配置yum源。配置方式请参见《openEuler 22.03 LTS 管理员指南》。\\n', '安装操作需要root用户权限。\\n', '安装步骤\\n', '安装QEMU组件。\\n', '\\n', '# yum install -y qemu\\n', '安装libvirt组件。\\n', '\\n', '# yum install -y libvirt\\n', '启动libvirtd服务。\\n', '\\n', '# systemctl start libvirtd\\n', ' 说明：\\n', 'KVM模块已经集成在openEuler内核中，因此不需要单独安装。\\n', '\\n', '验证安装是否成功\\n', '查看内核是否支持KVM虚拟化，即查看/dev/kvm和/sys/module/kvm文件是否存在，命令和回显如下：\\n', '\\n', '$ ls /dev/kvm\\n', '/dev/kvm\\n', '$ ls /sys/module/kvm\\n', 'parameters  uevent\\n', '若上述文件存在，说明内核支持KVM虚拟化。若上述文件不存在，则说明系统内核编译时未开启KVM虚拟化，需要更换支持KVM虚拟化的Linux内核。\\n', '\\n', '确认QEMU是否安装成功。若安装成功则可以看到QEMU软件包信息，命令和回显如下：\\n', '\\n', '$ rpm -qi qemu\\n', 'Name        : qemu\\n', 'Epoch       : 2\\n', 'Version     : 4.0.1\\n', 'Release     : 10\\n', 'Architecture: aarch64\\n', 'Install Date: Wed 24 Jul 2019 04:04:47 PM CST\\n', 'Group       : Unspecified\\n', 'Size        : 16869484\\n', 'License     : GPLv2 and BSD and MIT and CC-BY\\n', 'Signature   : (none)\\n', 'Source RPM  : qemu-4.0.0-1.src.rpm\\n', 'Build Date  : Wed 24 Jul 2019 04:03:52 PM CST\\n', 'Build Host  : localhost\\n', 'Relocations : (not relocatable)\\n', 'URL         : http://www.qemu.org\\n', 'Summary     : QEMU is a generic and open source machine emulator and virtualizer\\n', 'Description :\\n', 'QEMU is a generic and open source processor emulator which achieves a good\\n', 'emulation speed by using dynamic translation. QEMU has two operating modes:\\n', '\\n', ' * Full system emulation. In this mode, QEMU emulates a full system (for\\n', '   example a PC), including a processor and various peripherals. It can be\\n', '   used to launch different Operating Systems without rebooting the PC or\\n', '   to debug system code.\\n', ' * User mode emulation. In this mode, QEMU can launch Linux processes compiled\\n', '   for one CPU on another CPU.\\n', '\\n', 'As QEMU requires no host kernel patches to run, it is safe and easy to use.\\n', '确认libvirt是否安装成功。若安装成功则可以看到libvirt软件包信息，命令和回显如下：\\n', '\\n', '$ rpm -qi libvirt\\n', 'Name        : libvirt\\n', 'Version     : 5.5.0\\n', 'Release     : 1\\n', 'Architecture: aarch64\\n', 'Install Date: Tue 30 Jul 2019 04:56:21 PM CST\\n', 'Group       : Unspecified\\n', 'Size        : 0\\n', 'License     : LGPLv2+\\n', 'Signature   : (none)\\n', 'Source RPM  : libvirt-5.5.0-1.src.rpm\\n', 'Build Date  : Mon 29 Jul 2019 08:14:57 PM CST\\n', 'Build Host  : 71e8c1ce149f\\n', 'Relocations : (not relocatable)\\n', 'URL         : https://libvirt.org/\\n', 'Summary     : Library providing a simple virtualization API\\n', 'Description :\\n', 'Libvirt is a C toolkit to interact with the virtualization capabilities\\n', 'of recent versions of Linux (and other OSes). The main package includes\\n', 'the libvirtd server exporting the virtualization support.\\n', '查看libvirt服务是否启动成功。若服务处于“Active”状态，说明服务启动成功，可以正常使用libvirt提供的virsh命令行工具，命令和回显如下：\\n', '\\n', '$ systemctl status libvirtd\\n', '● libvirtd.service - Virtualization daemon\\n', '   Loaded: loaded (/usr/lib/systemd/system/libvirtd.service; enabled; vendor preset: enabled)\\n', '   Active: active (running) since Tue 2019-08-06 09:36:01 CST; 5h 12min ago\\n', '     Docs: man:libvirtd(8)\\n', '           https://libvirt.org\\n', ' Main PID: 40754 (libvirtd)\\n', '    Tasks: 20 (limit: 32768)\\n', '   Memory: 198.6M\\n', '   CGroup: /system.slice/libvirtd.service\\n', '           ─40754 /usr/sbin/libvirtd\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_文件权限.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.html", "text_entry": "['文件权限\\n', '文件权限\\n', '设置文件的权限和属主\\n', '删除无主文件\\n', '处理空链接文件\\n', '设置守护进程的umask值\\n', '为全局可写目录添加粘滞位属性\\n', '删除非授权文件的全局可写属性\\n', '限制at命令的使用权限\\n', '限制cron命令的使用权限\\n', '限制sudo命令的使用权限\\n', '设置文件的权限和属主\\n', '说明\\n', 'Linux将所有对象都当作文件来处理，即使一个目录也被看作是包含有多个其他文件的大文件。因此，Linux中最重要的就是文件和目录的安全性。文件和目录的安全性主要通过权限和属主来保证。\\n', '\\n', 'openEuler默认对系统中的常用目录、可执行文件和配置文件设置了权限和属主。\\n', '\\n', '实现\\n', '以/bin目录为例，修改文件权限和文件属主的操作如下：\\n', '\\n', '修改文件权限。例如将/bin目录权限设置为755。\\n', '\\n', 'chmod 755 /bin\\n', '修改文件属主。例如将/bin目录的拥有者和群组设置为root:root。\\n', '\\n', 'chown root:root /bin\\n', '删除无主文件\\n', '说明\\n', '系统管理员在删除用户/群组时，存在着忘记删除该用户/该群组所拥有文件的问题。如果后续新创建的用户/群组与被删除的用户/群组同名，则新用户/新群组会拥有部分不属于其权限的文件，建议将此类文件删除。\\n', '\\n', '实现\\n', '删除用户ID不存在的文件\\n', '\\n', '查找用户ID不存在的文件。\\n', '\\n', 'find / -nouser\\n', '删除查找到的文件。其中 filename 为用户ID不存在文件的文件名。\\n', '\\n', 'rm -f filename\\n', '删除群组ID不存在的文件\\n', '\\n', '查找群主ID不存在的文件。\\n', '\\n', 'find / -nogroup\\n', '删除查找到的文件。其中 filename 为用户ID不存在文件的文件名。\\n', '\\n', 'rm -f filename\\n', '处理空链接文件\\n', '说明\\n', '无指向的空链接文件，可能会被恶意用户利用，影响系统安全性。建议用户删除无效的空链接文件，提高系统安全性。\\n', '\\n', '特殊场景\\n', 'openEuler系统安装完成后，可能存在空链接文件，这些空链接文件可能有对应用途（有些空链接文件是预制的，会被其他组件依赖）。请用户根据实际环境进行处理，处理方式请参见实现。\\n', '\\n', '例如，openEuler支持UEFI和legacy BIOS两种安装模式，两种引导场景支持的grub相关包默认都安装，当用户选择legacy BIOS模式安装时，形成空链接文件“/etc/grub2-efi.cfg”；当用户选择UEFI模式安装时，会形成空链接文件“/etc/grub2.cfg”，需要用户根据实际情况处理空链接。\\n', '\\n', '实现\\n', '通过如下命令查找系统中的空链接文件。\\n', '\\n', 'find dirname -type l -follow 2>/dev/null\\n', ' 说明：\\n', 'dirname为搜索目录的名称，通常需要关注系统关键目录：/bin、/boot、/usr、/lib64、/lib、/var等。\\n', '\\n', '如果此类文件无实际作用，可通过如下命令删除。\\n', '\\n', 'rm -f filename\\n', ' 说明：\\n', 'filename为步骤1找出的文件名。\\n', '\\n', '设置守护进程的umask值\\n', '说明\\n', 'umask值用来为新创建的文件和目录设置缺省权限。如果没有设定umask值，则生成的文件具有全局可写权限，存在一定的风险。守护进程负责系统上某个服务，让系统可以接受来自用户或者是网络客户的要求。为了提高守护进程所创建文件和目录的安全性，建议设置其umask值为0027。umask值代表的是权限的“补码”，umask值和权限的换算方法请参见 “附录 > umask值含义” 。\\n', '\\n', ' 说明：\\n', 'openEuler默认已设置守护进程的umask值为0022。\\n', '\\n', '实现\\n', '在配置文件/etc/sysconfig/init中新增一行：umask 0027。\\n', '\\n', '为全局可写目录添加粘滞位属性\\n', '说明\\n', '任意用户可以删除、修改全局可写目录中的文件和目录，为了确保全局可写目录中的文件和目录不会被任意删除，需要为全局可写目录添加粘滞位属性。\\n', '\\n', '实现\\n', '搜索全局可写目录。\\n', '\\n', 'find / -type d -perm -0002 ! -perm -1000 -ls | grep -v proc\\n', '为全局可写目录添加粘滞位属性。dirname 为实际查找到的目录名。\\n', '\\n', 'chmod +t dirname\\n', '删除非授权文件的全局可写属性\\n', '说明\\n', '全局可写文件可被系统中的任意用户修改，影响系统完整性。\\n', '\\n', '实现\\n', '列举系统中所有的全局可写文件。\\n', '\\n', 'find / -type d ( -perm -o+w ) | grep -v proc\\n', 'find / -type f ( -perm -o+w ) | grep -v proc\\n', '查看步骤1列举的所有文件(粘滞位位的文件和目录可以排除在外)，删除文件或去掉其全局可写权限。使用以下命令去掉权限，其中filename为对应文件名：\\n', '\\n', 'chmod o-w  filename\\n', ' 说明：\\n', '可通过如下命令确定对应文件或目录是否设置了粘滞位，若回显中包含T标记，则为粘滞位文件或目录。命令中的filename为需要查询文件或目录的名称。\\n', '\\n', 'ls -l filename  \\n', '限制at命令的使用权限\\n', '说明\\n', 'at命令用于创建在指定时间自动执行的任务。为避免任意用户通过at命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户。\\n', '\\n', '实现\\n', '删除/etc/at.deny文件。\\n', '\\n', 'rm -f /etc/at.deny\\n', '将/etc/at.allow的文件属主改为root:root。\\n', '\\n', 'chown root:root /etc/at.allow\\n', '控制/etc/at.allow的文件权限，仅root可操作。\\n', '\\n', 'chmod og-rwx /etc/at.allow\\n', '限制cron命令的使用权限\\n', '说明\\n', 'cron命令用于创建例行性任务。为避免任意用户通过cron命令安排工作，造成系统易受攻击，需要指定可使用该命令的用户。\\n', '\\n', '实现\\n', '删除/etc/cron.deny文件。\\n', '\\n', 'rm -f /etc/cron.deny\\n', '将/etc/cron.allow的文件属主改为root:root。\\n', '\\n', 'chown root:root /etc/cron.allow\\n', '控制/etc/cron.allow的文件权限，仅root可操作。\\n', '\\n', 'chmod og-rwx /etc/cron.allow\\n', '限制sudo命令的使用权限\\n', '说明\\n', 'sudo命令用于普通用户以root权限执行命令。为了增强系统安全性，有必要对sudo命令的使用权进行控制，只允许root使用sudo命令，限制其他帐户使用。openEuler默认未限制非root用户使用sudo命令的权限。\\n', '\\n', '实现\\n', 'sudo命令的使用控制通过修改/etc/sudoers文件实现，需要注释掉如下配置行：\\n', '\\n', '#%wheel ALL=(ALL)       ALL\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_虚拟机配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE.html", "text_entry": "['虚拟机配置\\n', '概述\\n', '使用 StratoVirt 时，可以通过命令行参数指定虚拟机配置，也支持对接 libvirt ，通过 XML 文件配置。本章介绍命令行方式的配置方式。\\n', '\\n', '说明\\n', '\\n', '本文中的 /path/to/socket 为用户自定义路径下的 socket 文件。\\n', '\\n', '从 openEuler 22.03 LTS 版本开始，取消了对 json 文件的支持。\\n', '\\n', '规格说明\\n', 'StratoVirt 支持启动轻量级虚拟机和标准虚拟机。\\n', '\\n', '轻量级虚拟机使用轻量级 microVM 主板，以及 mmio 总线。\\n', '标准虚拟机支持标准启动，在 x86 平台使用 Q35 主板，AArch64 架构下使用 virt 主板以及 PCI 总线。\\n', '轻量级虚拟机\\n', '虚拟机 CPU 个数：[1, 254]\\n', '虚拟机内存大小：[256 MiB, 512 GiB]\\n', '虚拟机磁盘个数（包括热插的磁盘）：[0, 6]\\n', '虚拟机网卡个数（包括热插的网卡）：[0, 2]\\n', '虚拟机 console 设备仅支持单路连接\\n', '主机 CPU 架构为 x86_64 时，最多可以配置 11 个 mmio 设备，但是除了磁盘和网卡，建议最多配置 2 个其他设备; AArch64 平台，最多可以配置 160 个 mmio 设备，但是除了磁盘和网卡，建议最多配置 12 个其他设备。\\n', '标准虚拟机\\n', '虚拟机 CPU 个数：[1, 254]\\n', '虚拟机内存大小：[256 MiB, 512 GiB]\\n', '虚拟机 console 设备仅支持单路连接\\n', '只支持 1 个 console 设备\\n', '最多支持 32 个 PCI 设备\\n', 'PCI 设备挂载的 PCI 总线 slot 取值范围： [0, 32)；function 取值范围 [0, 8)\\n', '最小配置\\n', 'StratoVirt 能够运行的最小配置为：\\n', '\\n', 'PE 格式或 bzImage 格式（仅 x86_64）的 Linux 内核镜像\\n', '将 rootfs 镜像设置成 virtio-blk 设备，并添加到内核参数中\\n', '使用 api-channel 控制 StratoVirt\\n', '如果要使用串口 登录，添加一个串口到内核启动命令行，AArch64平台标准机型为ttyAMA0，其他情况为ttyS0.\\n', '配置介绍\\n', '命令格式\\n', '使用 cmdline 配置的命令格式如下：\\n', '\\n', '$ /path/to/stratovirt -[参数1] [参数选项] -[参数2] [参数选项] …\\n', '\\n', '使用说明\\n', '首先，为确保可以创建 api-channel 需要的 socket，可以参考如下命令清理环境：\\n', '\\n', '$ rm [参数] [用户自定义socket文件路径]\\n', '然后，运行 cmdline 命令。\\n', '\\n', '$ /path/to/stratovirt -[参数1] [参数选项] -[参数2] [参数选项] ...\\n', '基本信息配置\\n', '基本配置信息如下表所示：\\n', '\\n', '参数\\t参数选项\\t说明\\n', '-name\\tVMname\\t配置虚拟机名称（字符长度：1-255字符）\\n', '-kernel\\t/path/to/vmlinux.bin\\t配置内核镜像\\n', '-append\\tconsole=ttyS0 root=/dev/vda reboot=k panic=1 rw\\t配置内核命令行参数，标准虚拟化AArch64平台使用console=ttyAMA0，而不是ttyS0.\\n', '-initrd\\t/path/to/initrd.img\\t配置initrd文件\\n', '-smp\\t[cpus=]个数\\t配置cpu个数，范围[1, 254]\\n', '-m\\t内存大小MiB、内存大小GiB，默认单位MiB\\t配置内存大小，范围[256MiB, 512GiB]\\n', '-qmp\\tunix:/path/to/socket,server,nowait\\t配置api-channel，运行前须保证socket文件不存在\\n', '-D\\t/path/to/logfile\\t配置日志文件\\n', '-pidfile\\t/path/to/pidfile\\t配置pid文件，必须和-daemonize一起使用。运行前须保证pid文件不存在\\n', '-disable-seccomp\\tNA\\t关闭Seccomp，默认打开\\n', '-daemonize\\tNA\\t开启进程daemon化\\n', '虚拟机类型\\n', '通过-machine参数来指定启动的虚拟机的类型。\\n', '\\n', '参数说明\\n', '\\n', 'type：启动虚拟机的类型（轻量级虚拟化为“MicroVm”类型，标准虚拟化在x86_64平台为”q35“，在aarch64平台为”virt”）。\\n', 'dump-guest-core：进程panic时，是否dump虚拟机内存（可选配置）。\\n', 'mem-share：是否与其他进程共享内存（可选配置）。\\n', '磁盘配置\\n', '虚拟机磁盘配置包含以下配置项\\n', '\\n', 'drive_id： 磁盘的id。\\n', 'path_on_host： 磁盘的路径。\\n', 'serial_num： 磁盘的串号（可选配置）。\\n', 'read_only： 是否只读（可选配置）。\\n', 'direct： 是否以“O_DIRECT”模式打开（可选配置）。\\n', 'iothread： 配置iothread属性（可选配置）。\\n', 'throttling.iops-total： 配置磁盘QoS，以限制磁盘的io操作（可选配置）。\\n', 'if：driver的类型，block设备为“none”（可选配置，默认值为“none”）\\n', 'bus：设备要挂载的bus。\\n', 'addr：设备要挂载的slot和function号。\\n', 'multifunction：是否开启pci多功能。（可选配置）\\n', '磁盘配置方式\\n', '磁盘的配置分为两步：driver的配置和block设备的配置\\n', '\\n', '轻量虚拟机配置格式为：\\n', '\\n', '-drive id=drive_id,file=path_on_host[,readonly=off][,direct=off][,throttling.iops-total=200][,if=none]\\n', '-device virtio-blk-device,drive=drive_id,id=blkid[,iothread=iothread1][,serial=serial_num]\\n', '标准虚拟机配置格式为：\\n', '\\n', '-drive id=drive_id,file=path_on_host[,readonly=off][,direct=off][,throttling.iops-total=200][,if=none]\\n', '-device virtio-blk-pci,drive=drive_id,bus=pcie.0,addr=0x3.0x0,id=blkid[,iothread=iothread1,][serial=serial_num][,multifunction=on]\\n', '下面对throttling.iops-total和iothread两个配置项进行详细说明：\\n', '\\n', '磁盘QoS\\n', '简介\\n', 'QoS（Quality of Service）是服务质量的意思。在云场景中，单主机内会启动多台虚拟机，当某台虚拟机对磁盘访问压力大时，由于同主机的磁盘访问总带宽有限，这会挤占其他虚拟机的访问带宽，从而造成对其他虚拟机IO影响。为了降低影响，可以为虚拟机配置QoS属性，限制它们对磁盘访问的速率，从而降低对彼此的影响。\\n', '\\n', '注意事项\\n', '当前QoS支持配置磁盘的iops。\\n', 'iops的设定范围是[0, 1000000]，0为不限速；实际iops不会超过设定值，并且不会超过后端磁盘实际性能的上限。\\n', '只能限制平均iops，无法限速瞬时的突发流量。\\n', '配置方式\\n', '用法：\\n', '\\n', '命令行\\n', '\\n', '-drive xxx,throttling.iops-total=200\\n', '参数：\\n', '\\n', 'throttling.iops-total：当配置了iops后，本磁盘在虚拟机内部的IO下发速度，不会超过此配置值。\\n', 'xxx：表示磁盘的其他设置。\\n', 'iothread\\n', 'iothread配置细节见iothread配置\\n', '\\n', '网卡配置\\n', '虚拟机网卡的配置包含以下配置项：\\n', '\\n', 'id：唯一的设备 id。\\n', 'tap：指定 tap 设备。\\n', 'ifname：host 上的 tap 设备名。\\n', 'mac：设置虚拟机 mac 地址（可选配置）。\\n', 'iothread：配置磁盘的 iothread 属性（可选配置）。网卡 iothread 配置详见 iothread配置 。\\n', '配置方式\\n', '说明\\n', '\\n', '使用网络前请先使用如下命令配置好 host 网桥和 tap 设备。\\n', '\\n', '$ yum install -y bridge-utils iproute net-tools\\n', '$ brctl addbr qbr0\\n', '$ ip tuntap add tap0 mode tap\\n', '$ brctl addif qbr0 tap0\\n', '$ ifconfig qbr0 up; ifconfig tap0 up\\n', '$ ifconfig qbr0 192.168.0.1\\n', '配置 virtio-net（本文中 [] 表示可选参数）\\n', '轻量级虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name[,vhostfd=2]\\n', '-device virtio-net-device,netdev=netdevid,id=netid[,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', '标准虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name[,vhostfd=2]\\n', '-device virtio-net-pci,netdev=netdevid,id=netid,bus=pcie.0,addr=0x2.0x0[,multifunction=on,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', '配置 vhost-net\\n', '轻量级虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name,vhost=on[,vhostfd=2]\\n', '-device virtio-net-device,netdev=netdevid,id=netid[,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', '标准虚拟机：\\n', '\\n', '-netdev tap,id=netdevid,ifname=host_dev_name,vhost=on[,vhostfd=2]\\n', '-device virtio-net-pci,netdev=netdevid,id=netid,bus=pcie.0,addr=0x2.0x0[,multifunction=on,iothread=iothread1,mac=12:34:56:78:9A:BC]\\n', 'chardev 配置\\n', '将来自 Guest 的 I/O 重定向到宿主机的 chardev。chardev 后端的类型可以是：stdio、pty、socket 和 file。其中 file 仅支持输出时设置。配置项：\\n', '\\n', 'id：唯一的设备 id。\\n', 'backend：重定向的类型。\\n', 'path：设备重定向文件路径。仅 socket 和 file 类型的设备需要此参数。\\n', 'server：将 chardev 作为服务器运行。仅 socket 类型的设备需要此参数。\\n', 'nowait：预期状态为断开连接。仅 socket 类型的设备需要此参数。\\n', '使用 chardev 时，会创建并使用 console 文件，所以启动 stratovirt 之前，请确保 console 文件不存在。\\n', '\\n', '配置方式\\n', '-chardev backend,id=chardev_id[,path=path,server,nowait]\\n', '串口配置\\n', '串口是虚拟机的设备，用于主机和虚拟机之间传送数据。使用串口时，kernel 命令行中配置 console=ttyS0 ，在 AArch64 平台上标准启动时，配置 console=ttyAMA0 。配置项：\\n', '\\n', 'chardev：重定向的 chardev 设备\\n', 'backend、path、server、nowait：这些参数的含义与 chardev 中的相同。\\n', '配置方式\\n', '-serial chardev:chardev_id\\n', '或者：\\n', '\\n', '-chardev backend[,path=path,server,nowait]\\n', 'console 设备配置\\n', 'virtio-console 是通用的串口设备，用于主机和虚拟机之间传送数据。当只配 console 并通过 console 进行 I/O 操作时，kernel 启动参数中配置 console=hvc0。console 设备有如下配置项：\\n', '\\n', 'id： 设备的 id。\\n', 'path：virtio console 文件路径。\\n', 'socket：以 socket 的方式重定向。\\n', 'chardev：重定向的 chardev 设备。\\n', '配置方式\\n', 'console 配置分为三步：首先指定 virtio-serial，然后创建字符设备，最后创建 virtconsole 设备。\\n', '\\n', '轻量级虚拟机：\\n', '\\n', '-device virtio-serial-device[,id=virtio-serial0]\\n', '-chardev socket,path=socket_path,id=virtioconsole1,server,nowait\\n', '-device virtconsole,chardev=virtioconsole1,id=console_id\\n', '标准虚拟机：\\n', '\\n', '-device virtio-serial-pci,bus=pcie.0,addr=0x1.0x0[,multifunction=on,id=virtio-serial0]\\n', '-chardev socket,path=socket_path,id=virtioconsole1,server,nowait\\n', '-device virtconsole,chardev=virtioconsole1,id=console_id\\n', 'vsock 设备配置\\n', 'vsock 也是主机和虚拟机之间通信的设备，类似于 console，但具有更好的性能。配置项：\\n', '\\n', 'id： 唯一的设备 id。\\n', 'guest_cid： 唯一的 context id 。\\n', '配置方式：\\n', '轻量级虚拟机：\\n', '\\n', '-device vhost-vsock-device,id=vsock_id,guest-cid=3\\n', '标准虚拟机：\\n', '\\n', '-device vhost-vsock-pci,id=vsock_id,guest-cid=3,bus=pcie.0,addr=0x1.0x0[,multifunction=on]\\n', '内存大页配置\\n', '概述\\n', 'StratoVirt 支持为虚拟机配置内存大页，相比传统的 4KiB 内存分页模式，大页内存可以有效减少 TLB Miss 次数和缺页中断次数，能够显著提升内存密集型业务性能。\\n', '\\n', '注意事项\\n', '指定的大页挂载的目录，必须是绝对路径。\\n', '仅支持在启动时配置。\\n', '仅支持静态大页。\\n', '使用大页前， 在Host上需要配置好大页。\\n', '使用大页特性， 指定虚拟机内存规格必须是大页页面大小的整数倍。\\n', '互斥特性\\n', '内存大页和 ballon 特性互斥，同时配置时，balloon 特性无效。\\n', '配置方式\\n', '配置Host上大页\\n', '挂载\\n', '将大页文件系统挂载到指定目录上，其中 /path/to/hugepages为用户自定义的空目录。\\n', '\\n', '$ mount -t hugetlbfs hugetlbfs /path/to/hugepages\\n', '设置大页数目\\n', '设置静态大页数目, num为指定的大页数目\\n', '\\n', '$ sysctl vm.nr_hugepages=num\\n', '查询大页统计信息\\n', '\\n', '$ cat /proc/meminfo | grep Hugepages\\n', '如果需要查看其它页面大小的大页统计信息， 可以查看 /sys/kernel/mm/hugepages/hugepages-*/目录下相关信息。\\n', '\\n', '说明\\n', '\\n', '请根据大页使用情况，配置StratoVirt内存规格和大页。如果大页资源不足，虚拟机会启动失败。\\n', '\\n', '启动StratoVirt时添加大页配置\\n', '命令行\\n', '\\n', '-mem-path /page/to/hugepages\\n', '其中 /page/to/hugepages为大页文件系统挂载的目录，仅支持绝对路径。\\n', '\\n', '\\n', '说明\\n', '\\n', '**典型配置：**指定StratoVirt命令行中的mem-path项为：大页文件系统挂载的目录。 推荐使用典型配置使用StratoVirt大页特性。\\n', '\\n', '配置iothread\\n', '简介\\n', '当StratoVirt启动了带iothread配置的虚拟机后，会在主机上启动独立于主线程的单独线程，这些单独线程可以用来处理设备的IO请求，一方面提升设备的IO性能，另一方面降低对管理面消息处理的影响。\\n', '\\n', '注意事项\\n', '支持配置最多8个iothread线程\\n', '支持磁盘和网卡配置iothread属性\\n', 'iothread线程会占用主机CPU资源，在虚拟机内部大IO压力情况下，单个iothread占用的CPU资源取决于磁盘的访问速度，例如普通的SATA盘会占用20%以内CPU资源。\\n', '创建iothread线程\\n', '命令行：\\n', '\\n', '-object iothread,id=iothread1 -object iothread,id=iothread2\\n', '参数：\\n', '\\n', 'id：用于标识此iothread线程，该id可以被设置到磁盘或网卡的iothread属性。当启动参数配置了iothread线程信息，虚拟机启动后会在主机上启动相应id名的线程。\\n', '配置磁盘或网卡的iothread属性\\n', '命令行配置\\n', '\\n', '轻量虚拟机：\\n', '\\n', '磁盘\\n', '\\n', '-device virtio-blk-device xxx,iothread=iothread1\\n', '网卡\\n', '\\n', '-device virtio-net-device xxx,iothread=iothread2\\n', '标准虚拟机：\\n', '\\n', '磁盘\\n', '\\n', '-device virtio-blk-pci xxx,iothread=iothread1\\n', '网卡\\n', '\\n', '-device virtio-net-pci xxx,iothread=iothread2\\n', '参数：\\n', 'iothread：设置成 iothread 线程的 id，指明处理本设备 I/O 的线程。\\n', 'xxx: 表示磁盘或者网卡的其他配置\\n', '配置balloon设备\\n', '简介\\n', '在虚拟机运行过程中,由虚拟机里的balloon驱动来动态占用或释放内存,从而动态改变这台虚拟机当前可用内存，达到内存弹性的效果。\\n', '\\n', '注意事项\\n', '启用balloon前须确保guest和host的页面大小相同。\\n', 'guest内核须开启balloon特性支持。\\n', '开启内存弹性时，有可能造成虚拟机内部轻微卡顿、内存性能下降。\\n', '互斥特性\\n', '大页内存互斥。\\n', '在x86下，由于中断数量有限，所以balloon设备和其他virtio的数量（默认使用6个block设备，2个net设备和1个串口设备）总和不得超过11个。\\n', '规格\\n', '每个VM只能配置1个balloon设备。\\n', '配置方式\\n', '轻量级虚拟机：\\n', '\\n', '-device virtio-balloon-device,deflate-on-oom=true\\n', '标准虚拟机：\\n', '\\n', '-device virtio-balloon-pci,bus=pcie.0,addr=0x4.0x0,deflate-on-oom=true[,multifunction=on]\\n', '说明\\n', '\\n', 'deflate-on-oom的取值为bool类型，表示是否开启auto deflate特性。开启时，如果balloon已经回收部分内存，当guest需要内存时，balloon设备会自动放气，归还内存给guest。不开启则不会自动归还。\\n', '使用qmp命令回收虚拟机内存时，应确保回收后虚拟机仍然有足够的内存来保持最基本的运行。否则可能会出现一些操作超时，以及导致虚拟机内部无法申请到空闲内存等现象。\\n', '如果虚拟机内部开启内存大页，balloon不能回收大页占用内存。\\n', 'deflate-on-oom=false时，当Guest中内存不足时，balloon不会自动放气并归还内存，可能会引起Guest内部OOM，进程被Kill，甚至虚拟机无法正常运行。\\n', '\\n', '配置示例\\n', '轻量级虚拟机\\n', '此处给出创建一个轻量级虚拟机的最小配置示例。\\n', '\\n', '登录主机，删除 socket 文件，确保可以创建 QMP。\\n', '\\n', '$ rm -f /tmp/stratovirt.socket\\n', '运行 StratoVirt 。\\n', '\\n', '$ /path/to/stratovirt \\\\\\n', '    -kernel /path/to/vmlinux.bin \\\\\\n', '    -append console=ttyS0 root=/dev/vda rw reboot=k panic=1 \\\\\\n', '    -drive file=/home/rootfs.ext4,id=rootfs,readonly=false \\\\\\n', '    -device virtio-blk-device,drive=rootfs \\\\\\n', '    -qmp unix:/tmp/stratovirt.socket,server,nowait \\\\\\n', '    -serial stdio\\n', '运行成功后，将根据指定的配置参数创建并启动虚拟机。\\n', '\\n', '标准虚拟机\\n', '此处给出在 ARM 平台创建一个标准虚拟机的最小配置示例。\\n', '\\n', '删除 socket 文件，确保可以创建 QMP 。\\n', '\\n', '$ rm -f /tmp/stratovirt.socket\\n', '运行 StratoVirt 。\\n', '\\n', '$ /path/to/stratovirt \\\\\\n', '    -kernel /path/to/vmlinux.bin \\\\\\n', '    -append console=ttyAMA0 root=/dev/vda rw reboot=k panic=1 \\\\\\n', '    -drive file=/path/to/code_storage_file,if=pflash,unit=0[,readonly=true] \\\\\\n', '    -drive file=/path/to/data_storage_file,if=pfalsh,unit=1, \\\\\\n', '    -drive file=/home/rootfs.ext4,id=rootfs,readonly=false \\\\\\n', '    -device virtio-blk-device,drive=rootfs,bus=pcie.0,addr=0x1 \\\\\\n', '    -qmp unix:/tmp/stratovirt.socket,server,nowait \\\\\\n', '    -serial stdio\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_安装指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AF%BC.html", "text_entry": "['安装指导\\n', '本章以光盘安装为例介绍安装openEuler，其他安装方式除在启动安装时的引导方式不同外，待启动安装后则安装流程相同，在此不再说明。\\n', '\\n', '启动安装\\n', '使用光盘引导安装\\n', '在服务器的光驱中加载openEuler安装镜像，重启服务器，具体步骤如下。\\n', '\\n', ' 说明：\\n', '在安装开始前，需要保证服务器启动选项为光驱优先。安装步骤以BMC挂载虚拟光驱进行光盘安装的操作举例。通过物理光驱安装的操作简单，启动安装后的流程相同，在此不再说明。\\n', '\\n', '在虚拟界面工具栏中，单击虚拟光驱工具如下图所示。\\n', '\\n', '图 1 光驱图标\\n', '\\n', '\\n', '弹出镜像对话框，如下图所示。\\n', '\\n', '图 2 镜像对话框\\n', '\\n', '\\n', '在镜像对话框中，选择“镜像文件”， 并单击“浏览”。弹出“打开”对话框。\\n', '\\n', '选择镜像文件，单击“打开”。然后在镜像对话框中，单击“连接”。当“连接”显示为“断开”后，表示虚拟光驱已连接到服务器。\\n', '\\n', '在工具栏中，单击重启工具重启设备，如下图所示。\\n', '\\n', '图 3 重启图标\\n', '\\n', '\\n', '安装引导界面\\n', '系统使用引导介质完成引导后会显示引导菜单。该引导菜单除启动安装程序外还提供一些选项。安装系统时，默认采用“Test this media & install openEuler 22.03_LTS”方式进行安装。如果要选择默认选项之外的选项，请使用键盘中的“↑”和“↓”方向键进行选择，并在选项为高亮状态时按“Enter”。\\n', '\\n', ' 说明：\\n', '\\n', '如果60秒内未按任何键，系统将从默认选项“Test this media & install openEuler 22.03_LTS”自动进入安装界面。\\n', '安装物理机时，如果使用键盘上下键无法选择启动选项，按“Enter”键无响应，可以单击BMC界面上的鼠标控制图标“”，设置“键鼠复位”。\\n', '图 4 安装引导界面\\n', '\\n', '\\n', '安装引导选项说明如下：\\n', '\\n', 'Install openEuler 22.03_LTS —— 在您的服务器上使用图形用户界面模式安装。\\n', '\\n', 'Test this media & install openEuler 22.03_LTS —— 默认选项，在您的服务器上使用图形用户界面模式安装，但在启动安装程序前会进行安装介质的完整性检查。\\n', '\\n', 'Troubleshooting —— 问题定位模式，系统无法正常安装时使用。进入问题定位模式后，有如下两个选项。\\n', '\\n', 'Install openEuler 22.03_LTS in basic graphics mode —— 简单图形安装模式，该模式下在系统启动并运行之前不启动视频驱动程序。\\n', 'Rescue the openEuler system —— 救援模式，用于修复系统。该模式下输出定向到VNC或BMC（Baseboard Management Controller）端，串口不可用。\\n', '在安装引导界面，按“e”进入已选选项的参数编辑界面，按“c”进入命令行模式。\\n', '\\n', '图形化模式安装\\n', '在“安装引导界面”中选择“Test this media & install openEuler 22.03_LTS”进入图形化模式安装。\\n', '\\n', '可以通过键盘操作图形化安装程序。\\n', '\\n', '“Tab”、“shift Tab”：界面控件（按钮、区域框、复选框等）间的移动。\\n', '“↑”、“↓”方向键：列表里的移动。\\n', '“←”、“→”方向键：水平工具条和表条间移动。\\n', '“空格”、“Enter”：选择或删除高亮显示的选项、展开或折叠下拉菜单。\\n', '“Alt”+“快捷键”：选择快捷键所在的控件，其中快捷键可通过按住Alt高亮（加下划线）显示。\\n', '设置安装程序语言\\n', '启动安装后，在进入安装程序主界面之前，系统会提示用户设置安装过程中使用的语言。当前默认为英语，用户可根据实际情况进行调整，如图5所示，选择“中文”。\\n', '\\n', '图 5 选择语言\\n', '\\n', '\\n', '完成设置后，单击“继续”，进入安装设置主界面。\\n', '\\n', '如果您想退出安装，可以单击“退出”并在弹出的“您确定要退出安装程序吗？”对话框中单击“是”重新进入“安装引导界面”。\\n', '\\n', '进入安装界面\\n', '系统安装程序正常启动后，会进入图6所示的安装设置主界面。用户可以进行时间、语言、安装源、网络、安装位置等相关设置。\\n', '\\n', '部分配置项会有告警符号，用户完成该选项配置后，告警符号消失。当界面上不存在告警符号时，用户才能单击“开始安装”进行系统安装。\\n', '\\n', '如果您想退出安装，可以单击“退出”并在弹出的“您确定要退出安装程序吗？”对话框中单击“是”重新进入“安装引导界面”。\\n', '\\n', '图 6 安装概览\\n', '\\n', '\\n', '设置键盘\\n', '在“安装概览”页面中选择“键盘”，用户可以在系统中添加或者删除多个键盘布局。\\n', '\\n', '要查看键盘布局，请在左侧选框中单击选中该键盘布局，然后单击下面的“键盘”按钮。\\n', '要测试键盘布局，请在左侧选框中添加键盘布局，然后在右上角键盘图标处进行点击切换为目标键盘，单击右侧文本框内部，输入文本以确认所选键盘布局可正常工作。\\n', '图 7 键盘布局\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置系统语言\\n', '在“安装概览”页面中选择“语言支持”，设置系统的语言。如图8所示，用户也可根据实际情况进行调整，选择“中文”。\\n', '\\n', ' 说明：\\n', '若选择“中文”，系统安装完成后，使用VNC登录不支持中文显示，使用串口登录支持中文显示，使用SSH登录时是否支持中文显示与使用的SSH客户端有关。若选择“English”，则无影响。\\n', '\\n', '图 8 语言支持\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置时间和日期\\n', '在“安装概览”页面中选择“时间和日期”，设置系统的时区、日期、时间等。\\n', '\\n', '设置时区时，用户可通过鼠标在地图上单击指定的城市，也可以通过页面顶部的“地区”和“城市”下拉菜单中进行选择，如图9所示。\\n', '\\n', '如果您所在城市没有出现在地图或下拉菜单中，请选择同一时区中离您最近的城市。\\n', '\\n', ' 说明：\\n', '\\n', '手动设置时区时，请先关闭右上角“网络时间”同步开关。\\n', '如需使用网络时间，请保证网络能连通远程NTP服务器，设置网络具体请参见“设置网络和主机名”。\\n', '图 9 日期和时间\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置安装源\\n', '在“安装概览”页面中选择“安装源”，指定安装源的位置。\\n', '\\n', '当使用完整光盘安装，安装程序会自动探测并显示安装源信息，用户直接使用默认配置即可，不需要进行设置，如图10所示。\\n', '\\n', '图 10 安装源\\n', '\\n', '\\n', '当使用网络源进行安装的时候，需设置网络源的 URL。\\n', '\\n', 'http 或 https 方式\\n', '\\n', 'http 或 https 方式的安装源如下图所示。\\n', '\\n', '\\n', '\\n', '如果https服务器使用的是私有证书，则需要在安装引导界面按“e”进入已选选项的参数编辑界面，在参数中增加 inst.noverifyssl 参数。\\n', '\\n', '输入框内容以实际版本发布的安装源地址为准，如https://repo.openeuler.org/openEuler-22.03-LTS/OS/x86_64/ ，其中openEuler-22.03-LTS 为版本号，x86_64 为CPU 架构，可根据实际情况输入。\\n', '\\n', 'ftp 方式\\n', '\\n', 'ftp 方式的安装源如下图所示，输入框内容根据的 ftp 地址输入。\\n', '\\n', '\\n', '\\n', 'ftp服务器需要用户自己搭建，将openEuler-22.03_LTS-x86_64-dvd.iso镜像进行挂载，挂载出的文件拷贝到ftp的共享目录中。其中x86_64为CPU 架构，可根据实际情况使用镜像。\\n', '\\n', 'nfs 方式\\n', '\\n', 'nfs 方式的安装源如下图所示，输入框内容根据的 nfs 地址输入。\\n', '\\n', '\\n', '\\n', 'nfs服务器需要用户自己搭建，将openEuler-22.03_LTS-x86_64-dvd.iso镜像进行挂载，挂载出的文件拷贝到nfs的共享目录中。其中x86_64为CPU 架构，可根据实际情况使用镜像。\\n', '\\n', '安装过程中，如果“设置安装源”有疑问，可参考“选择安装源出现异常”。\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '选择安装软件\\n', '在“安装概览”页面中选择“软件选择”，指定需要安装的软件包。\\n', '\\n', '用户需要根据实际的业务需求，在左侧选择一个“最小安装”，在右侧选择安装环境的附加选项，如图11所示。\\n', '\\n', '图 11 软件选择\\n', '\\n', '\\n', ' 说明：\\n', '\\n', '在最小安装的环境下，并非安装源中所有的包都会安装。如果用户需要使用的包未安装，可将安装源挂载到本地制作repo源，通过DNF工具单独安装。\\n', '选择“虚拟化主机”时会默认安装虚拟化组件qemu、libvirt、edk2，且可在附件选项处选择是否安装ovs等组件。\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置安装目的地\\n', '在“安装概览”页面中选择“安装目的地”，设置操作系统的安装磁盘及分区。\\n', '\\n', '在图12所示的页面中您可以看到计算机中的本地可用存储设备。\\n', '\\n', '图 12 安装目标位置\\n', '\\n', '\\n', '存储配置\\n', '在“安装目标位置”界面，您需要进行存储配置以便对系统分区。您可以手动配置分区，也可以选择让安装程序自动分区。\\n', '\\n', ' 说明：\\n', '\\n', '在进行分区时，出于系统性能和安全的考虑，建议您划分如下单独分区：/boot、/var、/var/log 、/var/log/audit、/home、/tmp。\\n', '系统如果配置了swap分区，当系统的物理内存不够用时，会使用swap分区。虽然 swap分区可以增大物理内存大小的限制，但是如果由于内存不足使用到swap分区，会增加系统的响应时间，性能变差。因此在物理内存充足或者性能敏感的系统中，不建议配置swap分区。\\n', '如果需要拆分逻辑卷组则需要选择“自定义”进行手动分区，并在“手动分区”界面单击“卷组”区域中的“修改”按钮重新配置卷组。\\n', '自动\\n', '\\n', '如果是在未使用过的存储设备中执行全新安装，或者不需要保留该存储设备中任何数据，建议选择“自动”进行自动分区。设置完成后，请单击“完成”返回“安装概览”页面。\\n', '\\n', '自定义\\n', '\\n', '若用户需进行手动分区，选择“自定义”按钮，并单击左上角“完成”，出现手动分区界面。\\n', '\\n', '在“手动分区”界面可以通过如下两种方式进行分区，分区完成后如图13所示。\\n', '\\n', '自动创建：在界面单击“点击这里自动创建它们”，系统会根据可用的存储空间，自动分出4个挂载点：/boot 、/、/boot/efi、swap。\\n', '\\n', '手动创建：单击“”添加新挂载点，建议每个挂载点的期望容量不超过可用空间。\\n', '\\n', ' 说明：\\n', '若设置的挂载点期望容量超过了可用空间，系统将剩余的可用空间全部分配给该挂载点。\\n', '\\n', '图 13 手动分区\\n', '\\n', '\\n', ' 说明：\\n', '如果选择非 UEFI 引导，则不需要 /boot/efi 分区。若选择 UEFI 引导，则必须有 /boot/efi 分区。\\n', '\\n', '设置完成后，请单击左上角”完成“按钮，弹出“更改摘要”对话框，提示更改产生的变更信息。\\n', '\\n', '点击“接受更改”，返回“安装概览”页面。\\n', '\\n', '设置网络和主机名\\n', '在“安装概览”页面中选择“网络和主机名”，设置系统的网络功能。\\n', '\\n', '安装程序会自动探测可本地访问的接口。探测到的接口列在左侧方框中，右侧显示相应的接口详情，如图14所示。用户可以通过页面右上角的开关，来开启或者关闭网络接口。开关默认是关闭状态，若设置安装源选择的是在网络上安装，需要开启开关。用户还可以单击“配置”以配置选中的接口。勾选“自动以优先级连接”选项，即可将该网卡设置为开机自启动，如图15所示。\\n', '\\n', '用户可在页面下方“主机名”字段输入主机名。主机名可以是完全限定域名（FQDN），其格式为hostname.domainname；也可以是简要主机名，其格式为hostname。\\n', '\\n', '图 14 网络和主机名\\n', '\\n', '\\n', '图 15 配置网络\\n', '\\n', '\\n', '设置完成后，请单击左上角“完成”返回“安装概览”页面。\\n', '\\n', '设置root密码\\n', '在“安装概览”页面中选择“根密码”，弹出设置“ROOT密码”界面，如图16所示，根据密码复杂度输入密码并再次输入密码进行确认。\\n', '\\n', ' 说明：\\n', '\\n', 'root帐户是用来执行关键系统管理任务，不建议您在日常工作及系统访问时使用root帐户。\\n', '\\n', '在“ROOT密码”界面若选择“锁定root帐户”则root帐户将禁用。\\n', '\\n', '图 16 root密码\\n', '\\n', '\\n', '密码复杂度\\n', '用户设置的root用户密码或新创建用户的密码均需要满足密码复杂度要求，否则会导致密码设置或用户创建失败。设置密码的复杂度的要求如下：\\n', '\\n', '口令长度至少8个字符。\\n', '\\n', '口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种。\\n', '\\n', '口令不能和账号一样。\\n', '\\n', '口令不能使用字典词汇。\\n', '\\n', ' 说明： 在已装好的openEuler环境中，可以通过cracklib-unpacker /usr/share/cracklib/pw_dict > dictionary.txt命令导出字典库文件dictionary.txt，用户可以查询密码是否在该字典中。\\n', '\\n', '完成设置后，单击左上角的“完成”返回“安装概览”页面。\\n', '\\n', '创建用户\\n', '在“安装概览”页面中选择“创建用户”，弹出“创建用户”的界面如图17所示。输入用户名，并设置密码。另外您还可以通过“高级”选项设置用户主目录、用户组等，如图18所示。\\n', '\\n', '图 17 创建用户\\n', '\\n', '\\n', '图 18 高级用户配置\\n', '\\n', '\\n', '完成设置后，单击左上角的“完成”返回“安装概览”页面。\\n', '\\n', '开始安装\\n', '在安装界面上完成所有必填选项的配置后，界面上的警告会消失。此时，用户可以单击“开始安装”进行系统安装。\\n', '\\n', '安装过程\\n', '开始安装后会出现进度页面，显示安装进度及所选软件包写入系统的进度，如图19所示。\\n', '\\n', '\\n', '若系统安装过程中，单击“退出”，或复位、下电服务器，则安装过程被中断，系统将不可用，需要重新进行安装。\\n', '\\n', '图 19 安装过程\\n', '\\n', '\\n', '安装完成\\n', '安装过程执行完成后，openEuler完成安装，单击“重启”后，系统将重新启动。\\n', '\\n', ' 说明：\\n', '\\n', '如果当前使用物理光盘安装操作系统，且在重启过程中安装光盘没有自动弹出，请手动取出光盘，则可以直接进入openEuler命令行登录界面。\\n', '如果当前使用虚拟光驱安装操作系统，则需要修改服务器的启动项为“硬盘”，然后重启服务器，则可以直接进入openEuler命令行登录界面。']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建FTP服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建FTP服务器\\n', '搭建FTP服务器\\n', '总体介绍\\n', 'FTP简介\\n', 'FTP使用到的端口\\n', 'vsftpd简介\\n', '使用vsftpd\\n', '安装vsftpd\\n', '管理vsftpd服务\\n', '配置vsftpd\\n', 'vsftpd配置文件介绍\\n', '默认配置说明\\n', '配置本地时间\\n', '配置欢迎信息\\n', '配置系统帐号登录权限\\n', '验证FTP服务是否搭建成功\\n', '配置防火墙\\n', '传输文件\\n', '概述\\n', '连接服务器\\n', '下载文件\\n', '上传文件\\n', '删除文件\\n', '断开服务器\\n', '总体介绍\\n', 'FTP简介\\n', 'FTP（File Transfer Protocol）即文件传输协议，是互联网最早的传输协议之一，其最主要的功能是服务器和客户端之间的文件传输。FTP使用户可以通过一套标准的命令访问远程系统上的文件，而不需要直接登录远程系统。另外，FTP服务器还提供了如下主要功能：\\n', '\\n', '用户分类\\n', '\\n', '默认情况下，FTP服务器依据登录情况，将用户分为实体用户（real user）、访客（guest）、匿名用户（anonymous）三类。三类用户对系统的访问权限差异较大，实体用户具有较完整的访问权限，匿名用户仅有下载资源的权限。\\n', '\\n', '命令记录和日志文件记录\\n', '\\n', 'FTP可以利用系统的syslogd记录数据，这些数据包括用户历史使用命令与用户传输数据（传输时间、文件大小等），用户可以在/var/log/中获得各项日志信息。\\n', '\\n', '限制用户的访问范围\\n', '\\n', 'FTP可以将用户的工作范围限定在用户主目录。用户通过FTP登录后系统显示的根目录就是用户主目录，这种环境被称为change root，简称chroot。这种方式可以限制用户只能访问主目录，而不允许访问/etc、/home、/usr/local等系统的重要目录，从而保护系统，使系统更安全。\\n', '\\n', 'FTP使用到的端口\\n', 'FTP的正常工作需要使用到多个网络端口，服务器端会使用到的端口主要有：\\n', '\\n', '命令通道，默认端口为21\\n', '数据通道，默认端口为20\\n', '两者的连接发起端不同，端口21主要接收来自客户端的连接，端口20则是FTP服务器主动连接至客户端。\\n', '\\n', 'vsftpd简介\\n', '由于FTP历史悠久，它采用未加密的传输方式，所以被认为是一种不安全的协议。为了更安全地使用FTP，这里介绍FTP较为安全的守护进程vsftpd（Very Secure FTP Daemon）。\\n', '\\n', '之所以说vsftpd安全，是因为它最初的发展理念就是构建一个以安全为中心的FTP服务器。它具有如下特点：\\n', '\\n', 'vsftpd服务的启动身份为一般用户，具有较低的系统权限。此外，vsftpd使用chroot改变根目录，不会误用系统工具。\\n', '任何需要较高执行权限的vsftpd命令均由一个特殊的上层程序控制，该上层程序的权限较低，以不影响系统本身为准。\\n', 'vsftpd整合了大部分FTP会使用到的额外命令（例如dir、ls、cd等），一般不需要系统提供额外命令，对系统来说比较安全。\\n', '使用vsftpd\\n', '安装vsftpd\\n', '使用vsftpd需要安装vsftpd软件，在已经配置yum源的情况下，通过root权限执行如下命令，即可完成vsftpd的安装。\\n', '\\n', '# dnf install vsftpd\\n', '管理vsftpd服务\\n', '启动、停止和重启vsftpd服务，请在root权限下执行对应命令。\\n', '\\n', '启动vsftpd服务\\n', '\\n', '# systemctl start vsftpd\\n', '可以通过netstat命令查看通信端口21是否开启，如下显示说明vsftpd已经启动。\\n', '\\n', '# netstat -tulnp | grep 21\\n', 'tcp6       0      0 :::21                   :::*                    LISTEN      19716/vsftpd\\n', ' 说明：\\n', '如果没有netstat命令，可以执行dnf install net-tools命令安装后再使用netstat命令。\\n', '\\n', '停止vsftpd服务\\n', '\\n', '# systemctl stop vsftpd\\n', '重启vsftpd服务\\n', '\\n', '# systemctl restart vsftpd\\n', '配置vsftpd\\n', 'vsftpd配置文件介绍\\n', '用户可以通过修改vsftpd的配置文件，控制用户权限等。vsftpd的主要配置文件和含义如表1所示，用户可以根据需求修改配置文件的内容。更多的配置参数含义可以通过man查看。\\n', '\\n', '表 1 vsftpd配置文件介绍\\n', '\\n', '\\n', '配置文件\\n', '\\n', '含义\\n', '\\n', '/etc/vsftpd/vsftpd.conf\\n', '\\n', 'vsftpd进程的主配置文件，配置内容格式为“参数=参数值”，且参数和参数值不能为空。\\n', '\\n', 'vsftpd.conf 的详细介绍可以使用如下命令查看：\\n', '\\n', 'man 5 vsftpd.conf\\n', '\\n', '/etc/pam.d/vsftpd\\n', '\\n', 'PAM（Pluggable Authentication Modules）认证文件，主要用于身份认证和限制一些用户的操作。\\n', '\\n', '/etc/vsftpd/ftpusers\\n', '\\n', '禁用使用vsftpd的用户列表文件。默认情况下，系统帐号也在该文件中，因此系统帐号默认无法使用vsftpd。\\n', '\\n', '/etc/vsftpd/user_list\\n', '\\n', '禁止或允许登录vsftpd服务器的用户列表文件。该文件是否生效，取决于主配置文件vsftpd.conf中的如下参数：\\n', '\\n', 'userlist_enable：是否启用userlist机制，YES为启用，此时userlist_deny配置有效，NO为禁用。\\n', '\\n', 'userlist_deny：是否禁止user_list中的用户登录，YES为禁止名单中的用户登录，NO为允许命令中的用户登录。\\n', '\\n', '例如userlist_enable=YES，userlist_deny=YES，则user_list中的用户都无法登录。\\n', '\\n', '/etc/vsftpd/chroot_list\\n', '\\n', '是否限制在主目录下的用户列表。该文件默认不存在，需要手动建立。它是主配置文件vsftpd.conf中参数chroot_list_file的参数值。\\n', '\\n', '其作用是限制还是允许，取决于主配置文件vsftpd.conf中的如下参数：\\n', '\\n', 'chroot_local_user：是否将所有用户限制在主目录，YES为启用，NO禁用。\\n', 'chroot_list_enable：是否启用限制用户的名单，YES为启用，NO禁用。\\n', '例如chroot_local_user=YES，chroot_list_enable=YES，且指定chroot_list_file=/etc/vsftpd/chroot_list时，表示所有用户被限制在其主目录下，而chroot_list中的用户不受限制。\\n', '\\n', '/usr/sbin/vsftpd\\n', '\\n', 'vsftpd的唯一执行文件。\\n', '\\n', '/var/ftp/\\n', '\\n', '匿名用户登录的默认根目录，与ftp帐户的用户主目录有关。\\n', '\\n', '默认配置说明\\n', ' 说明：\\n', '文档中的配置内容仅供参考，请用户根据实际情况（例如安全加固需要）进行修改。\\n', '\\n', 'openEuler系统中 ，vsftpd默认不开放匿名用户，使用vim命令查看主配置文件，其内容如下：\\n', '\\n', '$ vim /etc/vsftpd/vsftpd.conf\\n', 'anonymous_enable=NO\\n', 'local_enable=YES\\n', 'write_enable=YES\\n', 'local_umask=022\\n', 'dirmessage_enable=YES\\n', 'xferlog_enable=YES\\n', 'connect_from_port_20=YES\\n', 'xferlog_std_format=YES\\n', 'listen=NO\\n', 'listen_ipv6=YES\\n', 'pam_service_name=vsftpd\\n', 'userlist_enable=YES\\n', '其中各参数含义如表2所示。\\n', '\\n', '表 2 参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '含义\\n', '\\n', 'anonymous_enable\\n', '\\n', '是否允许匿名用户登录，YES为允许匿名登录，NO为不允许。\\n', '\\n', 'local_enable\\n', '\\n', '是否允许本地用户登入，YES 为允许本地用户登入，NO为不允许。\\n', '\\n', 'write_enable\\n', '\\n', '是否允许登录用户有写权限，YES为启用上传写入功能，NO为禁用。\\n', '\\n', 'local_umask\\n', '\\n', '本地用户新增档案时的umask值。\\n', '\\n', 'dirmessage_enable\\n', '\\n', '当用户进入某个目录时，是否显示该目录需要注意的内容，YES为显示注意内容，NO为不显示。\\n', '\\n', 'xferlog_enable\\n', '\\n', '是否记录使用者上传与下载文件的操作，YES为记录操作，NO为不记录。\\n', '\\n', 'connect_from_port_20\\n', '\\n', 'Port模式进行数据传输是否使用端口20，YES为使用端口20，NO为不使用端口20。\\n', '\\n', 'xferlog_std_format\\n', '\\n', '传输日志文件是否以标准xferlog格式书写，YES为使用该格式书写，NO为不使用。\\n', '\\n', 'listen\\n', '\\n', '设置vsftpd是否以stand alone的方式启动，YES为使用stand alone方式启动，NO为不使用该方式。\\n', '\\n', 'pam_service_name\\n', '\\n', '支持PAM模块的管理，配置值为服务名称，例如vsftpd。\\n', '\\n', 'userlist_enable\\n', '\\n', '是否支持/etc/vsftpd/user_list文件内的账号登录控制，YES为支持，NO为不支持。\\n', '\\n', 'tcp_wrappers\\n', '\\n', '是否支持TCP Wrappers的防火墙机制，YES为支持，NO为不支持。\\n', '\\n', 'listen_ipv6\\n', '\\n', '是否侦听IPv6的FTP请求，YES为侦听，NO为不侦听。listen和listen_ipv6不能同时开启。\\n', '\\n', '配置本地时间\\n', '概述\\n', 'openEuler系统中，vsftpd默认使用GMT时间（格林尼治时间），可能和本地时间不一致，例如GMT时间比北京时间晚8小时，请用户改为本地时间，否则服务器和客户端时间不一致，在上传下载文件时可能引起错误。\\n', '\\n', '设置方法\\n', '在root权限下设置vsftpd时间为本地时间的操作步骤如下：\\n', '\\n', '打开配置文件vsftpd.conf，将参数use_localtime的参数值改为YES。命令如下：\\n', '\\n', '# vim /etc/vsftpd/vsftpd.conf\\n', '配置内容如下：\\n', '\\n', 'use_localtime=YES\\n', '重启vsftpd服务。\\n', '\\n', '# systemctl restart vsftpd\\n', '设置vsftpd服务开机启动。\\n', '\\n', '# systemctl enable vsftpd\\n', '配置欢迎信息\\n', '正常使用vsftpd服务，需要存在欢迎信息文件。在root权限下设置vsftp的欢迎信息welcome.txt文件的操作步骤如下：\\n', '\\n', '打开配置文件vsftpd.conf，加入欢迎信息文件配置内容后保存退出。\\n', '\\n', '# vim /etc/vsftpd/vsftpd.conf\\n', '需要加入的配置行如下：\\n', '\\n', 'banner_file=/etc/vsftpd/welcome.txt\\n', '建立欢迎信息。即打开welcome.txt文件，写入欢迎信息后保存退出。\\n', '\\n', '# vim /etc/vsftpd/welcome.txt\\n', '欢迎信息举例如下：\\n', '\\n', 'Welcome to this FTP server!\\n', '配置系统帐号登录权限\\n', '一般情况下，用户需要限制部分帐号的登录权限。用户可根据需要进行配置。\\n', '\\n', '限制系统帐号登录的文件有两个，默认如下：\\n', '\\n', '/etc/vsftpd/ftpusers：受/etc/pam.d/vsftpd文件的设置影响，由PAM模块掌管。\\n', '/etc/vsftpd/user_list：由vsftpd.conf的userlist_file设置，由vsftpd主动提供。\\n', '两个文件的必须同时存在且内容相同，请参考/etc/passwd文件，将UID小于500的帐号写入这两个文件，每一行代表一个帐号。\\n', '\\n', '如果用户需要限制系统帐号登录，需要在root权限下将对应帐号添加到/etc/vsftpd/ftpusers和/etc/vsftpd/user_list。\\n', '\\n', '打开user_list可以查看当前文件中包含的帐号信息，命令和回显如下：\\n', '\\n', '$ vim /etc/vsftpd/user_list\\n', 'root\\n', 'bin\\n', 'daemon\\n', 'adm\\n', 'lp\\n', 'sync\\n', 'shutdown\\n', 'halt\\n', 'mail\\n', 'news\\n', 'uucp\\n', 'operator\\n', 'games\\n', 'nobody\\n', '验证FTP服务是否搭建成功\\n', '可以使用openEuler提供的FTP客户端进行验证。命令和回显如下，根据提示输入用户名（用户为系统中存在的用户）和密码。如果显示Login successful，即说明FTP服务器搭建成功。\\n', '\\n', '$ ftp localhost\\n', 'Trying 127.0.0.1...\\n', 'Connected to localhost (127.0.0.1).\\n', '220-Welcome to this FTP server!\\n', '220\\n', 'Name (localhost:root): USERNAME\\n', '331 Please specify the password.\\n', 'Password:\\n', '230 Login successful.\\n', 'Remote system type is UNIX.\\n', 'Using binary mode to transfer files.\\n', 'ftp> bye\\n', '221 Goodbye.\\n', ' 说明：\\n', '如果没有ftp命令，可以在root权限下执行dnf install ftp命令安装后再使用ftp命令。\\n', '\\n', '配置防火墙\\n', '如果要将FTP开放给Internet使用，需要在root权限下对防火墙和SElinux进行设置。\\n', '\\n', '# firewall-cmd --add-service=ftp --permanent\\n', 'success\\n', '# firewall-cmd --reload\\n', 'success\\n', '# setsebool -P ftpd_full_access on\\n', '传输文件\\n', '概述\\n', '这里给出vsftpd服务启动后，如何进行文件传输的指导。\\n', '\\n', '连接服务器\\n', '命令格式\\n', '\\n', 'ftp [hostname | ip-address]\\n', '\\n', '其中hostname为服务器名称，ip-address为服务器IP地址。\\n', '\\n', '操作说明\\n', '\\n', '在openEuler系统的命令行终端，执行如下命令：\\n', '\\n', '$ ftp ip-address\\n', '根据提示输入用户名和密码，认证通过后显示如下，说明ftp连接成功，此时进入了连接到的服务器目录。\\n', '\\n', 'ftp>\\n', '在该提示符下，可以输入不同的命令进行相关操作：\\n', '\\n', '显示服务器当前路径\\n', '\\n', 'ftp>pwd\\n', '显示本地路径，用户可以将该路径下的文件上传到FTP服务器对应位置\\n', '\\n', 'ftp>lcd\\n', '退出当前窗口，返回本地Linux终端\\n', '\\n', 'ftp>！\\n', '下载文件\\n', '通常使用get或mget命令下载文件。\\n', '\\n', 'get使用方法\\n', '\\n', '功能说明：将文件从远端主机中传送至本地主机中\\n', '\\n', '命令格式：get [remote-file] [local-file]\\n', '\\n', '其中 remote-file 为远程文件，local-file 为本地文件\\n', '\\n', '示例：获取远程服务器上的/home/openEuler/openEuler.htm文件到本地/home/myopenEuler/，并改名为myopenEuler.htm，命令如下：\\n', '\\n', 'ftp> get /home/openEuler/openEuler.htm /home/myopenEuler/myopenEuler.htm\\n', 'mget使用方法\\n', '\\n', '功能说明：从远端主机接收一批文件至本地文件\\n', '\\n', '命令格式：mget [remote-file]\\n', '\\n', '其中 remote-file 为远程文件\\n', '\\n', '示例：获取服务器上/home/openEuler/目录下的所有文件，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> mget *.*\\n', ' 说明：\\n', '\\n', '此时每下载一个文件，都会有提示信息。如果要屏蔽提示信息，则在 mget *.* 命令前先执行prompt off\\n', '文件都被下载到Linux主机的当前目录下。比如，在/home/myopenEuler/下运行的ftp命令，则文件都下载到/home/myopenEuler/下。\\n', '上传文件\\n', '通常使用put或mput命令上传文件。\\n', '\\n', 'put使用方法\\n', '\\n', '功能说明：将本地的一个文件传送到远端主机中\\n', '\\n', '命令格式：put [local-file] [remote-file]\\n', '\\n', '其中 remote-file 为远程文件，local-file 为本地文件\\n', '\\n', '示例：将本地的myopenEuler.htm传送到远端主机/home/openEuler/，并改名为openEuler.htm，命令如下：\\n', '\\n', 'ftp> put myopenEuler.htm /home/openEuler/openEuler.htm\\n', 'mput使用方法\\n', '\\n', '功能说明：将本地主机中一批文件传送至远端主机\\n', '\\n', '命令格式：mput [local-file]\\n', '\\n', '其中 local-file 为本地文件\\n', '\\n', '示例：将本地当前目录下所有htm文件上传到服务器/home/openEuler/下，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> mput *.htm\\n', '删除文件\\n', '通常使用delete或mdelete命令删除文件。\\n', '\\n', 'delete使用方法\\n', '\\n', '功能说明：删除远程服务器上的一个或多个文件\\n', '\\n', '命令格式：delete [remote-file]\\n', '\\n', '其中 remote-file 为远程文件\\n', '\\n', '示例：删除远程服务器上/home/openEuler/下的openEuler.htm文件，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> delete openEuler.htm\\n', 'mdelete使用方法\\n', '\\n', '功能说明：删除远程服务器上的文件，常用于批量删除\\n', '\\n', '命令格式：mdelete [remote-file]\\n', '\\n', '其中 remote-file 为远程文件\\n', '\\n', '示例：删除远程服务器上/home/openEuler/下所有a开头的文件，命令如下：\\n', '\\n', 'ftp> cd /home/openEuler/\\n', 'ftp> mdelete a*\\n', '断开服务器\\n', '断开与服务器的连接，使用bye命令，如下：\\n', '\\n', 'ftp> bye ']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_工具使用指南_LibcarePlus.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/LibcarePlus.html", "text_entry": "['LibcarePlus\\n', '概述\\n', '软硬件要求\\n', '注意事项和约束\\n', '安装 LibcarePlus\\n', '制作 LibcarePlus 热补丁\\n', '应用 LibcarePlus 热补丁\\n', '概述\\n', 'LibcarePlus 是一个用户态进程热补丁框架，可以在不重启进程的情况下对 Linux 系统上运行的目标进程进行热补丁操作。热补丁可以应用于 CVE 漏洞修复，也可以应用于不中断应用服务的紧急 bug 修复。\\n', '\\n', '软硬件要求\\n', '在 openEuler 上使用 LibcarePlus，需要满足一定的软硬件要求：\\n', '\\n', '当前LibcarePlus支持 x86 体系架构和arm64体系架构。\\n', 'LibcarePlus 可以在任何支持安装 libunwind、 elfutils 以及 binutils 的 Linux 发行版系统上运行。\\n', 'LibcarePlus 使用ptrace()系统调用，需要对应Linux发行版本的相关编译选项支持。\\n', 'LibcarePlus 制作热补丁时，依赖原可执行文件的符号表，因此，请勿过早将符号表strip掉。\\n', '对于开启selinux的Linux系统，需要自行适配对应的selinux规则。\\n', '注意事项和约束\\n', '使用 LibcarePlus，需遵循以下热补丁规范和约束：\\n', '\\n', '仅支持对 C 语言编写的代码，不支持汇编语言等。\\n', '代码文件名必须符合 C 语言标识符命名规范：由字母（A-Z,a-z）、数字 （0-9）、下划线“_”组成；并且首字符不能是数字，但可以是字母或者下划线；不能包含“-”、“$”等特殊符号。\\n', '支持增量补丁，即支持对进程打多个补丁，但补丁加卸载管理需使用者执行设计，一般遵循FILO规则。\\n', '不支持补丁自动加载，对于特定进程，需使用者自行设计。\\n', '支持补丁查询功能。\\n', '静态函数补丁受限于系统中能找到该函数的符号表。\\n', '热补丁为进程粒度，即动态库热补丁只能对调用这个动态库的进程打补丁。\\n', '单个进程支持的补丁数受限于跳转指令的跳转范围和虚拟内存地址空洞大小，一般支持[1, 512]；\\n', '对于TLS变量，仅支持修改IE模式的TLS变量；\\n', '后续补丁不能使用之前补丁中定义的符号；\\n', '以下场景不支持热补丁:\\n', '死循环函数、不退出函数、inline 函数、初始化函数、NMI 中断处理函数\\n', '替换全局变量\\n', '小于5字节的短函数\\n', '修改头文件\\n', '增加和删除目标函数的出参和入参\\n', '数据结构成员变化（新增、删除、修改）\\n', '修改包含 LINE ， FILE 等gcc编译宏的 C 文件\\n', '修改 intel 矢量汇编指令\\n', '安装 LibcarePlus\\n', '安装软件依赖\\n', 'LibcarePlus 运行依赖于 libunwind、 elfutils 和 binutils，在配置了 yum 源的 openEuler 系统上，可以参考如下命令安装 LibcarePlus 的依赖软件。\\n', '\\n', '# yum install -y binutils elfutils elfutils-libelf-devel libunwind-devel\\n', '安装 LibcarePlus\\n', '# yum install libcareplus -y\\n', '查看安装是否成功：\\n', '\\n', '# libcare-ctl -h\\n', 'usage: libcare-ctl [options] <cmd> [args]\\n', '\\n', 'Options:\\n', '  -v          - verbose mode\\n', '  -h          - this message\\n', '\\n', 'Commands:\\n', '  patch  - apply patch to a user-space process\\n', '  unpatch- unapply patch from a user-space process\\n', '  info   - show info on applied patches\\n', '\\n', '制作 LibcarePlus 热补丁\\n', '概述\\n', 'LibcarePlus 支持如下方式制作热补丁：\\n', '\\n', '手动制作\\n', '通过脚本制作\\n', '手动制作热补丁的过程繁琐，对于代码量较大的工程，例如QEMU，手动制作热补丁极其困难。建议使用 LibcarePlus 自带脚本一键式地生成热补丁文件。\\n', '\\n', '手动制作\\n', '本节以原文件 foo.c 和补丁文件 bar.c 为例，给出手动制作热补丁的指导。\\n', '\\n', '准备 C 语言编写的原文件和补丁文件。例如原文件 foo.c 和补丁文件 bar.c 。\\n', '\\n', '点击展开 foo.c\\n', '点击展开 bar.c\\n', '编译得到原文件和补丁文件的汇编文件 foo.s 和 bar.s，参考命令如下：\\n', '\\n', '# gcc -S foo.c\\n', '# gcc -S bar.c\\n', '# ls\\n', 'bar.c  bar.s  foo.c  foo.s\\n', '使用 kpatch_gensrc 对比 foo.s 和 bar.s 差异，生成包含原文件的汇编内容和差异内容的 foobar.s，参考命令如下：\\n', '\\n', \"# sed -i 's/bar.c/foo.c/' bar.s\\n\", '# kpatch_gensrc --os=rhel6 -i foo.s -i bar.s -o foobar.s --force-global\\n', '由于 kpatch_gensrc 默认对同一 C 语言原文件进行对比，所以对比前需要使用 sed 命令将补丁汇编文件 bar.s 中的 bar.c 改为原文件名称 foo.c。随后调用 kpatch_gensrc，指定输入文件为 foo.s 与 bar.s，输出文件为 foobar.s。\\n', '\\n', '编译原文件的汇编文件 foo.s 和生成的汇编文件 foobar.s，得到可执行文件 foo 和 foobar，参考命令如下：\\n', '\\n', '# gcc -o foo foo.s\\n', '# gcc -o foobar foobar.s -Wl,-q\\n', '链接选项**-Wl, -q**将保留foobar中的重定位节。\\n', '\\n', '利用 kpatch_strip 去除可执行程序 foo 和 foobar 的相同内容，保留制作热补丁所需要的内容。\\n', '\\n', '# kpatch_strip --strip foobar foobar.stripped\\n', '# kpatch_strip --rel-fixup foo foobar.stripped\\n', '# strip --strip-unneeded foobar.stripped\\n', '# kpatch_strip --undo-link foo foobar.stripped\\n', '上述命令中的各参数含义为：\\n', '\\n', '–strip 用于去除 foobar 中对于补丁制作无用的 section；\\n', '–rel-fixup 用于修复补丁内所访问的变量以及函数的地址；\\n', 'strip –strip-unneeded 用于去除对于热补丁重定位操作无用的符号信息；\\n', '–undo-link 用于将补丁内符号的地址从绝对地址更改为相对地址。\\n', '制作热补丁文件。\\n', '\\n', '通过以上操作，已经得到了热补丁制作所需的主要内容。接下来需要使用 kpatch_make 将原可执行文件的 Build ID 以及 kpatch_strip 的输出文件 foobar.stripped 作为参数传递给 kpatch_make，最终生成热补丁文件，参考命令如下：\\n', '\\n', \"# str=$(readelf -n foo | grep 'Build ID')\\n\", '# substr=${str##* }\\n', '# kpatch_make -b $substr -i 0001 foobar.stripped -o foo.kpatch\\n', '# ls\\n', 'bar.c  bar.s  foo  foobar  foobar.s  foobar.stripped  foo.c  foo.kpatch  foo.s\\n', '至此，就得到了patch ID为0001的热补丁文件 foo.kpatch。\\n', '\\n', '通过脚本制作\\n', '本节介绍如何利用 LibcarePlus 自带的 libcare-patch-make 脚本制作热补丁文件，仍以原文件 foo.c 和补丁文件 bar.c 为例。\\n', '\\n', '利用 diff 命令生成 foo.c 和 bar.c 的对比文件，命令如下所示:\\n', '\\n', '# diff -up foo.c bar.c > foo.patch\\n', 'foo.patch 文件内容如下所示：\\n', '\\n', '点击展开 foo.patch\\n', '编写编译 foo.c 的 MakeFile 文件，具体如下所示：\\n', '\\n', '点击展开 MakeFile\\n', '编写好 MakeFile 之后，直接调用 libcare-patch-make 即可。若 libcare-patch-make 询问选择哪个文件进行打补丁操作，输入原文件名即可，具体如下所示：\\n', '\\n', '# libcare-patch-make --clean -i 0001 foo.patch\\n', 'rm -f foo\\n', 'BUILDING ORIGINAL CODE\\n', '/usr/local/bin/libcare-cc -o foo foo.c\\n', 'INSTALLING ORIGINAL OBJECTS INTO /libcareplus/test/lpmake\\n', 'mkdir $DESTDIR || :\\n', 'cp foo $DESTDIR\\n', 'applying foo.patch...\\n', \"can't find file to patch at input line 3\\n\", 'Perhaps you used the wrong -p or --strip option?\\n', 'The text leading up to this was:\\n', '--------------------------\\n', '|--- foo.c\\t2020-12-10 09:43:04.445375845 +0800\\n', '|+++ bar.c\\t2020-12-10 09:48:36.778379648 +0800\\n', '--------------------------\\n', 'File to patch: foo.c         \\n', 'patching file foo.c\\n', 'BUILDING PATCHED CODE\\n', '/usr/local/bin/libcare-cc -o foo foo.c\\n', 'INSTALLING PATCHED OBJECTS INTO /libcareplus/test/.lpmaketmp/patched\\n', 'mkdir $DESTDIR || :\\n', 'cp foo $DESTDIR\\n', 'MAKING PATCHES\\n', 'Fixing up relocation printf@@GLIBC_2.2.5+fffffffffffffffc\\n', 'Fixing up relocation print_hello+0\\n', 'patch for /libcareplus/test/lpmake/foo is in /libcareplus/test/patchroot/700297b7bc56a11e1d5a6fb564c2a5bc5b282082.kpatch\\n', '执行成功之后，输出显示：热补丁文件位于当前目录的 patchroot 目录下，可执行文件则在 lpmake 目录下。脚本生成的热补丁文件默认是采用 Build ID 作为热补丁文件的文件名。\\n', '\\n', '应用 LibcarePlus 热补丁\\n', '本节以原文件 foo.c 和补丁文件 bar.c 为例，介绍 LibcarePlus 热补丁的应用指导。\\n', '\\n', '前期准备\\n', '应用 LibcarePlus 热补丁之前，需要提前准备好原可执行程序 foo、以及热补丁文件 foo.kpatch。\\n', '\\n', '加载热补丁\\n', '本节介绍应用 LibcarePlus 热补丁的具体流程。\\n', '\\n', '首先在第一个 shell 窗口运行需要打补丁的可执行程序，如下所示：\\n', '\\n', '# ./lpmake/foo\\n', 'Hello world!\\n', 'Hello world!\\n', 'Hello world!\\n', '随后在第二个 shell 窗口运行 libcare-ctl 应用热补丁，命令如下所示：\\n', '\\n', '# libcare-ctl -v patch -p $(pidof foo) ./foo.kpatch\\n', '若此时热补丁应用成功，第二个 shell 窗口会有如下输出：\\n', '\\n', \"1 patch hunk(s) have been successfully applied to PID '10999'\\n\", '而第一个 shell 窗口内运行的目标进程则会出现如下输出：\\n', '\\n', 'Hello world!\\n', 'Hello world!\\n', 'Hello world being patched!\\n', 'Hello world being patched!\\n', '查询补丁\\n', '本节介绍查询LibcarePlus热补丁的具体流程。\\n', '\\n', '在第二个shell窗口执行如下命令：\\n', '\\n', '# libcare-ctl info -p $(pidof foo)\\n', '\\n', '此时若进程存在已经加载的热补丁，则第二个shell窗口会有如下输出：\\n', '\\n', 'Pid:                      551763\\n', 'Target:                   foo\\n', 'Build id:                 df05a25bdadd282812d3ee5f0a460e69038575de\\n', 'Applied patch number:     1\\n', 'Patch id:                 0001\\n', '卸载热补丁\\n', '本节介绍卸载 LibcarePlus 热补丁的具体流程。\\n', '\\n', '在第二个 shell 窗口执行如下命令：\\n', '\\n', '# libcare-ctl unpatch -p $(pidof foo)\\n', '此时若热补丁卸载成功，第二个 shell 窗口会有如下输出：\\n', '\\n', \"1 patch hunk(s) were successfully cancelled from PID '10999'\\n\", '第一个 shell 窗口内运行的目标进程则会出现如下输出：\\n', '\\n', 'Hello world being patched!\\n', 'Hello world being patched!\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_安全特性.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7.html", "text_entry": "['安全特性\\n', '安全特性\\n', 'seccomp安全配置场景\\n', 'capabilities安全配置场景\\n', 'SELinux安全配置场景\\n', 'seccomp安全配置场景\\n', '场景说明\\n', 'seccomp（secure computing mode）是linux kernel从2.6.23版本开始引入的一种简洁的sandboxing机制。在一些特定场景下，用户需要在容器中执行一些“特权”操作，但又不想启动特权容器，用户经常会在run时添加–cap-add来获得一些“小范围”的权限。对于安全要求比较严格的容器实例，上述的CAP粒度不一定能够满足安全需要，可使用一些办法精细化控制权限范围。\\n', '\\n', '举例\\n', '\\n', '普通容器场景中，用户使用-v将宿主机某目录（包含某普通用户无法执行的二进制），映射到容器中。\\n', '\\n', '在容器中，可以将二进制修改权限chmod 4777加入S标志位。这样在宿主机上，原先不能运行二进制的普通用户（或者运行此二进制受限），可以在S标志位的添加动作后，在运行此二进制的时候，获取到二进制自身的权限（比如root），从而提权运行或者访问其他文件。\\n', '\\n', '这个场景，如果在严格安全要求下，需要使用seccomp裁剪chmod、fchmod、fchmodat系统调用。\\n', '\\n', '使用限制\\n', 'seccomp可能会影响性能，设置seccomp之前需要对场景进行评估，确定必要时加入seccomp配置。\\n', '使用指导\\n', '通过–security-opt将配置文件传给要过滤系统调用的容器。\\n', '\\n', 'isula run -itd --security-opt seccomp=/path/to/seccomp/profile.json rnd-dockerhub.huawei.com/official/busybox\\n', ' 说明：\\n', '\\n', '创建容器时通过–security-opt将配置文件传给容器时，采用默认配置文件（/etc/isulad/seccomp_default.json）。\\n', '创建容器时–security-opt设置为unconfined时，对容器不过滤系统调用。\\n', '“/path/to/seccomp/profile.json”需要是绝对路径。\\n', '获取普通容器的默认seccomp配置\\n', '启动一个普通容器（或者是带–cap-add的容器），并查看默认权限配置：\\n', '\\n', 'cat /etc/isulad/seccomp_default.json | python -m json.tool > profile.json\\n', '可以看到\"seccomp\"字段中，有很多的\"syscalls\"，在此基础上，仅提取syscalls的部分，参考定制seccomp配置文件，进行定制化操作。\\n', '\\n', '\"defaultAction\": \"SCMP_ACT_ERRNO\",\\n', '\"syscalls\": [\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"accept\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"accept4\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"access\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"alarm\"\\n', '},\\n', '{\\n', '\"action\": \"SCMP_ACT_ALLOW\",\\n', '\"name\": \"bind\"\\n', '},\\n', ']...\\n', '查看转换为lxc可识别的seccomp配置\\n', '\\n', 'cat /var/lib/isulad/engines/lcr/74353e38021c29314188e29ba8c1830a4677ffe5c4decda77a1e0853ec8197cd/seccomp\\n', '...\\n', 'waitpid allow\\n', 'write allow\\n', 'writev allow\\n', 'ptrace allow\\n', 'personality allow [0,0,SCMP_CMP_EQ,0]\\n', 'personality allow [0,8,SCMP_CMP_EQ,0]\\n', 'personality allow [0,131072,SCMP_CMP_EQ,0]\\n', 'personality allow [0,131080,SCMP_CMP_EQ,0]\\n', 'personality allow [0,4294967295,SCMP_CMP_EQ,0]\\n', '...\\n', '定制seccomp配置文件\\n', '在启动容器的时候使用–security-opt引入seccomp配置文件，容器实例会按照配置文件规则进行限制系统API的运行。首先获取普通容器的默认seccomp，得到完整模板，然后按照本节定制配置文件，启动容器：\\n', '\\n', 'isula run --rm -it --security-opt seccomp:/path/to/seccomp/profile.json rnd-dockerhub.huawei.com/official/busybox\\n', '配置文件模板：\\n', '\\n', '{\\n', '\"defaultAction\": \"SCMP_ACT_ALLOW\",\\n', '\"syscalls\": [\\n', '{\\n', '\"name\": \"syscall-name\",\\n', '\"action\": \"SCMP_ACT_ERRNO\",\\n', '\"args\": null\\n', '}\\n', ']\\n', '}\\n', ' 须知：\\n', '\\n', 'defaultAction、syscalls：对应的action的类型是一样的，但其值是不能一样的，目的就是让所有的syscal都有一个默认的action，并且如果syscalls数组中有明确的定义，就以syscalls中的为准，由于defaultAction、action的值不一样，就能保证action不会有冲突。当前支持的action有：\\n', '“SCMP_ACT_ERRNO”：禁止，并打印错误信息。\\n', '“SCMP_ACT_ALLOW”：允许。\\n', 'syscalls： 数组，可以只有一个syscall，也可以有多个，可以带args，也可以不带。\\n', 'name：要过滤的syscall。\\n', 'args：数组，里面的每个object的定义如下：\\n', 'type Arg struct {  \\n', 'Index    uint     `json:\"index\"`     //参数的序号，如open(fd, buf, len),fd 对应的就是0，buf为1  \\n', 'Value    uint64   `json:\"value\"`     //跟参数进行比较的值  \\n', 'ValueTwo uint64   `json:\"value_two\"` //仅当Op=MaskEqualTo时起作用，用户传入值跟Value按位与操作后，跟ValueTwo进行比较，若相等则执行action。  \\n', 'Op       Operator `json:\"op\"`  \\n', '}  \\n', 'args中的Op，其取值可以下页面的任意一种：\\n', '“SCMP_CMP_NE”: NotEqualTo\\n', '“SCMP_CMP_LT”: LessThan\\n', '“SCMP_CMP_LE”: LessThanOrEqualTo\\n', '“SCMP_CMP_EQ”: EqualTo\\n', '“SCMP_CMP_GE”: GreaterThanOrEqualTo\\n', '“SCMP_CMP_GT”: GreaterThan\\n', '“SCMP_CMP_MASKED_EQ”: MaskEqualTo\\n', '\\n', 'capabilities安全配置场景\\n', '场景说明\\n', \"capabilities机制是linux kernel 2.2之后引入的安全特性，用更小的粒度控制超级管理员权限,可以避免使用 root 权限，将root用户的权限细分为不同的领域，可以分别启用或禁用。capabilities详细信息可通过Linux Programmer's Manual进行查看（capabilities(7) - Linux man page）：\\n\", '\\n', 'man capabilities\\n', '使用限制\\n', 'isulad默认Capabilities（白名单）配置如下，普通容器进程将默认携带：\\n', '\\n', '\"CAP_CHOWN\",\\n', '\"CAP_DAC_OVERRIDE\",\\n', '\"CAP_FSETID\",\\n', '\"CAP_FOWNER\",\\n', '\"CAP_MKNOD\",\\n', '\"CAP_NET_RAW\",\\n', '\"CAP_SETGID\",\\n', '\"CAP_SETUID\",\\n', '\"CAP_SETFCAP\",\\n', '\"CAP_SETPCAP\",\\n', '\"CAP_NET_BIND_SERVICE\",\\n', '\"CAP_SYS_CHROOT\",\\n', '\"CAP_KILL\",\\n', '\"CAP_AUDIT_WRITE\"\\n', '默认的权能配置，包含了CAP_SETUID和CAP_FSETID，如host和容器共享目录，容器可对共享目录的二进制文件进行文件权限设置，host上的普通用户可能使用该特性进行提权攻击。CAP_AUDIT_WRITE，容器可以对host写入，存在一定的风险，如果使用场景不需要，推荐在启动容器的时候使用–cap-drop将其删除。\\n', '\\n', '增加Capabilities意味着容器进程具备更大的能力，同时也会开放更多的系统调用接口。\\n', '\\n', '使用指导\\n', 'iSulad使用–cap-add/–cap-drop给容器增加/删去特定的权限，在非必要情况下，不要给容器增加额外的权限，推荐将容器默认但非必要的权限也去掉。\\n', '\\n', 'isula run --rm -it --cap-add all --cap-drop SYS_ADMIN rnd-dockerhub.huawei.com/official/busybox\\n', 'SELinux安全配置场景\\n', '场景说明\\n', 'SELinux(Security-Enhanced Linux)是一个Linux内核的安全模块，提供了访问控制安全策略机制，iSulad将采用MCS（多级分类安全）实现对容器内进程打上标签限制容器访问资源的方式，减少提权攻击的风险，防止造成更为重要的危害。\\n', '\\n', '使用限制\\n', '确保宿主机已使能SELinux，且daemon端已打开SELinux使能开发（/etc/isulad/daemon.json中“selinux-enabled”字段为true, 或者命令行参数添加–selinux-enabled）\\n', '确保宿主机上已配置合适的selinux策略，推荐使用container-selinux进行配置\\n', '引入SELinux会影响性能，设置SELinux之前需要对场景进行评估，确定必要时打开daemon端SELinux开关并设置容器SELinux配置\\n', '对挂载卷进行标签配置时，源目录不允许为/、/usr、/etc、/tmp、/home、/run、/var、/root以及/usr的子目录。\\n', ' 说明：\\n', '\\n', '目前iSulad不支持对容器的文件系统打标签，确保容器文件系统及配置目录打上容器可访问标签，需使用chcon命令对其打上标签。\\n', '若iSulad启用SELinux访问控制，建议daemon启动前对/var/lib/isulad目录打上标签，容器容器创建时目录下生产的文件及文件夹将默认继承其标签，例如：\\n', 'chcon -R system_u:object_r:container_file_t:s0 /var/lib/isulad  \\n', '使用指导\\n', 'daemon端使能selinux：\\n', '\\n', 'isulad --selinux-enabled\\n', '  \\n', '\\n', '启动容器时配置selinux标签安全上下文\\n', '\\n', '–security-opt=“label=user:USER” 配置安全上下文用户\\n', '\\n', '–security-opt=“label=role:ROLE” 配置安全上下文角色\\n', '\\n', '–security-opt=“label=type:TYPE” 配置安全上下文类型\\n', '\\n', '–security-opt=“label=level:LEVEL” 配置安全上下文域\\n', '\\n', '–security-opt=“label=disable” 容器禁用SELinux配置\\n', '\\n', '$ isula run -itd --security-opt label=type:container_t --security-opt label=level:s0:c1,c2 rnd-dockerhub.huawei.com/official/centos\\n', '9be82878a67e36c826b67f5c7261c881ff926a352f92998b654bc8e1c6eec370\\n', '  \\n', '\\n', \"为挂载卷打selinux标签('z'为共享模式)\\n\", '\\n', '$ isula run -itd -v /test:/test:z rnd-dockerhub.huawei.com/official/centos\\n', '9be82878a67e36c826b67f5c7261c881ff926a352f92998b654bc8e1c6eec370\\n', '\\n', '$ls -Z /test\\n', 'system_u:object_r:container_file_t:s0 file\\n', '  \\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_安装与配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE-2.html", "text_entry": "['安装与配置\\n', '安装与配置\\n', '安装方法\\n', '配置方法\\n', '安装方法\\n', '前提条件\\n', '安全容器的安装需要使用root权限。\\n', '为了获取更好的性能体验，安全容器需要运行在裸金属服务器上，暂不支持安全容器运行在虚拟机内。\\n', '安全容器运行依赖以下组件，请确保环境上已安装所需版本的依赖组件。以下组件来自配套的openEuler版本。如果使用iSula容器引擎，请参考iSula容器引擎的安装方法章节安装iSulad。\\n', 'docker-engine\\n', 'qemu\\n', '安装操作\\n', '安全容器发布组件集成在同一个kata-containers-<version>.rpm包中，使用rpm命令可以直接安装对应的软件，其中version为。\\n', '\\n', 'rpm -ivh kata-containers-<version>.rpm\\n', '配置方法\\n', 'docker-engine容器引擎的配置\\n', '为了让docker-engine容器引擎支持新的容器运行时kata-runtime，需要通过以下步骤对docker-engine容器引擎进行配置：\\n', '\\n', '请保证环境上所有的软件包（docker-engine、kata-containers）都已经安装完毕。\\n', '\\n', '停止docker-engine。\\n', '\\n', 'systemctl stop docker\\n', '修改docker-engine的配置文件/etc/docker/daemon.json，并新增如下配置：\\n', '\\n', '{\\n', '  \"runtimes\": {\\n', '    \"kata-runtime\": {\\n', '      \"path\": \"/usr/bin/kata-runtime\",\\n', '      \"runtimeArgs\": [\\n', '          \"--kata-config\",\\n', '          \"/usr/share/defaults/kata-containers/configuration.toml\"\\n', '        ]\\n', '    }\\n', '  }\\n', '}\\n', '重新启动docker-engine。\\n', '\\n', 'systemctl start docker\\n', 'iSula容器引擎的配置\\n', '与docker-engine容器引擎类似，为了让iSula容器引擎支持新的容器运行时kata-runtime，需要通过以下步骤对iSula容器引擎进行配置：\\n', '\\n', '请保证环境上所有的软件包（iSulad、kata-containers）都已经安装完毕。\\n', '\\n', '停止isulad。\\n', '\\n', 'systemctl stop isulad\\n', '修改iSula容器引擎的配置文件/etc/isulad/daemon.json，并新增如下配置：\\n', '\\n', '{\\n', '  \"runtimes\": {\\n', '    \"kata-runtime\": {\\n', '      \"path\": \"/usr/bin/kata-runtime\",\\n', '      \"runtime-args\": [\\n', '          \"--kata-config\",\\n', '          \"/usr/share/defaults/kata-containers/configuration.toml\"\\n', '        ]\\n', '    }\\n', '  }\\n', '}\\n', '重新启动isulad。\\n', '\\n', 'systemctl start isulad\\n', '安全容器全局配置文件configuration-toml\\n', '安全容器提供全局配置文件configuration.toml进行配置开关，用户也可以定制安全容器配置文件路径与配置选项。\\n', '\\n', '在docker-engine的runtimeArges字段可以利用–kata-config指定私有文件，默认的配置文件路径为/usr/share/defaults/kata-containers/configuration.toml。\\n', '\\n', '常用配置文件字段如下，详细的配置文件选项参见“安全容器 > 附录 > configuration.toml配置说明”。\\n', '\\n', 'hypervisor.qemu\\n', '\\n', 'path ：指定虚拟化qemu执行路径。\\n', 'kernel ：指定guest kernel执行路径。\\n', 'initrd ：指定guest initrd执行路径。\\n', 'machin_type ：指定模拟芯片类型，其中arm为virt，x86架构为pc。\\n', 'kernel_params ：指定guest内核运行参数。\\n', 'proxy.kata\\n', '\\n', 'path ：指定kata-proxy运行路径。\\n', 'enable_debug ：kata-proxy进程debug开关。\\n', 'agent.kata\\n', '\\n', 'enable_blk_mount ：开启block设备guest挂载。\\n', 'enable_debug ：kata-agent进程debug开关。\\n', 'runtime\\n', '\\n', 'enable_cpu_memory_hotplug：CPU和内存热插拔开关。\\n', 'enable_debug：kata-runtime进程debug开关。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_准备虚拟机.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%87%86%E5%A4%87%E8%99%9A%E6%8B%9F%E6%9C%BA.html", "text_entry": "['准备虚拟机\\n', '本章介绍使用 virt manager 安装虚拟机的方法，如果您已经准备好虚拟机，可以跳过本章节。\\n', '\\n', '安装依赖工具\\n', '安装虚拟机，会依赖相关工具，安装依赖并使能 libvirtd 服务的参考命令如下（如果需要代理，请先配置代理）：\\n', '\\n', '$ dnf install virt-install virt-manager libvirt-daemon-qemu edk2-aarch64.noarch virt-viewer\\n', '$ systemctl start libvirtd\\n', '$ systemctl enable libvirtd\\n', '准备虚拟机磁盘文件\\n', '$ dnf install -y qemu-img\\n', '$ virsh pool-define-as vmPool --type dir --target /mnt/vm/images/\\n', '$ virsh pool-build vmPool\\n', '$ virsh pool-start vmPool\\n', '$ virsh pool-autostart  vmPool\\n', '$ virsh vol-create-as --pool vmPool --name master0.img --capacity 200G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name master1.img --capacity 200G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name master2.img --capacity 200G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name node1.img --capacity 300G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name node2.img --capacity 300G --allocation 1G --format qcow2\\n', '$ virsh vol-create-as --pool vmPool --name node3.img --capacity 300G --allocation 1G --format qcow2\\n', '打开 VNC 防火墙端口\\n', '方法一\\n', '\\n', '查询端口\\n', '\\n', '$ netstat -lntup | grep qemu-kvm\\n', '打开 VNC 的防火墙端口。假设端口从 5900 开始，参考命令如下：\\n', '\\n', '$ firewall-cmd --zone=public --add-port=5900/tcp\\n', '$ firewall-cmd --zone=public --add-port=5901/tcp\\n', '$ firewall-cmd --zone=public --add-port=5902/tcp\\n', '$ firewall-cmd --zone=public --add-port=5903/tcp\\n', '$ firewall-cmd --zone=public --add-port=5904/tcp\\n', '$ firewall-cmd --zone=public --add-port=5905/tcp\\n', '方法二\\n', '\\n', '直接关闭防火墙\\n', '\\n', '$ systemctl stop firewalld\\n', '准备虚拟机配置文件\\n', '创建虚拟机需要虚拟机配置文件。假设配置文件为 master.xml ，以虚拟机 hostname 为 k8smaster0 的节点为例，参考配置如下：\\n', '\\n', ' cat master.xml\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>k8smaster0</name>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    <vcpu>8</vcpu>\\n', '    <os>\\n', \"\\t<type arch='aarch64' machine='virt'>hvm</type>\\n\", \"\\t<loader readonly='yes' type='pflash'>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw</loader>\\n\", '\\t<nvram>/var/lib/libvirt/qemu/nvram/k8smaster0.fd</nvram>\\n', '    </os>\\n', '    <features>\\n', '\\t<acpi/>\\n', \"\\t<gic version='3'/>\\n\", '    </features>\\n', \"    <cpu mode='host-passthrough'>\\n\", \"        <topology sockets='2' cores='4' threads='1'/>\\n\", '    </cpu>\\n', '    <iothreads>1</iothreads>\\n', \"    <clock offset='utc'/>\\n\", '    <on_poweroff>destroy</on_poweroff>\\n', '    <on_reboot>restart</on_reboot>\\n', '    <on_crash>restart</on_crash>\\n', '    <devices>\\n', '\\t<emulator>/usr/libexec/qemu-kvm</emulator>\\n', \"\\t<disk type='file' device='disk'>\\n\", '\\t    <driver name=\\'qemu\\' type=\\'qcow2\\' iothread=\"1\"/>\\n', \"\\t    <source file='/mnt/vm/images/master0.img'/>\\n\", \"\\t    <target dev='vda' bus='virtio'/>\\n\", \"\\t    <boot order='1'/>\\n\", '\\t</disk>\\n', \"\\t<disk type='file' device='cdrom'>\\n\", \"\\t    <driver name='qemu' type='raw'/>\\n\", \"\\t    <source file='/mnt/openEuler-21.09-everything-aarch64-dvd.iso'/>\\n\", '\\t    <readonly/>\\n', \"\\t    <target dev='sdb' bus='scsi'/>\\n\", \"\\t    <boot order='2'/>\\n\", '\\t</disk>\\n', \"        <interface type='network'>\\n\", \"           <mac address='52:54:00:00:00:80'/>\\n\", \"           <source network='default'/>\\n\", \"           <model type='virtio'/>\\n\", '        </interface>\\n', \"\\t<console type='pty'/>\\n\", '        <video>\\n', \"           <model type='virtio'/>\\n\", '        </video>\\n', \"        <controller type='scsi' index='0' model='virtio-scsi'/>\\n\", \"\\t<controller type='usb' model='ehci'/>\\n\", \"\\t<input type='tablet' bus='usb'/>\\n\", \"\\t<input type='keyboard' bus='usb'/>\\n\", \"\\t<graphics type='vnc' listen='0.0.0.0'/>\\n\", '    </devices>\\n', \"    <seclabel type='dynamic' model='dac' relabel='yes'/>\\n\", '</domain>\\n', '由于虚拟机相关配置必须唯一，新增虚拟机需要适配修改如下内容，保证虚拟机的唯一性：\\n', '\\n', 'name：虚拟机 hostname，建议尽量小写。例中为 k8smaster0\\n', 'nvram：nvram的句柄文件路径，需要全局唯一。例中为 /var/lib/libvirt/qemu/nvram/k8smaster0.fd\\n', 'disk 的 source file：虚拟机磁盘文件路径。例中为 /mnt/vm/images/master0.img\\n', 'interface 的 mac address：interface 的 mac 地址。例中为 52:54:00:00:00:80\\n', '安装虚拟机\\n', '创建并启动虚拟机\\n', '\\n', '$ virsh define master.xml\\n', '$ virsh start k8smaster0\\n', '获取虚拟机的 VNC 端口号\\n', '\\n', '$ virsh vncdisplay k8smaster0\\n', '使用虚拟机链接工具，例如 VNC Viewer 远程链接虚拟机，并根据提示依次选择配置，完成系统安装\\n', '\\n', '设置虚拟机 hostname，例如设置为 k8smaster0\\n', '\\n', '$ hostnamectl set-hostname k8smaster0']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_安装、升级与卸载_安装与配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE.html", "text_entry": "['安装与配置\\n', '本章介绍iSulad的安装、安装后配置，以及升级和卸载的方法。\\n', '\\n', ' 说明： iSulad的安装、升级、卸载均需要使用root权限。\\n', '\\n', '安装与配置\\n', '安装方法\\n', '配置方法\\n', '安装方法\\n', 'iSulad可以通过yum或rpm命令两种方式安装，由于yum会自动安装依赖，而rpm命令需要手动安装所有依赖，所以推荐使用yum安装。\\n', '\\n', '这里给出两种安装方式的操作方法。\\n', '\\n', '（推荐）使用yum安装iSulad，参考命令如下：\\n', '\\n', '# sudo yum install -y iSulad\\n', '使用rpm安装iSulad，需要下载iSulad及其所有依赖库的RPM包，然后手动安装。安装单个iSulad的RPM包（依赖包安装方式相同），参考命令如下：\\n', '\\n', '# sudo rpm -ihv iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm\\n', '# isulad -l DEBUG\\n', '配置方法\\n', 'iSulad 安装完成后，可以根据需要进行相关配置。\\n', '\\n', '配置方式\\n', '轻量级容器引擎（iSulad）服务端daemon为isulad，isulad可以通过配置文件进行配置，也可以通过命令行的方式进行配置，例如：isulad –xxx，优先级从高到低是：命令行方式>配置文件>代码中默认配置。\\n', '\\n', ' 说明：\\n', '如果采用systemd管理iSulad进程，修改/etc/sysconfig/iSulad文件中的OPTIONS字段，等同于命令行方式进行配置。\\n', '\\n', '命令行方式\\n', '\\n', '在启动服务的时候，直接通过命令行进行配置。其配置选项可通过以下命令查阅：\\n', '\\n', '# isulad --help\\n', 'lightweight container runtime daemon\\n', '\\n', 'Usage:  isulad [global options]\\n', '\\n', 'GLOBAL OPTIONS:\\n', '\\n', '      --authorization-plugin            Use authorization plugin\\n', '      --cgroup-parent                   Set parent cgroup for all containers\\n', '      --cni-bin-dir                     The full path of the directory in which to search for CNI plugin binaries. Default: /opt/cni/bin\\n', '      --cni-conf-dir                    The full path of the directory in which to search for CNI config files. Default: /etc/cni/net.d\\n', '      --default-ulimit                  Default ulimits for containers (default [])\\n', '  -e, --engine                          Select backend engine\\n', '  -g, --graph                           Root directory of the iSulad runtime\\n', '  -G, --group                           Group for the unix socket(default is isulad)\\n', '      --help                            Show help\\n', '      --hook-spec                       Default hook spec file applied to all containers\\n', '  -H, --host                            The socket name used to create gRPC server\\n', '      --image-layer-check               Check layer intergrity when needed\\n', '      --image-opt-timeout               Max timeout(default 5m) for image operation\\n', '      --insecure-registry               Disable TLS verification for the given registry\\n', '      --insecure-skip-verify-enforce    Force to skip the insecure verify(default false)\\n', '      --log-driver                      Set daemon log driver, such as: file\\n', '  -l, --log-level                       Set log level, the levels can be: FATAL ALERT CRIT ERROR WARN NOTICE INFO DEBUG TRACE\\n', '      --log-opt                         Set daemon log driver options, such as: log-path=/tmp/logs/ to set directory where to store daemon logs\\n', '      --native.umask                    Default file mode creation mask (umask) for containers\\n', '      --network-plugin                  Set network plugin, default is null, suppport null and cni\\n', '  -p, --pidfile                         Save pid into this file\\n', '      --pod-sandbox-image               The image whose network/ipc namespaces containers in each pod will use. (default \"rnd-dockerhub.huawei.com/library/pause-${machine}:3.0\")\\n', '      --registry-mirrors                Registry to be prepended when pulling unqualified images, can be specified multiple times\\n', '      --start-timeout                   timeout duration for waiting on a container to start before it is killed\\n', '  -S, --state                           Root directory for execution state files\\n', '      --storage-driver                  Storage driver to use(default overlay2)\\n', '  -s, --storage-opt                     Storage driver options\\n', '      --tls                             Use TLS; implied by --tlsverify\\n', '      --tlscacert                       Trust certs signed only by this CA (default \"/root/.iSulad/ca.pem\")\\n', '      --tlscert                         Path to TLS certificate file (default \"/root/.iSulad/cert.pem\")\\n', '      --tlskey                          Path to TLS key file (default \"/root/.iSulad/key.pem\")\\n', '      --tlsverify                       Use TLS and verify the remote\\n', '      --use-decrypted-key               Use decrypted private key by default(default true)\\n', '  -V, --version                         Print the version\\n', '   --websocket-server-listening-port    CRI websocket streaming service listening port (default 10350)\\n', '示例： 启动isulad，并将日志级别调整成DEBUG\\n', '\\n', '# isulad -l DEBUG\\n', '配置文件方式\\n', '\\n', 'isulad配置文件为/etc/isulad/daemon.json，各配置字段说明如下：\\n', '\\n', '\\n', '配置参数\\n', '\\n', '配置文件示例\\n', '\\n', '参数解释\\n', '\\n', '备注\\n', '\\n', '-e, --engine\\n', '\\n', '\"engine\": \"lcr\"\\n', '\\n', 'iSulad的运行时，默认是lcr\\n', '\\n', '无\\n', '\\n', '-G, --group\\n', '\\n', '\"group\": \"isulad\"\\n', '\\n', 'socket所属组\\n', '\\n', '无\\n', '\\n', '--hook-spec\\n', '\\n', '\"hook-spec\": \"/etc/default/isulad/hooks/default.json\"\\n', '\\n', '针对所有容器的默认钩子配置文件\\n', '\\n', '无\\n', '\\n', '-H, --host\\n', '\\n', '\"hosts\": \"unix:///var/run/isulad.sock\"\\n', '\\n', '通信方式\\n', '\\n', '除本地socket外，还支持tcp://ip:port方式，port范围（0-65535，排除被占用端口）\\n', '\\n', '--log-driver\\n', '\\n', '\"log-driver\": \"file\"\\n', '\\n', '日志驱动配置\\n', '\\n', '无\\n', '\\n', '-l, --log-level\\n', '\\n', '\"log-level\": \"ERROR\"\\n', '\\n', '设置日志输出级别\\n', '\\n', '无\\n', '\\n', '--log-opt\\n', '\\n', '\"log-opts\": {\\n', '\\n', '\"log-file-mode\": \"0600\",\\n', '\\n', '\"log-path\": \"/var/lib/isulad\",\\n', '\\n', '\"max-file\": \"1\",\\n', '\\n', '\"max-size\": \"30KB\"\\n', '\\n', '}\\n', '\\n', '日志相关的配置\\n', '\\n', '可以指定max-file，max-size，log-path。max-file指日志文件个数；max-size指日志触发防爆的阈值，若max-file为1，max-size失效；log-path指定日志文件存储路径；log-file-mode用于设置日志文件的读写权限，格式要求必须为八进制格式，如0666。\\n', '\\n', '--start-timeout\\n', '\\n', '\"start-timeout\": \"2m\"\\n', '\\n', '启动容器的耗时\\n', '\\n', '无\\n', '\\n', '--runtime\\n', '\\n', '\"default-runtime\": \"lcr\"\\n', '\\n', '创建容器时的runtime运行时，默认是lcr\\n', '\\n', '当命令行和配置文件均未指定时，默认为lcr，runtime的三种指定方式优先级：命令行>配置文件>默认lcr，当前支持lcr、kata-runtime。\\n', '\\n', '无\\n', '\\n', '\"runtimes\":  {\\n', '    \"kata-runtime\": {\\n', '      \"path\": \"/usr/bin/kata-runtime\",\\n', '      \"runtime-args\": [\\n', '        \"--kata-config\",\\n', '        \"/usr/share/defaults/kata-containers/configuration.toml\"\\n', '      ]\\n', '    }\\n', '}\\n', '启动容器时，通过此字段指定多runtimes配置，在此集合中的元素均为有效的启动容器的runtime运行时。\\n', '\\n', '容器的runtime白名单，在此集合中的自定义runtime才是有效的。示例为以kata-runtime为例的配置。\\n', '\\n', '-p, --pidfile\\n', '\\n', '\"pidfile\": \"/var/run/isulad.pid\"\\n', '\\n', '保存pid的文件\\n', '\\n', '当启动一个容器引擎的时候不需要配置，当需要启动两个以上的容器引擎时才需要配置。\\n', '\\n', '-g, --graph\\n', '\\n', '\"graph\": \"/var/lib/isulad\"\\n', '\\n', 'iSulad运行时的根目录\\n', '\\n', '-S, --state\\n', '\\n', '\"state\": \"/var/run/isulad\"\\n', '\\n', '执行文件的根目录\\n', '\\n', '--storage-driver\\n', '\\n', '\"storage-driver\": \"overlay2\"\\n', '\\n', '镜像存储驱动，默认为overlay2\\n', '\\n', '当前只支持overlay2\\n', '\\n', '-s, --storage-opt\\n', '\\n', '\"storage-opts\": [ \"overlay2.override_kernel_check=true\" ]\\n', '\\n', '镜像存储驱动配置选项\\n', '\\n', '可使用的选项为：\\n', '\\n', 'overlay2.override_kernel_check=true # 忽略内核版本检查\\n', 'overlay2.size=${size} # 设置rootfs quota限额为${size}大小\\n', 'overlay2.basesize=${size} #等价于overlay2.size\\n', '--image-opt-timeout\\n', '\\n', '\"image-opt-timeout\": \"5m\"\\n', '\\n', '镜像操作超时时间，默认为5m\\n', '\\n', '值为-1表示不限制超时。\\n', '\\n', '--registry-mirrors\\n', '\\n', '\"registry-mirrors\": [ \"docker.io\" ]\\n', '\\n', '镜像仓库地址\\n', '\\n', '无\\n', '\\n', '--insecure-registry\\n', '\\n', '\"insecure-registries\": [ ]\\n', '\\n', '不使用TLS校验的镜像仓库\\n', '\\n', '无\\n', '\\n', '--native.umask\\n', '\\n', '\"native.umask\": \"secure\"\\n', '\\n', '容器umask策略，默认\"secure\"，normal为不安全配置\\n', '\\n', '设置容器umask值。\\n', '\\n', '支持配置空字符（使用默认值0027）、\"normal\"、\"secure\"：\\n', '\\n', 'normal    # 启动的容器umask值为0022\\n', 'secure    # 启动的容器umask值为0027（默认值）\\n', '--pod-sandbox-image\\n', '\\n', '\"pod-sandbox-image\": \"rnd-dockerhub.huawei.com/library/pause-aarch64:3.0\"\\n', '\\n', 'pod默认使用镜像，默认为\"rnd-dockerhub.huawei.com/library/pause-${machine}:3.0\"\\n', '\\n', '无\\n', '\\n', '--network-plugin\\n', '\\n', '\"network-plugin\": \"\"\\n', '\\n', '指定网络插件，默认为空字符，表示无网络配置，创建的sandbox只有loop网卡。\\n', '\\n', '支持cni和空字符，其他非法值会导致isulad启动失败。\\n', '\\n', '--cni-bin-dir\\n', '\\n', '\"cni-bin-dir\": \"\"\\n', '\\n', '指定cni插件依赖的二进制的存储位置\\n', '\\n', '默认为/opt/cni/bin\\n', '\\n', '--cni-conf-dir\\n', '\\n', '\"cni-conf-dir\": \"\"\\n', '\\n', '指定cni网络配置文件的存储位置\\n', '\\n', '默认为/etc/cni/net.d\\n', '\\n', '--image-layer-check=false\\n', '\\n', '\"image-layer-check\": false\\n', '\\n', '开启镜像层完整性检查功能，设置为true；关闭该功能，设置为false。默认为关闭。\\n', '\\n', 'isulad启动时会检查镜像层的完整性，如果镜像层被破坏，则相关的镜像不可用。isulad进行镜像完整性校验时，无法校验内容为空的文件和目录，以及链接文件。因此若镜像因掉电导致上述类型文件丢失，isulad的镜像数据完整性校验可能无法识别。isulad版本变更时需要检查是否支持该参数，如果不支持，需要从配置文件中删除。\\n', '\\n', '--insecure-skip-verify-enforce=false\\n', '\\n', '\"insecure-skip-verify-enforce\": false\\n', '\\n', 'Bool类型，是否强制跳过证书的主机名/域名验证，默认为false。当设置为true时，为不安全配置，会跳过证书的主机名/域名验证\\n', '\\n', '默认为false（不跳过），注意：因isulad使用的yajl json 解析库限制，若在/etc/isulad/daemon.json配置文件中配置非Bool类型的其他符合json格式的值时，isulad将使用默认值false。\\n', '\\n', '--use-decrypted-key=true\\n', '\\n', '\"use-decrypted-key\": true\\n', '\\n', 'Bool类型，指定是否使用不加密的私钥。指定为true，表示使用不加密的私钥；指定为false，表示使用的为加密后的私钥，即需要进行双向认证。\\n', '\\n', '默认配置为true(使用不加密的私钥)，注意：因isulad使用的yajl json 解析库限制，若在/etc/isulad/daemon.json配置文件中配置非Bool类型的其他符合json格式的值时，isulad将使用默认值true。\\n', '\\n', '--tls\\n', '\\n', '\"tls\":false\\n', '\\n', 'Bool类型，是否使用TLS\\n', '\\n', '默认值为false， 仅用于-H tcp://IP:PORT方式\\n', '\\n', '--tlsverify\\n', '\\n', '\"tlsverify\":false\\n', '\\n', 'Bool类型，是否使用TLS，并验证远程访问\\n', '\\n', '仅用于-H tcp://IP:PORT方式\\n', '\\n', '--tlscacert\\n', '\\n', '--tlscert\\n', '\\n', '--tlskey\\n', '\\n', '\"tls-config\": {\\n', '\\n', '\"CAFile\": \"/root/.iSulad/ca.pem\",\\n', '\\n', '\"CertFile\": \"/root/.iSulad/server-cert.pem\",\\n', '\\n', '\"KeyFile\":\"/root/.iSulad/server-key.pem\"\\n', '\\n', '}\\n', '\\n', 'TLS证书相关的配置\\n', '\\n', '仅用于-H tcp://IP:PORT方式\\n', '\\n', '--authorization-plugin\\n', '\\n', '\"authorization-plugin\": \"authz-broker\"\\n', '\\n', '用户权限认证插件\\n', '\\n', '当前只支持authz-broker\\n', '\\n', '--cgroup-parent\\n', '\\n', '\"cgroup-parent\": \"lxc/mycgroup\"\\n', '\\n', '字符串类型，容器默认cgroup父路径\\n', '\\n', '指定daemon端容器默认的cgroup父路径，如果客户端指定了--cgroup-parent，以客户端参数为准。\\n', '\\n', '注意：如果启了一个容器A，然后启一个容器B，容器B的cgroup父路径指定为容器A的cgroup路径，在删除容器的时候需要先删除容器B再删除容器A，否则会导致cgroup资源残留。\\n', '\\n', '--default-ulimits\\n', '\\n', '\"default-ulimits\": {\\n', '\\n', '\"nofile\": {\\n', '\\n', '\"Name\": \"nofile\",\\n', '\\n', '\"Hard\": 6400,\\n', '\\n', '\"Soft\": 3200\\n', '\\n', '}\\n', '\\n', '}\\n', '\\n', 'ulimit指定限制的类型，soft值及hard值\\n', '\\n', \"指定限制的资源类型，如“nofile”。两个字段名字必须相同，即都为nofile，否则会报错。Hard指定的值需要大于等于Soft'。如果Hard字段或者Soft字段未设置，则默认该字段默认为0。\\n\", '\\n', '--websocket-server-listening-port\\n', '\\n', '\"websocket-server-listening-port\": 10350\\n', '\\n', '设置CRI websocket流式服务侦听端口，默认端口号10350\\n', '\\n', '指定CRI websocket流式服务侦听端，如果客户端指定了\\n', '\\n', '--websocket-server-listening-port，以客户端参数为准。端口范围1024-49151\\n', '\\n', '示例：\\n', '\\n', '# cat /etc/isulad/daemon.json\\n', '{\\n', '    \"group\": \"isulad\",\\n', '    \"default-runtime\": \"lcr\",\\n', '    \"graph\": \"/var/lib/isulad\",\\n', '    \"state\": \"/var/run/isulad\",\\n', '    \"engine\": \"lcr\",\\n', '    \"log-level\": \"ERROR\",\\n', '    \"pidfile\": \"/var/run/isulad.pid\",\\n', '    \"log-opts\": {\\n', '        \"log-file-mode\": \"0600\",\\n', '        \"log-path\": \"/var/lib/isulad\",\\n', '        \"max-file\": \"1\",\\n', '        \"max-size\": \"30KB\"\\n', '    },\\n', '    \"log-driver\": \"stdout\",\\n', '    \"hook-spec\": \"/etc/default/isulad/hooks/default.json\",\\n', '    \"start-timeout\": \"2m\",\\n', '    \"storage-driver\": \"overlay2\",\\n', '    \"storage-opts\": [\\n', '        \"overlay2.override_kernel_check=true\"\\n', '    ],\\n', '    \"registry-mirrors\": [\\n', '        \"docker.io\"\\n', '    ],\\n', '    \"insecure-registries\": [\\n', '        \"rnd-dockerhub.huawei.com\"\\n', '    ],\\n', '    \"pod-sandbox-image\": \"\",\\n', '    \"image-opt-timeout\": \"5m\",\\n', '    \"native.umask\": \"secure\",\\n', '    \"network-plugin\": \"\",\\n', '    \"cni-bin-dir\": \"\",\\n', '    \"cni-conf-dir\": \"\",\\n', '    \"image-layer-check\": false,\\n', '    \"use-decrypted-key\": true,\\n', '    \"insecure-skip-verify-enforce\": false\\n', '}\\n', ' 须知：\\n', '默认配置文件/etc/isulad/daemon.json仅供参考，请根据实际需要进行配置\\n', '\\n', '存储说明\\n', '\\n', '文件名\\n', '\\n', '文件路径\\n', '\\n', '内容\\n', '\\n', '\\\\*\\n', '\\n', '/etc/default/isulad/\\n', '\\n', '存放isulad的OCI配置文件和钩子模板文件，文件夹下的配置文件权限设置为0640，sysmonitor检查脚本权限为0550\\n', '\\n', '\\\\*\\n', '\\n', '/etc/isulad/\\n', '\\n', 'isulad的默认配置文件和seccomp的默认配置文件\\n', '\\n', 'isulad.sock\\n', '\\n', '/var/run/\\n', '\\n', '管道通信文件，客户端和isulad的通信使用的socket文件\\n', '\\n', 'isulad.pid\\n', '\\n', '/var/run/\\n', '\\n', '存放isulad的PID，同时也是一个文件锁防止启动多个isulad实例\\n', '\\n', '\\\\*\\n', '\\n', '/run/lxc/\\n', '\\n', '文件锁文件，isula运行过程创建的文件\\n', '\\n', '\\\\*\\n', '\\n', '/var/run/isulad/\\n', '\\n', '实时通讯缓存文件，isulad运行过程创建的文件\\n', '\\n', '\\\\*\\n', '\\n', '/var/run/isula/\\n', '\\n', '实时通讯缓存文件，isula运行过程创建的文件\\n', '\\n', '\\\\*\\n', '\\n', '/var/lib/lcr/\\n', '\\n', 'LCR 组件临时目录\\n', '\\n', '\\\\*\\n', '\\n', '/var/lib/isulad/\\n', '\\n', 'isulad运行的根目录，存放创建的容器配置、日志的默认路径、数据库文件、mount点等\\n', '\\n', '/var/lib/isulad/mnt/ ：容器rootfs的mount点\\n', '\\n', '/var/lib/isulad/engines/lcr/ ：存放lcr容器配置目录，每个容器一个目录（以容器名命名）\\n', '\\n', '约束限制\\n', '高并发场景（并发启动200容器）下，glibc的内存管理机制会导致内存空洞以及虚拟内存较大（例如10GB）的问题。该问题是高并发场景下glibc内存管理机制的限制，而不是内存泄露，不会导致内存消耗无限增大。可以通过设置MALLOC_ARENA_MAX环境变量来减少虚拟内存的问题，而且可以增大减少物理内存的概率。但是这个环境变量会导致iSulad的并发性能下降，需要用户根据实际情况做配置。\\n', '\\n', '参考实践情况，平衡性能和内存，可以设置MALLOC_ARENA_MAX为4。（在arm64服务器上面对iSulad的性能影响在10%以内）\\n', '\\n', '配置方法：\\n', '1. 手动启动iSulad的场景，可以直接export MALLOC_ARENA_MAX=4，然后再启动iSulad即可。\\n', '2. systemd管理iSulad的场景，可以修改/etc/sysconfig/iSulad，增加一条MALLOC_ARENA_MAX=4即可。\\n', '为daemon指定各种运行目录时的注意事项\\n', '\\n', '以–root为例，当使用/new/path/作为daemon新的Root Dir时，如果/new/path/下已经存在文件，且目录或文件名与isulad需要使用的目录或文件名冲突（例如：engines、mnt等目录）时，isulad可能会更新原有目录或文件的属性，包括属主、权限等为自己的属主和权限。\\n', '\\n', '所以，用户需要明白重新指定各种运行目录和文件，会对冲突目录、文件属性的影响。建议用户指定的新目录或文件为isulad专用，避免冲突导致的文件属性变化以及带来的安全问题。\\n', '\\n', '日志文件管理：\\n', '\\n', ' 须知：\\n', '日志功能对接： iSulad由systemd管理，日志也由systemd管理，然后传输给rsyslogd。rsyslog默认会对写日志速度有限制，可以通过修改/etc/rsyslog.conf文件，增加\"$imjournalRatelimitInterval 0\"配置项，然后重启rsyslogd的服务即可。\\n', '\\n', '命令行参数解析限制\\n', '\\n', \"使用iSulad命令行接口时，其参数解析方式与docker略有不同，对于命令行中带参数的flag，不管使用长flag还是短flag，只会将该flag后第一个空格或与flag直接相连接的'='后的字符串作为flag的参数，具体如下：\\n\", '\\n', '使用短flag时，与“-”连接的字符串中的每个字符都被当作短flag（当有=号时，=号后的字符串当成=号前的短flag的参数）。\\n', '\\n', 'isula run -du=root busybox 等价于 isula run -du root busybox 或 isula run -d -u=root busybox 或 isula run -d -u root busybox ，当使用isula run -du:root时，由于-:不是有效的短flag，因此会报错。前述的命令行也等价于isula run -ud root busybox，但不推荐这种使用方式，可能带来语义困扰。\\n', '\\n', '使用长flag时，与“–”连接的字符串作为一个整体当成长flag，若包含=号，则=号前的字符串为长flag，=号后的为参数。\\n', '\\n', 'isula run --user=root busybox\\n', '等价于\\n', '\\n', 'isula run --user root busybox\\n', '启动一个isulad容器，不能够以非root用户进行isula run -i/-t/-ti以及isula attach/exec操作。\\n', '\\n', 'iSulad对接OCI容器时，仅支持kata-runtime启动OCI容器。\\n', '\\n', 'DAEMON多端口的绑定\\n', '描述\\n', 'daemon端可以绑定多个unix socket或者tcp端口，并在这些端口上侦听，客户端可以通过这些端口和daemon端进行交互。\\n', '\\n', '接口\\n', '用户可以在/etc/isulad/daemon.json文件的hosts字段配置一个或者多个端口。当然用户也可以不指定hosts。\\n', '\\n', '{\\n', '    \"hosts\": [\\n', '        \"unix:///var/run/isulad.sock\",\\n', '        \"tcp://localhost:5678\",\\n', '        \"tcp://127.0.0.1:6789\"\\n', '    ]\\n', '}\\n', '用户也可以在/etc/sysconfig/iSulad中通过-H或者–host配置端口。用户同样可以不指定hosts。\\n', '\\n', \"OPTIONS='-H unix:///var/run/isulad.sock --host tcp://127.0.0.1:6789'\\n\", '如果用户在daemon.json文件及iSulad中均未指定hosts，则daemon在启动之后将默认侦听unix:///var/run/isulad.sock。\\n', '\\n', '限制\\n', '用户不可以在/etc/isulad/daemon.json和/etc/sysconfig/iSuald两个文件中同时指定hosts，如果这样做将会出现错误，isulad无法正常启动；\\n', '\\n', 'unable to configure the isulad with file /etc/isulad/daemon.json: the following directives are specified both as a flag and in the configuration file: hosts: (from flag: [unix:///var/run/isulad.sock tcp://127.0.0.1:6789], from file: [unix:///var/run/isulad.sock tcp://localhost:5678 tcp://127.0.0.1:6789])\\n', '若指定的host是unix socket，则必须是合法的unix socket，需要以\"unix://“开头，后跟合法的socket绝对路径；\\n', '\\n', '若指定的host是tcp端口，则必须是合法的tcp端口，需要以\"tcp://“开头，后跟合法的IP地址和端口，IP地址可以为localhost；\\n', '\\n', '可以指定至多10个有效的端口，超过10个则会出现错误，isulad无法正常启动。\\n', '\\n', '配置TLS认证与开启远程访问\\n', '描述\\n', 'iSulad采用C/S模式进行设计，在默认情况，iSulad守护进程isulad只侦听本地/var/run/isulad.sock，因此只能在本地通过客户端isula执行相关命令操作容器。为了能使isula可以远程访问容器，isulad守护进程需要通过tcp:ip的方式侦听远程访问的端口。然而，仅通过简单配置tcp ip:port进行侦听，这样会导致所有的ip都可以通过调用isula -H tcp://<remote server ip>:port与isulad通信，容易导致安全问题，因此推荐使用较安全版本的TLS(Transport Layer Security - 安全传输层协议）方式进行远程访问。\\n', '\\n', '生成TLS证书\\n', '明文私钥和证书生成方法示例\\n', '\\n', '#!/bin/bash\\n', 'set -e\\n', 'echo -n \"Enter pass phrase:\"\\n', 'read password\\n', 'echo -n \"Enter public network ip:\"\\n', 'read publicip\\n', 'echo -n \"Enter host:\"\\n', 'read HOST\\n', '\\n', 'echo \" => Using hostname: $publicip, You MUST connect to iSulad using this host!\"\\n', '\\n', 'mkdir -p $HOME/.iSulad\\n', 'cd $HOME/.iSulad\\n', 'rm -rf $HOME/.iSulad/*\\n', '\\n', 'echo \" => Generating CA key\"\\n', 'openssl genrsa -passout pass:$password -aes256 -out ca-key.pem 4096\\n', 'echo \" => Generating CA certificate\"\\n', 'openssl req -passin pass:$password -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem -subj \"/C=CN/ST=zhejiang/L=hangzhou/O=Huawei/OU=iSulad/CN=iSulad@huawei.com\"\\n', 'echo \" => Generating server key\"\\n', 'openssl genrsa -passout pass:$password -out server-key.pem 4096\\n', 'echo \" => Generating server CSR\"\\n', 'openssl req -passin pass:$password -subj /CN=$HOST -sha256 -new -key server-key.pem -out server.csr\\n', 'echo subjectAltName = DNS:$HOST,IP:$publicip,IP:127.0.0.1 >> extfile.cnf\\n', 'echo extendedKeyUsage = serverAuth >> extfile.cnf\\n', 'echo \" => Signing server CSR with CA\"\\n', 'openssl x509 -req -passin pass:$password -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out server-cert.pem -extfile extfile.cnf\\n', 'echo \" => Generating client key\"\\n', 'openssl genrsa -passout pass:$password -out key.pem 4096\\n', 'echo \" => Generating client CSR\"\\n', \"openssl req -passin pass:$password -subj '/CN=client' -new -key key.pem -out client.csr\\n\", 'echo \" => Creating extended key usage\"\\n', 'echo extendedKeyUsage = clientAuth > extfile-client.cnf\\n', 'echo \" => Signing client CSR with CA\"\\n', 'openssl x509 -req -passin pass:$password -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out cert.pem -extfile extfile-client.cnf\\n', 'rm -v client.csr server.csr extfile.cnf extfile-client.cnf\\n', 'chmod -v 0400 ca-key.pem key.pem server-key.pem\\n', 'chmod -v 0444 ca.pem server-cert.pem cert.pem\\n', '加密私钥和证书请求文件生成方法示例\\n', '\\n', '#!/bin/bash\\n', '\\n', 'echo -n \"Enter public network ip:\"\\n', 'read publicip\\n', 'echo -n \"Enter pass phrase:\"\\n', 'read password\\n', '\\n', '# remove certificates from previous execution.\\n', 'rm -f *.pem *.srl *.csr *.cnf\\n', '\\n', '\\n', '# generate CA private and public keys\\n', 'echo 01 > ca.srl\\n', 'openssl genrsa -aes256 -out ca-key.pem -passout pass:$password 2048\\n', \"openssl req -subj '/C=CN/ST=zhejiang/L=hangzhou/O=Huawei/OU=iSulad/CN=iSulad@huawei.com' -new -x509 -days $DAYS -passin pass:$password -key ca-key.pem -out ca.pem\\n\", '\\n', '# create a server key and certificate signing request (CSR)\\n', 'openssl genrsa -aes256 -out server-key.pem -passout pass:$PASS 2048\\n', \"openssl req -new -key server-key.pem -out server.csr -passin pass:$password -subj '/CN=iSulad'\\n\", '\\n', 'echo subjectAltName = DNS:iSulad,IP:${publicip},IP:127.0.0.1 > extfile.cnf\\n', 'echo extendedKeyUsage = serverAuth >> extfile.cnf\\n', '# sign the server key with our CA\\n', 'openssl x509 -req -days $DAYS -passin pass:$password -in server.csr -CA ca.pem -CAkey ca-key.pem -out server-cert.pem -extfile extfile.cnf\\n', '\\n', '# create a client key and certificate signing request (CSR)\\n', 'openssl genrsa -aes256 -out key.pem -passout pass:$password 2048\\n', \"openssl req -subj '/CN=client' -new -key key.pem -out client.csr -passin pass:$password\\n\", '\\n', '# create an extensions config file and sign\\n', 'echo extendedKeyUsage = clientAuth > extfile.cnf\\n', 'openssl x509 -req -days 365 -passin pass:$password -in client.csr -CA ca.pem -CAkey ca-key.pem -out cert.pem -extfile extfile.cnf\\n', '\\n', '# remove the passphrase from the client and server key\\n', 'openssl rsa -in server-key.pem -out server-key.pem -passin pass:$password\\n', 'openssl rsa -in key.pem -out key.pem -passin pass:$password\\n', '\\n', '# remove generated files that are no longer required\\n', 'rm -f ca-key.pem ca.srl client.csr extfile.cnf server.csr\\n', '接口\\n', '{\\n', '    \"tls\": true,\\n', '    \"tls-verify\": true,\\n', '    \"tls-config\": {\\n', '\\t\\t\"CAFile\": \"/root/.iSulad/ca.pem\",\\n', '\\t\\t\"CertFile\": \"/root/.iSulad/server-cert.pem\",\\n', '\\t\\t\"KeyFile\":\"/root/.iSulad/server-key.pem\"\\n', '    }\\n', '}\\n', '限制\\n', '服务端支持的模式如下：\\n', '\\n', '模式1（验证客户端）：tlsverify, tlscacert, tlscert, tlskey。\\n', '模式2（不验证客户端）：tls, tlscert, tlskey。\\n', '客户端支持的模式如下:\\n', '\\n', '模式1(使用客户端证书进行身份验证，并根据给定的CA验证服务器)：tlsverify, tlscacert, tlscert, tlskey。\\n', '模式2(验证服务器)：tlsverify, tlscacert。\\n', '如果需要采用双向认证方式进行通讯，则服务端采用模式1，客户端采用模式1；\\n', '\\n', '如果需要采用单向认证方式进行通讯，则服务端采用模式2，客户端采用模式2。\\n', '\\n', ' 须知：\\n', '\\n', '采用RPM安装方式时，服务端配置可通过/etc/isulad/daemon.json以及/etc/sysconfig/iSulad配置修改\\n', '相比非认证或者单向认证方式，双向认证具备更高的安全性，推荐使用双向认证的方式进行通讯\\n', 'GRPC开源组件日志不由iSulad进行接管，如果需要查看GRPC相关日志，请按需设置GRPC_VERBOSITY和GRPC_TRACE环境变量\\n', '  \\n', '示例\\n', '服务端：\\n', '\\n', ' isulad -H=tcp://0.0.0.0:2376 --tlsverify --tlscacert ~/.iSulad/ca.pem --tlscert ~/.iSulad/server-cert.pem --tlskey ~/.iSulad/server-key.pem\\n', '客户端：\\n', '\\n', ' isula version -H=tcp://$HOSTIP:2376 --tlsverify --tlscacert ~/.iSulad/ca.pem --tlscert ~/.iSulad/cert.pem --tlskey ~/.iSulad/key.pem\\n', '配置devicemapper存储驱动\\n', '使用devicemapper存储驱动需要先配置一个thinpool设备，而配置thinpool需要一个独立的块设备，且该设备需要有足够的空闲空间用于创建thinpool，请用户根据实际需求确定。这里假设独立块设备为/dev/xvdf，具体的配置方法如下：\\n', '\\n', '一、配置thinpool\\n', '\\n', '停止isulad服务。\\n', '\\n', '# systemctl stop isulad\\n', '基于块设备创建一个lvm卷。\\n', '\\n', '# pvcreate /dev/xvdf\\n', '使用刚才创建的物理卷创建一个卷组。\\n', '\\n', '# vgcreate isula /dev/xvdf\\n', 'Volume group \"isula\" successfully created：\\n', '创建名为thinpool和thinpoolmeta的两个逻辑卷。\\n', '\\n', '# lvcreate --wipesignatures y -n thinpool isula -l 95%VG\\n', 'Logical volume \"thinpool\" created.\\n', '# lvcreate --wipesignatures y -n thinpoolmeta isula -l 1%VG\\n', 'Logical volume \"thinpoolmeta\" created.\\n', '将新创建的两个逻辑卷转换成thinpool以及thinpool所使用的metadata，这样就完成了thinpool配置。\\n', '\\n', '# lvconvert -y --zero n -c 512K --thinpool isula/thinpool --poolmetadata isula/thinpoolmeta\\n', '\\n', 'WARNING: Converting logical volume isula/thinpool and isula/thinpoolmeta to\\n', \"thin pool's data and metadata volumes with metadata wiping.\\n\", 'THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.)\\n', 'Converted isula/thinpool to thin pool.\\n', '  \\n', '\\n', '二、修改isulad配置文件\\n', '\\n', '如果环境之前运行过isulad，请先备份之前的数据。\\n', '\\n', '# mkdir /var/lib/isulad.bk\\n', '# mv /var/lib/isulad/* /var/lib/isulad.bk\\n', '修改配置文件\\n', '\\n', '这里提供了两种配置方式，用户可根据实际情况的选择合适的方式。\\n', '\\n', '编辑/etc/isulad/daemon.json，配置storage-driver字段值为devicemapper，并配置storage-opts字段的相关参数，支持参数请参见参数说明。配置参考如下所示：\\n', '\\n', '{\\n', '    \"storage-driver\": \"devicemapper\"\\n', '    \"storage-opts\": [\\n', '        \"dm.thinpooldev=/dev/mapper/isula-thinpool\",\\n', '        \"dm.fs=ext4\",\\n', '            \"dm.min_free_space=10%\"\\n', '    ]\\n', '}\\n', '或者也可以通过编辑/etc/sysconfig/iSulad，在isulad启动参数里显式指定，支持参数请参见参数说明。配置参考如下所示：\\n', '\\n', 'OPTIONS=\"--storage-driver=devicemapper --storage-opt dm.thinpooldev=/dev/mapper/isula-thinpool --storage-opt dm.fs=ext4 --storage-opt dm.min_free_space=10%\"\\n', '启动isulad，使配置生效。\\n', '\\n', '# systemctl start isulad\\n', '参数说明\\n', 'storage-opts 支持的参数请参见表1。\\n', '\\n', '表 1 starage-opts字段参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '是否必选\\n', '\\n', '含义\\n', '\\n', 'dm.fs\\n', '\\n', '是\\n', '\\n', '用于指定容器使用的文件系统类型。当前必须配置为ext4，即dm.fs=ext4\\n', '\\n', 'dm.basesize\\n', '\\n', '否\\n', '\\n', '用于指定单个容器的最大存储空间大小，单位为k/m/g/t/p，也可以使用大写字母，例如dm.basesize=50G。该参数只在首次初始化时有效。\\n', '\\n', 'dm.mkfsarg\\n', '\\n', '否\\n', '\\n', '用于在创建基础设备时指定额外的mkfs参数。例如“dm.mkfsarg=-O ^has_journal”\\n', '\\n', 'dm.mountopt\\n', '\\n', '否\\n', '\\n', '用于在挂载容器时指定额外的mount参数。例如dm.mountopt=nodiscard\\n', '\\n', 'dm.thinpooldev\\n', '\\n', '否\\n', '\\n', '用于指定容器/镜像存储时使用的thinpool设备。\\n', '\\n', 'dm.min_free_space\\n', '\\n', '否\\n', '\\n', '用于指定最小的预留空间，用百分比表示。例如dm.min_free_space=10%，表示当剩余存储空间只剩10%左右时，创建容器等和存储相关操作就会失败。\\n', '\\n', '注意事项\\n', '配置devicemapper时，如果系统上没有足够的空间给thinpool做自动扩容，请禁止自动扩容功能。\\n', '\\n', '禁止自动扩容的方法是把/etc/lvm/profile/isula-thinpool.profile中thin_pool_autoextend_threshold和thin_pool_autoextend_percent两个值都改成100，如下所示：\\n', '\\n', 'activation {   \\n', '  thin_pool_autoextend_threshold=100   \\n', '  thin_pool_autoextend_percent=100 \\n', '}\\n', '使用devicemapper时，容器文件系统必须配置为ext4，需要在isulad的配置参数中加上–storage-opt dm.fs=ext4。\\n', '\\n', '当graphdriver为devicemapper时，如果metadata文件损坏且不可恢复，需要人工介入恢复。禁止直接操作或篡改daemon存储devicemapper的元数据。\\n', '\\n', '使用devicemapper lvm时，异常掉电导致的devicemapper thinpool损坏，无法保证thinpool损坏后可以修复，也不能保证数据的完整性，需重建thinpool。\\n', '\\n', 'iSula开启了user namespace特性，切换devicemapper存储池时的注意事项\\n', '\\n', '一般启动容器时，deviceset-metadata文件为：/var/lib/isulad/devicemapper/metadata/deviceset-metadata。\\n', '使用了user namespace场景下，deviceset-metadata文件使用的是：/var/lib/isulad/{userNSUID.GID}/devicemapper/metadata/deviceset-metadata。\\n', '使用devicemapper存储驱动，容器在user namespace场景和普通场景之间切换时，需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空；针对thinpool扩容或者重建的场景下，也同样的需要将对应deviceset-metadata文件中的BaseDeviceUUID内容清空，否则isulad服务会重启失败。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_虚拟机管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86.html", "text_entry": "['管理虚拟机\\n', '概述\\n', 'StratoVirt可以查询虚拟机信息并对虚拟机的资源和生命周期进行管理。由于StratoVirt使用QMP管理虚拟机，所以查询虚拟机信息，也需要先连接到虚拟机。\\n', '\\n', '查询虚拟机信息\\n', '简介：\\n', 'StratoVirt可以查询虚拟机状态、vCPU拓扑信息、vCPU上线情况等。\\n', '\\n', '查询状态\\n', '使用query-status命令查询虚拟机的运行状态。\\n', '\\n', '用法：\\n', '\\n', '{ “execute”: “query-status” }\\n', '\\n', '示例：\\n', '\\n', '<- { \"execute\": \"query-status\" }\\n', '-> { \"return\": { \"running\": true,\"singlestep\": false,\"status\": \"running\" } \\n', '查询拓扑\\n', '使用query-cpus命令查询所有CPU的拓扑结构。\\n', '\\n', '用法：\\n', '{ “execute”: “query-cpus” }\\n', '\\n', '示例：\\n', '<- { \"execute\": \"query-cpus\" }\\n', '-> {\"return\":[{\"CPU\":0,\"arch\":\"x86\",\"current\":true,\"halted\":false,\"props\":{\"core-id\":0,\"socket-id\":0,\"thread-id\":0},\"qom_path\":\"/machine/unattached/device[0]\",\"thread_id\":8439},{\"CPU\":1,\"arch\":\"x86\",\"current\":true,\"halted\":false,\"props\":{\"core-id\":0,\"socket-id\":1,\"thread-id\":0},\"qom_path\":\"/machine/unattached/device[1]\",\"thread_id\":8440}]}\\n', '查询vCPU上线情况\\n', '使用query-hotpluggable-cpus命令查询所有vCPU的online/offline情况。\\n', '\\n', '用法：\\n', '{ “execute”: “query-hotpluggable-cpus” }\\n', '\\n', '示例：\\n', '<- { \"execute\": \"query-hotpluggable-cpus\" }\\n', '-> {\"return\":[{\"props\":{\"core-id\":0,\"socket-id\":0,\"thread-id\":0},\"qom-path\":\"/machine/unattached/device[0]\",\"type\":\"host-x86-cpu\",\"vcpus-count\":1},{\"props\":{\"core-id\":0,\"socket-id\":1,\"thread-id\":0},\"qom-path\":\"/machine/unattached/device[1]\",\"type\":\"host-x86-cpu\",\"vcpus-count\":1}]}\\n', '其中，online的vCPU具有qom-path项，offline的vCPU则没有。\\n', '\\n', '管理虚拟机生命周期\\n', '简介\\n', 'StratoVirt可以对虚拟机进行启动、暂停、恢复、退出等生命周期进行管理。\\n', '\\n', '创建并启动虚拟机\\n', '通过命令行参数指定虚拟机配置，创建并启动虚拟机。\\n', '\\n', '使用命令行参数给出虚拟机配置，创建并启动虚拟机的命令如下：\\n', '$ /path/to/stratovirt -[参数1] [参数选项] -[参数2] [参数选项] ...\\n', '说明：\\n', '\\n', '轻量虚拟启动后，内部会有eth0和eth1两张网卡。这两张网卡预留用于网卡热插拔。热插的第一张网卡是eth0，热插的第二张网卡是eth1，目前只支持热插两张virtio-net网卡。\\n', '\\n', '连接虚拟机\\n', 'StratoVirt当前采用QMP管理虚拟机，暂停、恢复、退出虚拟机等操作需要通过QMP连接到虚拟机进行管理。\\n', '\\n', '在主机上打开新的命令行窗口B，并使用root权限进行api-channel连接，参考命令如下：\\n', '\\n', '# ncat -U /path/to/socket\\n', '连接建立后，会收到来自StratoVirt的问候消息，如下所示：\\n', '\\n', '{\"QMP\":{\"version\":{\"qemu\":{\"micro\":1,\"minor\":0,\"major\":4},\"package\":\"\"},\"capabilities\":[]}}\\n', '现在，可以在窗口B中输入QMP命令来管理虚拟机。\\n', '\\n', '说明：\\n', '\\n', 'QMP提供了stop、cont、quit和query-status等来管理和查询虚拟机状态。\\n', '\\n', '管理虚拟机的QMP命令均在窗口B中进行输入。符号：<-表示命令输入，->表示QMP结果返回。\\n', '\\n', '暂停虚拟机\\n', 'QMP提供了stop命令用于暂停虚拟机，即暂停虚拟机所有的vCPU。命令格式如下：\\n', '\\n', '{“execute”:“stop”}\\n', '\\n', '示例：\\n', '\\n', '使用stop暂停该虚拟机的命令和回显如下：\\n', '\\n', '<- {\"execute\":\"stop\"}\\n', '-> {\"event\":\"STOP\",\"data\":{},\"timestamp\":{\"seconds\":1583908726,\"microseconds\":162739}}\\n', '-> {\"return\":{}}\\n', '恢复虚拟机\\n', 'QMP提供了cont命令用于恢复处于暂停状态suspend的虚拟机，即恢复虚拟机所有vCPU的运行。命令格式如下：\\n', '\\n', '{“execute”:“cont”}\\n', '\\n', '示例：\\n', '\\n', '使用cont恢复该虚拟机的命令和回显如下：\\n', '\\n', '<- {\"execute\":\"cont\"}\\n', '-> {\"event\":\"RESUME\",\"data\":{},\"timestamp\":{\"seconds\":1583908853,\"microseconds\":411394}}\\n', '-> {\"return\":{}}\\n', '退出虚拟机\\n', 'QMP提供了quit命令用于退出虚拟机，即退出StratoVirt进程。命令格式如下：\\n', '\\n', '{“execute”:“quit”}\\n', '\\n', '示例：\\n', '\\n', '<- {\"execute\":\"quit\"}\\n', '-> {\"return\":{}}\\n', '-> {\"event\":\"SHUTDOWN\",\"data\":{\"guest\":false,\"reason\":\"host-qmp-quit\"},\"timestamp\":{\"ds\":1590563776,\"microseconds\":519808}}\\n', '管理虚拟机资源\\n', '热插拔磁盘\\n', 'StratoVirt支持在虚拟机运行过程中调整磁盘数量，即在不中断业务前提下，增加或删除虚拟机磁盘。\\n', '\\n', '注意事项\\n', '\\n', '对于标准机型，需要虚拟机内核开启 CONFIG_HOTPLUG_PCI_PCIE=y 配置。\\n', '\\n', '对于标准机型，目前支持热插拔设备到 Root Port 设备，Root Port 设备需要在虚拟机启动前配置。\\n', '\\n', '不建议在虚拟机启动、关闭、内部高压力等状态下进行设备热插拔，可能会因为虚拟机内驱动没有及时响应导致虚拟机出现异常。\\n', '\\n', '热插磁盘\\n', '用法：\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '{\"execute\": \"device_add\", \"arguments\": {\"id\": \"drive-0\", \"driver\": \"virtio-blk-mmio\", \"addr\": \"0x1\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"drive-0\", \"driver\":\"virtio-blk-pci\", \"drive\": \"drive-0\", \"addr\":\"0x0\", \"bus\": \"pcie.1\"}}\\n', '参数\\n', '\\n', '对于轻量机型，blockdev-add 中的 node-name 要和 device_add 中的 id 一致，如上都是 drive-0。\\n', '\\n', '对于标准机型 drive 参数需要和 blockdev-add 中的 node-name 一致。\\n', '\\n', '/path/to/block 是被热插磁盘的镜像路径，不能是启动 rootfs 的磁盘镜像。\\n', '\\n', '对于轻量机型，addr 参数从 0x0 开始与虚拟机的 vda 映射，0x1 与 vdb 映射，以此类推。为了兼容 QMP 协议，“addr” 也可以用 “lun” 代替，但是 lun=0 与客户机的 vdb 映射。对于标准机型，目前 addr 参数需要指定为 0x0。\\n', '\\n', '对于标准机型，bus 为设备要挂载的总线名称，目前只支持热插到 Root Port 设备，需要和 Root Port 的 id 保持一致。\\n', '\\n', '对于轻量机型，StratoVirt 支持的最大 virtio-blk 磁盘数量是6个，热插磁盘时请注意规格约束。对于标准机型，热插磁盘的数量取决于 Root Port 设备的数量。\\n', '\\n', '示例\\n', '\\n', '轻量机型：\\n', '\\n', '<- {\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\": \"device_add\", \"arguments\": {\"id\": \"drive-0\", \"driver\": \"virtio-blk-mmio\", \"addr\": \"0x1\"}}\\n', '-> {\"return\": {}}\\n', '标准机型：\\n', '\\n', '<- {\"execute\": \"blockdev-add\", \"arguments\": {\"node-name\": \"drive-0\", \"file\": {\"driver\": \"file\", \"filename\": \"/path/to/block\"}, \"cache\": {\"direct\": true}, \"read-only\": false}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"drive-0\", \"driver\":\"virtio-blk-pci\", \"drive\": \"drive-0\", \"addr\":\"0x0\", \"bus\": \"pcie.1\"}}\\n', '-> {\"return\": {}}\\n', '热拔磁盘\\n', '用法：\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\":\"drive-0\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\":\"drive-0\"}}\\n', '{\"execute\": \"blockdev-del\", \"arguments\": {\"node-name\": \"drive-0\"}}\\n', '参数：\\n', '\\n', 'id 为热拔磁盘的 ID 号。\\n', 'node-name 为磁盘后端名称。\\n', '示例\\n', '\\n', '轻量机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\": \"drive-0\"}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"drive-0\",\"path\":\"drive-0\"},\"timestamp\":{\"seconds\":1598513162,\"microseconds\":367129}}\\n', '-> {\"return\": {}}\\n', '标准机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\":\"drive-0\"}}\\n', '-> {\"return\": {}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"drive-0\",\"path\":\"drive-0\"},\"timestamp\":{\"seconds\":1598513162,\"microseconds\":367129}}\\n', '<- {\"execute\": \"blockdev-del\", \"arguments\": {\"node-name\": \"drive-0\"}}\\n', '-> {\"return\": {}}\\n', '当收到 DEVICE_DELETED 事件时，表示设备在 StratoVirt 侧被移除。\\n', '\\n', '热插拔网卡\\n', 'StratoVirt支持在虚拟机运行过程中调整网卡数量，即在不中断业务前提下，给虚拟机增加或删除网卡。\\n', '\\n', '注意事项\\n', '\\n', '对于标准机型，需要虚拟机内核开启 CONFIG_HOTPLUG_PCI_PCIE=y 配置。\\n', '\\n', '对于标准机型，目前支持热插拔设备到 Root Port 设备，Root Port 设备需要在虚拟机启动前配置。\\n', '\\n', '不建议在虚拟机启动、关闭、内部高压力等状态下进行设备热插拔，可能会因为虚拟机内驱动没有及时响应导致虚拟机出现异常。\\n', '\\n', '热插网卡\\n', '准备工作（需要使用root权限）\\n', '\\n', '创建并启用Linux网桥，例如网桥名为 qbr0 的参考命令如下：\\n', '# brctl addbr qbr0\\n', '# ifconfig qbr0 up\\n', '创建并启用 tap 设备，例如设备名为 tap0 的参考命令如下：\\n', '# ip tuntap add tap0 mode tap\\n', '# ifconfig tap0 up\\n', '添加 tap 设备到网桥：\\n', '# brctl addif qbr0 tap0\\n', '用法\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-mmio\", \"addr\":\"0x0\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-pci\", \"addr\":\"0x0\", \"netdev\": \"net-0\", \"bus\": \"pcie.1\"}}\\n', '参数\\n', '\\n', '对于轻量机型，netdev_add 中的 id 应该和 device_add 中的 id 一致，ifname 是后端的 tap 设备名称。\\n', '\\n', '对于标准机型，netdev 参数需要和 netdev_add 中的 id 一致。\\n', '\\n', '对于轻量机型，addr 参数从 0x0 开始与虚拟机的 eth0 映射，0x1 和虚拟机的 eth1 映射。对于标准机型，目前 addr 参数需要指定为 0x0。\\n', '\\n', '对于标准机型，bus 为设备要挂载的总线名称，目前只支持热插到 Root Port 设备，需要和 Root Port 的 id 保持一致。\\n', '\\n', '对于轻量机型，由于 StratoVirt 支持的最大 virtio-net 数量为2个，热插网卡时请注意规格约束。对于标准机型，热插磁盘的数量取决于 Root Port 设备的数量。\\n', '\\n', '示例\\n', '\\n', '轻量机型:\\n', '\\n', '<- {\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-mmio\", \"addr\":\"0x0\"}} \\n', '-> {\"return\": {}}\\n', '其中，addr:0x0,对应虚拟机内部的eth0。\\n', '\\n', '标准机型：\\n', '\\n', '<- {\"execute\":\"netdev_add\", \"arguments\":{\"id\":\"net-0\", \"ifname\":\"tap0\"}}\\n', '-> {\"return\": {}}\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"net-0\", \"driver\":\"virtio-net-pci\", \"addr\":\"0x0\", \"netdev\": \"net-0\", \"bus\": \"pcie.1\"}}\\n', '-> {\"return\": {}}\\n', '热拔网卡\\n', '用法\\n', '\\n', '轻量机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '标准机型：\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\":\"net-0\"}}\\n', '{\"execute\": \"netdev_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '参数\\n', '\\n', 'id：网卡的ID号，例如 net-0。\\n', '\\n', 'netdev_del 中的 id 是网卡后端的名称。\\n', '\\n', '示例\\n', '\\n', '轻量机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"net-0\",\"path\":\"net-0\"},\"timestamp\":{\"seconds\":1598513339,\"microseconds\":97310}}\\n', '-> {\"return\": {}}\\n', '标准机型：\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\":\"net-0\"}}\\n', '-> {\"return\": {}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"net-0\",\"path\":\"net-0\"},\"timestamp\":{\"seconds\":1598513339,\"microseconds\":97310}}\\n', '<- {\"execute\": \"netdev_del\", \"arguments\": {\"id\": \"net-0\"}}\\n', '-> {\"return\": {}}\\n', '当收到 DEVICE_DELETED 事件时，表示设备在 StratoVirt 侧被移除。\\n', '\\n', '热插拔直通设备\\n', 'StratoVirt 标准机型支持在虚拟机运行过程中调整直通设备数量，即在不中断业务前提下，给虚拟机增加或删除直通设备。\\n', '\\n', '注意事项\\n', '\\n', '需要虚拟机内核开启 CONFIG_HOTPLUG_PCI_PCIE=y 配置。\\n', '\\n', '目前支持热插拔设备到 Root Port 设备，Root Port 设备需要在虚拟机启动前配置。\\n', '\\n', '不建议在虚拟机启动、关闭、内部高压力等状态下进行设备热插拔，可能会因为虚拟机内驱动没有及时响应导致虚拟机出现异常。\\n', '\\n', '热插直通设备\\n', '用法\\n', '\\n', '{\"execute\":\"device_add\", \"arguments\":{\"id\":\"vfio-0\", \"driver\":\"vfio-pci\", \"bus\": \"pcie.1\", \"addr\":\"0x0\", \"host\": \"0000:1a:00.3\"}}\\n', '参数\\n', '\\n', 'id 为热插设备的 ID 号。\\n', '\\n', 'bus 为设备要挂载的总线名称。\\n', '\\n', 'addr 为设备要挂载的 slot 和 function 号，目前 addr 参数需要指定为 0x0。\\n', '\\n', 'host 为直通设备在主机上的 domain 号, bus 号, slot 号和 function 号。\\n', '\\n', '示例\\n', '\\n', '<- {\"execute\":\"device_add\", \"arguments\":{\"id\":\"vfio-0\", \"driver\":\"vfio-pci\", \"bus\": \"pcie.1\", \"addr\":\"0x0\", \"host\": \"0000:1a:00.3\"}}\\n', '-> {\"return\": {}}\\n', '热拔直通设备\\n', '用法\\n', '\\n', '{\"execute\": \"device_del\", \"arguments\": {\"id\": \"vfio-0\"}}\\n', '参数\\n', '\\n', 'id 为热拔设备的 ID 号。在热插设备时指定。\\n', '示例\\n', '\\n', '<- {\"execute\": \"device_del\", \"arguments\": {\"id\": \"vfio-0\"}}\\n', '-> {\"return\": {}}\\n', '-> {\"event\":\"DEVICE_DELETED\",\"data\":{\"device\":\"vfio-0\",\"path\":\"vfio-0\"},\"timestamp\":{\"seconds\":1614310541,\"microseconds\":554250}}\\n', '当收到 DEVICE_DELETED 事件时，表示设备在 StratoVirt 侧被移除。\\n', '\\n', 'Balloon设备使用\\n', '使用balloon设备可以从虚拟机回收空闲的内存。Balloon通过qmp命令来调用。qmp命令使用如下：\\n', '\\n', '用法：\\n', '\\n', '{\"execute\": \"balloon\", \"arguments\": {\"value\": 2147483648}}\\n', '参数：\\n', '\\n', 'value： 想要设置的guest内存大小值，单位为字节。如果该值大于虚拟机启动时配置的内存值，则以启动时配置的内存值为准。\\n', '示例：\\n', '\\n', '启动时配置的内存大小为4GiB，在虚拟机内部通过free命令查询虚拟机空闲内存大于2GiB，那么可以通过qmp命令设置guest内存大小为2147483648字节。\\n', '\\n', '<- {\"execute\": \"balloon\", \"arguments\": {\"value\": 2147483648}}\\n', '-> {\"return\": {}}\\n', '查询虚拟机的当前实际内存：\\n', '\\n', '<- {\"execute\": \"query-balloon\"}\\n', '-> {\"return\":{\"actual\":2147483648}}\\n', '虚拟机内存快照\\n', '简介\\n', '虚拟机内存快照是指将虚拟机的设备状态和内存信息保存在快照文件中。当虚拟机系统损坏时，可以使用内存快照将虚拟机恢复到快照对应时间点，从而提升系统的可靠性。\\n', '\\n', 'StratoVirt 支持对处于暂停状态（suspend）的虚拟机制作快照，并且支持虚拟机以快照文件为虚拟机模板批量创建新的虚拟机。只要制作快照的时间点在虚拟机启动完成并进入用户态之后，快速启动就能够跳过内核启动阶段和用户态服务初始化阶段，在毫秒级完成虚拟机启动。\\n', '\\n', '互斥特性\\n', '虚拟机配置了如下设备或使用了如下特性时，不能制作和使用内存快照：\\n', '\\n', 'vhost-net 设备\\n', 'vfio 直通设备\\n', 'balloon 设备\\n', '大页内存\\n', 'mem-shared 特性\\n', '配置了内存后端文件 mem-path\\n', '制作快照\\n', '针对 StratoVirt 虚拟机，可以参考如下步骤制作存储快照：\\n', '\\n', '创建并启动虚拟机。\\n', '\\n', '在 Host 上执行 QMP 命令暂停虚拟机：\\n', '\\n', '<- {\"execute\":\"stop\"}\\n', '-> {\"event\":\"STOP\",\"data\":{},\"timestamp\":{\"seconds\":1583908726,\"microseconds\":162739}}\\n', '-> {\"return\":{}}\\n', '\\n', '确认虚拟机处于暂停状态：\\n', '\\n', '<- {\"execute\":\"query-status\"}\\n', '-> {\"return\":{\"running\":true,\"singlestep\":false,\"status\":\"paused\"}}\\n', '\\n', '执行如下 QMP 命令，在任一指定的绝对路径下创建虚拟机快照，例如 /path/to/template 路径，参考命令如下：\\n', '\\n', '<- {\"execute\":\"migrate\", \"arguments\":{\"uri\":\"file:/path/to/template\"}}\\n', '-> {\"return\":{}}\\n', '\\n', '确认快照是否创建成功。\\n', '\\n', '<- {\"execute\":\"query-migrate\"}\\n', '\\n', '如果回显 {“return”:{“status”:“completed”}} ，说明快照创建成功。\\n', '\\n', '快照创建成功，会在指定路径 /path/to/template 生成 memory 和 state 两个目录。state文件包含虚拟机设备状态的信息，memory文件包含虚拟机内存的数据信息，memory 文件大小接近配置的虚拟机内存。\\n', '\\n', '查询快照状态\\n', '当前在整个快照过程中，存在5种状态：\\n', '\\n', 'None: 快照资源没有准备完成\\n', 'Setup: 快照资源准备完成，可以进行快照\\n', 'Active: 处于制作快照状态中\\n', 'Completed: 快照制作成功\\n', 'Failed: 快照制作失败\\n', '可以通过在 Host 执行query-migrateqmp 命令查询当前快照的状态，如当虚拟机快照制作成功时查询：\\n', '\\n', '<- {\"execute\":\"query-migrate\"}\\n', '-> {\"return\":{\"status\":\"completed\"}}\\n', '\\n', '恢复虚拟机\\n', '注意事项\\n', '快照以及从快照启动特性支持的机型包括：\\n', 'microvm\\n', 'q35（x86_64）\\n', 'virt（aarch64平台）\\n', '在使用快照恢复时，配置的设备必须与制作快照时保持一致\\n', '当使用 microvm 机型，并且在快照前使用了磁盘/网卡的热插特性，在恢复时需要将热插的磁盘/网卡配置进启动命令行\\n', '从快照文件中恢复虚拟机\\n', '命令格式\\n', '\\n', 'stratovirt -incoming URI\\n', '\\n', '参数说明\\n', '\\n', 'URI：快照的路径，当前版本只支持 file 类型，后加上快照文件的绝对路径\\n', '\\n', '示例\\n', '\\n', '假设制作快照所使用的虚拟机是通过以下命令创建的：\\n', '\\n', '$ stratovirt \\\\\\n', '    -machine microvm \\\\\\n', '    -kernel /path/to/kernel \\\\\\n', '    -smp 1 -m 1024 \\\\\\n', '    -append \"console=ttyS0 pci=off reboot=k quiet panic=1 root=/dev/vda\" \\\\\\n', '    -drive file=/path/to/rootfs,id=rootfs,readonly=off,direct=off \\\\\\n', '    -device virtio-blk-device,drive=rootfs \\\\\\n', '    -qmp unix:/path/to/socket,server,nowait \\\\\\n', '    -serial stdio\\n', '\\n', '那么，使用快照恢复虚拟机的参考命令如下（此处假设快照存放的路径为 /path/to/template ）:\\n', '\\n', '$ stratovirt \\\\\\n', '    -machine microvm \\\\\\n', '    -kernel /path/to/kernel \\\\\\n', '    -smp 1 -m 1024 \\\\\\n', '    -append \"console=ttyS0 pci=off reboot=k quiet panic=1 root=/dev/vda\" \\\\\\n', '    -drive file=/path/to/rootfs,id=rootfs,readonly=off,direct=off \\\\\\n', '    -device virtio-blk-device,drive=rootfs \\\\\\n', '    -qmp unix:/path/to/another_socket,server,nowait \\\\\\n', '    -serial stdio \\\\\\n', '    -incoming file:/path/to/template\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_支持CNI网络.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%94%AF%E6%8C%81CNI%E7%BD%91%E7%BB%9C.html", "text_entry": "['支持CNI网络\\n', '支持CNI网络\\n', '描述\\n', '接口\\n', 'CNI网络配置说明\\n', '加入CNI网络列表\\n', '退出CNI网络列表\\n', '使用限制\\n', '描述\\n', '实现CRI接口对接CNI网络的能力，包括CNI网络配置文件的解析、CNI网络的加入和退出。Pod需要支持网络时，例如通过canal等容器网络插件提供网络能力，那么需要CRI接口能够和canal实现对接，并且调用canal的接口，为Pod提供网络能力。\\n', '\\n', 'CNI配置文件相关行为描述：\\n', '\\n', '对–cni-conf-dir目录下的合法配置文件名进行字典排序，取第一个合法配置作为default网络平面的配置；\\n', '每隔5s对配置目录进行扫描，重新加载更新CNI配置；\\n', 'CRI Status接口不更新CNI的网络配置；\\n', '接口\\n', 'CNI对用户可见的接口，主要涉及CNI网络配置和Pod配置中CNI网络相关的项。\\n', '\\n', 'CNI网络配置相关的接口，主要是isulad指定CNI网络配置文件所在路径、CNI网络插件二进制文件所在的路径以及使用的网络模式。详情请参见表1 CNI网络配置接口。\\n', 'Pod配置中CNI网络相关的项，主要是设置Pod加入的附加CNI网络列表，默认情况Pod只会加入到default CNI网络平面中，可以通过该配置把Pod加入到多个CNI网络平面中。\\n', '表 1 CNI网络配置接口\\n', '\\n', '\\n', '  \\n', '\\n', '命令行\\n', '\\n', '配置文件\\n', '\\n', '说明\\n', '\\n', '设置CNI网络插件二进制文件所在路径\\n', '\\n', '--cni-bin-dir\\n', '\\n', '\"cni-bin-dir\": \"\",\\n', '\\n', '默认为/opt/cni/bin\\n', '\\n', '设置CNI网络配置文件所在路径\\n', '\\n', '--cni-conf-dir\\n', '\\n', '\"cni-conf-dir\": \"\",\\n', '\\n', '系统会遍历目录下面所有后缀名为\".conf\"、\".conflist\"和 \".json\"的文件。默认为/etc/cni/net.d\\n', '\\n', '指定网络模式\\n', '\\n', '--network-plugin\\n', '\\n', '\"network-plugin\": \"\",\\n', '\\n', '指定网络插件，默认为空字符，表示无网络配置，创建的sandbox只有loop网卡。支持cni和空字符，其他非法值会导致isulad启动失败。\\n', '\\n', '附加CNI网络配置方式：\\n', '\\n', '在Pod的配置文件的\"annotations\"中，增加一项\"network.alpha.kubernetes.io/network\": “网络平面配置”；\\n', '\\n', '网络平面配置为json格式，包含两项：\\n', '\\n', 'name：指定CNI网络平面的名字\\n', 'interface：指定网络接口的名字\\n', '附件CNI网络配置方式示例如下：\\n', '\\n', '\"annotations\" : {\\n', '        \"network.alpha.kubernetes.io/network\": \"{\\\\\"name\\\\\": \\\\\"mynet\\\\\", \\\\\"interface\\\\\": \\\\\"eth1\\\\\"}\"\\n', ' }\\n', '  \\n', '\\n', 'CNI网络配置说明\\n', 'CNI网络配置包含两种类型，文件格式都为json：\\n', '\\n', '单网络平面配置，以.conf和.json为后缀的文件：具体的配置项请参见\"附录 > CNI配置参数\" 章节的 “表 CNI单网络配置参数”。\\n', '多网络平面配置，以.conflist为后缀的文件：具体的配置项请参见\"附录 > CNI配置参数\" 章节的 “表3 CNI多网络配置参数”。\\n', '加入CNI网络列表\\n', '如果iSulad配置了–network-plugin=cni，而且设置了default网络平面配置，那么在启动Pod的时候，会自动把Pod加入到default网络平面。如果在Pod的配置中配置了附加网络配置，那么启动Pod的时候也会把Pod加入到这些附加网络平面中。\\n', '\\n', 'Pod配置中和网络相关的还有port_mappings项，用于设置Pod的端口映射关系。配置方式如下：\\n', '\\n', '\"port_mappings\":[\\n', '     { \\n', '         \"protocol\": 1,\\n', '         \"container_port\": 80,\\n', '         \"host_port\": 8080\\n', '      }\\n', ']\\n', 'protocol：表示映射使用的协议，支持tcp（用0标识）、udp（用1标识）；\\n', 'container_port：表示容器映射出去的port；\\n', 'host_port：表示映射到主机的port。\\n', '退出CNI网络列表\\n', 'StopPodSandbox的时候，会调用退出CNI网络的接口，清理网络相关的资源。\\n', '\\n', ' 说明：\\n', '\\n', '在调用RemovePodSandbox接口之前，至少要调用一次StopPodSandbox接口\\n', 'StopPodSandbox调用CNI接口失败，可能导致的网络资源残留。\\n', '使用限制\\n', 'cniVersion的版本，当前只支持0.3.0和0.3.1。由于后期可能需要支持0.1.0和0.2.0，错误日志打印时，保留了0.1.0和0.2.0的提示信息。\\n', \"name：必须是小写字符、数字、'-'以及'.'组成； '.'和'-'不能作为首字符和尾字符； 而且长度不超过200个字符。\\n\", '配置文件个数不超过200个，单个配置文件大小不超过1MB。\\n', '扩展之后的参数，需要根据实际网络需求来配置，不需要使用的可选参数可以不写入到netconf.json文件中。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_容器管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86.html", "text_entry": "['容器管理\\n', '容器管理\\n', '创建容器\\n', '启动容器\\n', '运行容器\\n', '停止容器\\n', '强制停止容器\\n', '删除容器\\n', '接入容器\\n', '重命名容器\\n', '在容器中执行新命令\\n', '查询单个容器信息\\n', '查询所有容器信息\\n', '重启容器\\n', '等待容器退出\\n', '查看容器中进程信息\\n', '查看容器使用的资源\\n', '获取容器日志\\n', '容器与主机之间数据拷贝\\n', '暂停容器\\n', '恢复容器\\n', '从服务端实时获取事件消息\\n', '创建容器\\n', '描述\\n', 'isula create 命令用于创建一个新的容器。容器引擎会使用指定的容器镜像创建容器读写层，或者使用指定的本地rootfs作为容器的运行环境。创建完成后，会将容器的ID输出到标准输出，后续可以使用isula start 命令启动该容器。新创建的容器状态为inited状态\\n', '\\n', '用法\\n', 'isula create [OPTIONS] IMAGE [COMMAND] [ARG...]\\n', '参数\\n', 'create命令支持参数参考下表。\\n', '\\n', '表 1 create命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'create\\n', '\\n', '  \\n', '\\n', '--annotation\\n', '\\n', '设置容器的annotations。例如支持native.umask选项：\\n', '\\n', '--annotation native.umask=normal # 启动的容器umask值为0022\\n', '--annotation native.umask=secure # 启动的容器umask值为0027\\n', '注意如果没有配置该参数，则使用isulad中的umask配置。\\n', '\\n', '--cap-drop\\n', '\\n', '删除Linux 权限功能\\n', '\\n', '--cgroup-parent\\n', '\\n', '指定容器cgroup父路径\\n', '\\n', '--cpuset-cpus\\n', '\\n', '允许执行的CPU（e.g. 0-3，0，1）\\n', '\\n', '--cpu-shares\\n', '\\n', 'CPU份额（相对权重）\\n', '\\n', '--cpu-quota\\n', '\\n', '限制CPU CFS（完全公平调度器）的配额\\n', '\\n', '--device=[]\\n', '\\n', '为容器添加一个主机设备\\n', '\\n', '--dns\\n', '\\n', '添加DNS服务器\\n', '\\n', '--dns-opt\\n', '\\n', '添加DNS选项\\n', '\\n', '--dns-search\\n', '\\n', '设定容器的搜索域\\n', '\\n', '-e, --env\\n', '\\n', '设置环境变量\\n', '\\n', '--env-file\\n', '\\n', '通过文件配置环境变量\\n', '\\n', '--entrypoint\\n', '\\n', '启动容器时要运行的入口点\\n', '\\n', '--external-rootfs=PATH\\n', '\\n', '指定一个不由iSulad管理的rootfs(可以为文件夹或块设备)给容器\\n', '\\n', '--files-limit\\n', '\\n', '调整容器内能够打开的文件句柄数（-1表示不限制）\\n', '\\n', '--group-add=[]\\n', '\\n', '指定额外的用户组添加到容器\\n', '\\n', '--help\\n', '\\n', '打印帮助信息\\n', '\\n', '--health-cmd\\n', '\\n', '在容器内执行的命令\\n', '\\n', '--health-exit-on-unhealthy\\n', '\\n', '检测到容器非健康时是否杀死容器\\n', '\\n', '--health-interval\\n', '\\n', '相邻两次命令执行的间隔时间\\n', '\\n', '--health-retries\\n', '\\n', '健康检查失败最大的重试次数\\n', '\\n', '--health-start-period\\n', '\\n', '容器初始化时间\\n', '\\n', '--health-timeout\\n', '\\n', '单次检查命令执行的时间上限\\n', '\\n', '--hook-spec\\n', '\\n', '钩子配置文件\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-h, --hostname\\n', '\\n', '容器主机名称\\n', '\\n', '-i, --interactive\\n', '\\n', '即使没有连接到容器的标准输入，也要保持容器的标准输入打开\\n', '\\n', '--hugetlb-limit=[]\\n', '\\n', '大页文件限制，例如：--hugetlb-limit 2MB:32MB\\n', '\\n', '--log-opt=[]\\n', '\\n', '日志驱动程序选项，默认禁用记录容器串口日志功能，可以通过\"--log-opt disable-log=false\"来开启。\\n', '\\n', '-l，--label\\n', '\\n', '为容器设置标签\\n', '\\n', '--lablel-file\\n', '\\n', '通过文件设置容器标签\\n', '\\n', '-m, --memory\\n', '\\n', '内存限制\\n', '\\n', '--memory-reservation\\n', '\\n', '设置容器内存限制，默认与--memory一致。可认为--memory是硬限制，--memory-reservation是软限制；当使用内存超过预设值时，会动态调整（系统回收内存时尝试将使用内存降低到预设值以下），但不确保一定不超过预设值。一般可以和--memory一起使用，数值小于--memory的预设值，最小设置为4MB。\\n', '\\n', '--memory-swap\\n', '\\n', '正整数，内存 + 交换空间，-1 表示不限制\\n', '\\n', '--memory-swappiness\\n', '\\n', '正整数，swappiness参数值可设置范围在0到100之间。 此参数值越低，就会让Linux系统尽量少用swap分区，多用内存；参数值越高就是反过来，使内核更多的去使用swap空间，默认值为-1，表示使用系统默认值。\\n', '\\n', '--mount\\n', '\\n', '挂载主机目录/卷/文件系统到容器中\\n', '\\n', '--no-healthcheck\\n', '\\n', '禁用健康检查配置\\n', '\\n', '--name=NAME\\n', '\\n', '容器名\\n', '\\n', '--net=none\\n', '\\n', '容器连接到网络\\n', '\\n', '--pids-limit\\n', '\\n', '调整容器内能够执行的进程数（-1表示不限制）\\n', '\\n', '--privileged\\n', '\\n', '给予容器扩展的特权\\n', '\\n', '-R, --runtime\\n', '\\n', '容器运行时，参数支持\"lcr\"，忽略大小写，因此\"LCR\"和\"lcr\"是等价的\\n', '\\n', '--read-only\\n', '\\n', '设置容器的根文件系统为只读\\n', '\\n', '--restart\\n', '\\n', '当容器退出时重启策略\\n', '\\n', '系统容器支持--restart on-reboot\\n', '\\n', '--storage-opt\\n', '\\n', '配置容器的存储驱动选项\\n', '\\n', '-t, --tty\\n', '\\n', '分配伪终端\\n', '\\n', '--ulimit\\n', '\\n', '为容器设置ulimit限制\\n', '\\n', '-u, --user\\n', '\\n', '用户名或UID，格式[<name|uid>][:<group|gid>]\\n', '\\n', '-v, --volume=[]\\n', '\\n', '挂载一个卷\\n', '\\n', '--volumes-from=[]\\n', '\\n', '使用指定的容器的挂载配置\\n', '\\n', '约束限制\\n', '使用–user或–group-add参数，在容器启动阶段校验user或group时，容器如果使用的是OCI镜像，是从镜像的真实rootfs的etc/passwd和etc/group文件中校验，如果使用的是rootfs文件夹或块设备作为容器的rootfs，则校验的是host中的etc/passwd和etc/group文件；查找时使用的rootfs会忽略-v 和–mount等挂载参数，意味着使用这些参数尝试覆盖etc/passwd和etc/group两个文件时，在查找阶段不生效，只在容器真正启动时生效。生成的配置保存在\"iSulad根目录/engine/容器ID/start_generate_config.json\"，文件格式如下：\\n', '\\n', '{\\n', '    \"uid\": 0,\\n', '    \"gid\": 8,\\n', '    \"additionalGids\": [\\n', '        1234,\\n', '        8\\n', '    ]\\n', '}\\n', '示例\\n', '创建一个新容器\\n', '\\n', '# isula create busybox\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '# isula ps -a\\n', 'STATUS PID IMAGE   COMMAND EXIT_CODE RESTART_COUNT STARTAT FINISHAT RUNTIME ID           NAMES                                                            inited -   busybox \"sh\"    0         0             -       -        lcr     fd7376591a9c fd7376591a9c4521...\\n', '启动容器\\n', '描述\\n', 'isula start命令用于启动一个或多个容器。\\n', '\\n', '用法\\n', 'isula start [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'start命令支持参数参考下表。\\n', '\\n', '表 1 start命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'start\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-R, --runtime\\n', '\\n', '容器运行时，参数支持\"lcr\"，忽略大小写，因此\"LCR\"和\"lcr\"是等价的\\n', '\\n', '示例\\n', '启动一个新容器\\n', '\\n', '# isula start fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '运行容器\\n', '描述\\n', 'isula run命令命令用于创建一个新的容器。会使用指定的容器镜像创建容器读写层，并且为运行指定的命令做好准备。创建完成后，使用指定的命令启动该容器。run命令相当于create然后start容器。\\n', '\\n', '用法\\n', 'isula run [OPTIONS] ROOTFS|IMAGE [COMMAND] [ARG...]\\n', '参数\\n', 'run命令支持参数参考下表。\\n', '\\n', '表 1 run命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'run\\n', '\\n', '--annotation\\n', '\\n', '设置容器的annotations。例如支持native.umask选项：\\n', '\\n', '--annotation native.umask=normal # 启动的容器umask值为0022\\n', '--annotation native.umask=secure # 启动的容器umask值为0027\\n', '注意如果没有配置该参数，则使用isulad中的umask配置。\\n', '\\n', '--cap-add\\n', '\\n', '添加Linux功能\\n', '\\n', '--cap-drop\\n', '\\n', '删除Linux功能\\n', '\\n', '--cgroup-parent\\n', '\\n', '指定容器cgroup父路径\\n', '\\n', '--cpuset-cpus\\n', '\\n', '允许执行的CPU（e.g. 0-3，0，1）\\n', '\\n', '--cpu-shares\\n', '\\n', 'CPU份额（相对权重）\\n', '\\n', '--cpu-quota\\n', '\\n', '限制CPU CFS（完全公平调度器）的配额\\n', '\\n', '-d, --detach\\n', '\\n', '后台运行容器并打印容器ID\\n', '\\n', '--device=[]\\n', '\\n', '为容器添加一个主机设备\\n', '\\n', '--dns\\n', '\\n', '添加DNS服务器\\n', '\\n', '--dns-opt\\n', '\\n', '添加DNS选项\\n', '\\n', '--dns-search\\n', '\\n', '设定容器的搜索域\\n', '\\n', '-e, --env\\n', '\\n', '设置环境变量\\n', '\\n', '--env-file\\n', '\\n', '通过文件配置环境变量\\n', '\\n', '--entrypoint\\n', '\\n', '启动容器时要运行的入口点\\n', '\\n', '--external-rootfs=PATH\\n', '\\n', '指定一个不由iSulad管理的rootfs(可以为文件夹或块设备)给容器\\n', '\\n', '--files-limit\\n', '\\n', '调整容器内能够打开的文件句柄数（-1表示不限制）\\n', '\\n', '--group-add=[]\\n', '\\n', '指定额外的用户组添加到容器\\n', '\\n', '--help\\n', '\\n', '打印帮助信息\\n', '\\n', '--health-cmd\\n', '\\n', '在容器内执行的命令\\n', '\\n', '--health-exit-on-unhealthy\\n', '\\n', '检测到容器非健康时是否杀死容器\\n', '\\n', '--health-interval\\n', '\\n', '相邻两次命令执行的间隔时间\\n', '\\n', '--health-retries\\n', '\\n', '健康检查失败最大的重试次数\\n', '\\n', '--health-start-period\\n', '\\n', '容器初始化时间\\n', '\\n', '--health-timeout\\n', '\\n', '单次检查命令执行的时间上限\\n', '\\n', '--hook-spec\\n', '\\n', '钩子配置文件\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-h, --hostname\\n', '\\n', '容器主机名称\\n', '\\n', '--hugetlb-limit=[]\\n', '\\n', '大页文件限制，例如：--hugetlb-limit 2MB:32MB\\n', '\\n', '-i, --interactive\\n', '\\n', '即使没有连接到容器的标准输入，也要保持容器的标准输入打开\\n', '\\n', '--log-driver\\n', '\\n', '设置日志驱动，支持syslog和json-file。\\n', '\\n', '--log-opt=[]\\n', '\\n', '日志驱动程序选项，默认禁用记录容器串口日志功能，可以通过\"--log-opt disable-log=false\"来开启。\\n', '\\n', '-m, --memory\\n', '\\n', '内存限制\\n', '\\n', '--memory-reservation\\n', '\\n', '设置容器内存限制，默认与--memory一致。可认为--memory是硬限制，--memory-reservation是软限制；当使用内存超过预设值时，会动态调整（系统回收内存时尝试将使用内存降低到预设值以下），但不确保一定不超过预设值。一般可以和--memory一起使用，数值小于--memory的预设值，最小设置为4MB。\\n', '\\n', '--memory-swap\\n', '\\n', '正整数，内存 + 交换空间，-1 表示不限制\\n', '\\n', '--memory-swappiness\\n', '\\n', '正整数，swappiness参数值可设置范围在0到100之间。 此参数值越低，就会让Linux系统尽量少用swap分区，多用内存；参数值越高就是反过来，使内核更多的去使用swap空间，默认值为-1，表示使用系统默认值。\\n', '\\n', '--mount\\n', '\\n', '挂载主机目录到容器中\\n', '\\n', '--no-healthcheck\\n', '\\n', '禁用健康检查配置\\n', '\\n', '--name=NAME\\n', '\\n', '容器名\\n', '\\n', '--net=none\\n', '\\n', '容器连接到网络\\n', '\\n', '--pids-limit\\n', '\\n', '调整容器内能够执行的进程数（-1表示不限制）\\n', '\\n', '--privileged\\n', '\\n', '给予容器扩展的特权\\n', '\\n', '-R, --runtime\\n', '\\n', '容器运行时，参数支持\"lcr\"，忽略大小写，因此\"LCR\"和\"lcr\"是等价的\\n', '\\n', '--read-only\\n', '\\n', '设置容器的根文件系统为只读\\n', '\\n', '--restart\\n', '\\n', '当容器退出时重启策略\\n', '\\n', '系统容器支持--restart on-reboot\\n', '\\n', '--rm\\n', '\\n', '当容器退出时自动清理容器\\n', '\\n', '--storage-opt\\n', '\\n', '配置容器的存储驱动选项\\n', '\\n', '-t, --tty\\n', '\\n', '分配伪终端\\n', '\\n', '--ulimit\\n', '\\n', '为容器设置ulimit限制\\n', '\\n', '-u, --user\\n', '\\n', '用户名或UID，格式[<name|uid>][:<group|gid>]\\n', '\\n', '-v, --volume=[]\\n', '\\n', '挂载一个卷\\n', '\\n', '约束限制\\n', '容器父进程进程退出时，则对应的容器也自动退出。\\n', '\\n', '创建普通容器时父进程不能为init，因为普通容器的权限不够，导致容器可以创建成功，但是attach进去的时候会卡住。\\n', '\\n', '运行容器时，不指定–net，默认hostname为localhost。\\n', '\\n', '使用–files-limit参数传入一个很小的值，如1时，启动容器时，iSulad创建cgroup子组后先设置files.limit值，再将容器进程的PID写入该子组的cgroup.procs文件，此时容器进程已经打开超过1个句柄，因而写入报错导致启动失败启动容器会失败。\\n', '\\n', '–mount参数和–volume参数同时存在时，如果目的路径有冲突，则–mount会在–volume之后挂载(即将–volume中的挂载点覆盖掉)。\\n', '\\n', '备注：轻量级容器的参数中type支持bind或squashfs，当type=squashfs时，src是镜像的路径；原生docker的参数type支持bind、volume、tmpfs。\\n', '\\n', 'restart重启策略不支持unless-stopped。\\n', '\\n', '以下三种情况与docker 返回值不一致，docker返回127,轻量级容器返回125\\n', '\\n', '–device参数指定主机设备为不存在的设备\\n', '\\n', '–hook-spec参数指定不存在的hook json文件\\n', '\\n', '–entrypoint 参数指定不存在的入口参数\\n', '\\n', '使用–volume参数时，由于容器启动时会对/dev/ptmx设备进行删除重建，因此请勿将/dev目录挂载至容器/dev目录，应使用–device对/dev下的设备在容器中进行挂载\\n', '\\n', '禁止使用echo的方式向run命令的stdin输入数据，会导致客户端卡死。应该直接将echo的值作为命令行参数传给容器\\n', '\\n', '# echo ls | isula run -i busybox /bin/sh\\n', '\\n', '\\n', '^C\\n', '#\\n', '上述命令出现客户端卡死现象，这是由于上述命令相当于往stdin输入ls，随后EOF被读取，客户端不再发送数据，等待服务端退出，但是服务端无法区分客户端是否需要继续发送数据，因而服务端卡在read数据上，最终导致双方均卡死。\\n', '\\n', '正确的执行方式为：\\n', '\\n', '# isula run -i busybox ls\\n', 'bin\\n', 'dev\\n', 'etc\\n', 'home\\n', 'proc\\n', 'root\\n', 'sys\\n', 'tmp\\n', 'usr\\n', 'var\\n', '#\\n', '使用host的根目录（/）作为容器的文件系统，那么在挂载路径时，如果有如下情况\\n', '\\n', '表 2 挂载情况\\n', '\\n', '\\n', 'Host 路径（source）\\n', '\\n', '容器路径（dest）\\n', '\\n', '/home/test1\\n', '\\n', '/mnt/\\n', '\\n', '/home/test2\\n', '\\n', '/mnt/abc\\n', '\\n', ' 须知：\\n', '第一种情况，先挂载/home/test1，然后挂载/home/test2，这种情况会导致/home/test1的内容覆盖掉原来/mnt下面的内容，这样可能导致/mnt下面不存在abc目录，这样会导致挂载/home/test2到/mnt/abc失败。\\n', '第二种情况，先挂载/home/test2，然后挂载/home/test1。这种情况，第二次的挂载会把/mnt的内容替换为/home/test1的内容，这样第一次挂载的/home/test2到/mnt/abc的内容就看不到了。\\n', '因此，不支持第一种使用方式；第二种使用用户需要了解这种数据无法访问的风险\\n', '\\n', ' 须知：\\n', '\\n', '高并发场景（并发启动200容器）下，glibc的内存管理机制会导致内存空洞以及虚拟内存较大（例如10GB）的问题。该问题是高并发场景下glibc内存管理机制的限制，而不是内存泄露，不会导致内存消耗无限增大。可以通过设置MALLOC_ARENA_MAX环境变量来减少虚拟内存的问题，而且可以增大减少物理内存的概率。但是这个环境变量会导致iSulad的并发性能下降，需要用户根据实际情况做配置。\\n', '参考实践情况，平衡性能和内存，可以设置MALLOC_ARENA_MAX为4。（在arm64服务器上面对iSulad的性能影响在10%以内）  \\n', '配置方法：  \\n', '1. 手动启动iSulad的场景，可以直接export MALLOC_ARENA_MAX=4，然后再启动iSulad即可。  \\n', '2. systemd管理iSulad的场景，可以修改/etc/sysconfig/iSulad，增加一条MALLOC_ARENA_MAX=4即可。  \\n', '示例\\n', '运行一个新容器\\n', '\\n', '# isula run -itd busybox\\n', '9c2c13b6c35f132f49fb7ffad24f9e673a07b7fe9918f97c0591f0d7014c713b\\n', '停止容器\\n', '描述\\n', 'isula stop命令用于停止一个或多个运行中的容器。首先向容器中的首进程会发送SIGTERM信号，在指定时间（默认为10s）内容器未停止时，会发送SIGKILL。\\n', '\\n', '用法\\n', 'isula stop [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'stop命令支持参数参考下表。\\n', '\\n', '表 1 stop命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'stop\\n', '\\n', '-f, --force\\n', '\\n', '强制停止正在运行的容器\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-t, --time\\n', '\\n', '先优雅停止，超过这个时间，则强行终止\\n', '\\n', '约束限制\\n', '指定t参数且t<0时，请确保自己容器的应用会处理stop信号。\\n', '\\n', 'Stop的原理：Stop会首先给容器发送Stop 信号（SIGTERM），然后等待一定的时间（这个时间就是用户输入的 t），过了指定时间如果容器还仍处于运行状态，那么就发送kill信号（SIGKILL）使容器强制退出。\\n', '\\n', '输入参数t的含义：\\n', '\\n', 't<0 : 表示一直等待，不管多久都等待程序优雅退出，既然用户这么输入了，表示对自己的应用比较放心，认为自己的程序有 合理的stop信号的处理机制。\\n', '\\n', 't=0 ： 表示不等，立即发送kill -9 到容器。\\n', '\\n', 't>0 ： 表示等一定的时间，如果容器还未退出，就发送kill -9 到容器。\\n', '\\n', '所以如果用户使用t<0 （比如t=-1），请确保自己容器的应用会正确处理SIGTERM. 如果容器忽略了该信号，会导致isula stop一直卡住。\\n', '\\n', '示例\\n', '停止一个容器\\n', '\\n', '# isula stop fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '强制停止容器\\n', '描述\\n', 'isula kill命令用于强制停止一个或多个运行中的容器。\\n', '\\n', '用法\\n', 'isula kill [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'kill命令支持参数参考下表。\\n', '\\n', '表 1 kill命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'kill\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-s, --signal\\n', '\\n', '发送给容器的信号\\n', '\\n', '示例\\n', '杀掉一个容器\\n', '\\n', '# isula kill fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '删除容器\\n', '描述\\n', 'isula rm命令用于删除一个或多个容器。\\n', '\\n', '用法\\n', 'isula rm [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'rm命令支持参数参考下表。\\n', '\\n', '表 1 rm命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'rm\\n', '\\n', '-f, --force\\n', '\\n', '强制移除正在运行的容器\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-v, --volume\\n', '\\n', '移除挂载在容器上的卷（备注：目前iSulad尚不使用此功能）\\n', '\\n', '约束限制\\n', '在IO正常情况，空环境（只有1个容器）删除一个running容器的时间为T1，200个容器的环境（容器无大量IO操作，host IO正常）删除一个running容器所需时间为T2。T2的规格为：T2 = max { T1 * 3, 5 } 秒钟。\\n', '示例\\n', '删除一个停止状态的容器\\n', '\\n', '# isula rm fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', 'fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '接入容器\\n', '描述\\n', 'isula attach命令用于将当前终端的标准输入、标准输出和标准错误连接到正在运行的容器。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula attach [OPTIONS] CONTAINER\\n', '参数\\n', 'attach命令支持参数参考下表。\\n', '\\n', '表 1 attach命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'attach\\n', '\\n', '--help\\n', '\\n', '打印帮助信息\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-D, --debug\\n', '\\n', '开启debug模式\\n', '\\n', '约束限制\\n', '原生docker attach容器会直接进入容器，而isulad attach容器后需要敲一个回车才进入。\\n', '示例\\n', '接入一个运行状态的容器\\n', '\\n', '# isula attach fd7376591a9c3d8ee9a14f5d2c2e5255b02cc44cddaabca82170efd4497510e1\\n', '/ #\\n', '/ #\\n', '重命名容器\\n', '描述\\n', 'isula rename命令用于重命名容器。\\n', '\\n', '用法\\n', 'isula rename [OPTIONS] OLD_NAME NEW_NAME\\n', '参数\\n', 'rename命令支持参数参考下表。\\n', '\\n', '表 1 rename 命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'rename\\n', '\\n', '-H, --host\\n', '\\n', '重命名容器\\n', '\\n', '示例\\n', '重命名一个容器\\n', '\\n', '# isula rename my_container my_new_container\\n', '在容器中执行新命令\\n', '描述\\n', 'isula exec命令用于正在运行的容器中运行一个新命令。新执行的命令将在容器的默认目录中运行。如果基础镜像指定了自定义目录，则将使用该目录。\\n', '\\n', '用法\\n', 'isula exec [OPTIONS] CONTAINER COMMAND [ARG...]\\n', '参数\\n', 'exec命令支持参数参考下表。\\n', '\\n', '表 1 exec命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'exec\\n', '\\n', '  \\n', '\\n', '-d, --detach\\n', '\\n', '后台运行命令\\n', '\\n', '-e, --env\\n', '\\n', '设置环境变量（备注：目前iSulad尚不使用此功能）\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-i, --interactive\\n', '\\n', '没有连接，也要保持标准输入打开（备注：目前iSulad尚不使用此功能）\\n', '\\n', '-t, --tty\\n', '\\n', '分配伪终端（备注：目前iSulad尚不使用此功能）\\n', '\\n', '-u, --user\\n', '\\n', '指定用户登录容器执行命令\\n', '\\n', '约束限制\\n', 'isula exec 不指定任何参数时，会默认使用-it参数， 表示分配一个伪终端，以交互式的方式进入容器\\n', '\\n', '当使用isula exec 执行脚本，在脚本中执行后台进程时，需使用nohup标志忽略SIGHUP信号。\\n', '\\n', '使用isula exec运行脚本,在脚本中运行后台进程需使用nohup标志。否则内核会在exec执行的进程（session首进程）退出时，向后台执行的进程发送SIGHUP信号，导致后台进程退出，出现僵尸进程。\\n', '\\n', 'isula exec 进入容器进程后，不能执行后台程序，否则会出现卡死现象。\\n', '\\n', 'isula exec执行后台进程的方式如下：\\n', '\\n', '使用isula exec进入容器终端，isula exec container_name bash\\n', '进入容器后，执行 script &\\n', '执行exit，导致终端卡死\\n', 'isula exec 进入容器后，执行后台程序卡住的原因为isula exec进入容器运行后台while1程序，当bash退出时，while1程序并不会退出，变为孤儿进程由1号\\n', '进程接管，while1程序是由容器的初始bash进程fork &exec执行的，while1进程复制了bash进程的文件句柄，导致bash退出时，句柄并未完全关闭，导致\\n', 'console进程收不到句柄关闭事件，epoll_wait卡住，进程不退出。\\n', 'isula exec 不能用后台方式执行，否则可能会出现卡死现象。\\n', '\\n', 'isula exec后台执行的方式如下：\\n', '\\n', '使用**isula exec 脚本 & **的方式后台执行exec，如：isula exec container_name script & ，isula exec 后台执行，执行的脚本中不断cat某一文件，正常时在当前终端有输出，如果在当前终端执行回车操作，客户端会因读IO失败而退出读stdout的动作，使终端不再输出，服务端由于进程仍然在cat文件，会继续往fifo的buffer里写入数据，当缓存写满时，容器内进程会卡死在write动作上。\\n', '\\n', '轻量级容器使用exec执行带有管道操作的命令时，建议使用/bin/bash -c 方式执行该命令。\\n', '\\n', '典型应用场景：\\n', '\\n', '使用isula exec container_name -it ls /test | grep “xx” | wc -l,用于统计test目录下xx的文件个数，因exec执行的为\"ls /test\",其输出通过管道进行grep、wc 处理。exec执行的为\"ls /test\"的输出会换行，再针对该输出进行处理时，结果有误。\\n', '\\n', '原因：使用exec 执行ls /test,输出带有换行，针对该输出进行“| grep “xx” | wc -l“，处理结果为2（两行）\\n', '\\n', '# isula exec  -it container ls /test\\n', 'xx    xx10  xx12  xx14  xx3   xx5   xx7   xx9\\n', 'xx1   xx11  xx13  xx2   xx4   xx6   xx8\\n', '#\\n', '建议处理方式：使用run/exec执行带有管道操作的命令时，使用/bin/bash -c 执行命令，在容器中执行管道操作。\\n', '\\n', '# isula exec  -it container  /bin/sh -c \"ls /test | grep \"xx\" | wc -l\"\\n', '15\\n', '#\\n', '禁止使用echo的方式向exec命令的stdin输入数据，会导致客户端卡死。应该直接将echo的值作为命令行参数传给容器\\n', '\\n', '# echo ls | isula exec 38 /bin/sh\\n', '\\n', '\\n', '^C\\n', '#\\n', '上述命令可能出现客户端卡死现象，这是由于上述命令相当于往stdin输入ls，随后EOF被读取，客户端不再发送数据，等待服务端退出，但是服务端无法区分客户端是否需要继续发送数据，因而服务端卡在read数据上，最终导致双方均卡死。\\n', '\\n', '正确的执行方式为：\\n', '\\n', '# isula exec 38 ls\\n', 'bin   dev   etc   home  proc  root  sys   tmp   usr   var\\n', '示例\\n', '在运行中的容器中，执行echo命令\\n', '\\n', '# isula exec c75284634bee echo \"hello,world\"\\n', 'hello,world\\n', '查询单个容器信息\\n', '描述\\n', 'isula inspect提供了容器的详细信息。\\n', '\\n', '用法\\n', 'isula inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]\\n', '参数\\n', 'inspect命令支持参数参考下表。\\n', '\\n', '表 1 inspect命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'inspect\\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-f, --format\\n', '\\n', '使用模板格式化输出\\n', '\\n', '-t, --time\\n', '\\n', '超时时间的秒数，若在该时间内inspect查询容器信息未执行成功，则停止等待并立即报错，默认为120秒，当配置小于等于0的值，表示不启用timeout机制inspect查询容器信息会一直等待，直到获取容器信息成功后返回。\\n', '\\n', '约束限制\\n', '轻量级容器不支持format为“{ {.State} }”的格式化输出，支持“{ {json .State} }”的json格式化输出。当inspect镜像时，不支持-f参数。\\n', '示例\\n', '查询容器信息\\n', '\\n', '# isula inspect c75284634bee\\n', '[\\n', '    {\\n', '        \"Id\": \"c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\",\\n', '        \"Created\": \"2019-08-01T22:48:13.993304927-04:00\",\\n', '        \"Path\": \"sh\",\\n', '        \"Args\": [],\\n', '        \"State\": {\\n', '            \"Status\": \"running\",\\n', '            \"Running\": true,\\n', '            \"Paused\": false,\\n', '            \"Restarting\": false,\\n', '            \"Pid\": 21164,\\n', '            \"ExitCode\": 0,\\n', '            \"Error\": \"\",\\n', '            \"StartedAt\": \"2019-08-02T06:09:25.535049168-04:00\",\\n', '            \"FinishedAt\": \"2019-08-02T04:28:09.479766839-04:00\",\\n', '            \"Health\": {\\n', '                \"Status\": \"\",\\n', '                \"FailingStreak\": 0,\\n', '                \"Log\": []\\n', '            }\\n', '        },\\n', '        \"Image\": \"busybox\",\\n', '        \"ResolvConfPath\": \"\",\\n', '        \"HostnamePath\": \"\",\\n', '        \"HostsPath\": \"\",\\n', '        \"LogPath\": \"none\",\\n', '        \"Name\": \"c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\",\\n', '        \"RestartCount\": 0,\\n', '        \"HostConfig\": {\\n', '            \"Binds\": [],\\n', '            \"NetworkMode\": \"\",\\n', '            \"GroupAdd\": [],\\n', '            \"IpcMode\": \"\",\\n', '            \"PidMode\": \"\",\\n', '            \"Privileged\": false,\\n', '            \"SystemContainer\": false,\\n', '            \"NsChangeFiles\": [],\\n', '            \"UserRemap\": \"\",\\n', '            \"ShmSize\": 67108864,\\n', '            \"AutoRemove\": false,\\n', '            \"AutoRemoveBak\": false,\\n', '            \"ReadonlyRootfs\": false,\\n', '            \"UTSMode\": \"\",\\n', '            \"UsernsMode\": \"\",\\n', '            \"Sysctls\": {},\\n', '            \"Runtime\": \"lcr\",\\n', '            \"RestartPolicy\": {\\n', '                \"Name\": \"no\",\\n', '                \"MaximumRetryCount\": 0\\n', '            },\\n', '            \"CapAdd\": [],\\n', '            \"CapDrop\": [],\\n', '            \"Dns\": [],\\n', '            \"DnsOptions\": [],\\n', '            \"DnsSearch\": [],\\n', '            \"ExtraHosts\": [],\\n', '            \"HookSpec\": \"\",\\n', '            \"CPUShares\": 0,\\n', '            \"Memory\": 0,\\n', '            \"OomScoreAdj\": 0,\\n', '            \"BlkioWeight\": 0,\\n', '            \"BlkioWeightDevice\": [],\\n', '            \"CPUPeriod\": 0,\\n', '            \"CPUQuota\": 0,\\n', '            \"CPURealtimePeriod\": 0,\\n', '            \"CPURealtimeRuntime\": 0,\\n', '            \"CpusetCpus\": \"\",\\n', '            \"CpusetMems\": \"\",\\n', '            \"SecurityOpt\": [],\\n', '            \"StorageOpt\": {},\\n', '            \"KernelMemory\": 0,\\n', '            \"MemoryReservation\": 0,\\n', '            \"MemorySwap\": 0,\\n', '            \"OomKillDisable\": false,\\n', '            \"PidsLimit\": 0,\\n', '            \"FilesLimit\": 0,\\n', '            \"Ulimits\": [],\\n', '            \"Hugetlbs\": [],\\n', '            \"HostChannel\": {\\n', '                \"PathOnHost\": \"\",\\n', '                \"PathInContainer\": \"\",\\n', '                \"Permissions\": \"\",\\n', '                \"Size\": 0\\n', '            },\\n', '            \"EnvTargetFile\": \"\",\\n', '            \"ExternalRootfs\": \"\"\\n', '        },\\n', '        \"Mounts\": [],\\n', '        \"Config\": {\\n', '            \"Hostname\": \"localhost\",\\n', '            \"User\": \"\",\\n', '            \"Env\": [\\n', '                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\\n', '                \"TERM=xterm\",\\n', '                \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"\\n', '            ],\\n', '            \"Tty\": true,\\n', '            \"Cmd\": [\\n', '                \"sh\"\\n', '            ],\\n', '            \"Entrypoint\": [],\\n', '            \"Labels\": {},\\n', '            \"Annotations\": {\\n', '                \"log.console.file\": \"none\",\\n', '                \"log.console.filerotate\": \"7\",\\n', '                \"log.console.filesize\": \"1MB\",\\n', '                \"rootfs.mount\": \"/var/lib/isulad/mnt/rootfs\",\\n', '                \"native.umask\": \"secure\"\\n', '            },\\n', '            \"HealthCheck\": {\\n', '                \"Test\": [],\\n', '                \"Interval\": 0,\\n', '                \"Timeout\": 0,\\n', '                \"StartPeriod\": 0,\\n', '                \"Retries\": 0,\\n', '                \"ExitOnUnhealthy\": false\\n', '            }\\n', '        },\\n', '        \"NetworkSettings\": {\\n', '            \"IPAddress\": \"\"\\n', '        }\\n', '    }\\n', ']\\n', '查询所有容器信息\\n', '描述\\n', 'isula ps 用于查询所有容器的信息。\\n', '\\n', '用法\\n', 'isula ps [OPTIONS]\\n', '参数\\n', 'ps命令支持参数参考下表。\\n', '\\n', '表 1 ps命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'ps\\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '-a, --all\\n', '\\n', '显示所有的容器\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-q, --quiet\\n', '\\n', '只显示容器名字\\n', '\\n', '-f, --filter\\n', '\\n', '增加筛选过滤条件\\n', '\\n', '--format\\n', '\\n', '按照模板声明的方式输出数据\\n', '\\n', '--no-trunc\\n', '\\n', '不对容器ID进行截断打印\\n', '\\n', '示例\\n', '查询所有容器信息\\n', '\\n', '# isula ps -a\\n', '\\n', 'ID           IMAGE                                     STATUS  PID    COMMAND EXIT_CODE RESTART_COUNT STARTAT        FINISHAT    RUNTIME NAMES\\n', 'e84660aa059c rnd-dockerhub.huawei.com/official/busybox running 304765 \"sh\"    0         0             13 minutes ago -           lcr     e84660aa059cafb0a77a4002e65cc9186949132b8e57b7f4d76aa22f28fde016\\n', '# isula ps -a --format \"table {{.ID}} {{.Image}}\" --no-trunc\\n', 'ID                                                               IMAGE\\n', 'e84660aa059cafb0a77a4002e65cc9186949132b8e57b7f4d76aa22f28fde016 rnd-dockerhub.huawei.com/official/busybox\\n', '\\n', '重启容器\\n', '描述\\n', 'isula restart 用于重启一个或者多个容器。\\n', '\\n', '用法\\n', 'isula restart [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'restart命令支持参数参考下表。\\n', '\\n', '表 1 restart 命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'restart\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-t, --time\\n', '\\n', '先优雅停止，超过这个时间，则强行终止\\n', '\\n', '约束限制\\n', '指定t参数且t<0时，请确保自己容器的应用会处理stop信号。\\n', '\\n', 'restart会首先调用stop停止容器。stop会首先给容器发送stop信号（SIGTERM），然后等待一定的时间（这个时间就是用户输入的 t），过了一定时间如果容器仍处于运行状态，那么就发送kill信号（SIGKILL）使容器强制退出。\\n', '\\n', '输入参数t的含义：\\n', '\\n', 't<0 : 表示一直等待，不管多久都等待程序优雅退出，既然用户这么输入了，表示对自己的应用比较放心，认为自己的程序有合理的stop信号的处理机制。\\n', '\\n', 't=0 ： 表示不等，立即发送kill -9 到容器。\\n', '\\n', 't>0 ： 表示等一定的时间，如果容器还未退出，就发送kill -9 到容器。\\n', '\\n', '所以如果用户使用t<0（比如t=-1），请确保自己容器的应用会正确处理SIGTERM. 如果容器忽略了该信号，会导致isula restart一直卡住。\\n', '\\n', '示例\\n', '重启单个容器\\n', '\\n', '# isula restart c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\\n', ' c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a \\n', '等待容器退出\\n', '描述\\n', 'isula wait用于等待一个或者多个容器退出。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula wait [OPTIONS] CONTAINER [CONTAINER...]\\n', '参数\\n', 'wait命令支持参数参考下表。\\n', '\\n', '表 1 wait命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'wait\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '/\\n', '\\n', '阻塞，直到容器停止，然后打印退出代码\\n', '\\n', '示例\\n', '等待单个容器退出\\n', '\\n', '# isula wait c75284634beeede3ab86c828790b439d16b6ed8a537550456b1f94eb852c1c0a\\n', ' 137 \\n', '查看容器中进程信息\\n', '描述\\n', 'isula top用于查看容器中的进程信息。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula top [OPTIONS] container [ps options]\\n', '参数\\n', 'top命令支持参数参考下表。\\n', '\\n', '表 1 top命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'top\\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '/\\n', '\\n', '查询运行容器的进程信息\\n', '\\n', '示例\\n', '查询容器中进程信息\\n', '\\n', '# isula top 21fac8bb9ea8e0be4313c8acea765c8b4798b7d06e043bbab99fc20efa72629c\\n', 'UID        PID  PPID  C STIME TTY          TIME CMD\\n', 'root     22166 22163  0 23:04 pts/1    00:00:00 sh\\n', '查看容器使用的资源\\n', '描述\\n', 'isula stats用于实时显示资源使用的统计信息。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula stats [OPTIONS] [CONTAINER...]\\n', '参数\\n', 'stats命令支持参数参考下表。\\n', '\\n', '表 1 stats命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'stats\\n', '\\n', '  \\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-a, --all\\n', '\\n', '显示所有容器（默认只显示运行中的容器）\\n', '\\n', '--no-stream\\n', '\\n', '非流式方式的stats，只打印第一次结果\\n', '\\n', '示例\\n', '显示资源使用的统计信息\\n', '\\n', '# isula stats --no-stream 21fac8bb9ea8e0be4313c8acea765c8b4798b7d06e043bbab99fc20efa72629c                                                                                 CONTAINER        CPU %      MEM USAGE / LIMIT          MEM %      BLOCK I / O                PIDS      \\n', '21fac8bb9ea8     0.00       56.00 KiB / 7.45 GiB       0.00       0.00 B / 0.00 B            1  \\n', '获取容器日志\\n', '描述\\n', 'isula logs用于获取容器的日志。仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula logs [OPTIONS] [CONTAINER...]\\n', '参数\\n', 'logs命令支持参数参考下表。\\n', '\\n', '表 1 logs命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'logs\\n', '\\n', '  \\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-f, --follow\\n', '\\n', '跟踪日志输出\\n', '\\n', '--tail\\n', '\\n', '显示日志行数\\n', '\\n', '约束限制\\n', '容器串口logs日志记录功能，默认为开启状态，需要关闭可以通过 isula create –log-opt disable-log=true 或 isula run –log-opt disable-log=true 关闭。\\n', '示例\\n', '获取容器日志\\n', '\\n', '# isula logs 6a144695f5dae81e22700a8a78fac28b19f8bf40e8827568b3329c7d4f742406\\n', 'hello, world\\n', 'hello, world\\n', 'hello, world\\n', '容器与主机之间数据拷贝\\n', '描述\\n', 'isula cp 用于容器与主机之间的数据拷贝，仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH\\n', 'isula cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH\\n', '参数\\n', 'cp命令支持参数参考下表。\\n', '\\n', '表 1 cp命令参数列表\\n', '\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'cp\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '约束限制\\n', 'iSulad在执行拷贝时，不会挂载/etc/hostname， /etc/resolv.conf，/etc/hosts三个文件，也不会对–volume和–mount参数传入的参数挂载到host，所以对这些文件的拷贝使用的是镜像中的原始文件，而不是真实容器中的文件。\\n', '\\n', '# isula cp b330e9be717a:/etc/hostname /tmp/hostname\\n', '# cat /tmp/hostname\\n', '# \\n', 'iSulad在解压文件时，不会对文件系统中即将被覆盖的文件或文件夹做类型判断，而是直接覆盖，所以在拷贝时，如果源为文件夹，同名的文件会被强制覆盖为文件夹；如果源为文件，同名的文件夹会被强制覆盖为文件。\\n', '\\n', '# rm -rf /tmp/test_file_to_dir && mkdir /tmp/test_file_to_dir\\n', '# isula exec b330e9be717a /bin/sh -c \"rm -rf /tmp/test_file_to_dir && touch /tmp/test_file_to_dir\"\\n', '# isula cp b330e9be717a:/tmp/test_file_to_dir /tmp\\n', '# ls -al /tmp | grep test_file_to_dir\\n', '-rw-r-----    1 root     root             0 Apr 26 09:59 test_file_to_dir\\n', 'iSulad 在cp拷贝过程中，会将容器freeze住，在拷贝完成后，恢复容器运行。\\n', '\\n', '示例\\n', '将主机/test/host目录拷贝到容器21fac8bb9ea8的/test目录下。\\n', '\\n', 'isula cp /test/host 21fac8bb9ea8:/test\\n', '将容器21fac8bb9ea8的/www目录拷贝到主机的/tmp目录中。\\n', '\\n', 'isula cp 21fac8bb9ea8:/www /tmp/\\n', '暂停容器\\n', '描述\\n', 'isula pause用于暂停容器中所有的进程，仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula pause CONTAINER [CONTAINER...]\\n', '参数\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'pause\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '约束限制\\n', '只有状态为running的容器可以被执行pause操作\\n', '当容器被pause后，无法执行其他生命周期管理操作（如restart/exec/attach/kill/stop/rm等）\\n', '当带有健康检查配置的容器被pause后，容器状态最终变为unhealthy状态\\n', '示例\\n', '暂停一个正在运行的容器，命令示例如下：\\n', '\\n', '# isula pause 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac\\n', ' 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac \\n', '恢复容器\\n', '描述\\n', 'isula unpause用于恢复容器中所有的进程, 为isula pause的逆过程，仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula unpause CONTAINER [CONTAINER...]\\n', '参数\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'pause\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '约束限制\\n', '只有状态为paused的容器可以被执行unpause操作\\n', '示例\\n', '恢复一个被暂停的容器，命令示例如下：\\n', '\\n', '# isula unpause 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac\\n', ' 8fe25506fb5883b74c2457f453a960d1ae27a24ee45cdd78fb7426d2022a8bac \\n', '从服务端实时获取事件消息\\n', '描述\\n', 'isula events用于从服务端实时获取容器镜像生命周期、运行等事件消息, 仅支持runtime类型为lcr的容器。\\n', '\\n', '用法\\n', 'isula events [OPTIONS]\\n', '参数\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '说明\\n', '\\n', 'events\\n', '\\n', '-H, --host\\n', '\\n', '指定要连接的iSulad socket文件路径\\n', '\\n', '-n, --name\\n', '\\n', '获取指定容器的事件消息\\n', '\\n', '-S, --since\\n', '\\n', '获取指定时间以来的事件消息\\n', '\\n', '示例\\n', '从服务端实时获取事件消息，命令示例如下：\\n', '\\n', '# isula events\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_对接 libvirt.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%AF%B9%E6%8E%A5libvirt.html", "text_entry": "['对接 libvirt\\n', '[[toc]]\\n', '\\n', '概述\\n', 'libvirt 是一个管理 hypervisor 的上层软件，它通过不同的驱动统一管理不同类型的 hypervisor ，并对外提供统一、稳定的应用程序接口。\\n', '\\n', '在云场景中，业内广泛使用 libvirt 管理大规模的虚拟机。为了方便地对大规模的 StratoVirt 虚拟机进行部署、编排和管理，StratoVirt 标准虚拟化支持对接 libvirt，打通了 libvirt 北向接口。用户可以通过 libvirt 对应的 XML 文件描述一个虚拟机，包括虚拟机名称、CPU、磁盘等。\\n', '\\n', '本章介绍 StratoVirt 平台支持的 XML 配置，以及如何使用 virsh 命令管理虚拟机。\\n', '\\n', '前提条件\\n', 'StratoVirt 对接 libvirt，主机需要满足如下条件：\\n', '\\n', '已正确配置 yum 源\\n', '已正确安装并启动 libvirt\\n', '已正确安装 StratoVirt\\n', '虚拟机配置\\n', 'libvirt 工具采用 XML 格式的文件描述一个虚拟机特征，包括虚拟机名称、CPU、内存、磁盘、网卡等信息。用户可以通过修改配置文件，对虚拟机进行管理。\\n', '\\n', 'StratoVirt 对接 libvirt 之前，需要先配置 XML 文件。本小节介绍 StratoVirt 对接 libvirt 时支持的 XML 配置项以及配置方式。\\n', '\\n', '说明\\n', '\\n', '使用 libvirt 管理 StratoVirt 虚拟机前，应该注意到 StratoVirt 当前支持的特性、特性之间的互斥关系、特性的配置前提条件、规格等，详细信息请参见命令行方式的 “虚拟机配置”章节。\\n', '\\n', '虚拟机描述\\n', '虚拟机 XML 文件必须包含描述虚拟机的最基本元素： domain 和 name 。\\n', '\\n', '元素介绍\\n', 'domain ： 虚拟机配置的根元素，用于配置运行 StratoVirt 虚拟机的 hypervisor 类型。\\n', '\\n', '属性 type ：domain 的类型，在 StratoVirt 虚拟化中，该值为 kvm 。\\n', '\\n', 'name ：虚拟机名称。\\n', '\\n', '虚拟机名称是一个长度不超过 255 字符的字符串。同一个主机上的虚拟机名称不能重复，虚拟机名称必须由数字、字母、“_”、“－”、“:” 组成。\\n', '\\n', '配置示例\\n', '假设配置虚拟机名称为 StratoVirt ，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>StratoVirt</name>\\n', '    ... \\n', '</domain>\\n', '虚拟CPU和内存\\n', '本节介绍虚拟 CPU 和虚拟内存的配置。\\n', '\\n', '元素介绍\\n', 'vcpu：虚拟处理器的个数。\\n', '\\n', 'memory：虚拟内存大小。\\n', '\\n', '属性 unit ：指定内存单位，属性值支持 KiB（210 字节）、MiB（220 字节）、GiB（230 字节）、TiB（240 字节）等。\\n', '\\n', '说明\\n', '\\n', 'StratoVirt 暂不支持 CPU 拓扑结构，请勿配置该项。\\n', '\\n', '配置示例\\n', '配置 8GiB 内存，4 个虚拟处理器的示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ... \\n', '    <vcpu>4</vcpu>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    ... \\n', '</domain>\\n', '虚拟机设备\\n', '本节介绍如何使用 XML 文件配置虚拟机设备：磁盘，网卡，rng，balloon，console，vsock 设备。\\n', '\\n', '磁盘\\n', '元素介绍\\n', '属性 type ：指定后端存储介质类型，在 StratoVirt 虚拟化中，该值为 file 。\\n', '\\n', '属性 device：呈现给虚拟机的存储介质类型，在 StratoVirt 虚拟化中，该值为 disk 。\\n', '\\n', 'driver：指定后端驱动的详细信息。\\n', '\\n', '属性 type ：磁盘的格式类型，在 StratoVirt 虚拟化中，该值为 raw 。StratoVirt 当前只支持 raw 格式的磁盘。\\n', '\\n', '属性 iothread：为磁盘配置 iothread ，取值为 iothread 编号。在配置磁盘的 iothread 之前，需使用 iothread 元素配置 iothread 的个数。\\n', '\\n', 'source： 指定后端存储介质。\\n', '\\n', '属性 file：指定磁盘路径。\\n', '\\n', 'target：指定后端驱动的详细信息。\\n', '\\n', '属性 dev：指定磁盘名称。\\n', '\\n', '属性 bus：指定磁盘设备的类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'iotune： 指定磁盘 IO 特性。\\n', '\\n', '属性 total_iops_sec：设置磁盘 iops 的值。\\n', '\\n', 'address：用于设置设备所要挂载的总线属性。\\n', '\\n', '属性 type：总线类型，在 StratoVirt 虚拟化中，该值为 pci 。\\n', '\\n', '属性 domain：虚拟机的域。\\n', '\\n', '属性 bus：设备将要挂载的 bus 号。\\n', '\\n', '属性 slot：设备将要挂载的 slot 号，取值范围为：[0, 31] 。\\n', '\\n', '属性 function：设备将要挂载的 function 号，取值范围为：[0, 7] 。\\n', '\\n', '配置示例\\n', '配置磁盘路径为：/home/openEuler-21.09-stratovirt.img，配置 1 个 iothread，并且磁盘 iothread 配置为 iothread1 ，iops 为 10000，并将其挂载在 bus 为 1、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <iothreads>1</iothreads>\\n', '    <devices>\\n', \"        <disk type='file' device='disk'>\\n\", '\\t    <driver name=\\'qemu\\' type=\\'raw\\' iothread=\"1\"/>\\n', \"\\t    <source file='/home/openEuler-21.09-stratovirt.img'/>\\n\", \"\\t    <target dev='hda' bus='virtio'/>\\n\", '        <iotune>\\n', '        \\t<total_iops_sec>10000</total_iops_sec>    \\n', '        </iotune>\\n', \"\\t    <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x00' />\\n\", '\\t</disk>\\n', '    ...\\n', '    </devices>\\n', '</domain>\\n', '网络设备\\n', '元素介绍\\n', 'interface：网络接口\\n', '\\n', '属性 type：指定网络设备类型。\\n', '\\n', 'mac：虚拟网卡地址\\n', '\\n', '属性 address：虚拟网卡地址。\\n', '\\n', 'source： 指定后端网桥\\n', '\\n', '属性 bridge：指定网桥。\\n', '\\n', 'target：指定后端网卡\\n', '\\n', '属性 dev：指定后端的 tap 设备。\\n', '\\n', 'model： 虚拟网卡类型\\n', '\\n', '属性 type： 虚拟网卡类型，在 StratoVirt 虚拟化中，该值为 virtio。\\n', '\\n', 'driver：用来指定是否开启 vhost 。\\n', '\\n', '属性 name：如果设置 name 为 qemu 则使用 virtio-net 设备，如果不配置 driver 或者 name 值为 vhost ，则使用 vhost-net 设备。\\n', '\\n', '配置示例\\n', '配置网络前请参考 配置linux网桥，配置好 Linux 网桥。配置 mac 地址为：de:ad:be:ef:00:01，网桥为配置好的 br0 ，使用 virtio-net 设备，并将其挂载在 bus 为 2、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <interface type='bridge'>\\n\", \"            <mac address='de:ad:be:ef:00:01' />\\n\", \"            <source bridge='br0'/> \\n\", \"            <model type='virtio'/>\\n\", \"            <driver name='qemu'/>\\n\", \"            <address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x00' />\\n\", '        </interface>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'balloon 设备\\n', '元素介绍\\n', 'memballoon：balloon 设备类型\\n', '\\n', '属性 model ：指定 balloon 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'alias：balloon 设备的别名\\n', '\\n', '属性 name ：balloon 设备的 id 。\\n', '\\n', '属性 autodeflate ：设置 auto deflate（自动收缩）特性，可选值为：on 、off 。\\n', '\\n', '配置示例\\n', '配置 balloon 设备，开启 autodeflate 特性，并将其挂载在 bus 为 3、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <memballoon model='virtio'>\\n\", \"            <alias name='balloon0' autodeflate='on'/>\\n\", '            \\n', \"            <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x00' />\\n\", '        </memballoon>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'console 设备\\n', '由于 console 设备挂载在 virtio-serial 下的总线上，所以在创建 console 设备时，需要创建 virtio-serial 设备。\\n', '\\n', '说明\\n', '\\n', 'StratoVirt 的 console 设备暂时不支持多端口特性，每个虚拟机只能配置一个 console 设备。\\n', '\\n', '元素介绍\\n', 'controller：控制器\\n', '\\n', '属性 type：控制器类型，此处值为 virtio-serial 。\\n', '\\n', 'alias：别名\\n', '\\n', '属性 name：设备的 id。\\n', '\\n', 'console：console 设备\\n', '\\n', '属性 type：指定 console 设备的重定向方式。支持的重定向方式有：pty ， file 和 unix 。\\n', '\\n', 'target：配置 console 设备。\\n', '\\n', '属性 type：指定 console 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', '配置示例\\n', '配置重定向方式为 pty ，并将其挂载在 bus 为 4、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <controller type='virtio-serial'>\\n\", \"            <alias name='virt-serial0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x04' slot='0x00' function='0x00'/>\\n\", '        </controller>\\n', \"        <console type='pty'>\\n\", \"            <target type='virtio'/>\\n\", \"            <alias name='console0'/>\\n\", '        </console>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'rng 设备\\n', '元素介绍\\n', 'rng：rng 设备\\n', '\\n', '属性 model：指定 rng 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'rate：rng 设备产生随机数速率\\n', '\\n', '属性 period ：用于设置随机数产生周期，单位为毫秒，当前 StratoVirt 不支持设置周期值，默认值为1000毫秒，请将该值设置为1000。\\n', '\\n', '属性 bytes ：周期内产生的最大字节数。\\n', '\\n', 'backend：设置 rng 设备后端，值为 host 中 rng 设备的路径\\n', '\\n', '属性 model：用于指定后端设备类型，在 StratoVirt 虚拟化中，该值为 random 。\\n', '\\n', '配置示例\\n', '配置周期为 1000ms 内最多产生 1234 字节，rng 设备在 host 中路径为 /dev/random ，并将其挂载在 bus 为 5、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <rng model='virtio'>\\n\", \"            <rate period='1000' bytes='1234'/>\\n\", \"            <backend model='random'>/dev/random`</backend>\\n\", \"            <address type='pci' domain='0x000' bus='0x05' slot='0x00' function='0x00'/>\\n\", '        </rng>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', 'vsock 设备\\n', '元素介绍\\n', 'vsock：vsock 设备\\n', '\\n', '属性 model：指定 vsock 设备类型，在 StratoVirt 虚拟化中，该值为 virtio 。\\n', '\\n', 'cid ：设置 vsock 设备的 cid\\n', '\\n', '属性 address：用于设置 cid 的值\\n', '\\n', '配置示例\\n', '配置 cid 为 8，并将其挂载在 bus 为 6、slot 为 0，function 为 0 的 PCI 总线上，示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <devices>\\n', \"        <vsock model='virtio'>\\n\", \"            <cid auto='no' address='8'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x06' slot='0x00' function='0x00'/>\\n\", '        </vsock>\\n', '        ...\\n', '    </devices>\\n', '</domain>\\n', '体系架构相关配置\\n', 'XML 中还有一些体系架构相关的配置，如 pflash、主板等。\\n', '\\n', '元素介绍\\n', 'os：定义虚拟机启动参数\\n', '\\n', '子元素 type ：指定虚拟机类型，属性 arch 表示架构，属性 machine 表示主板类型，在 StratoVirt 虚拟化中，AArch64 架构只支持 virt 主板，x86_64 架构只支持 Q35 主板。\\n', '\\n', '子元素 kernel ：用于指定 kernel 路径。\\n', '\\n', '子元素 cmdline ：指定命令行启动参数。\\n', '\\n', '子元素 loader ：指定加载固件，属性 readonly 表示是否只读；属性 type 表示类型，在 StratoVirt 虚拟化中，该值为 pflash 。\\n', '\\n', 'features：hypervisor 支持的以下特性\\n', '\\n', '子元素 acpi ：是否支持 ACPI，在 StratoVirt 虚拟化中使用了 ACPI 特性，所以该特性必须配置。\\n', '\\n', '子元素 gic ：ARM 处理器指定中断处理器，属性 version 表示 GIC 的版本，在 StratoVirt 虚拟化中，该值为 3 。\\n', '\\n', '配置示例\\n', '配置虚拟机 CPU 架构 ARM，主板为 virt ，启动命令行为：console=ttyAMA0 root=/dev/vda reboot=k panic=1 rw 。pflash 路径为：/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw，属性为只读。 kernel 路径为：/home/std-vmlinuxz。示例为：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <os>\\n', \"        <type arch='aarch64' machine='virt'>hvm</type>\\n\", '        <kernel>/home/std-vmlinuxz</kernel>\\n', '        <cmdline>console=ttyAMA0 root=/dev/vda reboot=k panic=1 rw</cmdline>\\n', \"        <loader readonly='yes' type='pflash'>`/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw`</loader>\\n\", '    </os>\\n', '    ...\\n', '</domain>\\n', '内存大页\\n', '元素介绍\\n', 'memoryBacking：表示配置内存相关的信息\\n', '\\n', 'hugepages ：配置内存大页\\n', '\\n', 'page ：大页配置\\n', '\\n', '属性 size ：内存大页的大小\\n', '\\n', '属性 unit ：大页大小的单位\\n', '\\n', '配置示例\\n', '配置 2MiB 大页示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', '    <memoryBacking>\\n', '    <hugepages>\\n', \"        <page size='2' unit='MiB' />\\n\", '    </hugepages>\\n', '    </memoryBacking>\\n', '    ...\\n', '</domain>\\n', '配置示例\\n', 'x86 配置示例\\n', '配置一台名为 StratoVirt ，内存 8GiB ，配置 1GiB 单位的内存大页，4 个虚拟 CPU，架构为 x86_64 ，主板类型为 Q35 ，对应 XML 文件的配置示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>StratoVirt</name>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    <!-- hugepages -->\\n', '    <memoryBacking>\\n', '    <hugepages>\\n', \"        <page size='1' unit='GiB' />\\n\", '    </hugepages>\\n', '    </memoryBacking>\\n', '    <vcpu>4</vcpu>\\n', '    <!-- iothread -->\\n', '    <iothreads>1</iothreads>\\n', '    <os>\\n', \"    <type arch='x86_64' machine='q35'>hvm</type>\\n\", '    <kernel>/path/to/standard_vm_kernel</kernel>\\n', '    <cmdline>console=hvc0 root=/dev/vda reboot=k panic=1 rw</cmdline>\\n', \"    <loader readonly='yes' type='pflash'>/path/to/pflash</loader>\\n\", '    <nvram>/path/to/OVMF_VARS</nvram>\\n', '    </os>\\n', '    <features>\\n', '        <acpi/>\\n', '    </features>\\n', '    <devices>\\n', '        <emulator>/path/to/StratoVirt_binary_file</emulator>\\n', \"        <controller type='pci' index='0' model='pcie-root' />\\n\", '        <!-- pcie-root-port -->\\n', \"        <controller type='pci' index='1' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='2' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='3' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='4' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='5' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='6' model='pcie-root-port' />\\n\", \"        <controller type='pci' index='7' model='pcie-root-port' />\\n\", '        <!-- block -->\\n', \"        <disk type='file' device='disk'>\\n\", \"            <driver name='qemu'  type='raw' iothread='1'/>\\n\", \"            <source file='/path/to/rootfs'/>\\n\", \"            <target dev='hda' bus='virtio'/>\\n\", '            <iotune>\\n', '                <total_iops_sec>1000</total_iops_sec>\\n', '            </iotune>\\n', \"            <address type='pci' domain='0x000' bus='0x01' slot='0x00' function='0x00'/>\\n\", '        </disk>\\n', '        <!-- net -->\\n', \"        <interface type='bridge'>\\n\", \"            <mac address='de:ad:be:ef:00:01'/>\\n\", \"            <source bridge='qbr0'/>\\n\", \"            <model type='virtio'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x02' slot='0x00' function='0x00'/>\\n\", '        </interface>\\n', '        <!-- virtio-serial -->\\n', \"        <controller type='virtio-serial' index='0'>\\n\", \"            <alias name='virt-serial0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x03' slot='0x00' function='0x00'/>\\n\", '        </controller>\\n', \"        <console type='pty'>\\n\", \"            <target type='virtio' port='0'/>\\n\", \"            <alias name='console0'/>\\n\", '        </console>\\n', '        <!-- balloon -->\\n', \"        <memballoon model='virtio'>\\n\", \"            <alias name='balloon0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x04' slot='0x00' function='0x00'/>\\n\", '        </memballoon>\\n', '        <!-- rng -->\\n', \"        <rng model='virtio'>\\n\", \"            <rate period='1000' bytes='1234'/>\\n\", \"            <backend model='random'>/path/to/random_file</backend>\\n\", \"            <address type='pci' domain='0x000' bus='0x05' slot='0x00' function='0x00'/>\\n\", '        </rng>\\n', '        <!-- vsock -->\\n', \"        <vsock model='virtio'>\\n\", \"            <cid auto='no' address='3'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x06' slot='0x00' function='0x00'/>\\n\", '        </vsock>\\n', '    </devices>\\n', '</domain>\\n', 'ARM 配置示例\\n', '如果想要配置一台名为 StratoVirt ，内存 8GiB，配置 1GiB 单位大页，4 个虚拟 CPU，架构为 aarch64 ，主板类型为 virt ，对应 XML 文件的配置示例如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    <name>StratoVirt</name>\\n', \"    <memory unit='GiB'>8</memory>\\n\", '    <!-- hugepages -->\\n', '    <memoryBacking>\\n', '    <hugepages>\\n', \"        <page size='1' unit='GiB' />\\n\", '    </hugepages>\\n', '    </memoryBacking>\\n', '    <vcpu>4</vcpu>\\n', '    <!-- iothread -->\\n', '    <iothreads>1</iothreads>\\n', '    <os>\\n', \"    <type arch='aarch64' machine='virt'>hvm</type>\\n\", '    <kernel>/path/to/standard_vm_kernel</kernel>\\n', '    <cmdline>console=ttyAMA0 root=/dev/vda reboot=k panic=1 rw</cmdline>\\n', \"    <loader readonly='yes' type='pflash'>/path/to/pflash</loader>\\n\", '    </os>\\n', '    <features>\\n', '        <acpi/>\\n', \"        <gic version='3'/>\\n\", '    </features>\\n', '    <devices>\\n', '        <emulator>/path/to/StratoVirt_binary_file</emulator>\\n', \"        <controller type='pci' index='0' model='pcie-root'/>\\n\", '        <!-- block -->\\n', \"        <disk type='file' device='disk'>\\n\", \"            <driver name='qemu'  type='raw' iothread='1'/>\\n\", \"            <source file='/path/to/rootfs'/>\\n\", \"            <target dev='hda' bus='virtio'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x01' function='0x00'/>\\n\", '            <iotune>\\n', '                <total_iops_sec>1000</total_iops_sec>\\n', '            </iotune>\\n', '        </disk>\\n', '        <!-- net -->\\n', \"        <interface type='bridge'>\\n\", \"            <mac address='de:ad:be:ef:00:01'/>\\n\", \"            <source bridge='qbr0'/>\\n\", \"            <model type='virtio'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x02' function='0x00'/>\\n\", '        </interface>\\n', '        <!-- virtio-serial -->\\n', \"        <controller type='virtio-serial' index='0'>\\n\", \"            <alias name='virt-serial0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x03' function='0x00'/>\\n\", '        </controller>\\n', \"        <console type='pty'>\\n\", \"            <target type='virtio' port='0'/>\\n\", \"            <alias name='console0'/>\\n\", '        </console>\\n', '        <!-- balloon -->\\n', \"        <memballoon model='virtio'>\\n\", \"            <alias name='balloon0'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x04' function='0x00'/>\\n\", '        </memballoon>\\n', '        <!-- rng -->\\n', \"        <rng model='virtio'>\\n\", \"            <rate period='1000' bytes='1234'/>\\n\", \"            <backend model='random'>/path/to/random_file</backend>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x05' function='0x00'/>\\n\", '        </rng>\\n', '        <!-- vsock -->\\n', \"        <vsock model='virtio'>\\n\", \"            <cid auto='no' address='3'/>\\n\", \"            <address type='pci' domain='0x000' bus='0x00' slot='0x06' function='0x00'/>\\n\", '        </vsock>\\n', '    </devices>\\n', '</domain>\\n', '管理虚拟机\\n', 'libvirt 使用 virsh 命令来管理虚拟机，当 StratoVirt 平台和 libvirt 对接时，仅支持以下与 StratoVirt 交互的命令：\\n', '\\n', 'create：创建虚拟机\\n', '\\n', 'suspend：挂起虚拟机\\n', '\\n', 'resume：恢复虚拟机\\n', '\\n', 'destroy：销毁虚拟机\\n', '\\n', 'console：通过 console 登录虚拟机\\n', '\\n', '说明\\n', '\\n', 'StratoVirt 暂不支持虚拟机重启、虚拟机关机等命令。\\n', '\\n', '管理虚拟机生命周期\\n', '假设用户已经按照需要完成一个名为 StratoVirt 的虚拟机配置文件 st.xml ，则对应生命周期管理的命令如下：\\n', '\\n', '创建虚拟机\\n', '\\n', 'virsh create st.xml\\n', '虚拟机创建完成后，可以通过 virsh list 命令查看，会存在一个名为 StratoVirt 的虚拟机。\\n', '\\n', '挂起虚拟机\\n', '\\n', 'virsh suspend StratoVirt\\n', '虚拟机挂起后，虚拟机暂停运行。可以通过 virsh list 命令查看，虚拟机 StratoVirt 的状态为 paused 。\\n', '\\n', '恢复虚拟机\\n', '\\n', 'virsh resume StratoVirt\\n', '虚拟机恢复后，可以通过 virsh list 命令查看，虚拟机 StratoVirt 的状态为 running 。\\n', '\\n', '销毁虚拟机\\n', '\\n', 'virsh destroy StratoVirt\\n', '虚拟机销毁后，使用 virsh list 查看虚拟机，发现虚拟机 StratoVirt 不存在。\\n', '\\n', '登录虚拟机\\n', '虚拟机创建完成后，可以通过 virsh console 登录虚拟机内部操作虚拟机。假设虚拟机名称为 StratoVirt，参考命令如下：\\n', '\\n', 'virsh console StratoVirt\\n', '说明\\n', '\\n', '为了可以正常使用 virsh console 命令，需要在 XML 中配置 console 设备的重定向类型为 pty 。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_容器镜像构建.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/isula-build%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.html", "text_entry": "['容器镜像构建\\n', '概述\\n', '安装\\n', '环境准备\\n', '安装isula-build\\n', '配置与管理服务\\n', '配置服务\\n', '管理服务\\n', '通过 systemd 管理（推荐方式）\\n', '直接运行 isula-build 服务端\\n', '使用指南\\n', '前提条件\\n', '总体说明\\n', 'ctr-img: 容器镜像管理\\n', 'build: 容器镜像构建\\n', 'image: 查看本地持久化构建镜像\\n', 'import: 导入容器基础镜像\\n', 'load: 导入层叠镜像\\n', 'rm: 删除本地持久化镜像\\n', 'save: 导出层叠镜像\\n', 'tag: 给本地持久化镜像打标签\\n', 'pull: 拉取镜像到本地\\n', 'push: 将本地镜像推送到远程仓库\\n', 'info: 查看运行环境与系统信息\\n', 'login: 登录远端镜像仓库\\n', 'logout: 退出远端镜像仓库\\n', 'version: 版本查询\\n', 'manifest: manifest列表管理（实验特性）\\n', 'create: manifest列表创建\\n', 'annotate: manifest列表更新\\n', 'inspect: manifest列表查询\\n', 'push: 将manifest列表推送到远程仓库\\n', '直接集成容器引擎\\n', '与iSulad集成\\n', '与Docker集成\\n', '使用注意事项\\n', '约束和限制\\n', '与“docker build”差异\\n', '附录\\n', '命令行参数说明\\n', '通信矩阵\\n', '文件与权限\\n', '概述\\n', 'isula-build是iSula容器团队推出的容器镜像构建工具，支持通过Dockerfile文件快速构建容器镜像。\\n', '\\n', 'isula-build采用服务端/客户端模式，其中，isula-build为客户端，提供了一组命令行工具，用于镜像构建及管理等；isula-builder为服务端，用于处理客户端管理请求，作为守护进程常驻后台。\\n', '\\n', 'isula-build architecture\\n', '\\n', ' 说明：\\n', '\\n', 'isula-build当前支持OCI镜像格式（OCI Image Format Specification）以及Docker镜像格式（Image Manifest Version 2, Schema 2）。通过命令`export ISULABUILD_CLI_EXPERIMENTAL=enabled开启实验特性以支持OCI镜像格式。不开启实验特性时，isula-build默认采用Docker镜像格式；当开启实验特性后，将默认采用OCI镜像格式。\\n', '安装\\n', '环境准备\\n', '为了确保isula-build成功安装，需满足以下软件硬件要求。\\n', '\\n', '支持的机器架构：x86_64 和 AArch64\\n', '支持的操作系统：openEuler\\n', '用户具有root权限。\\n', '安装isula-build\\n', '使用isula-build构建容器镜像，需要先安装以下软件包。\\n', '\\n', '（推荐）方法一：使用yum安装\\n', '\\n', '配置openEuler yum源。\\n', '\\n', '使用root权限，登录目标服务器，安装isula-build。\\n', '\\n', 'sudo yum install -y isula-build\\n', '方法二：使用rpm包安装\\n', '\\n', '从openEuler yum源中获取isula-build对应安装包isula-build-*.rpm。例如isula-build-0.9.6-4.oe1.x86_64.rpm。\\n', '\\n', '将获取的rpm软件包上传至目标服务器的任一目录，例如 /home/。\\n', '\\n', '使用root权限，登录目标服务器，参考如下命令安装isula-build。\\n', '\\n', 'sudo rpm -ivh /home/isula-build-*.rpm\\n', ' 说明：\\n', '\\n', '安装完成后，需要手工启动isula-build服务。启动请参见\"管理服务\"。\\n', '配置与管理服务\\n', '配置服务\\n', '在安装完 isula-build 软件包之后，systemd 管理服务会以 isula-build 软件包自带的 isula-build 服务端默认配置启动 isula-build 服务。如果 isula-build 服务端的默认配置文件不能满足用户的需求，可以参考如下介绍进行定制化配置。需要注意的是，修改完默认配置之后，需要重启 isula-build 服务端使新配置生效，具体操作可参考下一章节。\\n', '\\n', '目前 isula-build 服务端包含如下配置文件：\\n', '\\n', '/etc/isula-build/configuration.toml：isula-builder 总体配置文件，用于设置 isula-builder 日志级别、持久化目录和运行时目录、OCI runtime等。其中各参数含义如下：\\n', '配置项\\t是否可选\\t配置项含义\\t配置项取值\\n', 'debug\\t可选\\t设置是否打开debug日志\\ttrue：打开debug日志\\n', 'false：关闭debug日志\\n', 'loglevel\\t可选\\t设置日志级别\\tdebug\\n', 'info\\n', 'warn\\n', 'error\\n', 'run_root\\t必选\\t设置运行时数据根目录\\t运行时数据根目录路径，例如/var/run/isula-build/\\n', 'data_root\\t必选\\t设置本地持久化目录\\t本地持久化目录路径，例如/var/lib/isula-build/\\n', 'runtime\\t可选\\t设置runtime种类，目前仅支持runc\\trunc\\n', 'group\\t可选\\t设置本地套接字isula_build.sock文件属组使得加入该组的非特权用户可以操作isula-build\\tisula\\n', 'experimental\\t可选\\t设置是否开启实验特性\\ttrue：开启实验特性；false：关闭实验特性\\n', '/etc/isula-build/storage.toml: 本地持久化存储的配置文件，包含所使用的存储驱动的配置。\\n', '配置项\\t是否可选\\t配置项含义\\n', 'driver\\t可选\\t存储驱动类型，目前支持overlay2\\n', '更多设置可参考 containers-storage.conf.5.md。\\n', '\\n', '/etc/isula-build/registries.toml : 针对各个镜像仓库的配置文件。\\n', '配置项\\t是否可选\\t配置项含义\\n', 'registries.search\\t可选\\t镜像仓库搜索域，在此list的镜像仓库可以被感知，不在此列的不被感知。\\n', 'registries.insecure\\t可选\\t可访问的不安全镜像仓库地址，在此列表中的镜像仓库将不会通过鉴权，不推荐使用。\\n', '更多设置可参考 containers-registries.conf.5.md。\\n', '\\n', '/etc/isula-build/policy.json：镜像pull/push策略文件。注：当前不支持对其进行配置\\n', ' 说明：\\n', '\\n', 'isula-build 支持最大 1MiB 的上述配置文件。\\n', 'isula-build 不支持将持久化工作目录 dataroot 配置在内存盘上，比如 tmpfs。\\n', 'isula-build 目前仅支持使用overlay2为底层 graphdriver。\\n', '在设置–group参数前，需保证本地OS已经创建了对应的用户组，且非特权用户已经加入该组。重启isula-builder之后即可使该非特权用户使用isula-build功能。同时，为了保持权限一致性，isula-build的配置文件目录/etc/isula-build的属组也会被设置为–group指定的组。\\n', '管理服务\\n', '目前 openEuler 采用 systemd 管理软件服务，isula-build 软件包已经自带了 systemd 的服务文件，用户安装完 isula-build 软件包之后可以直接通过 systemd 工具对它进行服务启停等操作。用户同样可以手动启动 isula-build 服务端软件。需要注意的是，同一个节点上不可以同时启动多个 isula-build 服务端软件。\\n', '\\n', ' 说明：\\n', '\\n', '同一个节点上不可以同时启动多个 isula-build 服务端软件。\\n', '通过 systemd 管理（推荐方式）\\n', '用户可以通过如下 systemd 的标准指令控制 isula-build 服务的启动、停止、重启等动作：\\n', '\\n', '启动 isula-build 服务：\\n', '\\n', 'sudo systemctl start isula-build.service\\n', '停止 isula-build 服务：\\n', '\\n', 'sudo systemctl stop isula-build.service\\n', '重启 isula-builder 服务：\\n', '\\n', 'sudo systemctl restart isula-build.service\\n', 'isula-build 软件包安装的 systemd 服务文件保存在 /usr/lib/systemd/system/isula-build.service。如果用户需要修改 isula-build 服务的 systemd 配置，可以修改该文件，执行如下命令使配置生效，之后再根据上面提到的 systemd 管理指令重启 isula-build 服务\\n', '\\n', 'sudo systemctl daemon-reload\\n', '直接运行 isula-build 服务端\\n', '您也可以通过执行 isula-build 服务端命令（ isula-builder）的方式启动服务。其中，服务端启动配置，可通过isula-builder命令支持的 flags 设置。isula-build 服务端目前支持的 flags 如下：\\n', '\\n', '-D, –debug: 是否开启调测模式。\\n', '–log-level: 日志级别，支持 “debug”, “info”, “warn” or “error”，默认为 “info”。\\n', '–dataroot: 本地持久化路径，默认为”/var/lib/isula-build/“。\\n', '–runroot: 运行时路径，默认为”/var/run/isula-build/“。\\n', '–storage-driver：底层存储驱动类型。\\n', '–storage-opt: 底层存储驱动配置。\\n', '–group: 设置本地套接字isula_build.sock文件属组使得加入该组的非特权用户可以操作isula-build，默认为“isula”。\\n', '–experimental: 是否开启实验特性，默认为false。\\n', ' 说明：\\n', '\\n', '当命令行启动参数中传递了与配置文件相同的配置选项时，优先使用命令行参数启动。\\n', '启动 isula-build 服务。例如指定本地持久化路径/var/lib/isula-build，且不开启调试的参考命令如下：\\n', '\\n', 'sudo isula-builder --dataroot \"/var/lib/isula-build\" --debug=false\\n', '使用指南\\n', '前提条件\\n', 'isula-build 构建 Dockerfile 内的 RUN 指令时依赖可执行文件 runc ，需要 isula-build 的运行环境上预装好 runc。安装方式视用户使用场景而定，如果用户不需要使用完整的 docker-engine 工具链，则可以仅安装 docker-runc rpm包：\\n', '\\n', 'sudo yum install -y docker-runc\\n', '如果用户需要使用完整的 docker-engine 工具链，则可以安装 docker-engine rpm包，默认包含可执行文件 runc ：\\n', '\\n', 'sudo yum install -y docker-engine\\n', ' 说明：\\n', '\\n', '用户需保证OCI runtime（runc）可执行文件的安全性，避免被恶意替换。\\n', '总体说明\\n', 'isula-build 客户端提供了一系列命令用于构建和管理容器镜像，当前 isula-build 包含的命令行指令如下：\\n', '\\n', 'ctr-img，容器镜像管理。ctr-img又包含如下子命令：\\n', 'build，根据给定dockerfile构建出容器镜像。\\n', 'images，列出本地容器镜像。\\n', 'import，导入容器基础镜像。\\n', 'load，导入层叠镜像。\\n', 'rm，删除本地容器镜像。\\n', 'save，导出层叠镜像至本地磁盘。\\n', 'tag，给本地容器镜像打tag。\\n', 'pull，拉取镜像到本地。\\n', 'push，推送本地镜像到远程仓库。\\n', 'info，查看isula-build的运行环境和系统信息。\\n', 'login，登录远端容器镜像仓库。\\n', 'logout，退出远端容器镜像仓库。\\n', 'version，查看isula-build和isula-builder的版本号。\\n', 'manifest（实验特性），管理manifest列表。\\n', ' 说明：\\n', '\\n', 'isula-build completion 和 isula-builder completion 命令用于生成bash命令补全脚本。该命令为命令行框架隐式提供，不会显示在help信息中。\\n', 'isula-build客户端不包含配置文件，当用户需要使用isula-build实验特性时，需要在客户端通过命令export ISULABUILD_CLI_EXPERIMENTAL=enabled配置环境变量ISULABUILD_CLI_EXPERIMENTAL来开启实验特性。\\n', '以下按照上述维度依次详细介绍这些命令行指令的使用。\\n', '\\n', 'ctr-img: 容器镜像管理\\n', 'isula-build 将所有容器镜像管理相关命令划分在子命令 ctr-img 下，命令原型为：\\n', '\\n', 'isula-build ctr-img [command]\\n', 'build: 容器镜像构建\\n', 'ctr-img 的子命令 build 用于构建容器镜像，命令原型为：\\n', '\\n', 'isula-build ctr-img build [flags]\\n', '其中 build 包含如下 flags：\\n', '\\n', '–build-arg：string列表，构建过程中需要用到的变量。\\n', '–build-static：KeyValue值，构建二进制一致性。目前包含如下Key值：\\n', 'build-time：string，使用固定时间戳来构建容器镜像；时间戳格式为“YYYY-MM-DD HH-MM-SS”。\\n', '-f, –filename：string，Dockerfile的路径，不指定则是使用当前路径的Dockerfile文件。\\n', '–format： string, 设置构建镜像的镜像格式：oci | docker（需开启实验特性选项）。\\n', '–iidfile：string，输出 image ID 到本地文件。\\n', '-o, –output：string，镜像导出的方式和路径。\\n', '–proxy：布尔值，继承主机侧环境的proxy环境变量（默认为true）。\\n', '–tag：string，设置构建成功的镜像的tag值。\\n', '–cap-add：string列表，构建过程中RUN指令所需要的权限。\\n', '以下为各个 flags 的详解。\\n', '\\n', '--build-arg\\n', '\\n', '从命令行接受参数作为Dockerfile中的参数，用法：\\n', '\\n', '$ echo \"This is bar file\" > bar.txt\\n', '$ cat Dockerfile_arg\\n', 'FROM busybox\\n', 'ARG foo\\n', 'ADD ${foo}.txt .\\n', 'RUN cat ${foo}.txt\\n', '$ sudo isula-build ctr-img build --build-arg foo=bar -f Dockerfile_arg\\n', 'STEP  1: FROM busybox\\n', 'Getting image source signatures\\n', 'Copying blob sha256:8f52abd3da461b2c0c11fda7a1b53413f1a92320eb96525ddf92c0b5cde781ad\\n', 'Copying config sha256:e4db68de4ff27c2adfea0c54bbb73a61a42f5b667c326de4d7d5b19ab71c6a3b\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'STEP  2: ARG foo\\n', 'STEP  3: ADD ${foo}.txt .\\n', 'STEP  4: RUN cat ${foo}.txt\\n', 'This is bar file\\n', 'Getting image source signatures\\n', 'Copying blob sha256:6194458b07fcf01f1483d96cd6c34302ffff7f382bb151a6d023c4e80ba3050a\\n', 'Copying blob sha256:6bb56e4a46f563b20542171b998cb4556af4745efc9516820eabee7a08b7b869\\n', 'Copying config sha256:39b62a3342eed40b41a1bcd9cd455d77466550dfa0f0109af7a708c3e895f9a2\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Build success with image id: 39b62a3342eed40b41a1bcd9cd455d77466550dfa0f0109af7a708c3e895f9a2\\n', '--build-static\\n', '\\n', '指定为静态构建，即使用isula-build构建容器镜像时消除所有时间戳和其他构建因素（例如容器ID、hostname等）的差异。最终构建出满足静态要求的容器镜像。\\n', '\\n', '在使用isula-build进行容器镜像构建时，假如给 build 子命令一个固定的时间戳，并在限定如下条件的时候：\\n', '\\n', '构建环境前后保持一致。\\n', '构建Dockerfile前后保持一致。\\n', '构建产生的中间数据前后保持一致。\\n', '构建命令相同。\\n', '第三方库版本一致。\\n', '对于容器镜像构建，isula-build支持相同的Dockerfile。如果构建环境相同，则多次构建生成的镜像内容和镜像ID相同。\\n', '\\n', '–build-static接受k=v形式的键值对选项，当前支持的选项有：\\n', '\\n', 'build-time：字符串类型。构建静态镜像的固定时间戳，格式为“YYYY-MM-DD HH-MM-SS”。时间戳影响diff层创建修改时间的文件属性。\\n', '\\n', '使用示例如下：\\n', '\\n', \"$ sudo isula-build ctr-img build -f Dockerfile --build-static='build-time=2020-05-23 10:55:33' .\\n\", '以此方式，同一环境多次构建出来的容器镜像和镜像ID均会保持一致。\\n', '\\n', '--format 开始实验特性后该选项可用，默认为OCI镜像格式。可以手动指定镜像格式进行构建，例如，下面分别为构建OCI镜像格式以及Docker镜像格式镜像的命令。\\n', '\\n', '$ export ISULABUILD_CLI_EXPERIMENTAL=enabled; sudo isula-build ctr-img build -f Dockerfile --format oci .\\n', '$ export ISULABUILD_CLI_EXPERIMENTAL=enabled; sudo isula-build ctr-img build -f Dockerfile --format docker .\\n', '--iidfile\\n', '\\n', '将构建的镜像ID输出到文件，用法：\\n', '\\n', 'isula-build ctr-img build --iidfile filename\\n', '例如，将容器镜像ID输出到testfile的参考命令如下：\\n', '\\n', '$ sudo isula-build ctr-img build -f Dockerfile_arg --iidfile testfile\\n', '查看testfile中的容器镜像ID：\\n', '\\n', '$ cat testfile\\n', '76cbeed38a8e716e22b68988a76410eaf83327963c3b29ff648296d5cd15ce7b\\n', '-o, –output\\n', '\\n', '目前 -o, –output 支持如下形式：\\n', '\\n', 'isulad:image:tag：将构建成功的镜像直接推送到 iSulad。比如：-o isulad:busybox:latest。同时需要注意如下约束：\\n', '\\n', 'isula-build 和 iSulad 必须在同一个节点上\\n', 'tag必须配置\\n', 'isula-build client端需要将构建成功的镜像暂存成 /var/tmp/isula-build-tmp-%v.tar 再导入至 iSulad，用户需要保证 /var/tmp/ 目录有足够磁盘空间\\n', 'docker-daemon:image:tag：将构建成功的镜像直接推送到 Docker daemon。比如：-o docker-daemon:busybox:latest。同时需要注意如下约束：\\n', '\\n', 'isula-build 和 docker 必须在同一个节点上\\n', 'tag必须配置\\n', 'docker://registry.example.com/repository:tag：将构建成功的镜像以Docker镜像格式直接推送到远端镜像仓库。比如：-o docker://localhost:5000/library/busybox:latest。\\n', '\\n', 'docker-archive:<path>/<filename>:image:tag：将构建成功的镜像以Docker镜像格式保存至本地。比如：-o docker-archive:/root/image.tar:busybox:latest。\\n', '\\n', '打开实验特性之后，可以启用相应OCI镜像的构建：\\n', '\\n', 'oci://registry.example.com/repository:tag：将构建成功的镜像以OCI镜像格式直接推送到远端镜像仓库（远程镜像仓库须支持OCI镜像格式）。比如：-o oci://localhost:5000/library/busybox:latest。\\n', '\\n', 'oci-archive:<path>/<filename>:image:tag：将构建成功的镜像以OCI镜像的格式保存至本地。比如：-o oci-archive:/root/image.tar:busybox:latest。\\n', '\\n', '除去各个flags之外，build子命令的命令行最后还会接收一个argument，该argument类型是string，意义为context，即该Dockerfile构建环境的上下文。该参数默认值为isula-build被执行的当前路径。该路径会影响 .dockerignore 和 Dockerfile的ADD/COPY指令 所检索的路径。\\n', '\\n', '--proxy\\n', '\\n', '选择构建时RUN指令启动的容器是否从环境上继承proxy相关环境变量”http_proxy”,“https_proxy”,“ftp_proxy”,“no_proxy”,“HTTP_PROXY”,“HTTPS_PROXY”,“FTP_PROXY”,“NO_PROXY”，默认为true。\\n', '\\n', '当用户在Dockerfile配置proxy相关ARG或ENV，将覆盖所继承的环境变量。\\n', '\\n', '注意：若client与daemon不在同一个终端运行，所能继承的环境变量为daemon所在终端的环境变量。\\n', '\\n', '--tag\\n', '\\n', '设置镜像构建成功之后，该镜像在本地磁盘存储时的tag。\\n', '\\n', '--cap-add\\n', '\\n', '添加构建过程中RUN指令所需权限，用法：\\n', '\\n', 'isula-build ctr-img build --cap-add ${CAP}\\n', '使用举例：\\n', '\\n', '$ sudo isula-build ctr-img build --cap-add CAP_SYS_ADMIN --cap-add CAP_SYS_PTRACE -f Dockerfile\\n', ' 说明：\\n', '\\n', 'isula-build最大支持并发构建100个容器镜像。\\n', 'isula-build支持Dockerfile最大为1MiB。\\n', 'isula-build支持 .dockerignore 最大为 1MiB。\\n', '用户需保证Dockerfile文件的权限为仅当前用户可读写，避免别的用户进行篡改。\\n', '构建时，RUN指令会启动容器在容器内进行构建，目前 isula-build 仅支持使用主机网络。\\n', 'isula-build 导出的镜像压缩格式，目前仅支持tar格式。\\n', 'isula-build 在每一个镜像构建stage完成后做一次提交，而不是每执行 Dockerfile的一行就提交一次。\\n', 'isula-build 暂不支持构建缓存。\\n', 'isula-build 仅在构建RUN指令时会启动构建容器。\\n', '目前不支持docker镜像格式的history功能。\\n', 'isula-build 的stage name支持以数字开头。\\n', 'isula-build 的stage name最长可为64个字符。\\n', 'isula-build 暂不支持对单次Dockerfile的构建进行资源限制。如有资源限制需求，可通过对 isula-builder 服务端配置资源限额的方式进行限制。\\n', 'isula-build 目前不支持Dockerfile里的ADD指令提供的数据来源是远端url。\\n', 'isula-build 使用docker-archive以及oci-archive类型导出的本地tar包未经压缩。如有需求，用户可以手动进行压缩。\\n', 'image: 查看本地持久化构建镜像\\n', '可通过images命令查看当前本地持久化存储的镜像：\\n', '\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                   SIZE\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'localhost:5000/library/alpine            latest       a24bb4013296       2022-01-17 10:02:19       5.85 MB\\n', '<none>                                   <none>       39b62a3342ee       2022-01-17 10:01:12       1.45 MB\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', ' 说明：\\n', '\\n', '通过isula-build ctr-img images查看的镜像大小与docker images的显示上有一定差异。这是因为统计镜像大小时，isula-build是直接计算每层tar包大小之和，而docker是通过解压tar遍历diff目录计算文件大小之和，因此存在统计上的差异。\\n', 'import: 导入容器基础镜像\\n', '可以通过ctr-img import指令将rootfs形式的tar文件导入到isula-build中。\\n', '\\n', '命令原型如下：\\n', '\\n', 'isula-build ctr-img import [flags]\\n', '使用举例：\\n', '\\n', '$ sudo isula-build ctr-img import busybox.tar mybusybox:latest\\n', 'Getting image source signatures\\n', 'Copying blob sha256:7b8667757578df68ec57bfc9fb7754801ec87df7de389a24a26a7bf2ebc04d8d\\n', 'Copying config sha256:173b3cf612f8e1dc34e78772fcf190559533a3b04743287a32d549e3c7d1c1d1\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Import success with image id: \"173b3cf612f8e1dc34e78772fcf190559533a3b04743287a32d549e3c7d1c1d1\"\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                   SIZE\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'mybusybox                                latest       173b3cf612f8       2022-01-12 16:02:31       1.47 MB\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', ' 说明：\\n', '\\n', 'isula-build 支持导入最大1GiB的容器基础镜像。\\n', 'load: 导入层叠镜像\\n', '层叠镜像指的是通过 docker save 或 isula-build ctr-img save 等指令，将一个构建完成的镜像保存至本地之后，镜像压缩包内是一层一层 layer.tar 的镜像包。可以通过 ctr-img load 指令将它导入至 isula-build。\\n', '\\n', '命令原型如下：\\n', '\\n', 'isula-build ctr-img load [flags]\\n', '目前支持的 flags 为：\\n', '\\n', '-i, –input：本地tar包的路径\\n', '使用举例如下：\\n', '\\n', '$ sudo isula-build ctr-img load -i ubuntu.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:cf612f747e0fbcc1674f88712b7bc1cd8b91cf0be8f9e9771235169f139d507c\\n', 'Copying blob sha256:f934e33a54a60630267df295a5c232ceb15b2938ebb0476364192b1537449093\\n', 'Copying blob sha256:943edb549a8300092a714190dfe633341c0ffb483784c4fdfe884b9019f6a0b4\\n', 'Copying blob sha256:e7ebc6e16708285bee3917ae12bf8d172ee0d7684a7830751ab9a1c070e7a125\\n', 'Copying blob sha256:bf6751561805be7d07d66f6acb2a33e99cf0cc0a20f5fd5d94a3c7f8ae55c2a1\\n', 'Copying blob sha256:c1bd37d01c89de343d68867518b1155cb297d8e03942066ecb44ae8f46b608a3\\n', 'Copying blob sha256:a84e57b779297b72428fc7308e63d13b4df99140f78565be92fc9dbe03fc6e69\\n', 'Copying blob sha256:14dd68f4c7e23d6a2363c2320747ab88986dfd43ba0489d139eeac3ac75323b2\\n', 'Copying blob sha256:a2092d776649ea2301f60265f378a02405539a2a68093b2612792cc65d00d161\\n', 'Copying blob sha256:879119e879f682c04d0784c9ae7bc6f421e206b95d20b32ce1cb8a49bfdef202\\n', 'Copying blob sha256:e615448af51b848ecec00caeaffd1e30e8bf5cffd464747d159f80e346b7a150\\n', 'Copying blob sha256:f610bd1e9ac6aa9326d61713d552eeefef47d2bd49fc16140aa9bf3db38c30a4\\n', 'Copying blob sha256:bfe0a1336d031bf5ff3ce381e354be7b2bf310574cc0cd1949ad94dda020cd27\\n', 'Copying blob sha256:f0f15db85788c1260c6aa8ad225823f45c89700781c4c793361ac5fa58d204c7\\n', 'Copying config sha256:c07ddb44daa97e9e8d2d68316b296cc9343ab5f3d2babc5e6e03b80cd580478e\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Loaded image as c07ddb44daa97e9e8d2d68316b296cc9343ab5f3d2babc5e6e03b80cd580478e\\n', ' 说明：\\n', '\\n', 'isula-build 支持导入最大50G的容器层叠镜像。\\n', 'isula-build 会自动识别容器层叠镜像的格式并进行导入。\\n', 'rm: 删除本地持久化镜像\\n', '可通过rm命令删除当前本地持久化存储的镜像。命令原型为：\\n', '\\n', 'isula-build ctr-img rm IMAGE [IMAGE...] [FLAGS]\\n', '目前支持的 flags 为：\\n', '\\n', '-a, –all：删除所有本地持久化存储的镜像。\\n', '-p, –prune：删除所有没有tag的本地持久化存储的镜像。\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build ctr-img rm -p\\n', 'Deleted: sha256:78731c1dde25361f539555edaf8f0b24132085b7cab6ecb90de63d72fa00c01d\\n', 'Deleted: sha256:eeba1bfe9fca569a894d525ed291bdaef389d28a88c288914c1a9db7261ad12c\\n', 'save: 导出层叠镜像\\n', '可通过save命令导出层叠镜像到本地磁盘。命令原型如下：\\n', '\\n', 'isula-build ctr-img save [REPOSITORY:TAG]|imageID -o xx.tar\\n', '目前支持的 flags 为：\\n', '\\n', '-f, –format：导出层叠镜像的镜像格式：oci | docker（需开启实验特性选项）\\n', '-o, –output：本地tar包路径\\n', '以下示例通过 image/tag 的形式将镜像进行导出：\\n', '\\n', '$ sudo isula-build ctr-img save busybox:latest -o busybox.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:50644c29ef5a27c9a40c393a73ece2479de78325cae7d762ef3cdc19bf42dd0a\\n', 'Copying blob sha256:824082a6864774d5527bda0d3c7ebd5ddc349daadf2aa8f5f305b7a2e439806f\\n', 'Copying blob sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\\n', 'Copying config sha256:21c3e96ac411242a0e876af269c0cbe9d071626bdfb7cc79bfa2ddb9f7a82db6\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Save success with image: busybox:latest\\n', '以下示例通过 ImageID 的形式将镜像进行导出：\\n', '\\n', '$ sudo isula-build ctr-img save 21c3e96ac411 -o busybox.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:50644c29ef5a27c9a40c393a73ece2479de78325cae7d762ef3cdc19bf42dd0a\\n', 'Copying blob sha256:824082a6864774d5527bda0d3c7ebd5ddc349daadf2aa8f5f305b7a2e439806f\\n', 'Copying blob sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef\\n', 'Copying config sha256:21c3e96ac411242a0e876af269c0cbe9d071626bdfb7cc79bfa2ddb9f7a82db6\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Save success with image: 21c3e96ac411\\n', '以下示例导出多个镜像到同一个tar包：\\n', '\\n', '$ sudo isula-build ctr-img save busybox:latest nginx:latest -o all.tar\\n', 'Getting image source signatures\\n', 'Copying blob sha256:eb78099fbf7fdc70c65f286f4edc6659fcda510b3d1cfe1caa6452cc671427bf\\n', 'Copying blob sha256:29f11c413898c5aad8ed89ad5446e89e439e8cfa217cbb404ef2dbd6e1e8d6a5\\n', 'Copying blob sha256:af5bd3938f60ece203cd76358d8bde91968e56491daf3030f6415f103de26820\\n', 'Copying config sha256:b8efb18f159bd948486f18bd8940b56fd2298b438229f5bd2bcf4cedcf037448\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Getting image source signatures\\n', 'Copying blob sha256:e2d6930974a28887b15367769d9666116027c411b7e6c4025f7c850df1e45038\\n', 'Copying config sha256:a33de3c85292c9e65681c2e19b8298d12087749b71a504a23c576090891eedd6\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Save success with image: [busybox:latest nginx:latest]\\n', ' 说明：\\n', '\\n', 'save 导出的镜像默认格式为未压缩的tar格式，如有需求，用户可以再save之后手动压缩。\\n', '在使用镜像名导出镜像时，需要给出完整的镜像名格式：REPOSITORY:TAG。\\n', 'tag: 给本地持久化镜像打标签\\n', '可使用tag命令给本地持久化的容器镜像打tag。命令原型如下：\\n', '\\n', 'isula-build ctr-img tag <imageID>/<imageName> busybox:latest\\n', '使用举例：\\n', '\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  --------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                     SIZE\\n', '---------------------------------------  -----------  -----------------  --------------------------  ------------\\n', 'alpine                                   latest       a24bb4013296       2020-05-29 21:19:46         5.85 MB\\n', '---------------------------------------  -----------  -----------------  --------------------------  ------------\\n', '$ sudo isula-build ctr-img tag a24bb4013296 alpine:v1\\n', '$ sudo isula-build ctr-img images\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'REPOSITORY                               TAG          IMAGE ID           CREATED                   SIZE\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'alpine                                   latest       a24bb4013296       2020-05-29 21:19:46       5.85 MB\\n', 'alpine                                   v1           a24bb4013296       2020-05-29 21:19:46       5.85 MB\\n', '---------------------------------------  -----------  -----------------  ------------------------  ------------\\n', 'pull: 拉取镜像到本地\\n', '可通过pull命令拉取远程镜像仓库中的镜像到本地。命令原型如下：\\n', '\\n', 'isula-build ctr-img pull REPOSITORY[:TAG]\\n', '使用示例：\\n', '\\n', '$ sudo isula-build ctr-img pull example-registry/library/alpine:latest\\n', 'Getting image source signatures\\n', 'Copying blob sha256:8f52abd3da461b2c0c11fda7a1b53413f1a92320eb96525ddf92c0b5cde781ad\\n', 'Copying config sha256:e4db68de4ff27c2adfea0c54bbb73a61a42f5b667c326de4d7d5b19ab71c6a3b\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Pull success with image: example-registry/library/alpine:latest\\n', 'push: 将本地镜像推送到远程仓库\\n', '可通过push命令将本地镜像推送到远程仓库。命令原型如下：\\n', '\\n', 'isula-build ctr-img push REPOSITORY[:TAG]\\n', '目前支持的 flags 为：\\n', '\\n', '-f, –format：推送的镜像格式：oci｜docker（需开启实验特性选项）\\n', '使用示例：\\n', '\\n', '$ sudo isula-build ctr-img push example-registry/library/mybusybox:latest\\n', 'Getting image source signatures\\n', 'Copying blob sha256:d2421964bad195c959ba147ad21626ccddc73a4f2638664ad1c07bd9df48a675\\n', 'Copying config sha256:f0b02e9d092d905d0d87a8455a1ae3e9bb47b4aa3dc125125ca5cd10d6441c9f\\n', 'Writing manifest to image destination\\n', 'Storing signatures\\n', 'Push success with image: example-registry/library/mybusybox:latest\\n', ' 说明：\\n', '\\n', '推送镜像时，需要先登录对应的镜像仓库。\\n', 'info: 查看运行环境与系统信息\\n', '可以通过“isula-build info”指令查看 isula-build 目前的运行环境与系统信息。命令原型如下：\\n', '\\n', ' isula-build info [flags]\\n', '支持如下Flags：\\n', '\\n', '-H, –human-readable 布尔值，以常用内存表示格式打印内存信息，使用1000次幂\\n', '-V, –verbose 布尔值，显示运行时内存占用信息\\n', '使用示例：\\n', '\\n', '$ sudo isula-build info -HV\\n', '   General:\\n', '     MemTotal:     7.63 GB\\n', '     MemFree:      757 MB\\n', '     SwapTotal:    8.3 GB\\n', '     SwapFree:     8.25 GB\\n', '     OCI Runtime:  runc\\n', '     DataRoot:     /var/lib/isula-build/\\n', '     RunRoot:      /var/run/isula-build/\\n', '     Builders:     0\\n', '     Goroutines:   12\\n', '   Store:\\n', '     Storage Driver:     overlay\\n', '     Backing Filesystem: extfs\\n', '   Registry:\\n', '     Search Registries:\\n', '       oepkgs.net\\n', '     Insecure Registries:\\n', '       localhost:5000\\n', '       oepkgs.net\\n', '   Runtime:\\n', '\\t MemSys:           68.4 MB\\n', '     HeapSys:          63.3 MB\\n', '     HeapAlloc:        7.41 MB\\n', '     MemHeapInUse:     8.98 MB\\n', '     MemHeapIdle:      54.4 MB\\n', '     MemHeapReleased:  52.1 MB\\n', 'login: 登录远端镜像仓库\\n', '用户可以运行 login 命令来登录远程镜像仓库。命令原型如下：\\n', '\\n', ' isula-build login SERVER [FLAGS]\\n', '目前支持的flag有：\\n', '\\n', ' Flags:\\n', '   -p, --password-stdin    Read password from stdin\\n', '   -u, --username string   Username to access registry\\n', '通过stdin输入密码。以下示例通过通过管道将creds.txt里的密码传给isula-build的stdin进行输入：\\n', '\\n', ' $ cat creds.txt | sudo isula-build login -u cooper -p mydockerhub.io\\n', ' Login Succeeded\\n', '通过交互式输入密码：\\n', '\\n', ' $ sudo isula-build login mydockerhub.io -u cooper\\n', ' Password:\\n', ' Login Succeeded\\n', 'logout: 退出远端镜像仓库\\n', '用户可以运行 logout 命令来登出远程镜像仓库。命令原型如下：\\n', '\\n', ' isula-build logout [SERVER] [FLAGS]\\n', '目前支持的flag有：\\n', '\\n', ' Flags:\\n', '   -a, --all   Logout all registries\\n', '使用示例如下：\\n', '\\n', ' $ sudo isula-build logout -a\\n', '   Removed authentications\\n', 'version: 版本查询\\n', '可通过version命令查看当前版本信息：\\n', '\\n', '$ sudo isula-build version\\n', 'Client:\\n', '  Version:       0.9.6-4\\n', '  Go Version:    go1.15.7\\n', '  Git Commit:    83274e0\\n', '  Built:         Wed Jan 12 15:32:55 2022\\n', '  OS/Arch:       linux/amd64\\n', '\\n', 'Server:\\n', '  Version:       0.9.6-4\\n', '  Go Version:    go1.15.7\\n', '  Git Commit:    83274e0\\n', '  Built:         Wed Jan 12 15:32:55 2022\\n', '  OS/Arch:       linux/amd64\\n', 'manifest: manifest列表管理\\n', 'manifest列表包含不同系统架构对应的镜像信息，通过使用manifest列表，用户可以在不同的架构中使用相同的manifest（例如openeuler:latest）获取对应架构的镜像，manifest包含create、annotate、inspect和push子命令。\\n', '\\n', ' 说明：\\n', '\\n', 'manifest为实验特性，使用时需开启客户端和服务端的实验选项，方式详见客户端总体说明和配置服务章节。\\n', 'create: manifest列表创建\\n', 'manifest的子命令create用于创建manifest列表，命令原型为：\\n', '\\n', 'isula-build manifest create MANIFEST_LIST MANIFEST [MANIFEST...]\\n', '用户可以指定manifest列表的名称以及需要加入到列表中的远程镜像，若不指定任何远程镜像，则会创建一个空的manifest列表。\\n', '\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest create openeuler localhost:5000/openeuler_x86:latest localhost:5000/openeuler_aarch64:latest\\n', 'annotate: manifest列表更新\\n', 'manifest的子命令annotate用于更新manifest列表，命令原型为：\\n', '\\n', 'isula-build manifest annotate MANIFEST_LIST MANIFEST [flags]\\n', '用户可以指定需要更新的manifest列表以及其中的镜像，通过flags指定需要更新的选项，此命令也可用于添加新的镜像到列表中。\\n', '\\n', '其中annotate包含如下flags：\\n', '\\n', '–arch： string，重写镜像适用架构\\n', '–os： string，重写镜像适用系统\\n', '–os-features： string列表，指定镜像需要的OS特性，很少使用\\n', '–variant： string，指定列表中记录镜像的变量\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest annotate --os linux --arch arm64 openeuler:latest localhost:5000/openeuler_aarch64:latest\\n', 'inspect: manifest列表查询\\n', 'manifest子命令inspect用于查询manifest列表信息，命令原型为：\\n', '\\n', 'isula-build manifest inspect MANIFEST_LIST\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest inspect openeuler:latest\\n', '{\\n', '    \"schemaVersion\": 2,\\n', '    \"mediaType\": \"application/vnd.docker.distribution.manifest.list.v2+json\",\\n', '    \"manifests\": [\\n', '        {\\n', '            \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\\n', '            \"size\": 527,\\n', '            \"digest\": \"sha256:bf510723d2cd2d4e3f5ce7e93bf1e52c8fd76831995ac3bd3f90ecc866643aff\",\\n', '            \"platform\": {\\n', '                \"architecture\": \"amd64\",\\n', '                \"os\": \"linux\"\\n', '            }\\n', '        },\\n', '        {\\n', '            \"mediaType\": \"application/vnd.docker.distribution.manifest.v2+json\",\\n', '            \"size\": 527,\\n', '            \"digest\": \"sha256:f814888b4bb6149bd39ba8375a1932fb15071b4dbffc7f76c7b602b06abbb820\",\\n', '            \"platform\": {\\n', '                \"architecture\": \"arm64\",\\n', '                \"os\": \"linux\"\\n', '            }\\n', '        }\\n', '    ]\\n', '}\\n', 'push: 将manifest列表推送到远程仓库\\n', 'manifest子命令push用于将manifest列表推送到远程仓库，命令原型为：\\n', '\\n', 'isula-build manifest push MANIFEST_LIST DESTINATION\\n', '使用示例如下：\\n', '\\n', '$ sudo isula-build manifest push openeuler:latest localhost:5000/openeuler:latest\\n', '直接集成容器引擎\\n', 'isula-build可以与iSulad和docker集成，将构建好的容器镜像导入到容器引擎的本地存储中。\\n', '\\n', '与iSulad集成\\n', '支持将构建成功的镜像直接导出到iSulad。\\n', '\\n', '命令行举例：\\n', '\\n', '$ sudo isula-build ctr-img build -f Dockerfile -o isulad:busybox:2.0\\n', '通过在-o参数中指定iSulad，将构建好的容器镜像导出到iSulad，可以通过isula images查询：\\n', '\\n', '$ sudo isula images\\n', 'isula images\\n', 'REPOSITORY                     TAG        IMAGE ID             CREATED              SIZE\\n', 'busybox                        2.0        2d414a5cad6d         2020-08-01 06:41:36  5.577 MB\\n', ' 说明：\\n', '\\n', '要求isula-build和iSulad在同一节点。\\n', '直接导出镜像到iSulad时，isula-build client端需要将构建成功的镜像暂存成 /var/lib/isula-build/tmp/[buildid]/isula-build-tmp-%v.tar 再导入至 iSulad，用户需要保证 /var/lib/isula-build/tmp/ 目录有足够磁盘空间；同时如果在导出过程中 isula-build client进程被KILL或Ctrl+C终止，需要依赖用户手动清理 /var/lib/isula-build/tmp/[buildid]/isula-build-tmp-%v.tar 文件。\\n', '与Docker集成\\n', '支持将构建成功的镜像直接导出到Docker daemon。\\n', '\\n', '命令行举例：\\n', '\\n', '$ sudo isula-build ctr-img build -f Dockerfile -o docker-daemon:busybox:2.0\\n', '通过在-o参数中指定docker-daemon，将构建好的容器镜像导出到docker, 可以通过docker images查询。\\n', '\\n', '$ sudo docker images\\n', 'REPOSITORY                                          TAG                 IMAGE ID            CREATED             SIZE\\n', 'busybox                                             2.0                 2d414a5cad6d        2 months ago        5.22MB\\n', ' 说明：\\n', '\\n', '要求isula-build和Docker在同一节点。\\n', '使用注意事项\\n', '本章节主要介绍在使用isula-build构建镜像时相关的约束和限制，以及与docker build的差异。\\n', '\\n', '约束和限制\\n', '当导出镜像到iSulad时，镜像必须指明tag。\\n', '因为isula-builder运行RUN指令时，需要调用系统中的oci 运行时（如runc），用户需要保证该运行时的安全性，不受篡改。\\n', 'DataRoot不能设置在内存盘上（tmpfs）。\\n', 'Overlay2是目前isula-builder唯一支持的存储驱动。\\n', 'Docker镜像是目前唯一支持的镜像格式，未来即将支持oci格式镜像。\\n', 'Dockerfile文件权限强烈建议设置为0600以防止恶意篡改。\\n', 'RUN命令中目前只支持主机侧网络（host network）。\\n', '当导出镜像到本地tar包时，目前只支持保存为tar格式。\\n', '当使用import功能导入基础镜像时，最大支持1G。\\n', '与“docker build”差异\\n', 'isula-build兼容Docker镜像格式规范，但仍然和docker build存在一些差异：\\n', '\\n', '支持镜像压缩，即对每个stage进行提交而非每一行。\\n', '目前不支持构建缓存。\\n', '只有RUN指令会运行容器进行构建。\\n', '目前不支持查询镜像构建历史。\\n', 'Stage名称可以用数字开头。\\n', 'Stage名称最大长度为64。\\n', 'ADD命令不支持远端URL格式。\\n', '暂不支持对单次构建进行资源限额，可采取对isula-builder配置资源限额的方式进行限制。\\n', '统计镜像大小时，isula-build是直接计算每层tar包大小之和，而docker是通过解压tar遍历diff目录计算文件大小之和，因此通过isula-build ctr-img images查看的镜像大小与docker images的显示上有一定差异。\\n', '操作时的镜像名称需要明确，格式为IMAGE_NAME:IMAGE_TAG。例如 busybox:latest, 其中latest不可省略。\\n', '附录\\n', '命令行参数说明\\n', '表1 ctr-img build 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img build\\t–build-arg\\tstring列表，构建过程中需要用到的变量\\n', '–build-static\\tKV值，构建二进制一致性。目前包含如下K值：- build-time：string，使用固定时间戳来构建容器镜像；时间戳格式为“YYYY-MM-DD HH-MM-SS”\\n', '-f, –filename\\tstring，Dockerfile的路径，不指定则是使用当前路径的Dockerfile文件\\n', '–format\\tstring，设置构建镜像的镜像格式：oci｜docker（需开启实验特性选项）\\n', '–iidfile\\tstring，输出 image ID 到本地文件\\n', '-o, –output\\tstring，镜像导出的方式和路径\\n', '–proxy\\t布尔值，继承主机侧环境的proxy环境变量（默认为true）\\n', '–tag\\tstring，给构建的镜像添加tag\\n', '–cap-add\\tstring列表，构建过程中RUN指令所需要的权限\\n', '表2 ctr-img load 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img load\\t-i, –input\\tstring，需要导入的本地tar包的路径\\n', '表3 ctr-img push 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img push\\t-f, –format\\tstring，推送的镜像格式：oci｜docker（需开启实验特性选项）\\n', '表4 ctr-img rm 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img rm\\t-a, –all\\t布尔值，删除所有本地持久化存储的镜像\\n', '-p, –prune\\t布尔值，删除所有没有tag的本地持久化存储的镜像\\n', '表5 ctr-img save 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'ctr-img save\\t-o, –output\\tstring，镜像导出后在本地的存储路径\\n', '-f, –format\\tstring，导出层叠镜像的镜像格式：oci｜docker（需开启实验特性选项）\\n', '表6 login 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'login\\t-p, –password-stdin\\t布尔值，是否通过stdin读入密码；或采用交互式界面输入密码\\n', '-u, –username\\tstring，登陆镜像仓库所使用的用户名\\n', '表7 logout 命令参数列表\\n', '\\n', '命令\\t参数\\t说明\\n', 'logout\\t-a, –all\\t布尔值，是否登出所有已登陆的镜像仓库\\n', '表8 manifest annotate命令参数列表\\n', '\\n', '命令\\t说明\\t参数\\n', 'manifest annotate\\t–arch\\tstring，重写镜像适用架构\\n', '–os\\tstring，重写镜像适用系统\\n', '–os-features\\tstring列表，指定镜像需要的OS特性，很少使用\\n', '–variant\\tstring，指定列表中记录镜像的变量\\n', '通信矩阵\\n', 'isula-build两个组件进程之间通过unix socket套接字文件进行通信，无端口通信。\\n', '\\n', '文件与权限\\n', 'isula-build 所有的操作均需要使用 root 权限。如需使用非特权用户操作，则需要配置–group参数\\n', '\\n', 'isula-build 运行涉及文件权限如下表所示：\\n', '\\n', '文件路径\\t文件/文件夹权限\\t说明\\n', '/usr/bin/isula-build\\t550\\t命令行工具二进制文件。\\n', '/usr/bin/isula-builder\\t550\\t服务端isula-builder进程二进制文件。\\n', '/usr/lib/systemd/system/isula-build.service\\t640\\tsystemd配置文件，用于管理isula-build服务。\\n', '/etc/isula-build\\t650\\tisula-builder 配置文件根目录\\n', '/etc/isula-build/configuration.toml\\t600\\tisula-builder 总配置文件，包含设置 isula-builder 日志级别、持久化目录和运行时目录、OCI runtime等。\\n', '/etc/isula-build/policy.json\\t600\\t签名验证策略文件的语法文件。\\n', '/etc/isula-build/registries.toml\\t600\\t针对各个镜像仓库的配置文件，含可用的镜像仓库列表、镜像仓库黑名单。\\n', '/etc/isula-build/storage.toml\\t600\\t本地持久化存储的配置文件，包含所使用的存储驱动的配置。\\n', '/etc/isula-build/isula-build.pub\\t400\\t非对称加密公钥文件\\n', '/var/run/isula_build.sock\\t660\\t服务端isula-builder的本地套接字。\\n', '/var/lib/isula-build\\t700\\t本地持久化目录。\\n', '/var/run/isula-build\\t700\\t本地运行时目录。\\n', '/var/lib/isula-build/tmp/[buildid]/isula-build-tmp-*.tar\\t644\\t镜像导出至iSulad时的本地暂存目录。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理内存.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/memory-management.html", "text_entry": "['etmem内存分级扩展\\n', '介绍\\n', '随着CPU算力的发展，尤其是ARM核成本的降低，内存成本和内存容量成为约束业务成本和性能的核心痛点，因此如何节省内存成本，如何扩大内存容量成为存储迫切要解决的问题。\\n', '\\n', 'etmem内存分级扩展技术，通过DRAM+内存压缩/高性能存储新介质形成多级内存存储，对内存数据进行分级，将分级后的内存冷数据从内存介质迁移到高性能存储介质中，达到内存容量扩展的目的，从而实现内存成本下降。(当前暂时还没有对非易失内存介质的支持）\\n', '\\n', '软件架构\\n', '\\n', '\\n', 'etmem客户端通过socket通信机制与服务端进行交互，下发创建/删除工程、启动/停止工程、查询工程的命令，服务端通过客户端下发的配置文件，读取project管理配置信息，以及engine配置信息，并执行客户端下发的操作。启动工程之后，服务端会对业务进程进行扫描，并根据扫描统计结果以及淘汰策略，对页面进行分级淘汰，实现节省内存的目标。\\n', '\\n', '编译教程\\n', '下载etmem源码\\n', '   # git clone https://gitee.com/src-openeuler/etmem.git\\n', '编译和运行依赖\\n', 'etmem的编译和运行依赖于libboundscheck组件。\\n', '\\n', '编译\\n', '   # cd etmem\\n', '   # mkdir build\\n', '   # cd build\\n', '   # cmake ..\\n', '   # make\\n', '使用说明\\n', '启动etmemd进程\\n', '使用方法\\n', '通过运行etmemd二进制运行服务端进程，例如：\\n', '\\n', '# etmemd -l 0 -s etmemd_socket\\n', '帮助信息\\n', 'options：\\n', '-l|--log-level <log-level>  Log level\\n', '-s|--socket <sockect name>  Socket name to listen to\\n', '-h|--help  Show this message\\n', '命令行参数说明\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t参数范围\\t示例说明\\n', '-l或–log-level\\tetmemd日志级别\\t否\\t是\\t0~3\\t0：debug级别 1：info级别 2：warning级别 3：error级别 只有大于等于配置的级别才会打印到/var/log/message文件中\\n', '-s或–socket\\tetmemd监听的名称，用于与客户端交互\\t是\\t是\\t107个字符之内的字符串\\t指定服务端监听的名称\\n', '-h或–help\\t帮助信息\\t否\\t否\\tNA\\t执行时带有此参数会打印后退出\\n', 'etmem配置文件\\n', '在运行etmem进程之前，需要管理员预先规划哪些进程需要做内存扩展，将进程信息配置到etmem配置文件中，并配置内存扫描的周期、扫描次数、内存冷热阈值等信息。\\n', '\\n', '配置文件的示例文件在源码包中，放置在源码根目录的conf/example_conf.yaml，建议在使用时放置在/etc/etmem/目录下，示例内容为：\\n', '\\n', 'options:    \\n', '\\tloop : 3\\n', '    interval : 1\\n', '    sleep: 2\\n', '\\tpolicies:\\n', '\\t\\ttype : pid/name\\n', '   \\t\\tvalue : 123456/mysql\\n', '    \\tmax_threads: 3\\n', '    \\tengine : slide\\n', '\\t\\t\\tparam:\\n', '\\t\\t\\t\\tT: 3\\n', '配置文件各字段说明：\\n', '\\n', '置项\\t配置项含义\\t是否必须\\t是否有参数\\t参数范围\\t示例说明\\n', 'options\\tproject公用配置段起始标识\\t是\\t否\\tNA\\t每个配置文件有且仅有一个此字段，并且文件以此字段开始\\n', 'loop\\t内存扫描的循环次数\\t是\\t是\\t1~120\\tloop:3 //扫描3次\\n', 'interval\\t每次内存扫描的时间间隔\\t是\\t是\\t1~1200\\tinterval:5 //每次扫描之间间隔5s\\n', 'sleep\\t每个内存扫描+操作的大周期之间时间间隔\\t是\\t是\\t1~1200\\tsleep:10 //每次大周期之间间隔10s\\n', 'policies\\tproject中各task任务配置段起始标识\\t是\\t否\\tNA\\t一个project中可以配置多个task，每个task以policies:开头\\n', 'type\\t目标进程识别的方式\\t是\\t是\\tpid/name\\tpid代表通过进程号识别，name代表通过进程名称识别\\n', 'value\\t目标进程识别的具体字段\\t是\\t是\\t实际的进程号/进程名称\\t与type字段配合使用，指定目标进程的进程号或进程名称，由使用者保证配置的正确及唯一性\\n', 'max_threads\\tetmemd内部线程池最大线程数，每个线程处理一个进程/子进程的内存扫描+操作任务\\t否\\t是\\t1~2 * core数 + 1，默认为1\\t对外部无表象，控制etmemd服务端内部处理线程个数，当目标进程有多个子进程时，配置越大，并发执行的个数也多，但占用资源也越多\\n', 'engine\\t扫描引擎类型\\t是\\t是\\tslide\\t声明使用slide引擎进行冷热内存识别\\n', 'param\\t扫描引擎私有参数配置起始标识\\t是\\t否\\tNA\\t引擎私有参数配置段以此标识起始，每个task对应一种引擎，每个引擎对应一个param及其字段\\n', 'T\\tslide引擎的水线配置\\t是\\t否\\t1~3 * loop\\t水线阈值，大于等于此值的内存会被识别为热内存，反之为冷内存\\n', 'etmem工程创建、删除、查询\\n', '场景描述\\n', '1）管理员创建etmem工程（一个工程可包含多个etmem任务）\\n', '\\n', '2）管理员查询已有的etmem工程\\n', '\\n', '3）管理员删除已有的etmem工程（删除工程前，会自动先停止该工程中的所有任务）\\n', '\\n', '使用方法\\n', '通过etmem二进制执行工程创建/删除/查询操作，前提是服务端已经成功运行，并且配置文件（e.g. /etc/etmem/example_conf.yaml）内容正确。\\n', '\\n', '添加工程：\\n', '\\n', '# etmem project add -n test -f /etc/etmem/example_conf.yaml -s etmemd_socket\\n', '删除工程：\\n', '\\n', '# etmem project del -n test -s etmemd_socket\\n', '查询工程：\\n', '\\n', '# etmem project show -s etmemd_socket\\n', '打印帮助：\\n', '\\n', '# etmem project help\\n', '帮助信息\\n', 'Usage:\\n', ' etmem project add [options]\\n', ' etmem project del [options]\\n', ' etmem project show\\n', ' etmem project help\\n', '\\n', ' Options:\\n', ' -f|--file <conf_file> Add configuration file\\n', ' -n|--name <proj_name> Add project name\\n', ' -s|--sock <sock_name> Socket name to connect\\n', '\\n', ' Notes:\\n', ' 1. Project name and socket name must be given when execute add or del option.\\n', ' 2. Configuration file must be given when execute add option.\\n', ' 3. Socket name must be given when execute show option.\\n', '命令行参数说明\\n', 'add命令：\\n', '\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-n或–name\\t指定project名称\\t是\\t是\\tproject名称，与配置文件一一对应\\n', '-f或–file\\t指定project的配置文件\\t是\\t是\\t需要指定路径名称\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信\\n', 'del命令：\\n', '\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-n或–name\\t指定project名称\\t是\\t是\\tproject名称，与配置文件一一对应\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信\\n', 'show命令：\\n', '\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信\\n', 'etmem任务启动、停止\\n', '场景描述\\n', '在已经通过etmem project add添加工程之后，在还未调用etmem project del删除工程之前，可以对etmem的工程进行启动和停止。\\n', '\\n', '1）管理员启动已添加的工程\\n', '\\n', '2）管理员停止已启动的工程\\n', '\\n', '在管理员调用project del删除工程时，如果工程已经启动，则会自动停止。\\n', '\\n', '使用方法\\n', '通过etmem二进制执行任务启动/停止操作，前提是服务端已经成功运行，配置文件（e.g. /etc/etmem/example_conf.yaml）内容正确，且etmem工程已经创建。\\n', '\\n', '启动工程\\n', '\\n', '# etmem migrate start -n test -s etmemd_socket\\n', '停止工程\\n', '\\n', '# etmem migrate stop -n test -s etmemd_socket\\n', '打印帮助\\n', '\\n', '# etmem migrate help\\n', '帮助信息\\n', 'Usage:\\n', ' etmem migrate start [options]\\n', ' etmem migrate stop [options]\\n', ' etmem migrate help\\n', '\\n', ' Options:\\n', ' -n|--name <proj_name> Add project name\\n', ' -s|--sock <sock_name> Socket name to connect\\n', '\\n', ' Notes:\\n', ' Project name and socket name must be given when execute start or stop option.\\n', '命令行参数说明\\n', '参数\\t参数含义\\t是否必须\\t是否有参数\\t示例说明\\n', '-n或–name\\t指定project名称\\t是\\t是\\tproject名称，与配置文件一一对应\\n', '-s或–socket\\t与etmemd服务端通信的socket名称，需要与etmemd启动时指定的保持一致\\t是\\t是\\t必须配置，在有多个etmemd时，由管理员选择与哪个etmemd通信']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_FAQ.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/FAQ-1.html", "text_entry": "['FAQ\\n', 'FAQ\\n', '树莓派启动失败\\n', 'nmcli 命令连接 WIFI 失败\\n', '树莓派启动失败\\n', '问题现象\\n', '将 openEuler 发布的树莓派镜像刷写入 SD 卡后，树莓派启动失败。\\n', '\\n', '原因分析\\n', '刷写 openEuler 发布的树莓派镜像后，树莓派启动失败，大致有以下几种情况：\\n', '\\n', '下载的镜像文件不完整，请确保该镜像通过完整性校验。\\n', '镜像写入 SD 卡过程中出现问题，多出现在 Windows 环境下使用应用软件刷写镜像到 SD 卡的情况。\\n', '解决方法\\n', '将完整的镜像重新刷写入 SD 卡。\\n', '\\n', 'nmcli 命令连接 WIFI 失败\\n', '问题现象\\n', '执行 nmcli dev wifi connect SSID password PWD 命令连接 WIFI 失败。例如提示 Error: Connection activation failed: (7) Secrets were required, but not provided. 等错误。\\n', '\\n', '原因分析\\n', '执行的命令缺少密码。注意，如果密码中包含特殊字符，需要使用单引号将密码括起来。如果使用 nmcli 命令行连接 WIFI 失败，建议使用 nmtui 字符界面进行连接。\\n', '\\n', '解决方法\\n', '执行 nmtui 命令进入到 nmtui 字符界面，按照以下步骤连接 WIFI。\\n', '\\n', '选择 Edit a connection，按 Enter 进入编辑网络连接窗口。\\n', '\\n', '按下键盘右方向键选择 Add，按 Enter 进入新建网络连接窗口。\\n', '\\n', '连接类型选择 Wi-Fi ，然后按下键盘右方向键选择 Create，按 Enter 进入 WIFI 编辑连接信息的界面。\\n', '\\n', 'WIFI 连接信息界面主要需要编辑以下内容，其他信息根据实际情况而定。编辑结束后选择 OK，按 Enter 完成编辑并回退到编辑网络连接窗口。\\n', '\\n', 'Profile name 栏输入该 WIFI 连接的名称，这里可以使用默认名称，如 Wi-Fi connection 1；\\n', 'Device 栏输入要使用的无线网卡接口，这里输入 wlan0；\\n', 'SSID 栏输入要连接的 WIFI 的 SSID；\\n', 'Security 栏选择 WIFI 密码加密方式，这里根据实际情况选择，例如选择 WPA & WPA2 Personal；\\n', 'Password 栏输入 WIFI 密码。\\n', '选择 Back 回退到最初的 nmtui 字符界面。\\n', '\\n', '选择 Activate a connection，按 Enter 进入激活网络连接窗口。\\n', '\\n', '查看添加的 WIFI 连接是否已激活（已激活的连接名称前有 * 标记）。如果未激活，选择该 WIFI 连接，然后按下键盘右方向键选择 Activate，按 Enter 激活该连接。待激活完成后，选择 Back，按 Enter 退出该激活界面，回退到最初的 nmtui 字符界面。\\n', '\\n', '选择 Quit，然后按下键盘右方向键选择 OK，按 Enter 退出 nmtui 字符界面。']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_授权认证.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81.html", "text_entry": "['授权认证\\n', '授权认证\\n', '设置网络远程登录的警告信息\\n', '禁止通过Ctrl+Alt+Del重启系统\\n', '设置终端的自动退出时间\\n', '设置用户的默认umask值为077\\n', '设置GRUB2加密口令\\n', '安全单用户模式\\n', '禁止交互式启动\\n', '设置网络远程登录的警告信息\\n', '说明\\n', '设置网络远程登录的警告信息，用于在登录进入系统之前向用户提示警告信息，明示非法侵入系统可能受到的惩罚，吓阻潜在的攻击者。同时也可以隐藏系统架构及其他系统信息，避免招致对系统的目标性攻击。\\n', '\\n', '实现\\n', '该设置可以通过修改/etc/issue.net文件的内容实现。将/etc/issue.net文件原有内容替换为如下信息（openEuler默认已设置）：\\n', '\\n', 'Authorized users only. All activities may be monitored and reported. \\n', '禁止通过Ctrl+Alt+Del重启系统\\n', '说明\\n', '操作系统默认能够通过“Ctrl+Alt+Del”进行重启，建议禁止该项特性，防止因为误操作而导致数据丢失。\\n', '\\n', '实现\\n', '禁止通过“Ctrl+Alt+Del”重启系统的操作步骤如下：\\n', '\\n', '删除两个ctrl-alt-del.target文件，参考命令如下：\\n', '\\n', 'rm -f /etc/systemd/system/ctrl-alt-del.target\\n', 'rm -f /usr/lib/systemd/system/ctrl-alt-del.target\\n', '修改/etc/systemd/system.conf文件，将#CtrlAltDelBurstAction=reboot-force修改为CtrlAltDelBurstAction=none。\\n', '\\n', '重启systemd，使修改生效，参考命令如下：\\n', '\\n', 'systemctl daemon-reexec\\n', '设置终端的自动退出时间\\n', '说明\\n', '无人看管的终端容易被侦听或被攻击，可能会危及系统安全。因此建议设置终端在停止运行一段时间后能够自动退出。\\n', '\\n', '实现\\n', '自动退出时间由/etc/profile文件的TMOUT字段（单位为秒）控制，在/etc/profile的尾部添加如下配置：\\n', '\\n', 'export TMOUT=300\\n', '设置用户的默认umask值为077\\n', '说明\\n', 'umask值用于为用户新创建的文件和目录设置缺省权限。如果umask的值设置过小，会使群组用户或其他用户的权限过大，给系统带来安全威胁。因此设置所有用户默认的umask值为0077，即用户创建的目录默认权限为700，文件的默认权限为600。umask值代表的是权限的“补码”，umask值和权限的换算方法请参见umask值含义。\\n', '\\n', ' 说明：\\n', 'openEuler默认已设置用户的默认umask值为022。\\n', '\\n', '实现\\n', '分别在/etc/bashrc文件和/etc/profile.d/目录下的所有文件中加入“umask 0077”。\\n', '\\n', 'echo \"umask 0077\" >> $FILE\\n', ' 说明：\\n', '$FILE 为具体的文件名，例如：echo “umask 0077” >> /etc/bashrc\\n', '\\n', '设置/etc/bashrc文件和/etc/profile.d/目录下所有文件的属主为root，群组为root。\\n', '\\n', 'chown root.root $FILE\\n', ' 说明：\\n', '$FILE 为具体的文件名，例如：chown root.root /etc/bashrc\\n', '\\n', '设置GRUB2加密口令\\n', '说明\\n', 'GRUB是GRand UnifiedBootloader的缩写，它是一个操作系统启动管理器，用来引导不同系统（如Windows、Linux），GRUB2是GRUB的升级版。\\n', '\\n', '系统启动时，可以通过GRUB2界面修改系统的启动参数。为了确保系统的启动参数不被任意修改，需要对GRUB2界面进行加密，仅在输入正确的GRUB2口令时才能修改启动参数。\\n', '\\n', ' 说明：\\n', 'GRUB2默认设置的口令为openEuler#12，建议用户首次登录时修改默认密码并定期更新，避免密码泄露后，启动选项被篡改，导致系统启动异常。\\n', '\\n', '实现\\n', '使用grub2-mkpasswd-pbkdf2命令生成加密的口令\\n', '\\n', ' 说明：\\n', 'GRUB2加密算法使用sha512。\\n', '\\n', '# grub2-mkpasswd-pbkdf2\\n', 'Enter password: \\n', 'Reenter password: \\n', 'PBKDF2 hash of your password is \\n', 'grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08\\n', ' 说明：\\n', '在Enter password和Reenter password输入相同的口令。\\n', 'grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08为openEuler#12经过grub2-mkpasswd-pbkdf2加密后的输出，每次输出的密文不同。\\n', '\\n', '使用vi工具打开/boot/efi/EFI/openEuler/grub.cfg的开始位置追加如下字段：\\n', '\\n', 'set superusers=\"root\"\\n', 'password_pbkdf2 root grub.pbkdf2.sha512.10000.5A45748D892672FDA02DD3B6F7AE390AC6E6D532A600D4AC477D25C7D087644697D8A0894DFED9D86DC2A27F4E01D925C46417A225FC099C12DBD3D7D49A7425.2BD2F5BF4907DCC389CC5D165DB85CC3E2C94C8F9A30B01DACAA9CD552B731BA1DD3B7CC2C765704D55B8CD962D2AEF19A753CBE9B8464E2B1EB39A3BB4EAB08\\n', ' 说明：\\n', '\\n', 'superusers字段用于设置GRUB2的超级管理员的帐户名。\\n', 'password_pbkdf2字段后的参数，第1个参数为GRUB2的帐户名，第2个为该帐户的加密口令。\\n', '安全单用户模式\\n', '说明\\n', '单用户模式是以root权限进入系统，如不设置密码，将存在较大安全隐患。\\n', '\\n', '实现\\n', '该设置可以通过修改/etc/sysconfig/init文件内容实现。将SINGLE选项配置为SINGLE=/sbin/sulogin。\\n', '\\n', '禁止交互式启动\\n', '说明\\n', '使用交互式引导，控制台用户可以禁用审计、防火墙或其他服务，削弱了系统安全性。用户可以禁止使用交互式引导，提升安全性。openEuler默认已禁止。\\n', '\\n', '实现\\n', '该设置可以通过修改/etc/sysconfig/init文件内容实现。将PROMPT选项配置为PROMPT=no。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n', '\\n', 'openEuler 是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目\\n', '\\n', 'footerLogo.png\\n', 'contact@openeuler.io\\n', '\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_iSula对接shim v2安全容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/iSula-shim-v2%E5%AF%B9%E6%8E%A5stratovirt.html", "text_entry": "['iSula对接shim v2安全容器\\n', '概述\\n', 'shim v2 是新一代 shim 架构方案，相比于 shim v1, 具有调用链更短、架构清晰的优势，在多业务容器场景，具备明显的低内存开销优势。iSula 运行安全容器可以通过 isulad-shim 或者 containerd-shim-kata-v2 来实现，其中 isulad-shim 组件是 shim v1 方案的具体实现，containerd-shim-kata-v2 组件是 shim v2 方案在安全容器场景的一种具体实现，本文介绍iSula 与 containerd-shim-kata-v2 的对接。\\n', '\\n', '对接 containerd-shim-v2-kata\\n', '前提条件\\n', 'iSula 对接 containerd-shim-v2-kata 前，需要满足如下前提：\\n', '\\n', '已安装 iSulad、lib-shim-v2 和 kata-containers\\n', 'StratoVirt 仅支持 devicemapper 存储驱动，因此需要配置 devicemapper 环境并确保 iSulad 使用的 devicemapper 存储驱动正常工作\\n', '环境准备\\n', '此处给出安装 iSulad 和 kata-containers 并进行相应配置的参考方法。\\n', '\\n', '安装依赖软件\\n', '按照所使用的OS版本自行配置相应的 yum 源，使用 root 权限安装 iSulad、lib-shim-v2和kata-containers ：\\n', '\\n', '# yum install iSulad\\n', '# yum install kata-containers\\n', '# yum install lib-shim-v2\\n', '制作并配置存储 Storage\\n', '需要用户准备一个磁盘， 如 /dev/sdx ， 该磁盘会被格式化，本章使用块设备 /dev/sda 进行演示。\\n', '\\n', '一、创建devicemapper\\n', '\\n', '创建 PV\\n', '\\n', '$ pvcreate /dev/sda\\n', '  Physical volume \"/dev/loop0\" successfully created.\\n', '创建 VG\\n', '\\n', '$ vgcreate isula /dev/sda\\n', '  Volume group \"isula\" successfully created\\n', '创建 thinpool 以及 thinpoolmeta 逻辑卷\\n', '\\n', '$ lvcreate --wipesignatures y -n thinpool isula -l 95%VG\\n', '  Logical volume \"thinpool\" created.\\n', '\\n', '$ lvcreate --wipesignatures y -n thinpoolmeta isula -l 1%VG\\n', '  Logical volume \"thinpoolmeta\" created.\\n', '将上面创建的逻辑卷转换为 thinpool\\n', '\\n', '$ lvconvert -y --zero n -c 64K \\\\\\n', '--thinpool isula/thinpool \\\\\\n', '--poolmetadata isula/thinpoolmeta\\n', '  Thin pool volume with chunk size 512.00 KiB can address at most 126.50 TiB of data.\\n', \"  WARNING: Converting isula/thinpool and isula/thinpoolmeta to thin pool's data and metadata volumes with metadata wiping.\\n\", '  THIS WILL DESTROY CONTENT OF LOGICAL VOLUME (filesystem etc.)\\n', '  Converted isula/thinpool and isula/thinpoolmeta to thin pool.\\n', '设置 lvm thinpool 自动扩展功能\\n', '\\n', '$ touch /etc/lvm/profile/isula-thinpool.profile\\n', '$ cat << EOF > /etc/lvm/profile/isula-thinpool.profile\\n', 'activation {\\n', '  thin_pool_autoextend_threshold=80\\n', '  thin_pool_autoextend_percent=20\\n', '}\\n', 'EOF\\n', '$ lvchange --metadataprofile isula-thinpool isula/thinpool\\n', 'Logical volume isula/thinpool changed.\\n', '二、修改 iSulad 存储驱动类型并设置默认runtime\\n', '\\n', '更改配置文件 /etc/isulad/daemon.json, 将 default-runtime 设置为 io.containerd.kata.v2 , 将默认存储驱动类型 overlay 配置成 devicemapper，修改后如下所示：\\n', '\\n', ' {\\n', '    \"default-runtime\": \"io.containerd.kata.v2\",\\n', '    \"storage-driver\": \"devicemapper\",\\n', '    \"storage-opts\": [\\n', '        \"dm.thinpooldev=/dev/mapper/isula-thinpool\",\\n', '        \"dm.fs=ext4\",\\n', '        \"dm.min_free_space=10%\"\\n', '    ],\\n', '}\\n', '三、使能配置\\n', '\\n', '重启 isulad使得配置生效 ：\\n', '\\n', '# systemctl daemon-reload\\n', '# systemctl restart isulad\\n', '确认 iSula 存储驱动是否配置成功：\\n', '\\n', '# isula info\\n', '若回显有如下信息，说明配置成功。\\n', '\\n', 'Storage Driver: devicemapper\\n', '对接指导\\n', '本章给出 iSula 对接 containerd-shim-kata-v2 的操作指导。\\n', '\\n', 'containerd-shim-kata-v2 默认使用 QEMU 虚拟化组件，本章分别介绍使用 QEMU 和 StratoVirt 两种虚拟化组件时的配置方法。\\n', '\\n', '使用 QEMU\\n', 'containerd-shim-kata-v2 使用的虚拟化组件为 QEMU 时，iSula 对接 containerd-shim-kata-v2 的操作如下：\\n', '\\n', '修改 kata 配置文件，路径为 /usr/share/defaults/kata-containers/configuration.toml\\n', '\\n', 'sandbox_cgroup_with_emulator 需要设置为 false， 目前 shimv2 不支该改功能， 其他参数与 shim v1 中 kata 配置参数保持一致或者保持默认值。\\n', '\\n', 'sandbox_cgroup_with_emulator = false\\n', '使用 busybox 镜像运行安全容器并检查使用的 runtime 为 io.containerd.kata.v2\\n', '\\n', '$ id=`isula run -tid busybox /bin/sh`\\n', \"$ isula inspect -f '{{ json .HostConfig.Runtime }}' $id\\n\", '\"io.containerd.kata.v2\"\\n', '确认 qemu 虚拟机进程被拉起，说明 qemu 和 shim v2 安全容器的对接成功\\n', '\\n', '$ ps -ef | grep qemu\\n', '使用 StratoVirt\\n', 'containerd-shim-kata-v2 使用的虚拟化组件为 StratoVirt 时，iSula 对接 containerd-shim-kata-v2 的操作如下：\\n', '\\n', '在任一目录（例如 /home 目录）新建脚本文件 stratovirt.sh 并使用 root 权限给文件添加执行权限：\\n', '\\n', '# touch /home/stratovirt.sh\\n', '# chmod +x /home/stratovirt.sh\\n', 'stratovirt.sh 内容如下，用于指定 StratoVirt 路径：\\n', '\\n', '#!/bin/bash\\n', 'export STRATOVIRT_LOG_LEVEL=info  # set log level which includes trace, debug, info, warn and error.\\n', '/usr/bin/stratovirt $@\\n', '修改 kata 配置文件 ，将安全容器的 hypervisor 类型配置为 stratovirt，kernel 配置 StratoVirt 的 kernel 镜像绝对路径，initrd 配置为 kata-containers 的 initrd 镜像文件（使用 yum 安装 kata-containers 时，默认会下载这个文件并存放在 /var/lib/kata/ 目录），StratoVirt 仅支持 devicemapper 存储模式，需提前准备好环境并将 iSulad 设置为 devicemapper 模式。\\n', '\\n', '配置参考如下：\\n', '\\n', '[hypervisor.stratovirt]\\n', 'path = \"/home/stratovirt.sh\"\\n', 'kernel = \"/var/lib/kata/vmlinux.bin\"\\n', 'initrd = \"/var/lib/kata/kata-containers-initrd.img\"\\n', 'block_device_driver = \"virtio-mmio\"\\n', 'use_vsock = true\\n', 'enable_netmon = true\\n', 'internetworking_model=\"tcfilter\"\\n', 'sandbox_cgroup_with_emulator = false\\n', 'disable_new_netns = false\\n', 'disable_block_device_use = false\\n', 'disable_vhost_net = true\\n', 'StratoVirt 中使用 vsock 功能， 需要开启 vhost_vsock 内核模块并确认是否开启成功\\n', '\\n', '$ modprobe vhost_vsock\\n', '$ lsmod |grep vhost_vsock\\n', '下载对应版本和架构的 kernel 并放到 /var/lib/kata/ 路径下, 如下载 openEuler 22.03 LTS 版本 x86 架构的内核 openeuler repo：\\n', '\\n', '$ cd /var/lib/kata\\n', '$ wget https://repo.openeuler.org/openEuler-22.03-LTS/stratovirt_img/x86_64/vmlinux.bin\\n', '使用 busybox 镜像运行安全容器并检查使用的 runtime 为 io.containerd.kata.v2\\n', '\\n', '$ id=`isula run -tid busybox sh`\\n', \"$ isula inspect -f '{{ json .HostConfig.Runtime }}' $id\\n\", '\"io.containerd.kata.v2\"\\n', '确认 stratovirt 虚拟机进程被拉起，说明 StratoVirt 和 shim v2 安全容器的对接成功\\n', '\\n', '$ ps -ef | grep stratovirt\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_安装、升级与卸载_卸载.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%8D%B8%E8%BD%BD.html", "text_entry": "['卸载\\n', '卸载iSulad的操作步骤如下：\\n', '\\n', '卸载iSulad及其依赖软件包\\n', '\\n', '若使用yum方式安装，卸载的参考命令如下：\\n', '\\n', '# yum remove iSulad\\n', '若使用rpm方式安装，需卸载iSulad及其依赖包，卸载单个RPM包的参考命令如下：\\n', '\\n', '# rpm -e iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm\\n', '镜像、容器、volumes以及相关配置文件不会自动删除，需要手动删除。参考命令如下：\\n', '\\n', '# rm -rf /var/lib/iSulad\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理设备.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87.html", "text_entry": "['管理设备\\n', '管理设备\\n', '配置虚拟机PCIe控制器\\n', '管理虚拟磁盘\\n', '管理虚拟网卡\\n', '配置虚拟串口\\n', '管理设备直通\\n', 'PCI直通\\n', 'SR-IOV直通\\n', '管理虚拟机USB\\n', '配置USB控制器\\n', '配置USB直通设备\\n', '管理快照\\n', '配置磁盘IO悬挂\\n', '总体介绍\\n', '概述\\n', '应用场景\\n', '注意事项和约束限制\\n', '磁盘IO悬挂配置\\n', 'Qemu命令行配置\\n', 'xml配置方式\\n', '配置虚拟机PCIe控制器\\n', '概述\\n', '虚拟机内部的网卡、磁盘控制器、PCIe直通设备都需要挂接到PCIe Root Port下面，每个Root Port对应一个PCIe插槽。Root Port的下挂设备支持热插拔，但是Root Port本身不支持热插拔，因此需要用户考虑设备热插的需求，规划虚拟机需要预留的最大PCIe Root Port数量，在虚拟机启动之前完成Root Port的静态配置。\\n', '\\n', '配置PCIe Root、PCIe Root Port和PCIe-PCI-Bridge\\n', '虚拟机PCIe控制器通过XML文件进行配置，PCIe Root、PCIe Root Port和PCIe-PCI-Bridge对应XML中的model分别为pcie-root、pcie-root-port、pcie-to-pci-bridge。\\n', '\\n', '简化配置方法\\n', '\\n', '在虚拟机的XML文件中写入以下内容，controller的其他属性由libvirt自动填充：\\n', '\\n', \"  <controller type='pci' index='0' model='pcie-root'/>\\n\", \"  <controller type='pci' index='1' model='pcie-root-port'/>\\n\", \"  <controller type='pci' index='2' model='pcie-to-pci-bridge'/>\\n\", \"  <controller type='pci' index='3' model='pcie-root-port'/>\\n\", \"  <controller type='pci' index='4' model='pcie-root-port'/>\\n\", \"  <controller type='pci' index='5' model='pcie-root-port'/>\\n\", '其中：由于pcie-root和pcie-to-pci-bridge分别占用1个index，因此最终的index等于需要的Root Port数量+1。\\n', '\\n', '完整配制方法\\n', '\\n', '在虚拟机的XML文件中写入以下内容：\\n', '\\n', \"  <controller type='pci' index='0' model='pcie-root'/>\\n\", \"  <controller type='pci' index='1' model='pcie-root-port'>\\n\", \"    <model name='pcie-root-port'/>\\n\", \"    <target chassis='1' port='0x8'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0' multifunction='on'/>\\n\", '  </controller>\\n', \"  <controller type='pci' index='2' model='pcie-to-pci-bridge'>\\n\", \"    <model name='pcie-pci-bridge'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>\\n\", '  </controller>\\n', \"  <controller type='pci' index='3' model='pcie-root-port'>\\n\", \"    <model name='pcie-root-port'/>\\n\", \"    <target chassis='3' port='0x9'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>\\n\", '  </controller>\\n', \"  <controller type='pci' index='3' model='pcie-root-port'>\\n\", '其中：\\n', '\\n', 'Root Port的chassis和port属性必须依次递增，由于中间插入一个PCIe-PCI-Bridge，chassis编号跳过2，但是port编号仍然连续。\\n', 'Root Port的address function的取值范围为0x0~0x7。\\n', '每个slot最多下挂8个function，挂满之后需要递增slot编号。\\n', '由于完整配置方法相对复杂，建议采用简化配置方法。\\n', '\\n', '管理虚拟磁盘\\n', '概述\\n', '虚拟磁盘类型主要包含virtio-blk、virtio-scsi、vhost-scsi等。virtio-blk模拟的是一种block设备，virtio-scsi和vhost-scsi模拟的是一种scsi设备。\\n', '\\n', 'virtio-blk：普通系统盘和数据盘可用，该种配置下虚拟磁盘在虚拟机内部呈现为vd[a-z]或vd[a-z][a-z]。\\n', 'virtio-scsi：普通系统盘和数据盘建议选用，该种配置下虚拟磁盘在虚拟机内部呈现为sd[a-z]或sd[a-z][a-z]。\\n', 'vhost-scsi：对性能要求高的虚拟磁盘建议选用，该种配置下虚拟磁盘在虚拟机内部呈现为sd[a-z]或sd[a-z][a-z]。\\n', '操作步骤\\n', '虚拟磁盘的配置步骤，请参见“虚拟机配置 > 存储设备”。本节以virtio-scsi磁盘为例，介绍挂载和卸载虚拟磁盘的简单方法。\\n', '\\n', '挂载virtio-scsi磁盘：\\n', '\\n', '使用virsh attach-device命令挂载virtio-scsi虚拟磁盘：\\n', '\\n', ' $ virsh attach-device <VMInstance> <attach-device.xml>\\n', '上述命令可以为虚拟机在线挂载磁盘，其中磁盘信息由attach-device.xml文件指定。下面是一个attach-device.xml文件的例子：\\n', '\\n', '### attach-device.xml ###\\n', \"    <disk type='file' device='disk'>\\n\", \"      <driver name='qemu' type='qcow2' cache='none' io='native'/>\\n\", \"      <source file='/path/to/another/qcow2-file'/>\\n\", '      <backingStore/>\\n', \"      <target dev='sdb' bus='scsi'/>\\n\", \"      <address type='drive' controller='0' bus='0' target='1' unit='0'/>\\n\", '    </disk>\\n', '通过上述命令挂载的磁盘，在虚拟机关机重启后失效。如果需要为虚拟机持久化挂载虚拟磁盘，需要使用带–config参数的virsh attach-device命令。\\n', '\\n', '卸载virtio-scsi磁盘：\\n', '\\n', '通过在线挂载的磁盘，如果不需要再使用，可以通过virsh detach命令动态卸载：\\n', '\\n', ' $ virsh detach-device <VMInstance> <detach-device.xml>\\n', '其中，detach-device.xml指定了需要卸载的磁盘的XML信息，与动态挂载时的XML信息保持一致。\\n', '\\n', '管理虚拟网卡\\n', '概述\\n', '虚拟网卡类型主要包含virtio-net、vhost-net、vhost-user等。用户在创建虚拟机后，可能会有挂载或者卸载虚拟网卡的需求。openEuler提供了网卡热插拔的功能，通过网卡热插拔，能够改变网络的吞吐量，提高系统的灵活性和扩展性。\\n', '\\n', '操作步骤\\n', '虚拟网卡的配置步骤，请参见“虚拟机配置 > 网络设备”。本节以vhost-net网卡为例，介绍挂载和卸载虚拟网卡的简单方法。\\n', '\\n', '挂载vhost-net网卡：\\n', '\\n', '使用virsh attach-device命令挂载vhost-net虚拟网卡：\\n', '\\n', ' $ virsh attach-device <VMInstance> <attach-device.xml>\\n', '上述命令可以为虚拟机在线挂载vhost-net网卡，其中网卡信息由attach-device.xml文件指定。下面是一个attach-device.xml文件的例子：\\n', '\\n', '### attach-device.xml ###\\n', \"    <interface type='bridge'>\\n\", \"      <mac address='52:54:00:76:f2:bb'/>\\n\", \"      <source bridge='br0'/>\\n\", \"      <virtualport type='openvswitch'/>\\n\", \"      <model type='virtio'/>\\n\", \"      <driver name='vhost' queues='2'/>\\n\", '    </interface>\\n', '通过上述命令挂载的vhost-net网卡，在虚拟机关机重启后失效。如果需要为虚拟机持久化挂载虚拟网卡，需要使用带–config参数的virsh attach-device命令。\\n', '\\n', '卸载vhost-net网卡：\\n', '\\n', '通过在线挂载的网卡，如果不需要再使用，可以通过virsh detach命令动态卸载：\\n', '\\n', ' $ virsh detach-device <VMInstance> <detach-device.xml>\\n', '其中，detach-device.xml指定了需要卸载虚拟网卡的XML信息，与动态挂载时的XML信息保持一致。\\n', '\\n', '配置虚拟串口\\n', '概述\\n', '在虚拟化环境下，由于管理和业务的需求，虚拟机与宿主机需要互相通信。但在云管理系统复杂的网络架构下，运行在管理平面的服务与运行在业务平面的虚拟机之间，不能简单的进行三层网络互相通信，导致服务部署和信息收集不够快速。因此需要提供虚拟串口，来达到虚拟机与宿主机之间互相通信的目的。 通过在虚拟机的XML配置文件中增加相应串口的配置项，可以实现虚拟机与宿主机之间的互相通信。\\n', '\\n', '操作步骤\\n', 'Linux虚拟机串口控制台，即虚拟机串口连接到宿主机的一个伪终端设备，通过宿主机的设备间接实现对虚拟机的交互式操作。在该场景下串口需配置为pty类型，本节介绍pty型串口的配置方法。\\n', '\\n', '在虚拟机的XML配置文件中\"devices\"节点下添加如下所示的虚拟串口配置项：\\n', '\\n', \"    <serial type='pty'>\\n\", '    </serial>\\n', \"    <console type='pty'>\\n\", \"      <target type='serial'/>\\n\", '    </console>\\n', '使用virsh console命令连接到正在运行的虚拟机的pty串口。\\n', '\\n', '$ virsh console <VMInstance>\\n', '如果要确保没有遗漏任何串口消息，请在启动虚拟机时使用–console选项连接到串口。\\n', '\\n', '$ virsh start --console <VMInstance>\\n', '管理设备直通\\n', '设备直通技术是指将host上的物理设备直接呈现给一台虚拟机，虚拟机可以直接访问该设备资源的一种使用方式。使用设备直通的方式可以让虚拟机获得良好的I/O性能。\\n', '\\n', '当前设备直通使用的是VFIO方式，按照直通的设备类型可以分为PCI直通和SR-IOV直通两种类型。\\n', '\\n', 'PCI直通\\n', 'PCI直通是指将host上的物理PCI设备直接呈现给一台虚拟机，供虚拟机直接访问的一种使用方式。PCI直通使用了vfio设备直通方式，为虚拟机配置PCI直通的xml配置如下：\\n', '\\n', \"<hostdev mode='subsystem' type='pci' managed='yes'>   \\n\", \"    <driver name='vfio'/> \\n\", '    <source>\\n', \"        <address domain='0x0000' bus='0x04' slot='0x10' function='0x01'/>\\n\", '    </source>\\n', \"    <rom bar='off'/>\\n\", \"    <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>\\n\", '</hostdev>\\n', '表 1 PCI直通设备配置项\\n', '\\n', '\\n', '参数名\\n', '\\n', '说明\\n', '\\n', '取值\\n', '\\n', 'hostdev.source.address.domain\\n', '\\n', 'host OS上的PCI设备的domain号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.source.address.bus\\n', '\\n', 'host OS上的PCI设备bus号。\\n', '\\n', '>=1\\n', '\\n', 'hostdev.source.address.slot\\n', '\\n', 'host OS上的PCI设备的device号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.source.address.function\\n', '\\n', 'host OS上的PCI设备的function号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.driver.name\\n', '\\n', '可选配置项，指定PCI直通的后端驱动。\\n', '\\n', 'vfio（默认配置项）\\n', '\\n', 'hostdev.rom\\n', '\\n', '直通设备的ROM是否呈现给虚拟机。\\n', '\\n', '可以配置为“on/off”，默认为“on”。\\n', '\\n', 'on：表示直通设备的ROM呈现给虚拟机，例如：直通网卡虚拟机需要从该网卡的PXE启动时，可以将该选项配置为“on”，HBA卡直通虚拟机需要从ROM中启动时可以将该选项配置为“on”。\\n', 'off：表示直通设备的ROM不呈现给虚拟机。\\n', 'hostdev.address type\\n', '\\n', 'PCI设备呈现的Guest内bdf号。\\n', '\\n', '[0x03-0x1e](./slot范围)\\n', '\\n', '说明：\\n', '\\n', 'domain为域信息，bus为总线号，slot为插槽号，function为功能\\n', '除了slot插槽号，这里其余均默认为0。\\n', '第一个slot插槽号0x00被系统占用，第二个slot号0x01被IDE控制器和USB控制器占用，第三个slot号0x02被video占用。\\n', '最后一个slot号0x1f被pvchannel占用。\\n', ' 说明：\\n', 'VFIO直通方式的最小直通单位是iommu_group，host根据硬件上的ACS位，来划分iommu_group。同一个iommu_group中的设备只允许直通给同一台虚拟机（一个PCI设备上的若干个function，如果属于同一个iommu_group，只允许直通给一个虚拟机使用）。\\n', '\\n', 'SR-IOV直通\\n', '概述\\n', 'SR-IOV（Single Root I/O Virtualizaiton）是一种基于硬件的虚拟化解决方案，通过SR-IOV技术可以将一个PF（Physical Function）虚拟成多个VF（Virtual Function），每个VF都可以单独被直通给一个虚拟机，极大地提升了硬件资源利用率和虚拟机的I/O性能。一种典型的应用场景就是网卡SR-IOV设备直通，利用SR-IOV技术可以将一个物理网卡（PF）虚拟成多个VF网卡，再把VF直通给虚拟机使用。\\n', '\\n', ' 说明：\\n', '\\n', 'SR-IOV需要物理硬件支持，使用SR-IOV前请确保要直通的硬件设备支持该能力，并且Host侧的设备驱动程序工作在SR-IOV模式下。\\n', '查询网卡具体型号的办法如下：\\n', '例如下述回显，第一列为网卡的PCI号，19e5:1822为网卡的厂商号设备号。\\n', '# lspci | grep Ether  \\n', '05:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '07:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '09:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '0b:00.0 Ethernet controller: Device 19e5:1822 (rev 45)  \\n', '81:00.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)  \\n', '81:00.1 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)  \\n', '操作方法\\n', '请使用root用户按照如下操作步骤配置SR-IOV直通网卡：\\n', '\\n', '开启网卡的SR-IOV模式。\\n', '\\n', '请确保Guest OS有网卡供应商提供的VF驱动支持，否则Guest OS内VF无法正常工作。\\n', '\\n', '在host OS的BIOS中开启SMMU/IOMMU的支持。不同厂家服务器的开启方式可能不同，请参考各服务器的帮助文档。\\n', '\\n', 'HOST驱动配置，开启SR-IOV的VF模式。这里以Hi1822网卡为例，开启16个VF。\\n', '\\n', 'echo 16 > /sys/class/net/ethX/device/sriov_numvfs\\n', '获取PF和VF的PCI BDF信息。\\n', '\\n', '获取当前单板上的网卡资源列表，参考命令如下：\\n', '\\n', '# lspci | grep Eth\\n', '03:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '04:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '05:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '06:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family (4*25GE) (rev 45)\\n', '7d:00.0 Ethernet controller: Huawei Technologies Co., Ltd. Device a222 (rev 20)\\n', '7d:00.1 Ethernet controller: Huawei Technologies Co., Ltd. Device a222 (rev 20)\\n', '7d:00.2 Ethernet controller: Huawei Technologies Co., Ltd. Device a221 (rev 20)\\n', '7d:00.3 Ethernet controller: Huawei Technologies Co., Ltd. Device a221 (rev 20)\\n', '查看VF的PCI BDF信息，参考命令如下：\\n', '\\n', '# lspci | grep \"Virtual Function\"\\n', '03:00.1 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.2 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.3 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.4 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.5 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.6 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:00.7 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:01.0 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:01.1 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '03:01.2 Ethernet controller: Huawei Technologies Co., Ltd. Hi1822 Family Virtual Function (rev 45)\\n', '选择一个可用的VF，根据其BDF信息将其配置写入虚拟机的配置文件中。以03:00.1设备为例，对应的bus号是03，slot号是00，function号是1。\\n', '\\n', '识别和管理PF/VF对应关系。\\n', '\\n', '识别PF对应的VF关系，以PF 03.00.0为例：\\n', '\\n', '# ls -l /sys/bus/pci/devices/0000\\\\:03\\\\:00.0/\\n', '可下显示如下的软链接信息，根据信息可以获得其对应的VF编号（virtfnX）和PCI BDF号。\\n', '\\n', '识别VF对应的PF关系，以VF 03:00.1为例：\\n', '\\n', '# ls -l /sys/bus/pci/devices/0000\\\\:03\\\\:00.1/\\n', '可显示下述软连接信息，即可获得其对应PF的PCI BDF号。\\n', '\\n', 'lrwxrwxrwx 1 root root       0 Mar 28 22:44 physfn -> ../0000:03:00.0\\n', '获知PF/VF对应的网卡设备名称，例如：\\n', '\\n', '# ls /sys/bus/pci/devices/0000:03:00.0/net\\n', 'eth0\\n', '设置VF的mac/vlan/qos信息，确保VF在直通之前处于UP状态。以VF 03:00.1为例，假设PF为eth0，VF编号为0。\\n', '\\n', '# ip link set eth0 vf 0 mac 90:E2:BA:21:XX:XX    # 设置mac地址\\n', '# ifconfig eth0 up\\n', '# ip link set eth0 vf 0 rate 100                 # 设置VF出口速率，单位Mbps\\n', '# ip link show eth0                              # 查看mac/vlan/qos信息，确认设置成功\\n', '挂载SR-IOV网卡到虚拟机中。\\n', '\\n', '创建虚拟机时，在虚拟机配置文件中增加SR-IOV直通的配置项。\\n', '\\n', \"<interface type='hostdev' managed='yes'> \\n\", \"    <mac address='fa:16:3e:0a:xx:xx'/>\\n\", '    <source> \\n', \"        <address type='pci' domain='0x0000' bus='0x06' slot='0x11' function='0x6'/>\\n\", '    </source> \\n', '    <vlan>\\n', \"        <tag id='1'/>\\n\", '    </vlan>\\n', '</interface>\\n', '表 1 SR-IOV配置选项说明\\n', '\\n', '\\n', '参数名\\n', '\\n', '说明\\n', '\\n', '取值\\n', '\\n', 'hostdev.managed\\n', '\\n', 'libvirt处理PCI设备的两种模式。\\n', '\\n', 'no：默认配置，表示直通设备由用户自行管理。\\n', '\\n', 'yes：表示直通设备由libvirt管理。SR-IOV直通场景需要配置为yes。\\n', '\\n', 'hostdev.source.address.bus\\n', '\\n', 'host OS上的PCI设备bus号。\\n', '\\n', '>=1\\n', '\\n', 'hostdev.source.address.slot\\n', '\\n', 'host OS上的PCI设备device号。\\n', '\\n', '>=0\\n', '\\n', 'hostdev.source.address.function\\n', '\\n', 'host OS上的PCI设备function号。\\n', '\\n', '>=0\\n', '\\n', ' 说明：\\n', '关闭SR-IOV功能。\\n', '在虚拟机使用完毕后（虚拟机关机，所有的VF均没有在使用中的时候），若要关闭SR-IOV功能。执行操作如下：\\n', '这里以Hi1822网卡（eth0对应PF的网口名称）为例：\\n', '\\n', 'echo 0 > /sys/class/net/eth0/device/sriov_numvfs  \\n', 'HPRE加速器SR-IOV直通\\n', '加速器引擎是TaiShan 200服务器基于Kunpeng 920处理器提供的硬件加速解决方案。HPRE加速器用于加速SSL/TLS应用，可以显著降低处理器消耗，提高处理器效率。\\n', '在鲲鹏服务器上，需要把主机Host上的HPRE加速器的VF直通给虚拟机，供虚拟机内部业务使用。\\n', '\\n', '表 1 HPRE加速器说明\\n', '\\n', '项目\\t说明\\n', '设备名称\\tHi1620 on-chip RSA/DH security algorithm accelerator (HPRE engine)\\n', '功能\\t模幂运算、RSA密钥对运算、DH计算、部分大数辅助运算(模幂、模乘、取模、乘法、模逆、素数测试、互质测试)\\n', 'VendorID\\t0x19E5\\n', 'PF DeviceID\\t0xA258\\n', 'VF DeviceID\\t0xA259\\n', '最大VF数量\\t一个HPRE PF最多支持创建63个VF\\n', ' 说明：\\n', '当虚拟机正在使用VF设备时，不允许卸载Host上的驱动，加速器不支持热插拔。\\n', 'VF操作(VFNUMS为0表示关闭VF，hpre_num用来标识具体的加速器设备)：\\n', '\\n', 'echo $VFNUMS > /sys/class/uacce/hisi_hpre-$hpre_num/device/sriov_numvfs\\n', '管理虚拟机USB\\n', '为了方便在虚拟机内部使用USBkey设备、USB海量存储设备等USB设备，openEuler提供了USB设备直通的功能。用户可以通过USB直通和热插拔相关接口给虚拟机配置直通USB设备、或者在虚拟机处于运行的状态下热插/热拔USB设备。\\n', '\\n', '配置USB控制器\\n', '概述\\n', 'USB控制器是为虚拟机上的USB设备提供具体USB功能的虚拟控制器设备，在虚拟机内部使用USB设备必须给虚拟机配置USB控制器。当前openEuler支持如下三种USB控制器：\\n', '\\n', 'UHCI（Universal Host Controller Interface）：通用主机控制器接口，也称为USB 1.1主机控制器规范。\\n', 'EHCI（Enhanced Host Controller）：增强主机控制器接口，也称为USB 2.0主机控制器规范。\\n', 'xHCI（eXtensible Host Controller Interface）：可扩展主机控制器接口，也称为USB 3.0主机控制器规范。\\n', '注意事项\\n', '主机服务器上需存在支持USB 1.1、USB 2.0和USB 3.0标准的USB控制器硬件和模块。\\n', '为虚拟机配置USB控制器时，请按照USB 1.1、USB 2.0到USB 3.0的顺序来配置。\\n', '一个xHCI控制器有8个端口，最多可以挂载4个USB 3.0设备和4个USB 2.0设备。一个EHCI控制器有6个端口，最多可以挂载6个USB2.0设备。一个UHCI控制器有2个端口，最多可以挂载2个USB 1.1设备。\\n', '每台虚拟机最多支持配置一个相同类型的USB控制器。\\n', '不支持热插拔USB控制器。\\n', '若虚拟机没有安装USB 3.0的驱动，可能无法识别xHCI控制器，USB 3.0驱动下载和安装方法请参见对应OS发行商官方说明。\\n', '为了不影响操作系统的兼容性，为虚拟机配置USB接口的tablet设备时，请指定USB控制器bus号为0（默认挂载到USB 1.1控制器上）。\\n', '配置方法\\n', '这里介绍为虚拟机配置USB控制器的配置内容说明。建议同时配置USB 1.1、USB 2.0和USB 3.0，做到同时兼容三种设备。\\n', '\\n', 'USB 1.1控制器（UHCI）的XML配置项为：\\n', '\\n', \"<controller type='usb' index='0' model='piix3-uhci'>\\n\", '</controller>\\n', 'USB 2.0控制器（EHCI）的XML配置为：\\n', '\\n', \"<controller type='usb' index='1' model='ehci'>\\n\", '</controller>\\n', 'USB 3.0控制器（xHCI）的XML配置为：\\n', '\\n', \"<controller type='usb' index='2' model='nec-xhci'>\\n\", '</controller>\\n', '配置USB直通设备\\n', '概述\\n', '当虚拟机配置好USB控制器后，就可以通过设备直通的方式将主机上的物理USB设备挂载到虚拟机内部供虚拟机使用。在虚拟化场景下，除了支持静态配置以外还同时支持USB设备的热插/拔操作，即在虚拟机处于运行状态的时候挂载/卸载USB设备。\\n', '\\n', '注意事项\\n', '一个USB设备只能直通给一台虚拟机使用\\n', '配置了直通USB设备的虚拟机不支持热迁移\\n', '虚拟机配置文件中直通的USB设备不存在时，虚拟机会创建失败\\n', '对一个正在读写的USB存储设备进行强制热拔操作有可能会损坏USB设备内的文件\\n', '配置说明\\n', '这里介绍为虚拟机配置USB设备的配置内容说明。\\n', '\\n', 'USB设备的XML描述：\\n', '\\n', \"<hostdev mode='subsystem' type='usb' managed='yes'>\\n\", '    <source>        \\n', \"        <address bus='m' device='n'/>\\n\", '    </source>\\n', \"    <address type='usb' bus='x' port='y'/>\\n\", '</hostdev>\\n', \"<address bus='m' device='n'/>，其中，m表示该USB设备在主机上的bus地址，n表示device ID编号。\\n\", \"<address type='usb' bus='x' port='y'/> 表示该USB设备要挂载到虚拟机指定的USB控制器。其中x表示控制器ID，与虚拟机所配置的USB控制器index编号相对应，y表示port地址。用户配置直通USB设备的时候需要配置这个字段，确保设备挂载的控制器与预期相符。\\n\", '配置方法\\n', '配置USB直通的步骤如下：\\n', '\\n', '为虚拟机配置USB控制器，配置方法请参见“虚拟机配置 > 配置USB控制器”。\\n', '\\n', '查询主机上的USB设备信息。\\n', '\\n', '通过lsusb命令（需要安装usbutils软件包）查询主机上的USB设备信息，包含bus地址、device地址、设备厂商ID、设备ID和产品描述信息等。例如：\\n', '\\n', '$ lsusb\\n', 'Bus 008 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\\n', 'Bus 007 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 004 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\\n', 'Bus 006 Device 002: ID 0bda:0411 Realtek Semiconductor Corp. \\n', 'Bus 006 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub\\n', 'Bus 005 Device 003: ID 136b:0003 STEC \\n', 'Bus 005 Device 002: ID 0bda:5411 Realtek Semiconductor Corp. \\n', 'Bus 005 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 001 Device 003: ID 12d1:0003 Huawei Technologies Co., Ltd. \\n', 'Bus 001 Device 002: ID 0bda:5411 Realtek Semiconductor Corp. \\n', 'Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub\\n', 'Bus 003 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub\\n', '准备USB设备的XML描述文件，注意在设备热拔之前，请确保USB设备当前不在使用当中，否则可能造成数据丢失。\\n', '\\n', '执行热插、热拔命令。\\n', '\\n', '假设虚拟机名称为openEulerVM，对应的配置文件为usb.xml。\\n', '\\n', '热插USB设备，只对当前运行的虚拟机有效，虚拟机冷重启后需要重新配置。\\n', '\\n', '$ virsh attach-device openEulerVM usb.xml --live\\n', '热插USB设备，持久化该配置，即该虚拟机重启后该设备会自动直通给该虚拟机使用。\\n', '\\n', '$ virsh attach-device openEulerVM usb.xml --config\\n', '热拔USB设备，只对当前运行的虚拟机有效，持久化配置的USB设备在虚拟机重启后USB设备会自动直通给该虚拟机。\\n', '\\n', '$ virsh detach-device openEulerVM usb.xml --live\\n', '热拔USB设备，持久化该配置。\\n', '\\n', '$ virsh detach-device openEulerVM usb.xml --config\\n', '管理快照\\n', '概述\\n', '虚拟机在使用过程中可能由于病毒对系统的破坏、系统文件被误删除或误格式化等原因造成虚拟机系统损坏导致系统无法启动。为了使损坏的系统快速恢复，openEuler提供了存储快照功能。openEuler可以在用户不感知的情况下制作虚拟机在某一时刻的快照（制作通常指需要几秒钟），该快照能帮助用户将磁盘快速恢复到某一时刻的状态，例如系统损坏后能快速恢复系统，从而提升系统可靠性。\\n', '\\n', ' 说明：\\n', '当前存储快照只支持raw、qcow2格式镜像，不支持block块设备。\\n', '\\n', '操作步骤\\n', '制作虚拟机存储快照的操作步骤如下：\\n', '\\n', '登录主机，通过virsh domblklist命令查询虚拟机使用的磁盘。\\n', '\\n', '$ virsh domblklist openEulerVM\\n', '  Target   Source\\n', ' ---------------------------------------------\\n', '  vda      /mnt/openEuler-image.qcow2\\n', '创建虚拟机磁盘快照_openEuler-snapshot1.qcow2_，命令及回显如下：\\n', '\\n', '$ virsh snapshot-create-as --domain openEulerVM --disk-only --diskspec vda,snapshot=external,file=/mnt/openEuler-snapshot1.qcow2 --atomic\\n', 'Domain snapshot 1582605802 created\\n', '磁盘快照查询操作。\\n', '\\n', '$ virsh snapshot-list openEulerVM\\n', ' Name         Creation Time               State\\n', '---------------------------------------------------------\\n', ' 1582605802   2020-02-25 12:43:22 +0800   disk-snapshot\\n', '总体介绍\\n', '概述\\n', '存储故障（比如存储断链）场景下，物理磁盘的IO错误，通过虚拟化层传给虚拟机前端，虚拟机内部收到IO错误，可能导致虚拟机内部的用户文件系统变成read-only状态，需要重启虚拟机或者用户手动恢复，这给用户带来额外的工作量。\\n', '\\n', '这种情况下，虚拟化平台提供了一种磁盘IO悬挂的能力，即当存储故障时，虚拟机IO下发到主机侧时将IO悬挂住，在悬挂时间内不对虚拟机内部返回IO错误，这样虚拟机内部的文件系统就不会因为IO错误而变为只读状态，而是呈现为Hang住；同时虚拟机后端按指定的悬挂间隔对IO进行重试。如果存储故障在悬挂时间内恢复正常，悬挂住的IO即可恢复落盘，虚拟机内部文件系统自动恢复运行，不需要重启虚拟机；如果存储故障在悬挂时间内未能恢复正常，则上报错误给虚拟机内部，通知给用户。\\n', '\\n', '应用场景\\n', '使用可能会发生存储面链路断链的云盘作为虚拟磁盘后端的场景。\\n', '\\n', '注意事项和约束限制\\n', '磁盘IO悬挂仅支持virtio-blk或virtio-scsi类型的虚拟磁盘。\\n', '\\n', '磁盘IO悬挂的虚拟磁盘后端一般为可能会发生存储面链路断链的云盘。\\n', '\\n', '磁盘IO悬挂可对读写IO错误分别使能，同一磁盘的读写IO错误重试间隔和超时时间使用相同配置。\\n', '\\n', '磁盘IO悬挂重试间隔不包含主机侧实际读写IO的开销，即两次IO重试操作实际间隔会大于配置的IO错误重试间隔。\\n', '\\n', '磁盘IO悬挂无法区分IO错误的具体类型（如存储断链、扇区坏道、预留冲突等），只要硬件返回IO错误，都会进行悬挂处理。\\n', '\\n', '磁盘IO悬挂时，虚拟机内部IO不会返回，fdisk等访问磁盘的系统命令会卡住，虚拟机内部依赖该命令返回的业务也会一直卡住。\\n', '\\n', '磁盘IO悬挂时，IO无法正常落盘，可能会导致虚拟机无法优雅关机，需要强制关机。\\n', '\\n', '磁盘IO悬挂时，无法读取磁盘数据，会造成虚拟机无法正常重启，需要先将虚拟机强制关机，等待存储故障恢复后在重新启动虚拟机。\\n', '\\n', '存储故障发生后，虽然存在磁盘IO悬挂，依然解决不了以下问题：\\n', '\\n', '存储相关高级特性执行失败\\n', '\\n', '高级特性包括：虚拟磁盘热插、虚拟磁盘热拔、创建虚拟磁盘、虚拟机启动、虚拟机关机、虚拟机强制关机、虚拟机休眠、虚拟机唤醒、虚拟机存储热迁移、虚拟机存储热迁移取消、虚拟机创建存储快照、虚拟机存储快照合并、查询虚拟机磁盘容量、磁盘在线扩容、插入虚拟光驱、弹出虚拟机光驱。\\n', '\\n', '虚拟机生命周期执行失败\\n', '\\n', '配置了磁盘IO悬挂的虚拟机发起热迁移时，应该在目的端磁盘的XML配置中带上与源端相同的磁盘IO悬挂配置。\\n', '\\n', '磁盘IO悬挂配置\\n', 'Qemu命令行配置\\n', '磁盘IO悬挂功能通过在虚拟磁盘设备上指定werror=retry rerror=retry进行使能，使用retry_interval和retry_timeout进行重试策略的配置。retry_interval为IO错误重试的间隔，配置范围为0-MAX_LONG，单位为毫秒，未配置时使用默认值1000ms；retry_timeout为IO错误重试超时时间，配置范围为0-MAX_LONG，0值表示不会发生超时，单位为毫秒，未配置时使用默认值0。\\n', '\\n', 'virtio-blk磁盘的磁盘IO悬挂配置如下：\\n', '\\n', '-drive file=/path/to/your/storage,format=raw,if=none,id=drive-virtio-disk0,cache=none,aio=native \\\\\\n', '-device virtio-blk-pci,scsi=off,bus=pci.0,addr=0x6,\\\\\\n', 'drive=drive-virtio-disk0,id=virtio-disk0,write-cache=on,\\\\\\n', 'werror=retry,rerror=retry,retry_interval=2000,retry_timeout=10000\\n', 'virtio-scsi磁盘的磁盘IO悬挂配置如下：\\n', '\\n', '-drive file=/path/to/your/storage,format=raw,if=none,id=drive-scsi0-0-0-0,cache=none,aio=native \\\\\\n', '-device scsi-hd,bus=scsi0.0,channel=0,scsi-id=0,lun=0,\\\\\\n', 'device_id=drive-scsi0-0-0-0,drive=drive-scsi0-0-0-0,id=scsi0-0-0-0,write-cache=on,\\\\\\n', 'werror=retry,rerror=retry,retry_interval=2000,retry_timeout=10000\\n', 'xml配置方式\\n', \"磁盘IO悬挂功能通过在磁盘xml配置中指定error_policy='retry' rerror_policy='retry'进行使能。主要是配置上retry_interval和retry_timeout的值。retry_interval为IO错误重试的间隔，配置范围为0-MAX_LONG，单位为毫秒，未配置时使用默认值1000ms；retry_timeout为IO错误重试超时时间，配置范围为0-MAX_LONG，0值表示不会发生超时，单位为毫秒，未配置时使用默认值0。\\n\", '\\n', 'virtio-blk磁盘的磁盘IO悬挂xml配置如下：\\n', '\\n', \"<disk type='block' device='disk'>\\n\", \"  <driver name='qemu' type='raw' cache='none' io='native' error_policy='retry' rerror_policy='retry' retry_interval='2000' retry_timeout='10000'/>\\n\", \"  <source dev='/path/to/your/storage'/>\\n\", \"  <target dev='vdb' bus='virtio'/>\\n\", '  <backingStore/>\\n', '</disk>\\n', 'virtio-scsi磁盘的磁盘IO悬挂xml配置如下：\\n', '\\n', \"<disk type='block' device='disk'>\\n\", \"  <driver name='qemu' type='raw' cache='none' io='native' error_policy='retry' rerror_policy='retry' retry_interval='2000' retry_timeout='10000'/>\\n\", \"  <source dev='/path/to/your/storage'/>\\n\", \"  <target dev='sdb' bus='scsi'/>\\n\", '  <backingStore/>\\n', \"  <address type='drive' controller='0' bus='0' target='0' unit='0'/>\\n\", '</disk>\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_构建指导_快速构建指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E6%8C%87%E5%AF%BC.html", "text_entry": "['快速构建指导\\n', '本章主要介绍如何构建openEuler Embedded。\\n', '\\n', '快速构建指导\\n', '环境准备\\n', 'Yocto中主机端命令使用\\n', 'openEuler Embedded所需构建工具\\n', '已安装好工具的构建容器\\n', '版本构建\\n', '构建代码下载\\n', '编译构建\\n', '构建结果说明\\n', '环境准备\\n', 'Yocto中主机端命令使用\\n', 'Yocto或者说Bitbake本质上是一组python程序，其最小运行环境要求如下：\\n', '\\n', 'Python3 > 3.6.0\\n', 'Git > 1.8.3.1\\n', 'Tar > 1.28\\n', '在构建过程中所需要的其他工具，Yocto都可以根据相应的软件包配方自行构建出来，从而达到自包含的效果。在这个过程中，Yocto还会依据自身需要，对相应的工具打上yocto专属补丁（如dnf，rpm等）。这些主机工具会在第一次的构建中从源码开始构建，因此Yocto第一次构建比较费时。\\n', '\\n', '为了加速构建特别是第一次构建，openEuler Embedded采取了\"能用原生工具就用原生工具，能不构建就不构建\"的策略，尽可能使用主机上预编译的原生的工具。这就需要依赖主机上软件包管理工具（apt, dnf, yum, zypper等)事先安装好。\\n', '\\n', 'Yocto是通过HOSTTOOLS变量来实现主机工具的引入，为会每个在HOSTTOOLS中列出的工具建立相应的软链接。为了避免来自主机对构建环境的污染，Yocto会重新准备不同于主机的环境，例如PATH变量等，因此如果新增依赖主机上的某个命令，需显示在Yocto的HOSTTOOLS变量中增加，否则即使主机上存在，Yocto构建时也会报错找不到相应的工具。相应流程如下图所示：\\n', '\\n', '\\n', '\\n', '当前openEuler Embedded所需要主机工具已经默认在local.conf.sample中的HOSTTOOLS定义，主要工具描述如下：\\n', '\\n', '工具名\\t用途\\n', 'cmake\\tcmake构建工具\\n', 'ninjia\\tninja构建系统\\n', 'openEuler Embedded所需构建工具\\n', '构建OS\\n', '\\n', '操作系统:openEuler-20.03-LTS-SP2\\n', '\\n', '安装系统额外工具\\n', '\\n', 'yum -y install tar cmake gperf sqlite-devel chrpath gcc-c++ patch rpm-build flex autoconf automake m4 bison bc libtool gettext-devel createrepo\\\\_c rpcgen texinfo hostname python meson dosfstools mtools parted ninja-build autoconf-archive libmpc-devel gmp-devel\\n', '预编译的交叉工具链和库\\n', '\\n', 'Yocto可以构建出交叉编译所需的交叉工具链和C库，但整个流程复杂且耗时，不亚于内核乃至镜像的构建，而且除了第一次构建，后面很少会再涉及。同时，绝大部分开发者都不会直接与工具链和C库构建打交道。所以为了简化该流程，openEuler Embedded采取的策略是采用预编译的交叉工具链和库，会专门维护和发布相应的带有C库的工具链。\\n', '\\n', '目前我们提供了对arm32位和aarch64位两种架构的工具链支持，通过如下方式可以获得：\\n', '\\n', '下载rpm包: wget https://repo.openeuler.org/openEuler-22.03-LTS/EPOL/main/x86_64/Packages/gcc-cross-1.0-0.oe2203.x86_64.rpm\\n', '解压rpm包: rpm2cpio gcc-cross-1.0-0.oe2203.x86_64.rpm | cpio -id\\n', '解压后可以看到当前路径下会有tmp目录，编译链存放于该目录下\\n', 'ARM 32位工具链: openeuler_gcc_arm32le.tar.xz\\n', 'ARM 64位工具链: openeuler_gcc_arm64le.tar.xz\\n', '已安装好工具的构建容器\\n', 'openEuler Embedded的构建过程中会使用到大量的各式各样的主机工具。如前文所述，为了加速构建，openEuler Embedded依赖主机事先安装好相应的工具，但这也会带来一不同主机环境会有不同的工具版本的问题，例如构建需要cmake高于1.9版本，但主机上最高只有cmake 1.8。为了解决这一问题，openEuler Embedded提供了专门的构建容器，提供统一的构建环境。\\n', '\\n', '使用者可以通过如下链接获得容器镜像直接用于编译：\\n', '\\n', '\\u200b openEuler Embedded构建容器的基础镜像\\n', '\\n', '具体构建指导请参考容器构建指导。\\n', '\\n', '版本构建\\n', '构建代码下载\\n', 'openEuler Embedded整个构建工程的文件布局如下，假设openeuler_embedded为顶层目录：\\n', '\\n', '<顶层目录openeuler_embedded> ├── src 源代码目录，包含所有软件包代码、内核代码和Yocto构建代码 ├── build openEuler Embedded的构建目录，生成的各种镜像放在此目录下\\n', '\\n', '获取源码下载脚本\\n', '\\n', '将脚本下载到指定目录，例如下载到src/yocto-meta-openeuler目录下：\\n', '\\n', 'git clone https://gitee.com/openeuler/yocto-meta-openeuler.git -b openEuler-22.03-LTS -v src/yocto-meta-openeuler\\n', '脚本为src/yocto-meta-openeuler/scripts/download_code.sh，此脚本有3个参数：\\n', '\\n', '参数1：下载的源码路径，默认相对脚本位置下载，例如前面样例，代码仓会下到src/下\\n', '参数2：下载的分支，默认值见脚本，不同分支按版本确定\\n', '参数3：下代码的xml文件，标准manifest格式，按xml配置下代码\\n', '通过脚本下载源码\\n', '\\n', '下载最新代码:\\n', '\\n', 'sh src/yocto-meta-openeuler/scripts/download_code.sh\\n', '下载指定版本代码:\\n', '\\n', 'sh src/yocto-meta-openeuler/scripts/download_code.sh \"\" \"\" \"manifest.xml\"\\n', '指定openEuler Embedded版本的代码的manifest.xml文件从openEuler Embedded发布件目录embedded_img/source-list/下获取。\\n', '\\n', '编译构建\\n', '一键式构建脚本：src/yocto-meta-openeuler/scripts/compile.sh, 具体细节可以参考该脚本。\\n', '\\n', '编译脚本的主要流程说明：\\n', '\\n', '设置PATH增加额外工具路径\\n', 'TEMPLATECONF指定local.conf.sample等配置文件路径\\n', '调用poky仓的oe-init-build-env进行初始化配置\\n', '在编译目录的conf/local.conf中配置MACHINE，按需增加额外新增的层\\n', '在编译目录执行bitbake openeuler-image编译openEuler Embedded的image和sdk\\n', '执行完发布件在编译目录的output目录下\\n', '运行编译脚本，以编译标准arm架构为例，编译方法如下:\\n', '\\n', 'source src/yocto-meta-openeuler/scripts/compile.sh arm-std\\n', 'bitbake openeuler-image  #执行第一条source后，会提示出bitbake命令\\n', '构建结果说明\\n', '结果件默认生成在构建目录下的output目录下，例如上面arm的构建结果件生成在/usr1/build/output目录下，如下表：\\n', '\\n', 'filename\\tdescription\\n', 'Image-*\\topenEuler Embedded image\\n', 'openeuler-glibc-x86_64-openeuler-image-*-toolchain-*.sh\\topenEuler Embedded sdk toolchain\\n', 'openeuler-image-qemu-aarch64-*.rootfs.cpio.gz\\topenEuler Embedded file system\\n', 'zImage\\topenEuler Embedded compressed']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理系统资源.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90.html", "text_entry": "['管理系统资源\\n', '总体说明\\n', 'openEuler 虚拟化使用libvirt命令来管理虚拟机的系统资源，如vCPU、虚拟内存资源等。\\n', '\\n', '在开始前：\\n', '\\n', '确保主机上运行了libvirtd守护进程。\\n', '用virsh list –all命令确认虚拟机已经被定义。\\n', '管理虚拟CPU\\n', 'CPU份额\\n', '概述\\n', '虚拟化环境下，同一主机上的多个虚拟机竞争使用物理CPU。为了防止某些虚拟机占用过多的物理CPU资源，影响相同主机上其他虚拟机的性能，需要平衡虚拟机vCPU的调度，避免物理CPU的过度竞争。\\n', '\\n', 'CPU份额表示一个虚拟机竞争物理CPU计算资源的能力大小总和。用户通过调整cpu_shares值能够设置虚拟机抢占物理CPU资源的能力。cpu_shares值无单位，是一个相对值。虚拟机获得的CPU计算资源，是与其他虚拟机的CPU份额，按相对比例，瓜分物理CPU除预留外可用计算资源。通过调整CPU份额来保证虚拟机CPU计算资源服务质量。\\n', '\\n', '操作步骤\\n', '通过修改分配给虚拟机的运行时间的cpu_shares值，来平衡vCPU之间的调度。\\n', '\\n', '查看虚拟机的当前CPU份额：\\n', '\\n', '$ virsh schedinfo <VMInstance>\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 1024\\n', 'vcpu_period    : 100000\\n', 'vcpu_quota     : -1\\n', 'emulator_period: 100000\\n', 'emulator_quota : -1\\n', 'global_period  : 100000\\n', 'global_quota   : -1\\n', 'iothread_period: 100000\\n', 'iothread_quota : -1\\n', '在线修改：修改处于running状态的虚拟机的当前CPU份额，使用带**–live**参数的virsh schedinfo命令：\\n', '\\n', '$ virsh schedinfo <VMInstance> --live cpu_shares=<number>\\n', '比如将正在运行的虚拟机openEulerVM的CPU份额从1024改为2048：\\n', '\\n', '$ virsh schedinfo openEulerVM --live cpu_shares=2048\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 2048\\n', 'vcpu_period    : 100000\\n', 'vcpu_quota     : -1\\n', 'emulator_period: 100000\\n', 'emulator_quota : -1\\n', 'global_period  : 100000\\n', 'global_quota   : -1\\n', 'iothread_period: 100000\\n', 'iothread_quota : -1\\n', '对cpu_shares值的修改立即生效，虚拟机_openEulerVM_能得到的运行时间将是原来的2倍。但是这一修改将在虚拟机关机并重新启动后失效。\\n', '\\n', '持久化修改：在libvirt内部配置中修改虚拟机的CPU份额，使用带**–config**参数的virsh schedinfo命令：\\n', '\\n', '$ virsh schedinfo <VMInstance> --config cpu_shares=<number>\\n', '比如将虚拟机openEulerVM的CPU份额从1024改为2048：\\n', '\\n', '$ virsh schedinfo openEulerVM --config cpu_shares=2048\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 2048\\n', 'vcpu_period    : 0\\n', 'vcpu_quota     : 0\\n', 'emulator_period: 0\\n', 'emulator_quota : 0\\n', 'global_period  : 0\\n', 'global_quota   : 0\\n', 'iothread_period: 0\\n', 'iothread_quota : 0\\n', '对cpu_shares值的修改不会立即生效，在虚拟机openEulerVM下一次启动后才生效，并持久生效。虚拟机openEulerVM能得到的运行时间将是原来的2倍。\\n', '\\n', '绑定QEMU进程至物理CPU\\n', '概述\\n', 'QEMU主进程绑定特性是将QEMU主进程绑定到特定的物理CPU范围内，从而保证了运行不同业务的虚拟机不会干扰到邻位虚拟机。例如在一个典型的云计算场景中，一台物理机上会运行多台虚拟机，而每台虚拟机的业务不同，造成了不同程度的资源占用，为了避免存储IO密集的虚拟机对邻位虚拟机的干扰，需要将不同虚拟机处理IO的存储进程完全隔离，由于QEMU主进程是处理前后端的主要服务进程，故需要实现隔离。\\n', '\\n', '操作步骤\\n', '通过virsh emulatorpin命令可以绑定QEMU主进程到物理CPU。\\n', '\\n', '查看QEMU进程当前绑定的物理CPU范围：\\n', '\\n', '$ virsh emulatorpin openEulerVM\\n', 'emulator: CPU Affinity\\n', '----------------------------------\\n', '       *: 0-63\\n', '这说明虚拟机_openEulerVM_对应的QEMU主进程可以在主机的所有物理CPU上调度。\\n', '\\n', '在线绑定：修改处于running状态的虚拟机对应的QEMU进程的绑定关系，使用带**–live**参数的vcpu emulatorpin命令：\\n', '\\n', '$ virsh emulatorpin openEulerVM --live 2-3\\n', '\\n', '$ virsh emulatorpin openEulerVM\\n', 'emulator: CPU Affinity\\n', '----------------------------------\\n', '       *: 2-3\\n', '以上命令把虚拟机_open__Euler__VM_对应的QEMU进程绑定到物理CPU2、3上，即限制了QEMU进程只在这两个物理CPU上调度。这一绑定关系的调整立即生效，但在虚拟机关机并重新启动后失效。\\n', '\\n', '持久化绑定：在libvirt内部配置中修改虚拟机对应的QEMU进程的绑定关系，使用带**–config**参数的virsh emulatorpin命令：\\n', '\\n', '$ virsh emulatorpin openEulerVM --config 0-3,^1\\n', '\\n', '$ virsh emulatorpin openEulerVM --config\\n', 'emulator: CPU Affinity\\n', '----------------------------------\\n', '       *: 0,2-3\\n', '以上命令把虚拟机_open__Euler__VM_对应的QEMU进程绑定到物理CPU0、2、3上，即限制了QEMU进程只在这三个物理CPU上调度。这一绑定关系的调整不会立即生效，在虚拟机下一次启动后才生效，并持久生效。\\n', '\\n', '调整虚拟CPU绑定关系\\n', '概述\\n', '把虚拟机的vCPU绑定在物理CPU上，即vCPU只在绑定的物理CPU上调度，在特定场景下达到提升虚拟机性能的目的。比如在NUMA系统中，把vCPU绑定在同一个NUMA节点上，可以避免vCPU跨节点访问内存，避免影响虚拟机运行性能。如果未绑定，默认vCPU可在任何物理CPU上调度。具体的绑定策略由用户来决定。\\n', '\\n', '操作步骤\\n', '通过virsh vcpupin命令可以调整vCPU和物理CPU的绑定关系。\\n', '\\n', '查看虚拟机的当前vCPU绑定信息：\\n', '\\n', ' $ virsh vcpupin openEulerVM\\n', ' VCPU   CPU Affinity\\n', '----------------------\\n', ' 0      0-63\\n', ' 1      0-63\\n', ' 2      0-63\\n', ' 3      0-63\\n', '这说明虚拟机_openEulerVM_的所有vCPU可以在主机的所有物理CPU上调度。\\n', '\\n', '在线调整：修改处于running状态的虚拟机的当前vCPU绑定关系，使用带**–live**参数的vcpu vcpupin命令：\\n', '\\n', ' $ virsh vcpupin openEulerVM  --live 0 2-3\\n', '\\n', ' $ virsh vcpupin openEulerVM\\n', ' VCPU   CPU Affinity\\n', '----------------------\\n', ' 0      2-3\\n', ' 1      0-63\\n', ' 2      0-63\\n', ' 3      0-63\\n', '以上命令把虚拟机_open__Euler__VM_的vCPU0绑定到PCPU2、3上，即限制了vCPU0只在这两个物理CPU上调度。这一绑定关系的调整立即生效，但在虚拟机关机并重新启动后失效。\\n', '\\n', '持久化调整：在libvirt内部配置中修改虚拟机的vCPU绑定关系，使用带**–config**参数的virsh vcpupin命令：\\n', '\\n', ' $ virsh vcpupin openEulerVM --config 0 0-3,^1\\n', '\\n', ' $ virsh vcpupin openEulerVM --config\\n', ' VCPU   CPU Affinity\\n', '----------------------\\n', ' 0      0,2-3\\n', ' 1      0-63\\n', ' 2      0-63\\n', ' 3      0-63\\n', '以上命令把虚拟机_open__Euler__VM_的vCPU0绑定到物理CPU0、2、3上，即限制了vCPU0只在这三个物理CPU上调度。这一绑定关系的调整不会立即生效，在虚拟机下一次启动后才生效，并持久生效。\\n', '\\n', 'CPU热插\\n', '概述\\n', '在线增加（热插）虚拟机CPU是指在虚拟机处于运行状态下，为虚拟机热插CPU而不影响虚拟机正常运行的方案。当虚拟机内部业务压力不断增大，会出现所有CPU均处于较高负载的情形。为了不影响虚拟机内的正常业务运行，可以使用CPU热插功能（在不关闭虚拟机情况下增加虚拟机的CPU数目），提升虚拟机的计算能力。\\n', '\\n', '约束限制\\n', '如果处理器为AArch64架构，创建虚拟机时指定的虚拟机芯片组类型(machine)需为virt-4.1或virt更高版本。如果处理器为x86_64架构，创建虚拟机时指定的虚拟机芯片组类型(machine)需为pc-i440fx-1.5或pc更高版本。\\n', '在配置Guest NUMA的场景中，必须把属于同一个socket的vcpu配置在同一vNode中，否则热插CPU后可能导致虚拟机softlockup，进而可能导致虚拟机panic。\\n', '虚拟机在迁移、休眠唤醒、快照过程中均不支持CPU热插。\\n', '虚拟机CPU热插是否自动上线取决于虚拟机操作系统自身逻辑，虚拟化层不保证热插CPU自动上线。\\n', 'CPU热插同时受限于Hypervisor和GuestOS支持的最大CPU数目。\\n', '虚拟机启动、关闭、重启过程中可能出现热插CPU失效的情况，但再次重启会生效。\\n', '热插虚拟机CPU的时候，如果新增CPU数目不是虚拟机CPU拓扑配置项中Cores的整数倍，可能会导致虚拟机内部看到的CPU拓扑是混乱的，建议每次新增的CPU数目为Cores的整数倍。\\n', '若需要热插CPU在线生效且在虚拟机重启后仍有效，virsh setvcpus接口中需要同时传入–config和–live选项， 将热插CPU动作持久化。\\n', '操作步骤\\n', '一、配置虚拟机XML\\n', '\\n', '使用CPU热插功能，需要在创建虚拟机时配置虚拟机当前的CPU数目、虚拟机所支持的最大CPU数目，以及虚拟机芯片组类型（对于AArch64架构，需为virt-4.1及以上版本。对于x86_64架构，需为pc-i440fx-1.5及以上版本）。这里以AArch64架构虚拟机为例，配置模板如下：\\n', '\\n', \"<domain type='kvm'>\\n\", '    ...\\n', \"    <vcpu placement='static' current='m'>n</vcpu>\\n\", '    <os>\\n', \"        <type arch='aarch64' machine='virt-4.1'>hvm</type>\\n\", '    </os>\\n', '    ...\\n', '<domain>\\n', ' 说明：\\n', '\\n', 'placement的值必须是static。\\n', 'm为虚拟机当前CPU数目，即虚拟机启动后默认的CPU数目。n为虚拟机支持热插到的最大CPU数目，该值不能超过Hypervisor支持的虚拟机最大CPU规格及GuestOS支持的最大CPU规格。n大于或等于m。\\n', '例如，配一个虚拟机当前CPU数目为4，最大支持的热插CPU上限为64的XML配置为：\\n', '\\n', \"<domain type='kvm'>\\n\", '……\\n', \"    <vcpu placement='static' current='4'>64</vcpu>\\n\", '    <os>\\n', \"        <type arch='aarch64' machine='virt-4.1'>hvm</type>\\n\", '    </os>\\n', '……\\n', '二、热插并上线CPU\\n', '\\n', '如果热插CPU后需要自动上线热插的CPU，可以使用root权限在虚拟机内部创建udev rules文件/etc/udev/rules.d/99-hotplug-cpu.rules，并在其中定义udev规则，内容参考如下：\\n', '\\n', '# automatically online hot-plugged cpu\\n', 'ACTION==\"add\", SUBSYSTEM==\"cpu\", ATTR{online}=\"1\"\\n', ' 说明： 如果没有使用udev rules自动上线热插CPU，可以在热插CPU后，使用root权限，参考如下命令手动上线：\\n', '\\n', 'for i in `grep -l 0 /sys/devices/system/cpu/cpu*/online`\\n', 'do\\n', '   echo 1 > $i\\n', 'done\\n', '利用virsh工具进行虚拟机CPU热插操作。例如给虚拟机openEulerVM热插CPU到6，且在线生效的参考命令如下：\\n', '\\n', 'virsh setvcpus openEulerVM 6 --live\\n', ' 说明： virsh setvcpus 进行虚拟机CPU热插操作的格式如下：\\n', '\\n', 'virsh setvcpus <domain> <count> [--config] [--live]\\n', 'domain: 参数，必填。指定虚拟机名称。\\n', 'count: 参数，必填。指定目标CPU数目，即热插后虚拟机CPU数目。\\n', '–config: 选项，选填。虚拟机下次启动时仍有效。\\n', '–live: 选项，选填。在线生效。\\n', '管理虚拟内存\\n', 'NUMA简介\\n', '传统的多核运算使用SMP（Symmetric Multi-Processor）模式：将多个处理器与一个集中的存储器和I/O总线相连。所有处理器只能访问同一个物理存储器，因此SMP系统也被称为一致存储器访问（UMA）系统。一致性指无论在什么时候，处理器只能为内存的每个数据保持或共享唯一一个数值。很显然，SMP的缺点是可伸缩性有限，因为在存储器和I/O接口达到饱和的时候，增加处理器并不能获得更高的性能。\\n', '\\n', 'NUMA（Non Uniform Memory Access Architecture） 模式是一种分布式存储器访问方式，处理器可以同时访问不同的存储器地址，大幅度提高并行性。 NUMA模式下，处理器被划分成多个“节点”（NODE）， 每个节点分配一块本地存储器空间。所有节点中的处理器都可以访问全部的物理存储器，但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多。\\n', '\\n', '配置Host-NUMA\\n', '为提升虚拟机性能，在虚拟机启动前，用户可以通过虚拟机XML配置文件为虚拟机指定主机的NUMA节点，使虚拟机内存分配在指定的NUMA节点上。本特性一般与vCPU绑定一起使用，从而避免vCPU远端访问内存。\\n', '\\n', '操作步骤\\n', '查看host的NUMA拓扑结构：\\n', '\\n', ' $ numactl -H\\n', 'available: 4 nodes (0-3)\\n', 'node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\\n', 'node 0 size: 31571 MB\\n', 'node 0 free: 17095 MB\\n', 'node 1 cpus: 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31\\n', 'node 1 size: 32190 MB\\n', 'node 1 free: 28057 MB\\n', 'node 2 cpus: 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47\\n', 'node 2 size: 32190 MB\\n', 'node 2 free: 10562 MB\\n', 'node 3 cpus: 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63\\n', 'node 3 size: 32188 MB\\n', 'node 3 free: 272 MB\\n', 'node distances:\\n', 'node   0   1   2   3\\n', '  0:  10  15  20  20\\n', '  1:  15  10  20  20\\n', '  2:  20  20  10  15\\n', '  3:  20  20  15  10\\n', '在虚拟机XML配置文件中添加numatune字段，创建并启动虚拟机。例如使用主机上的NUMA node 0给虚拟机分配内存，配置参数如下：\\n', '\\n', '  <numatune>\\n', '    <memory mode=\"strict\" nodeset=\"0\"/>\\n', '  </numatune>\\n', '假设虚拟机的vCPU也绑定在NODE0的物理CPU上，就可以避免由于vCPU访问远端内存带来的性能下降。\\n', '\\n', ' 说明：\\n', '\\n', '分配给虚拟机的内存不要超过该NUMA节点剩余的可用内存，否则可能导致虚拟机启动失败。\\n', '建议虚拟机内存和vCPU都绑定在同一NUMA节点，避免vCPU访问远端内存造成性能下降。例如将上例中vCPU也绑定在NUMA node 0上。\\n', '配置Guest-NUMA\\n', '虚拟机中运行的很多业务软件都针对NUMA架构进行了性能优化，尤其是对于大规格虚拟机，这种优化的作用更明显。openEuler提供了Guest NUMA特性，在虚拟机内部呈现出NUMA拓扑结构。用户可以通过识别这个结构，对业务软件的性能进行优化，从而保证业务更好的运行。\\n', '\\n', '配置Guest NUMA时可以指定vNode的内存在HOST上的分配位置，实现内存的分块绑定，同时配合vCPU绑定，使vNode上的vCPU和内存在同一个物理NUMA node上。\\n', '\\n', '操作步骤\\n', '在虚拟机的XML配置文件中，配置了Guest NUMA后，就可以在虚拟机内部查看NUMA拓扑结构。<numa>项是Guest NUMA的必配项。\\n', '\\n', '  <cputune>\\n', \"    <vcpupin vcpu='0' cpuset='0-3'/>\\n\", \"    <vcpupin vcpu='1' cpuset='0-3'/>\\n\", \"    <vcpupin vcpu='2' cpuset='16-19'/>\\n\", \"    <vcpupin vcpu='3' cpuset='16-19'/>\\n\", '  </cputune>\\n', '  <numatune>\\n', '    <memnode cellid=\"0\" mode=\"strict\" nodeset=\"0\"/>\\n', '    <memnode cellid=\"1\" mode=\"strict\" nodeset=\"1\"/>\\n', '  </numatune>\\n', '  [...]\\n', '  <cpu>\\n', '    <numa>\\n', \"      <cell id='0' cpus='0-1' memory='2097152'/>\\n\", \"      <cell id='1' cpus='2-3' memory='2097152'/>\\n\", '    </numa>\\n', '  </cpu>\\n', ' 说明：\\n', '\\n', '<numa>项提供虚拟机内部呈现NUMA拓扑功能，“cell id”表示vNode编号，“cpus”表示vCPU编号，“memory”表示对应vNode上的内存大小。\\n', '如果希望通过Guest NUMA提供更好的性能，则需要配置<numatune>和<cputune>，使vCPU和对应的内存分布在同一个物理NUMA NODE上：\\n', '<numatune>中的“cellid”和<numa>中的“cell id”是对应的；“mode”可以配置为“strict”（严格从指定node上申请内存，内存不够则失败）、“preferred”（优先从某一node上申请内存，如果不够则从其他node上申请）、“interleave”（从指定的node上交叉申请内存）；“nodeset”表示指定物理NUMA NODE。\\n', '<cputune>中需要将同一cell id中的vCPU绑定到与memnode相同的物理NUMA NODE上。\\n', '内存热插\\n', '概述\\n', '在虚拟化场景下，虚拟机的内存、CPU、外部设备都是软件模拟呈现的，因此可以在虚拟化底层为虚拟机提供内存在线调整的能力。当前openEuler版本支持在线给虚拟机添加内存，当虚拟机出现物理内存不足又无法关闭虚拟机的时候，可以使用此特性增加虚拟机的物理内存资源。\\n', '\\n', '约束限制\\n', '创建虚拟机的时候，AArch64平台上指定的主板类型(machine)需为virt-4.1或更高virt以上，x86平台上指定的主板类型需要为pc-i440fx-1.5以上版本。\\n', '内存热插特性依赖于Guest NUMA，虚拟机必须配置Guest NUMA，否则无法完成内存热插流程。\\n', '热插内存时候必须指定新增内存所属的Gust NUMA node编号，否则内存热插失败。\\n', '虚拟机内核必须支持内存热插能力，否则虚拟机无法识别新增内存或者无法上线内存。\\n', '配置使用大页的虚拟机，热插内存的容量必须是系统hugepagesz的整数倍，否则会导致热插失败。\\n', '热插内存的大小必须为Guest物理内存块大小block_size_bytes的整数倍，否则无法正常上线。在Guest内部执行lsmem可以获取block_size_bytes大小。\\n', '配置n个virtio-net网卡后，最大可热插次数取值为min{max_slot, 64 - n}，因为要给网卡预留slot。\\n', 'vhost-user设备和内存热插特性互斥。配置了vhost-user设备的虚拟机不支持内存热插；内存热插后，不支持虚拟机热插vhost-user设备。\\n', '如果虚拟机操作系统为Linux系列，请确保初始内存大于等于4GB。\\n', '如果虚拟机操作系统为Windows类型，第一次热插内存必须指定到Guest NUMA node0上，否则热插内存无法被虚拟机识别。\\n', '在直通场景下，由于需要预先分配内存，因此启动和热插内存都比普通虚拟机要慢（尤其是大规格虚拟机），属于正常现象。\\n', '建议虚拟机可用内存与热插内存的比例至少为1:32，即热插32G内存虚拟机至少需要有1G可用内存，如果低于该比例可能会导致虚拟机卡死。\\n', '热插内存是否自动上线取决于虚拟机操作系统自身逻辑，可以手动上线或者配置udev规则自动上线。\\n', '操作步骤\\n', '一、配置虚拟机XML\\n', '\\n', '使用内存热插功能，需要在创建虚拟机时配置可热插内存的最大范围、预留槽位号，并配置Guest NUMA拓扑结构。\\n', '\\n', '例如，为虚拟机配置32GiB初始内存，预留256个槽位号，最大支持1TiB内存上限，2个NUMA node的配置为：\\n', '\\n', \"<domain type='kvm'>\\n\", \"    <memory unit='GiB'>32</memory>\\n\", \"    <maxMemory slots='256' unit='GiB'>1024</maxMemory>\\n\", \"    <cpu mode='host-passthrough' check='none'>\\n\", \"        <topology sockets='2' cores='2' threads='1'/>\\n\", '        <numa>\\n', \"          <cell id='0' cpus='0-1' memory='16' unit='GiB'/>\\n\", \"          <cell id='1' cpus='2-3' memory='16' unit='GiB'/>\\n\", '        </numa>\\n', '     </cpu>\\n', '    ....\\n', ' 说明： 其中： maxMemory字段中slots号表示预留的内存插槽，最大取值为256。 maxMemory表示虚拟机支持的最大物理内存上限。 Guest NUMA配置请参见“配置Guest NUMA”相关章节。\\n', '\\n', '二、热插并上线内存\\n', '\\n', '如果热插内存后需要自动上线热插的内存，可以使用root权限在虚拟机内部创建udev rules文件/etc/udev/rules.d/99-hotplug-memory.rules，并在其中定义udev规则，内容参考如下：\\n', '\\n', '# automatically online hot-plugged memory\\n', 'ACTION==\"add\", SUBSYSTEM==\"memory\", ATTR{state}=\"online\"\\n', '根据需要热插的内存大小和虚拟机Guest NUMA Node创建内存描述xml文件。\\n', '\\n', '例如，热插1GiB内存到NUMA node0上：\\n', '\\n', \"<memory model='dimm'>\\n\", '  <target>\\n', \"  <size unit='MiB'>1024</size>\\n\", '  <node>0</node>\\n', '  </target>\\n', '</memory>\\n', '使用virsh attach-device命令为虚拟机热插内存。其中openEulerVM为虚拟机名称，memory.xml为热插内存的描述文件，–live表示热插内存在线生效，也可以使用–config 将热插内存持久化到虚拟机xml文件中。\\n', '\\n', '# virsh attach-device openEulerVM memory.xml --live\\n', ' 说明： 如果没有使用udev rules自动上线热插内存，也可以使用root权限，参考如下命令手动上线：\\n', '\\n', 'for i in `grep -l offline /sys/devices/system/memory/memory*/state`\\n', 'do\\n', '   echo online > $i\\n', 'done\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_安装指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AF%BC-1.html", "text_entry": "['安装指导\\n', '本章介绍将“树莓派镜像刷写入 SD 卡”后，启用树莓派的主要过程。\\n', '\\n', '安装指导\\n', '启动系统\\n', '登录系统\\n', '配置系统\\n', '扩展根目录分区\\n', '连接 WIFI\\n', '启动系统\\n', '将刷写镜像后的 SD 卡插入树莓派，通电启用。\\n', '\\n', '树莓派硬件相关信息请参考树莓派官网。\\n', '\\n', '登录系统\\n', '登录树莓派有以下两种方式：\\n', '\\n', '本地登录\\n', '\\n', '树莓派连接显示器（树莓派视频输出接口为 Micro HDMI）、键盘、鼠标后，启动树莓派，可以看到树莓派启动日志输出到显示器上。待树莓派启动成功，输入用户名（root）和密码（openeuler）登录。\\n', '\\n', 'ssh 远程登录\\n', '\\n', '树莓派默认采用 DHCP 的方式自动获取 IP。如果树莓派连接已知路由器，可登录路由器查看，新增的 IP 即为树莓派 IP。例如，树莓派对应 IP 为：192.168.31.109，使用命令 ssh root@192.168.31.109 后输入密码 openeuler，即可远程登录树莓派。\\n', '\\n', '配置系统\\n', '扩展根目录分区\\n', '默认根目录分区空间比较小，在使用之前，需要对分区进行扩容。\\n', '\\n', '请按照以下步骤扩展根目录分区：\\n', '\\n', '在 root 权限下执行 fdisk -l 命令查看磁盘分区信息。命令和回显如下：\\n', '\\n', '# fdisk -l\\n', 'Disk /dev/mmcblk0: 14.86 GiB, 15931539456 bytes, 31116288 sectors\\n', 'Units: sectors of 1 * 512 = 512 bytes\\n', 'Sector size (logical/physical): 512 bytes / 512 bytes\\n', 'I/O size (minimum/optimal): 512 bytes / 512 bytes\\n', 'Disklabel type: dos\\n', 'Disk identifier: 0xf2dc3842\\n', '\\n', 'Device         Boot   Start     End Sectors  Size Id Type\\n', '/dev/mmcblk0p1 *       8192  593919  585728  286M  c W95 FAT32 (LBA)\\n', '/dev/mmcblk0p2       593920 1593343  999424  488M 82 Linux swap / Solaris\\n', '/dev/mmcblk0p3      1593344 5044223 3450880  1.7G 83 Linux\\n', 'SD 卡对应盘符为 /dev/mmcblk0，包括 3 个分区，分别为\\n', '\\n', '/dev/mmcblk0p1：引导分区\\n', '/dev/mmcblk0p2：交换分区\\n', '/dev/mmcblk0p3：根目录分区\\n', '这里我们需要将根目录分区 /dev/mmcblk0p3 进行扩容。\\n', '\\n', '在 root 权限下执行 fdisk /dev/mmcblk0 命令进入到交互式命令行界面，按照以下步骤扩展分区，如图 1所示。\\n', '\\n', '输入 p，查看分区信息。\\n', '\\n', '记录分区 /dev/mmcblk0p3 的起始扇区号，即 /dev/mmcblk0p3 分区信息中 Start 列的值，示例中为 1593344。\\n', '\\n', '输入 d，删除分区。\\n', '\\n', '输入 3 或直接按 Enter，删除序号为 3 的分区，即 /dev/mmcblk0p3 分区。\\n', '\\n', '输入 n，创建新的分区。\\n', '\\n', '输入 p 或直接按 Enter，创建 Primary 类型的分区。\\n', '\\n', '输入 3 或直接按 Enter，创建序号为 3 的分区，即 /dev/mmcblk0p3 分区。\\n', '\\n', '输入新分区的起始扇区号，即第 1 步中记录的起始扇区号，示例中为 1593344。\\n', '\\n', ' 须知：\\n', '请勿直接按“Enter”或使用默认参数。\\n', '\\n', '按 Enter，使用默认的最后一个扇区号作为新分区的终止扇区号。\\n', '\\n', '输入 N，不修改扇区标记。\\n', '\\n', '输入 w，保存分区设置并退出交互式命令行界面。\\n', '\\n', '图 1 分区扩容\\n', '\\n', '\\n', '在 root 权限下执行 fdisk -l 命令查看磁盘分区信息，以确保磁盘分区正确。命令和回显如下：\\n', '\\n', '# fdisk -l\\n', 'Disk /dev/mmcblk0: 14.86 GiB, 15931539456 bytes, 31116288 sectors\\n', 'Units: sectors of 1 * 512 = 512 bytes\\n', 'Sector size (logical/physical): 512 bytes / 512 bytes\\n', 'I/O size (minimum/optimal): 512 bytes / 512 bytes\\n', 'Disklabel type: dos\\n', 'Disk identifier: 0xf2dc3842\\n', '\\n', 'Device         Boot   Start      End  Sectors  Size Id Type\\n', '/dev/mmcblk0p1 *       8192   593919   585728  286M  c W95 FAT32 (LBA)\\n', '/dev/mmcblk0p2       593920  1593343   999424  488M 82 Linux swap / Solaris\\n', '/dev/mmcblk0p3      1593344 31116287 29522944 14.1G 83 Linux\\n', '在 root 权限下执行 resize2fs /dev/mmcblk0p3，增大未加载的文件系统大小。\\n', '\\n', '执行 df -lh 命令查看磁盘空间信息，以确保根目录分区已扩展。\\n', '\\n', ' 须知：\\n', '如果根目录分区未扩展，可执行 reboot 命令重启树莓派之后再在 root 权限下执行 resize2fs /dev/mmcblk0p3。\\n', '\\n', '连接 WIFI\\n', '请按照以下步骤连接 WIFI：\\n', '\\n', '查看 IP 和网卡信息\\n', '\\n', 'ip a\\n', '\\n', '获取无线网卡 wlan0 信息：\\n', '\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '    inet 127.0.0.1/8 scope host lo\\n', '    valid_lft forever preferred_lft forever\\n', '    inet6 ::1/128 scope host\\n', '    valid_lft forever preferred_lft forever\\n', '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n', '    link/ether dc:a6:32:50:de:57 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.31.109/24 brd 192.168.31.255 scope global dynamic noprefixroute eth0\\n', '    valid_lft 41570sec preferred_lft 41570sec\\n', '    inet6 fe80::cd39:a969:e647:3043/64 scope link noprefixroute\\n', '    valid_lft forever preferred_lft forever\\n', '3: wlan0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000\\n', '    link/ether e2:e6:99:89:47:0c brd ff:ff:ff:ff:ff:ff\\n', '扫描可以连接的 WIFI 信息\\n', '\\n', 'nmcli dev wifi\\n', '\\n', '连接 WIFI\\n', '\\n', '在 root 权限下执行 nmcli dev wifi connect SSID password PWD 命令连接 WIFI。\\n', '\\n', '其中，SSID 为上一步扫描到的可供连接的 WIFI 的 SSID，PWD 为对应 WIFI 的密码。例如，SSID 为 openEuler-wifi，密码为 12345678，则连接该 WIFI 命令为：nmcli dev wifi connect openEuler-wifi password 12345678，连接成功：\\n', '\\n', \"Device 'wlan0' successfully activated with '26becaab-4adc-4c8e-9bf0-1d63cf5fa3f1'.\\n\", '查看 IP 和无线网卡信息\\n', '\\n', 'ip a\\n', '\\n', '1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\\n', '    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\\n', '    inet 127.0.0.1/8 scope host lo\\n', '    valid_lft forever preferred_lft forever\\n', '    inet6 ::1/128 scope host\\n', '    valid_lft forever preferred_lft forever\\n', '2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n', '    link/ether dc:a6:32:50:de:57 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.31.109/24 brd 192.168.31.255 scope global dynamic noprefixroute eth0\\n', '    valid_lft 41386sec preferred_lft 41386sec\\n', '    inet6 fe80::cd39:a969:e647:3043/64 scope link noprefixroute\\n', '    valid_lft forever preferred_lft forever\\n', '3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000\\n', '    link/ether dc:a6:32:50:de:58 brd ff:ff:ff:ff:ff:ff\\n', '    inet 192.168.31.110/24 brd 192.168.31.255 scope global dynamic noprefixroute wlan0\\n', '    valid_lft 43094sec preferred_lft 43094sec\\n', '    inet6 fe80::394:d086:27fa:deba/64 scope link noprefixroute\\n', '    valid_lft forever preferred_lft forever']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_安装准备.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E5%87%86%E5%A4%87.html", "text_entry": "['安装准备\\n', '介绍安装前需要考虑软硬件兼容性状况，以及相关的配置和准备工作。\\n', '\\n', '获取安装源\\n', '在安装开始前，您需要获取openEuler的发布包和校验文件。\\n', '\\n', '请按以下步骤获取openEuler的发布包和校验文件：\\n', '\\n', '登录openEuler社区网站。\\n', '单击“下载”进入页签，进入版本下载页面。\\n', '单击卡片 openEuler 22.03_LTS 上的“获取ISO”，显示ISO下载列表。\\n', 'aarch64：AArch64架构的ISO。\\n', 'x86_64：x86_64架构的ISO。\\n', 'source：openEuler源码ISO。\\n', '根据实际待安装环境的架构选择需要下载的 openEuler 的发布包和校验文件。\\n', '若为AArch64架构。\\n', '\\n', '单击“aarch64”。\\n', '若选择本地安装，分别将发布包 “openEuler-22.03_LTS-aarch64-dvd.iso”和校验文件“openEuler-22.03_LTS-aarch64-dvd.iso.sha256sum”下载到本地。\\n', '若选择网络安装，分别将发布包 “openEuler-22.03_LTS-netinst-aarch64-dvd.iso”和校验文件“openEuler-22.03_LTS-netinst-aarch64-dvd.iso.sha256sum”下载到本地。\\n', '若为x86_64架构。\\n', '\\n', '单击“x86_64”。\\n', '若选择本地安装，分别将发布包 “openEuler-22.03_LTS-x86_64-dvd.iso”和校验文件“openEuler-22.03_LTS-x86_64-dvd.iso.sha256sum”下载到本地。\\n', '若选择网络安装，分别将发布包 “openEuler-22.03_LTS-netinst-x86_64-dvd.iso ”和校验文件“openEuler-22.03_LTS-netinst-x86_64-dvd.iso.sha256sum”下载到本地。\\n', ' 说明：\\n', '\\n', '网络安装方式的 ISO 发布包较小，在有网络的安装环境可以选择网络安装方式。\\n', 'AArch64架构的发布包支持UEFI模式，x86_64架构的发布包支持UEFI模式和Legacy模式。\\n', '发布包完整性校验\\n', ' 说明：\\n', '本章节以AArch64架构的发布包完整性校验为例，x86_64架构的发布包完整性校验的操作方法相同。\\n', '\\n', '简介\\n', '为了防止软件包在传输过程中由于网络原因或者存储设备原因出现下载不完整的问题，在获取到软件包后，需要对软件包的完整性进行校验，通过了校验的软件包才能部署。\\n', '\\n', '这里通过对比校验文件中记录的校验值和手动方式计算的iso文件校验值，判断软件包是否完整。若两个值相同，说明iso文件完整，否则，iso完整性被破坏，请重新获取iso发布包。\\n', '\\n', '前提条件\\n', '在校验发布包完整性之前，需要准备如下文件：\\n', '\\n', 'iso文件：openEuler-22.03_LTS-aarch64-dvd.iso\\n', '\\n', '校验文件：openEuler-22.03_LTS-aarch64-dvd.iso.sha256sum\\n', '\\n', '操作指导\\n', '文件完整性校验操作步骤如下：\\n', '\\n', '获取校验文件中的校验值。执行命令如下：\\n', '\\n', '$ cat openEuler-22.03_LTS-aarch64-dvd.iso.sha256sum \\n', '计算文件的sha256校验值。执行命令如下：\\n', '\\n', '$ sha256sum openEuler-22.03_LTS-aarch64-dvd.iso\\n', '命令执行完成后，输出校验值。\\n', '\\n', '对比步骤1和步骤2计算的校验值是否一致。\\n', '\\n', '如果校验值一致说明iso文件完整性没有破坏，如果校验值不一致则可以确认文件完整性已被破坏，需要重新获取。\\n', '\\n', '物理机的安装要求\\n', '若需要在物理机环境上安装openEuler操作系统，则物理机需要满足如下的硬件兼容性和最小硬件要求。\\n', '\\n', '硬件兼容支持\\n', 'openEuler安装时，应注意硬件兼容性方面的问题，当前已支持的服务器类型如表1所示。\\n', '\\n', ' 说明：\\n', '\\n', 'TaiShan 200服务器基于华为鲲鹏920处理器。\\n', '当前仅支持华为TaiShan服务器和FusionServer Pro 机架服务器，后续将逐步增加对其他厂商服务器的支持。\\n', '表 1 支持的服务器类型\\n', '\\n', '服务器形态\\t服务器名称\\t服务器型号\\n', '机架服务器\\tTaiShan 200\\t2280均衡型\\n', '机架服务器\\tFusionServer Pro 机架服务器\\tFusionServer Pro 2288H V5\\n', '说明：\\n', '服务器要求配置Avago 3508 RAID控制卡和启用LOM-X722网卡\\n', '最小硬件要求\\n', 'openEuler所需的最小硬件要求如表2所示。\\n', '\\n', '表 2 最小硬件要求\\n', '\\n', '部件名称\\t最小硬件要求\\n', '架构\\tAArch64或x86_64\\n', 'CPU\\t2*CPU (1 core)\\n', '内存\\t不小于4GB（为了获得更好的应用体验，建议不小于8GB）\\n', '硬盘\\t不小于32GB（为了获得更好的应用体验，建议不小于120GB）\\n', '虚拟机的安装要求\\n', '若需要在虚拟机环境上安装openEuler操作系统，则虚拟机需要满足如下的虚拟化平台兼容性和最小虚拟化要求。\\n', '\\n', '虚拟化平台兼容性\\n', 'openEuler安装时，应注意虚拟化平台兼容性的问题，当前已支持的虚拟化平台为：\\n', '\\n', 'openEuler自有的虚拟化组件（HostOS为openEuler，虚拟化组件为发布包中的qemu、KVM）创建的虚拟化平台。\\n', '华为公有云的x86虚拟化平台。\\n', '最小虚拟化空间要求\\n', 'openEuler所需的最小虚拟化空间要求如表3所示。\\n', '\\n', '表 3 最小虚拟化空间要求\\n', '\\n', '部件名称\\t最小虚拟化空间要求\\n', '架构\\tAArch64或x86_64\\n', 'CPU\\t2个CPU\\n', '内存\\t不小于4GB（为了获得更好的应用体验，建议不小于8GB）\\n', '硬盘\\t不小于32GB（为了获得更好的应用体验，建议不小于120GB）']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_安装准备.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E5%87%86%E5%A4%87-1.html", "text_entry": "['安装准备\\n', '介绍安装前需要考虑软硬件兼容性状况，以及相关的配置和准备工作。\\n', '\\n', '安装准备\\n', '获取安装源\\n', '镜像完整性校验\\n', '简介\\n', '前提条件\\n', '操作指导\\n', '安装要求\\n', '硬件兼容支持\\n', '最小硬件要求\\n', '获取安装源\\n', '在安装开始前，您需要获取 openEuler 发布的树莓派镜像及其校验文件。\\n', '\\n', '登录openEuler社区网站。\\n', '\\n', '单击卡片 openEuler 22.03_LTS 上的“下载”按钮。\\n', '\\n', '单击“raspi_img”，进入树莓派镜像的下载列表。\\n', '\\n', 'aarch64：AArch64 架构的镜像。\\n', '单击“aarch64”，进入树莓派 AArch64 架构镜像的下载列表。\\n', '\\n', '单击“openEuler-22.03_LTS-raspi-aarch64.img.xz”，将 openEuler 发布的树莓派镜像下载到本地。\\n', '\\n', '单击“openEuler-22.03_LTS-raspi-aarch64.img.xz.sha256sum”，将 openEuler 发布的树莓派镜像的校验文件下载到本地。\\n', '\\n', '镜像完整性校验\\n', '简介\\n', '为了防止软件包在传输过程中由于网络原因或者存储设备原因出现下载不完整的问题，在获取到软件包后，需要对软件包的完整性进行校验，通过了校验的软件包才能部署。\\n', '\\n', '这里通过对比校验文件中记录的校验值和手动方式计算的文件校验值，判断软件包是否完整。若两个值相同，说明下载的文件完整，否则，下载的文件完整性被破坏，请重新获取软件包。\\n', '\\n', '前提条件\\n', '在校验镜像文件的完整性之前，需要准备如下文件：\\n', '\\n', '镜像文件：openEuler-22.03_LTS-raspi-aarch64.img.xz\\n', '\\n', '校验文件：openEuler-22.03_LTS-raspi-aarch64.img.xz.sha256sum\\n', '\\n', '操作指导\\n', '文件完整性校验操作步骤如下：\\n', '\\n', '获取校验文件中的校验值。执行命令如下：\\n', '\\n', '$ cat openEuler-22.03_LTS-raspi-aarch64.img.xz.sha256sum\\n', '计算文件的 sha256 校验值。执行命令如下：\\n', '\\n', '$ sha256sum openEuler-22.03_LTS-raspi-aarch64.img.xz\\n', '命令执行完成后，输出校验值。\\n', '\\n', '对比步骤 1 和步骤 2 计算的校验值是否一致。\\n', '\\n', '如果校验值一致说明下载的文件完整性没有破坏，如果校验值不一致则可以确认文件完整性已被破坏，需要重新获取。\\n', '\\n', '安装要求\\n', '在树莓派环境上安装 openEuler 操作系统，则树莓派需要满足如下的硬件兼容性和最小硬件要求。\\n', '\\n', '硬件兼容支持\\n', 'openEuler 树莓派版本镜像目前支持树莓派 3B/3B+/4B。\\n', '\\n', '最小硬件要求\\n', 'openEuler 树莓派版本镜像所需的最小硬件要求如表1所示。\\n', '\\n', '表 1 最小硬件要求\\n', '\\n', '\\n', '部件名称\\n', '\\n', '最小硬件要求\\n', '\\n', '说明\\n', '\\n', '树莓派版本\\n', '\\n', '树莓派 3B\\n', '树莓派 3B+\\n', '树莓派 4B\\n', '树莓派 400\\n', '-\\n', '\\n', '内存\\n', '\\n', '不小于 2GB（为了获得更好的应用体验，建议至少 4GB）\\n', '\\n', '-\\n', '\\n', '硬盘\\n', '\\n', '为了获得更好的应用体验，建议不小于 8GB\\n', '\\n', '-']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_工具使用指南_vmtop.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/vmtop.html", "text_entry": "['工具使用指南\\n', 'vmtop使用指南\\n', 'vmtop使用指南\\n', '概述\\n', 'vmtop 是运行在宿主机host上的用户态工具。使用vmtop可以实时动态地查看虚拟机资源的使用情况，例如CPU占用率、内存占用率、vCPU陷入陷出次数等。因此，可以使用vmtop作为虚拟化问题定位和性能调优的工具。\\n', '\\n', '多架构支持\\n', '当前vmtop支持AArch64和x86_64处理器架构。\\n', '\\n', '显示项说明\\n', '不同处理器架构的操作系统，vmtop的显示项存在差异，这里给出各个显示项的含义及其是否在对应架构呈现。 说明：以下采样差是指指定时间间隔内获取的两次数据的差值。\\n', '\\n', 'AArch64和x86_64架构共有显示项\\n', 'VM/task-name: 虚拟机/进程名称\\n', 'DID: 虚拟机id\\n', 'PID: 虚拟机qemu进程的pid\\n', '%CPU: 进程的CPU占用率\\n', 'EXTsum: kvm exit总次数（采样差）\\n', 'S: 进程状态\\n', 'P: 进程所占用的物理CPU号\\n', '%ST: 被抢占时间与cpu运行时间的比\\n', '%GUE: 虚拟机内部占用时间与CPU运行时间的比\\n', '%HYP: 虚拟化开销占比\\n', '仅AArch64架构的显示项\\n', 'EXThvc: hvc-exit次数（采样差）\\n', 'EXTwfe: wfe-exit次数（采样差）\\n', 'EXTwfi: wfi-exit次数（采样差）\\n', 'EXTmmioU: mmioU-exit次数（采样差）\\n', 'EXTmmioK: mmioK-exit次数（采样差）\\n', 'EXTfp: fp-exit次数（采样差）\\n', 'EXTirq: irq-exit次数（采样差）\\n', 'EXTsys64: sys64 exit次数（采样差）\\n', 'EXTmabt: mem abort exit次数（采样差）\\n', '仅x86_64架构的显示项\\n', 'PFfix: 缺页次数（采样差）\\n', 'PFgu: 向guest OS注入缺页次数（采样差）\\n', 'INvlpg: 冲刷tlb某项次数(tlb其中一项，并不固定)\\n', 'EXTio: io VM-exit次数（采样差）\\n', 'EXTmmio: mmio VM-exit次数（采样差）\\n', 'EXThalt: halt VM-exit次数（采样差）\\n', 'EXTsig: 信号处理引起的VM-exit次数（采样差）\\n', 'EXTirq: 中断引起的VM-exit次数（采样差）\\n', 'EXTnmiW: 处理不可屏蔽中断引起的VM-exit次数（采样差）\\n', 'EXTirqW: interruptwindow机制，开启中断使能时exit，以便注入中断（采样差）\\n', 'IrqIn: 注入irq中断次数（采样差）\\n', 'NmiIn: 注入nmi中断次数（采样差）\\n', 'TLBfl: 冲刷整个tlb次数（采样差）\\n', 'HostReL: 重载主机状态次数（采样差）\\n', 'Hyperv: 模拟Guest操作系统辅助虚拟化调用hypercall的处理次数（采样差）\\n', 'EXTcr: 访问CR寄存器退出次数（采样差）\\n', 'EXTrmsr: 读msr退出次数（采样差）\\n', 'EXTwmsr: 写msr退出次数（采样差）\\n', 'EXTapic: 写apic次数（采样差）\\n', 'EXTeptv: Ept缺页退出次数（采样差）\\n', 'EXTeptm: Ept错误退出次数（采样差）\\n', 'EXTpau: Vcpu暂停退出次数（采样差）\\n', '使用方法\\n', 'vmtop是一款命令行工具，直接以命令行的方式运行 vmtop 即可。 另外，vmtop还提供了不同可选选项，用于查询不同信息。\\n', '\\n', '语法格式\\n', 'vmtop [选项]\\n', '选项说明\\n', '-d: 设置显示刷新的时间间隔，单位：秒\\n', '-H: 显示虚拟机的线程信息\\n', '-n: 设置显示刷新的次数，刷新完成后退出\\n', '-b: Batch模式显示，可以用于重定向到文件\\n', '-h: 显示帮助信息\\n', '-v: 显示版本\\n', '-p: 监控指定id的虚拟机\\n', '快捷键\\n', '在vmtop运行状态下使用的快捷键\\n', '\\n', 'H: 显示或关闭虚拟机线程信息，默认显示该信息\\n', 'up/down: 向上/向下移动显示的虚拟机列表\\n', 'left/right: 向左/向右移动显示的信息，从而显示因屏幕宽度被隐藏的列\\n', 'f: 进入监控项编辑模式，选择要开启的监控项\\n', 'q: 退出vmtop进程\\n', '示例\\n', '在host上直接以命令行的方式运行vmtop\\n', '\\n', 'vmtop\\n', '输出如下:\\n', '\\n', 'vmtop - 2020-09-14 09:54:48 - 1.0\\n', 'Domains: 1 running\\n', '\\n', '  DID  VM/task-name     PID  %CPU    EXThvc    EXTwfe    EXTwfi  EXTmmioU  EXTmmioK     EXTfp    EXTirq  EXTsys64   EXTmabt    EXTsum    S    P   %ST  %GUE  %HYP\\n', '    2       example 4054916  13.0         0         0      1206        10         0       144        62       174         0      1452    S  106   0.0  99.7  16.0\\n', '可以看到，host上只有一台名称为“example”的虚拟机，ID为2，CPU占用率是13.0%，在1秒内的陷入陷出总次数是1452，虚拟机进程占用的物理CPU为106号CPU，虚拟机内部占用时间与CPU运行时间的比是99.7%。\\n', '\\n', '1.显示虚拟机线程信息 按下‘H’后可以显示线程信息：\\n', '\\n', 'vmtop - 2020-09-14 10:11:27 - 1.0\\n', 'Domains: 1 running\\n', '\\n', '  DID  VM/task-name     PID  %CPU    EXThvc    EXTwfe    EXTwfi  EXTmmioU  EXTmmioK     EXTfp    EXTirq  EXTsys64   EXTmabt    EXTsum    S    P   %ST  %GUE  %HYP\\n', '    2       example 4054916  13.0         0         0\\t   1191        17         4       120        76       147         0      1435    S  119   0.0 123.7   4.0\\n', '   |_      qemu-kvm 4054916   0.0         0         0         0         0         0         0         0         0         0         0    S  119   0.0   0.0   0.0\\n', '   |_      qemu-kvm 4054928   0.0         0         0         0         0         0         0         0         0         0         0    S  119   0.0   0.0   0.0\\n', '   |_  signalfd_com 4054929   0.0         0         0         0         0         0         0         0         0         0         0    S  120   0.0   0.0   0.0\\n', '   |_  IO mon_iothr 4054932   0.0         0         0         0         0         0         0         0         0         0         0    S  117   0.0   0.0   0.0\\n', '   |_     CPU 0/KVM 4054933   3.0         0         0       280         6         4        28        19        41         0       350    S  105   0.0  27.9   0.0\\n', '   |_     CPU 1/KVM 4054934   3.0         0         0       260         0         0        16        12        36         0       308    S   31   0.0  20.0   0.0\\n', '   |_     CPU 2/KVM 4054935   3.0         0         0       341         0         0        44        20        26         0       387    R  108   0.0  27.9   4.0\\n', '   |_     CPU 3/KVM 4054936   5.0         0         0       310        11         0        32        25        44         0       390    S  103   0.0  47.9   0.0\\n', '   |_   memory_lock 4054940   0.0         0         0         0         0         0         0         0         0         0         0    S  126   0.0   0.0   0.0\\n', '   |_    vnc_worker 4054944   0.0         0         0         0         0         0         0         0         0         0         0    S  118   0.0   0.0   0.0\\n', '   |_        worker 4143738   0.0         0         0         0         0         0         0         0         0         0         0    S  120   0.0   0.0   0.0\\n', 'example虚拟机有11个线程，其中包括vCPU线程、vnc_worker、IO mon_iotreads等等，每个线程同样会显示详细CPU占用、陷入陷出等信息。\\n', '\\n', '2.选择监控项 按下‘f’进入监控项编辑模式：\\n', '\\n', 'field filter - select which field to be showed\\n', 'Use up/down to navigate, use space to set whether chosen filed to be showed\\n', \"'q' to quit to normal display\\n\", '\\n', ' * DID\\n', ' * VM/task-name\\n', ' * PID\\n', ' * %CPU\\n', ' * EXThvc\\n', ' * EXTwfe\\n', ' * EXTwfi\\n', ' * EXTmmioU\\n', ' * EXTmmioK\\n', ' * EXTfp\\n', ' * EXTirq\\n', ' * EXTsys64\\n', ' * EXTmabt\\n', ' * EXTsum\\n', ' * S\\n', ' * P\\n', ' * %ST\\n', ' * %GUE\\n', ' * %HYP\\n', '当前所有监控项都默认显示，通过up/down键选择，用space键来设置对应显示项是否显示/隐藏，按‘q’键退出。 将%ST、%GUE、%HYP设置为隐藏后，输出如下:\\n', '\\n', 'vmtop - 2020-09-14 10:23:25 - 1.0\\n', 'Domains: 1 running\\n', '\\n', '  DID  VM/task-name     PID  %CPU    EXThvc    EXTwfe    EXTwfi  EXTmmioU  EXTmmioK     EXTfp    EXTirq  EXTsys64   EXTmabt    EXTsum    S    P\\n', '    2       example 4054916  12.0         0         0\\t   1213        14         1       144        68       168         0      1464    S  125\\n', '   |_\\t   qemu-kvm 4054916   0.0         0         0         0         0         0         0         0         0         0         0    S  125\\n', '   |_\\t   qemu-kvm 4054928   0.0         0         0         0         0         0         0         0         0         0         0    S  119\\n', '   |_  signalfd_com 4054929   0.0         0         0         0         0         0         0         0         0         0         0    S  120\\n', '   |_  IO mon_iothr 4054932   0.0         0         0         0         0         0         0         0         0         0         0    S  117\\n', '   |_     CPU 0/KVM 4054933   2.0         0         0       303         6         0        29        10        35         0       354    S   98\\n', '   |_     CPU 1/KVM 4054934   4.0         0         0       279         0         0        39        17        49         0       345    S    1\\n', '   |_     CPU 2/KVM 4054935   3.0         0         0       283         0         0        33        20        40         0       343    S  122\\n', '   |_     CPU 3/KVM 4054936   3.0         0         0       348         8         1        43        21        44         0       422    S  110\\n', '   |_   memory_lock 4054940   0.0         0         0         0         0         0         0         0         0         0         0    S  126\\n', '   |_    vnc_worker 4054944   0.0         0         0         0         0         0         0         0         0         0         0    S  118\\n', '   |_        worker    1794   0.0         0         0         0         0         0         0         0         0         0         0    S  126\\n', '%ST、%GUE、%HYP将不会出现在显示界面上。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_准备证书.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%87%86%E5%A4%87%E8%AF%81%E4%B9%A6.html", "text_entry": "['准备证书\\n', '声明：本文使用的证书为自签名，不能用于商用环境\\n', '\\n', '部署集群前，需要生成集群各组件之间通信所需的证书。本文使用开源 CFSSL 作为验证部署工具，以便用户了解证书的配置和集群组件之间证书的关联关系。用户可以根据实际情况选择合适的工具，例如 OpenSSL 。\\n', '\\n', '编译安装 CFSSL\\n', '编译安装 CFSSL 的参考命令如下（需要互联网下载权限，需要配置代理的请先完成配置），\\n', '\\n', '$ wget --no-check-certificate  https://github.com/cloudflare/cfssl/archive/v1.5.0.tar.gz\\n', '$ tar -zxf v1.5.0.tar.gz\\n', '$ cd cfssl-1.5.0/\\n', '$ make -j6\\n', '$ cp bin/* /usr/local/bin/\\n', '生成根证书\\n', '编写 CA 配置文件，例如 ca-config.json：\\n', '\\n', '$ cat ca-config.json | jq\\n', '{\\n', '  \"signing\": {\\n', '    \"default\": {\\n', '      \"expiry\": \"8760h\"\\n', '    },\\n', '    \"profiles\": {\\n', '      \"kubernetes\": {\\n', '        \"usages\": [\\n', '          \"signing\",\\n', '          \"key encipherment\",\\n', '          \"server auth\",\\n', '          \"client auth\"\\n', '        ],\\n', '        \"expiry\": \"8760h\"\\n', '      }\\n', '    }\\n', '  }\\n', '}\\n', '编写 CA CSR 文件，例如 ca-csr.json：\\n', '\\n', '$ cat ca-csr.json  | jq\\n', '{\\n', '  \"CN\": \"Kubernetes\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"openEuler\",\\n', '      \"OU\": \"WWW\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成 CA 证书和密钥：\\n', '\\n', '$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca\\n', '得到如下证书：\\n', '\\n', 'ca.csr  ca-key.pem  ca.pem\\n', '生成 admin 账户证书\\n', 'admin 是 K8S 用于系统管理的一个账户，编写 admin 账户的 CSR 配置，例如 admin-csr.json：\\n', '\\n', 'cat admin-csr.json | jq\\n', '{\\n', '  \"CN\": \"admin\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:masters\",\\n', '      \"OU\": \"Containerum\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin\\n', '结果如下：\\n', '\\n', 'admin.csr  admin-key.pem  admin.pem\\n', '生成 service-account 账户证书\\n', '编写 service-account 账户的 CSR 配置文件，例如 service-account-csr.json：\\n', '\\n', 'cat service-account-csr.json | jq\\n', '{\\n', '  \"CN\": \"service-accounts\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"Kubernetes\",\\n', '      \"OU\": \"openEuler k8s install\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -profile=kubernetes service-account-csr.json | cfssljson -bare service-account\\n', '结果如下：\\n', '\\n', 'service-account.csr  service-account-key.pem  service-account.pem\\n', '生成 kube-controller-manager 组件证书\\n', '编写 kube-controller-manager 的 CSR 配置：\\n', '\\n', '{\\n', '  \"CN\": \"system:kube-controller-manager\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:kube-controller-manager\",\\n', '      \"OU\": \"openEuler k8s kcm\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json-profile=kubernetes kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager\\n', '结果如下：\\n', '\\n', 'kube-controller-manager.csr  kube-controller-manager-key.pem  kube-controller-manager.pem\\n', '生成 kube-proxy 证书\\n', '编写 kube-proxy 的 CSR 配置：\\n', '\\n', '{\\n', '  \"CN\": \"system:kube-proxy\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:node-proxier\",\\n', '      \"OU\": \"openEuler k8s kube proxy\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy\\n', '结果如下：\\n', '\\n', 'kube-proxy.csr  kube-proxy-key.pem  kube-proxy.pem\\n', '生成 kube-scheduler 证书\\n', '编写 kube-scheduler 的 CSR 配置：\\n', '\\n', '{\\n', '  \"CN\": \"system:kube-scheduler\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:kube-scheduler\",\\n', '      \"OU\": \"openEuler k8s kube scheduler\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -profile=kubernetes kube-scheduler-csr.json | cfssljson -bare kube-scheduler\\n', '结果如下：\\n', '\\n', 'kube-scheduler.csr  kube-scheduler-key.pem  kube-scheduler.pem\\n', '生成 kubelet 证书\\n', '由于证书涉及到 kubelet 所在机器的 hostname 和 IP 地址信息，因此每个 node 节点配置不尽相同，所以编写脚本完成，生成脚本如下：\\n', '\\n', '$ cat node_csr_gen.bash\\n', '\\n', '#!/bin/bash\\n', '\\n', 'nodes=(k8snode1 k8snode2 k8snode3)\\n', 'IPs=(\"192.168.122.157\" \"192.168.122.158\" \"192.168.122.159\")\\n', '\\n', 'for i in \"${!nodes[@]}\"; do\\n', '\\n', 'cat > \"${nodes[$i]}-csr.json\" <<EOF\\n', '{\\n', '  \"CN\": \"system:node:${nodes[$i]}\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:nodes\",\\n', '      \"OU\": \"openEuler k8s kubelet\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', 'EOF\\n', '\\n', '\\t# generate ca\\n', '\\techo \"generate: ${nodes[$i]} ${IPs[$i]}\"\\n', '\\tcfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -hostname=${nodes[$i]},${IPs[$i]}-profile=kubernetes ${nodes[$i]}-csr.json | cfssljson -bare ${nodes[$i]}\\n', 'done\\n', '说明：如果节点存在多个 IP 或者其他别名，-hostname 可以增加其他的 IP 或者 hostname\\n', '\\n', '结果如下：\\n', '\\n', 'k8snode1.csr       k8snode1.pem       k8snode2-key.pem  k8snode3-csr.json\\n', 'k8snode1-csr.json  k8snode2.csr       k8snode2.pem      k8snode3-key.pem\\n', 'k8snode1-key.pem   k8snode2-csr.json  k8snode3.csr      k8snode3.pem\\n', 'CSR 配置信息，以 k8snode1 为例如下：\\n', '\\n', '$ cat k8snode1-csr.json\\n', '{\\n', '  \"CN\": \"system:node:k8snode1\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"system:nodes\",\\n', '      \"OU\": \"openEuler k8s kubelet\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '注意：由于每个 node 所属的账户组为 system:node，因此 CSR 的 CN 字段都为 system:node 加上hostname。\\n', '\\n', '生成 kube-apiserver 证书\\n', '编写 kube api server 的 CSR 配置文件：\\n', '\\n', '$ cat kubernetes-csr.json | jq\\n', '{\\n', '  \"CN\": \"kubernetes\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"Kubernetes\",\\n', '      \"OU\": \"openEuler k8s kube api server\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书和密钥：\\n', '\\n', 'cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -hostname=10.32.0.1,192.168.122.154,192.168.122.155,192.168.122.156,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.svc.cluster.local -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes\\n', '结果如下：\\n', '\\n', 'kubernetes.csr  kubernetes-key.pem  kubernetes.pem\\n', '说明：10.32.0.1 是内部 services 使用的 IP 地址区间，可以设置为其他值，后面启动 apiserver 服务时，会设置该参数。\\n', '\\n', '生成 etcd 证书（可选）\\n', '部署 etcd 有两种方式：\\n', '\\n', '在每个 api-server 对应的机器都启动一个 etcd 服务\\n', '独立部署一个 etcd 集群服务\\n', '如果是和 api-server 一起部署，那么直接使用上面生成的 kubernetes-key.pem 和 kubernetes.pem 证书即可。\\n', '\\n', '如果是独立的etcd集群，那么需要创建证书如下：\\n', '\\n', '编写 etcd 的 CSR 配置：\\n', '\\n', 'cat etcd-csr.json | jq\\n', '{\\n', '  \"CN\": \"ETCD\",\\n', '  \"key\": {\\n', '    \"algo\": \"rsa\",\\n', '    \"size\": 2048\\n', '  },\\n', '  \"names\": [\\n', '    {\\n', '      \"C\": \"CN\",\\n', '      \"L\": \"HangZhou\",\\n', '      \"O\": \"ETCD\",\\n', '      \"OU\": \"openEuler k8s etcd\",\\n', '      \"ST\": \"BinJiang\"\\n', '    }\\n', '  ]\\n', '}\\n', '生成证书：\\n', '\\n', '$ cfssl gencert -ca=../ca/ca.pem -ca-key=../ca/ca-key.pem -config=../ca/ca-config.json -hostname=192.168.122.154,192.168.122.155,192.168.122.156,127.0.0.1 -profile=kubernetes etcd-csr.json | cfssljson -bare etcd\\n', '说明：假设 etcd 集群的 IP地址是 192.168.122.154,192.168.122.155,192.168.122.156\\n', '\\n', '结果如下：\\n', '\\n', 'etcd.csr  etcd-key.pem  etcd.pem\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_系统服务.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1.html", "text_entry": "['系统服务\\n', '系统服务\\n', '加固SSH服务\\n', '加固SSH服务\\n', '说明\\n', 'SSH（Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性保障的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透过SSH可以对所有传输的数据进行加密，并防止DNS欺骗和IP欺骗。OpenSSH是SSH协议的免费开源实现。\\n', '\\n', '加固SSH服务，是指修改SSH服务中的配置来设置系统使用OpenSSH协议时的算法、认证等参数，从而提高系统的安全性。表1中详细说明了各加固项含义、建议加固值及其默认策略。\\n', '\\n', '实现\\n', '服务端加固操作如下：\\n', '\\n', '打开服务端SSH服务的配置文件/etc/ssh/sshd_config，在该文件中修改或添加对应加固项及其加固值。\\n', '\\n', '保存/etc/ssh/sshd_config文件。\\n', '\\n', '重启SSH服务，命令如下：\\n', '\\n', 'systemctl restart sshd\\n', '客户端加固操作如下：\\n', '\\n', '打开客户端SSH服务的配置文件/etc/ssh/ssh_config，在该文件中修改或添加对应加固项及其加固值。\\n', '\\n', '保存/etc/ssh/ssh_config文件。\\n', '\\n', '重启SSH服务，命令如下：\\n', '\\n', 'systemctl restart sshd\\n', '加固项说明\\n', '服务端加固策略\\n', '\\n', 'SSH服务的所有加固项均保存在配置文件/etc/ssh/sshd_config中，服务端各加固项的含义、加固建议以及openEuler默认是否已经加固为建议加固值请参见表1。\\n', '\\n', '表 1 SSH服务端加固项说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '加固建议\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'Protocol\\n', '\\n', '设置使用SSH协议的版本\\n', '\\n', '2\\n', '\\n', '是\\n', '\\n', 'SyslogFacility\\n', '\\n', '设置SSH服务的日志类型。加固策略将其设置为“AUTH”，即认证类日志\\n', '\\n', 'AUTH\\n', '\\n', '是\\n', '\\n', 'LogLevel\\n', '\\n', '设置记录sshd日志消息的层次\\n', '\\n', 'VERBOSE\\n', '\\n', '是\\n', '\\n', 'X11Forwarding\\n', '\\n', '设置使用SSH登录后，能否使用图形化界面\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'MaxAuthTries\\n', '\\n', '最大认证尝试次数\\n', '\\n', '3\\n', '\\n', '否\\n', '\\n', 'PubkeyAuthentication\\n', '\\n', '设置是否允许公钥认证。\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'RSAAuthentication\\n', '\\n', '设置是否允许只有RSA安全验证\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'IgnoreRhosts\\n', '\\n', '设置是否使用rhosts文件和shosts文件进行验证。rhosts文件和shosts文件用于记录可以访问远程计算机的计算机名及关联的登录名\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'RhostsRSAAuthentication\\n', '\\n', '设置是否使用基于rhosts的RSA算法安全验证。rhosts文件记录可以访问远程计算机的计算机名及关联的登录名\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'HostbasedAuthentication\\n', '\\n', '设置是否使用基于主机的验证。基于主机的验证是指已信任客户机上的任何用户都可以使用SSH连接\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'PermitRootLogin\\n', '\\n', '\\n', '是否允许root帐户直接使用SSH登录系统\\n', '\\n', '说明：\\n', '若需要直接使用root帐户通过SSH登录系统，请修改/etc/ssh/sshd_config文件的PermitRootLogin字段的值为yes。\\n', '\\n', 'no\\n', '\\n', '否\\n', '\\n', 'PermitEmptyPasswords\\n', '\\n', '设置是否允许用口令为空的账号登录\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'PermitUserEnvironment\\n', '\\n', '设置是否解析 ~/.ssh/environment和~/.ssh/authorized_keys中设定的环境变量\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'Ciphers\\n', '\\n', '设置SSH数据传输的加密算法\\n', '\\n', 'aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com,aes128-gcm@openssh.com,aes256-gcm@openssh.com\\n', '\\n', '是\\n', '\\n', 'ClientAliveCountMax\\n', '\\n', '设置超时次数。服务器发出请求后，客户端没有响应的次数达到一定值，连接自动断开\\n', '\\n', '0\\n', '\\n', '否\\n', '\\n', 'Banner\\n', '\\n', '指定登录SSH前后显示的提示信息的文件\\n', '\\n', '/etc/issue.net\\n', '\\n', '是\\n', '\\n', 'MACs\\n', '\\n', '设置SSH数据校验的哈希算法\\n', '\\n', 'hmac-sha2-512,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha2-256-etm@openssh.com\\n', '\\n', '是\\n', '\\n', 'StrictModes\\n', '\\n', '设置SSH在接收登录请求之前是否检查用户HOME目录和rhosts文件的权限和所有权\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'UsePAM\\n', '\\n', '使用PAM登录认证\\n', '\\n', 'yes\\n', '\\n', '是\\n', '\\n', 'AllowTcpForwarding\\n', '\\n', '设置是否允许TCP转发\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'Subsystem sftp /usr/libexec/openssh/sftp-server\\n', '\\n', 'sftp日志记录级别，记录INFO级别以及认证日志。\\n', '\\n', '-l INFO -f AUTH\\n', '\\n', '是\\n', '\\n', 'AllowAgentForwarding\\n', '\\n', '设置是否允许SSH Agent转发\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'GatewayPorts\\n', '\\n', '设置是否允许连接到转发客户端端口\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'PermitTunnel\\n', '\\n', 'Tunnel设备是否允许使用\\n', '\\n', 'no\\n', '\\n', '是\\n', '\\n', 'KexAlgorithms\\n', '\\n', '设置SSH密钥交换算法\\n', '\\n', 'curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256\\n', '\\n', '  \\n', 'LoginGraceTime\\n', '\\n', '限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 60 秒。\\n', '\\n', '60\\n', '\\n', '否\\n', '\\n', ' 说明：\\n', '默认情况下，登录SSH前后显示的提示信息保存在/etc/issue.net文件中，/etc/issue.net默认信息为“Authorized users only. All activities may be monitored and reported.”。\\n', '\\n', '客户端加固策略\\n', '\\n', 'SSH服务的所有加固项均保存在配置文件/etc/ssh/ssh_config中，客户端各加固项的含义、加固建议以及openEuler默认是否已经加固为建议加固值请参见表2。\\n', '\\n', '表 2 SSH客户端加固项说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '加固建议\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'KexAlgorithms\\n', '\\n', '设置SSH密钥交换算法\\n', '\\n', 'ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256\\n', '\\n', '否\\n', '\\n', 'VerifyHostKeyDNS\\n', '\\n', '是否使用DNS或者SSHFP资源记录验证HostKey\\n', '\\n', 'ask\\n', '\\n', '否\\n', '\\n', ' 说明：\\n', '对于使用dh算法进行密钥交换的第三方客户端和服务端工具，要求允许建立连接的最低长度为2048bits。\\n', '\\n', '其他安全建议\\n', 'SSH服务仅侦听指定IP地址\\n', '\\n', '出于安全考虑，建议用户在使用SSH服务时，仅在必需的IP上进行绑定侦听，而不是侦听0.0.0.0，可修改/etc/ssh/sshd_config文件中的ListenAddress配置项。\\n', '\\n', '打开并修改/etc/ssh/sshd_config文件\\n', '\\n', 'vi /etc/ssh/sshd_config\\n', '修改内容如下，表示绑定侦听IP为 192.168.1.100，用户可根据实际情况修改需要侦听的IP\\n', '\\n', '...\\n', 'ListenAddress 192.168.1.100\\n', '...\\n', '重启SSH服务\\n', '\\n', 'systemctl restart sshd.service\\n', '限制SFTP用户向上跨目录访问\\n', '\\n', 'SFTP是FTP over SSH的安全FTP协议，对于访问SFTP的用户建议使用专用账号，只能上传或下载文件，不能用于SSH登录，同时对SFTP可以访问的目录进行限定，防止目录遍历攻击，具体配置如下：\\n', '\\n', ' 说明：\\n', 'sftpgroup为示例用户组，sftpuser为示例用户名。\\n', '\\n', '创建SFTP用户组\\n', '\\n', 'groupadd sftpgroup\\n', '创建SFTP根目录\\n', '\\n', 'mkdir /sftp\\n', '修改SFTP根目录属主和权限\\n', '\\n', 'chown root:root /sftp\\n', 'chmod 755 /sftp\\n', '创建SFTP用户\\n', '\\n', 'useradd -g sftpgroup -s /sbin/nologin sftpuser\\n', '设置SFTP用户的口令\\n', '\\n', 'passwd sftpuser\\n', '创建SFTP用户上传目录\\n', '\\n', 'mkdir /sftp/sftpuser\\n', '修改SFTP用户上传目录属主和权限\\n', '\\n', 'chown root:root /sftp/sftpuser\\n', 'chmod 777 /sftp/sftpuser\\n', '修改/etc/ssh/sshd_config文件\\n', '\\n', 'vi /etc/ssh/sshd_config\\n', '修改内容如下：\\n', '\\n', '#Subsystem sftp /usr/libexec/openssh/sftp-server -l INFO -f AUTH\\n', 'Subsystem sftp internal-sftp -l INFO -f AUTH\\n', '...\\n', '\\n', 'Match Group sftpgroup                  \\n', '    ChrootDirectory /sftp/%u\\n', '    ForceCommand internal-sftp\\n', ' 说明：\\n', '\\n', '%u代表当前sftp用户的用户名，这是一个通配符，用户原样输入即可。\\n', '以下内容必须加在/etc/ssh/sshd_config文件的末尾。\\n', '  Match Group sftpgroup                    \\n', '    ChrootDirectory /sftp/%u  \\n', '    ForceCommand internal-sftp  \\n', '重启SSH服务\\n', '\\n', 'systemctl restart sshd.service\\n', 'SSH远程执行命令\\n', '\\n', 'OpenSSH通用机制，在远程执行命令时，默认不开启tty，如果执行需要密码的命令，密码会明文回显。出于安全考虑，建议用户增加-t选项，确保密码输入安全。如下：\\n', '\\n', 'ssh -t testuser@192.168.1.100 su\\n', ' 说明：\\n', '192.168.1.100为示例IP，testuser为示例用户。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_使用LVM管理硬盘.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8LVM%E7%AE%A1%E7%90%86%E7%A1%AC%E7%9B%98.html", "text_entry": "['使用LVM管理硬盘\\n', '使用LVM管理硬盘\\n', 'LVM简介\\n', '基本概念\\n', '安装\\n', '管理物理卷\\n', '创建物理卷\\n', '查看物理卷\\n', '修改物理卷属性\\n', '删除物理卷\\n', '管理卷组\\n', '创建卷组\\n', '查看卷组\\n', '修改卷组属性\\n', '扩展卷组\\n', '收缩卷组\\n', '删除卷组\\n', '管理逻辑卷\\n', '创建逻辑卷\\n', '查看逻辑卷\\n', '调整逻辑卷大小\\n', '扩展逻辑卷\\n', '收缩逻辑卷\\n', '删除逻辑卷\\n', '创建并挂载文件系统\\n', '创建文件系统\\n', '手动挂载文件系统\\n', '自动挂载文件系统\\n', 'LVM简介\\n', 'LVM是逻辑卷管理（Logical Volume Manager）的简称，它是Linux环境下对磁盘分区进行管理的一种机制。LVM通过在硬盘和文件系统之间添加一个逻辑层，来为文件系统屏蔽下层硬盘分区布局，提高硬盘分区管理的灵活性，\\n', '\\n', '使用LVM管理硬盘的基本过程如下：\\n', '\\n', '将硬盘创建为物理卷\\n', '将多个物理卷组合成卷组\\n', '在卷组中创建逻辑卷\\n', '在逻辑卷之上创建文件系统\\n', '通过LVM管理硬盘之后，文件系统不再受限于硬盘的大小，可以分布在多个硬盘上，也可以动态扩容。\\n', '\\n', '基本概念\\n', '物理存储介质（The physical media）：指系统的物理存储设备，如硬盘，系统中为/dev/hda、/dev/sda等等，是存储系统最低层的存储单元。\\n', '\\n', '物理卷（Physical Volume，PV）：指硬盘分区或从逻辑上与磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块。物理卷包括一个特殊的标签，该标签默认存放在第二个 512 字节扇区，但也可以将标签放在最开始的四个扇区之一。该标签包含物理卷的随机唯一识别符（UUID），记录块设备的大小和LVM元数据在设备中的存储位置。\\n', '\\n', '卷组（Volume Group，VG）：由物理卷组成，屏蔽了底层物理卷细节。可在卷组上创建一个或多个逻辑卷且不用考虑具体的物理卷信息。\\n', '\\n', '逻辑卷（Logical Volume，LV）：卷组不能直接用，需要划分成逻辑卷才能使用。逻辑卷可以格式化成不同的文件系统，挂载后直接使用。\\n', '\\n', '物理块（Physical Extent，PE）：物理卷以大小相等的“块”为单位存储，块的大小与卷组中逻辑卷块的大小相同。\\n', '\\n', '逻辑块（Logical Extent，LE）：逻辑卷以“块”为单位存储，在一卷组中的所有逻辑卷的块大小是相同的。\\n', '\\n', '安装\\n', ' 说明：\\n', 'openEuler操作系统默认已安装LVM。可通过rpm -qa | grep lvm2命令查询，若打印信息中包含“lvm2”信息，则表示已安装LVM，可跳过本章节内；若无任何打印信息，则表示未安装，可参考本章节内容进行安装。\\n', '\\n', '配置本地yum源，详细信息请参考搭建repo服务器。\\n', '\\n', '清除缓存。\\n', '\\n', '$ dnf clean all\\n', '创建缓存。\\n', '\\n', '$ dnf makecache\\n', '在root权限下安装LVM。\\n', '\\n', '# dnf install lvm2\\n', '查看安装后的rpm包。\\n', '\\n', '$ rpm -qa | grep lvm2\\n', '管理物理卷\\n', '创建物理卷\\n', '可在root权限下通过pvcreate命令创建物理卷。\\n', '\\n', 'pvcreate [option] devname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制创建物理卷，不需要用户确认。\\n', '\\n', '-u：指定设备的UUID。\\n', '\\n', '-y：所有的问题都回答“yes”。\\n', '\\n', 'devname：指定要创建的物理卷对应的设备名称，如果需要批量创建，可以填写多个设备名称，中间以空格间隔。\\n', '\\n', '示例1：将/dev/sdb、/dev/sdc创建为物理卷。\\n', '\\n', '# pvcreate /dev/sdb /dev/sdc\\n', '示例2：将/dev/sdb1、/dev/sdb2创建为物理卷。\\n', '\\n', '# pvcreate /dev/sdb1 /dev/sdb2\\n', '查看物理卷\\n', '可在root权限通过pvdisplay命令查看物理卷的信息，包括：物理卷名称、所属的卷组、物理卷大小、PE大小、总PE数、可用PE数、已分配的PE数和UUID。\\n', '\\n', 'pvdisplay [option] devname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-s：以短格式输出。\\n', '-m：显示PE到LE的映射。\\n', 'devname：指定要查看的物理卷对应的设备名称。如果不指定物理卷名称，则显示所有物理卷的信息。\\n', '\\n', '示例：显示物理卷/dev/sdb的基本信息。\\n', '\\n', '# pvdisplay /dev/sdb\\n', '修改物理卷属性\\n', '可在root权限下通过pvchange命令修改物理卷的属性。\\n', '\\n', 'pvchange [option] pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-u：生成新的UUID。\\n', '-x：是否允许分配PE”。\\n', 'pvname：指定要要修改属性的物理卷对应的设备名称，如果需要批量修改，可以填写多个设备名称，中间以空格间隔。\\n', '\\n', '示例：禁止分配/dev/sdb物理卷上的PE。\\n', '\\n', '# pvchange -x n /dev/sdb\\n', '删除物理卷\\n', '可在root权限下通过pvremove命令删除物理卷。\\n', '\\n', 'pvremove [option] pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制删除物理卷，不需要用户确认。\\n', '-y：所有的问题都回答“yes”。\\n', 'pvname：指定要删除的物理卷对应的设备名称，如果需要批量删除，可以填写多个设备名称，中间以空格间隔。\\n', '\\n', '示例：删除物理卷/dev/sdb。\\n', '\\n', '# pvremove /dev/sdb\\n', '管理卷组\\n', '创建卷组\\n', '可在root权限下通过vgcreate命令创建卷组。\\n', '\\n', 'vgcreate [option] vgname pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-l：卷组上允许创建的最大逻辑卷数。\\n', '-p：卷组中允许添加的最大物理卷数。\\n', '-s：卷组上的物理卷的PE大小。\\n', 'vgname：要创建的卷组名称。\\n', '\\n', 'pvname：要加入到卷组中的物理卷名称。\\n', '\\n', '示例：创建卷组 vg1，并且将物理卷/dev/sdb和/dev/sdc添加到卷组中。\\n', '\\n', '# vgcreate vg1 /dev/sdb /dev/sdc  \\n', '查看卷组\\n', '可在root权限下通过vgdisplay命令查看卷组的信息。\\n', '\\n', 'vgdisplay [option] [vgname]\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-s：以短格式输出。\\n', '-A：仅显示活动卷组的属性。\\n', 'vgname：指定要查看的卷组名称。如果不指定卷组名称，则显示所有卷组的信息。\\n', '\\n', '示例：显示卷组vg1的基本信息。\\n', '\\n', '# vgdisplay vg1\\n', '修改卷组属性\\n', '可在root权限下通过vgchange命令修改卷组的属性。\\n', '\\n', 'vgchange [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-a：设置卷组的活动状态。\\n', 'vgname：指定要修改属性的卷组名称。\\n', '\\n', '示例：将卷组vg1状态修改为活动。\\n', '\\n', '# vgchange -ay vg1\\n', '扩展卷组\\n', '可在root权限下通过vgextend命令动态扩展卷组。它通过向卷组中添加物理卷来增加卷组的容量。\\n', '\\n', 'vgextend [option] vgname pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-d：调试模式。\\n', '-t：仅测试。\\n', 'vgname：要扩展容量的卷组名称。\\n', '\\n', 'pvname：要加入到卷组中的物理卷名称。\\n', '\\n', '示例：向卷组vg1中添加物理卷/dev/sdb。\\n', '\\n', '# vgextend vg1 /dev/sdb\\n', '收缩卷组\\n', '可在root权限下通过vgreduce命令删除卷组中的物理卷来减少卷组容量。不能删除卷组中剩余的最后一个物理卷。\\n', '\\n', 'vgreduce [option] vgname pvname ...\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-a：如果命令行中没有指定要删除的物理卷，则删除所有的空物理卷。\\n', '--removemissing：删除卷组中丢失的物理卷，使卷组恢复正常状态。\\n', 'vgname：要收缩容量的卷组名称。\\n', '\\n', 'pvname：要从卷组中删除的物理卷名称。\\n', '\\n', '示例：从卷组vg1中移除物理卷/dev/sdb2。\\n', '\\n', '# vgreduce vg1 /dev/sdb2\\n', '删除卷组\\n', '可在root权限下通过vgremove命令删除卷组。\\n', '\\n', 'vgremove [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制删除卷组，不需要用户确认。\\n', 'vgname：指定要删除的卷组名称。\\n', '\\n', '示例：删除卷组vg1。\\n', '\\n', '# vgremove vg1\\n', '管理逻辑卷\\n', '创建逻辑卷\\n', '可在root权限下通过lvcreate命令创建逻辑卷。\\n', '\\n', 'lvcreate [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-n：指定要创建的逻辑卷名称。\\n', '-s：创建快照。\\n', 'vgname：要创建逻辑卷的卷组名称。\\n', '\\n', '示例1：在卷组vg1中创建10G大小的逻辑卷。\\n', '\\n', '# lvcreate -L 10G vg1\\n', '示例2：在卷组vg1中创建200M的逻辑卷，并命名为lv1。\\n', '\\n', '# lvcreate -L 200M -n lv1 vg1\\n', '查看逻辑卷\\n', '可在root权限下通过lvdisplay命令查看逻辑卷的信息，包括逻辑卷空间大小、读写状态和快照信息等属性。\\n', '\\n', 'lvdisplay [option] [lvname]\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-v：显示LE到PE的映射\\n', '\\n', 'lvname：指定要显示属性的逻辑卷对应的设备文件。如果省略，则显示所有的逻辑卷属性。\\n', '\\n', ' 说明：\\n', '逻辑卷对应的设备文件保存在卷组目录下，例如：在卷组vg1上创建一个逻辑卷lv1，则此逻辑卷对应的设备文件为/dev/vg1/lv1。\\n', '\\n', '示例：显示逻辑卷lv1的基本信息。\\n', '\\n', '# lvdisplay /dev/vg1/lv1\\n', '调整逻辑卷大小\\n', '可在root权限下通过lvresize命令调整LVM逻辑卷的空间大小，可以增大空间和缩小空间。使用lvresize命令调整逻辑卷空间大小和缩小空间时需要谨慎，因为有可能导致数据丢失。\\n', '\\n', 'lvresize [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-f：强制调整逻辑卷大小，不需要用户确认。\\n', 'lvname：指定要调整的逻辑卷名称。\\n', '\\n', '示例1：为逻辑卷/dev/vg1/lv1增加200M空间。\\n', '\\n', '# lvresize -L +200 /dev/vg1/lv1\\n', '示例2：为逻辑卷/dev/vg1/lv1减少200M空间。\\n', '\\n', '# lvresize -L -200 /dev/vg1/lv1\\n', '扩展逻辑卷\\n', '可在root权限下通过lvextend命令动态在线扩展逻辑卷的空间大小，而不中断应用程序对逻辑卷的访问。\\n', '\\n', 'lvextend [option] lvname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-f：强制调整逻辑卷大小，不需要用户确认。\\n', 'lvname：指定要扩展空间的逻辑卷的设备文件。\\n', '\\n', '示例：为逻辑卷/dev/vg1/lv1增加100M空间。\\n', '\\n', '# lvextend -L +100M /dev/vg1/lv1\\n', '收缩逻辑卷\\n', '可在root权限下通过lvreduce命令减少逻辑卷占用的空间大小。使用lvreduce命令收缩逻辑卷的空间大小有可能会删除逻辑卷上已有的数据，所以在操作前必须进行确认。\\n', '\\n', 'lvreduce [option] lvname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-L：指定逻辑卷的大小，单位为“kKmMgGtT”字节。\\n', '-l：指定逻辑卷的大小（LE数）。\\n', '-f：强制调整逻辑卷大小，不需要用户确认。\\n', 'lvname：指定要扩展空间的逻辑卷的设备文件。\\n', '\\n', '示例：将逻辑卷/dev/vg1/lv1的空间减少100M。\\n', '\\n', '# lvreduce -L -100M /dev/vg1/lv1\\n', '删除逻辑卷\\n', '可在root权限下通过lvremove命令删除逻辑卷。如果逻辑卷已经使用mount命令加载，则不能使用lvremove命令删除。必须使用umount命令卸载后，逻辑卷方可被删除。\\n', '\\n', 'lvremove [option] vgname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-f：强制删除逻辑卷，不需要用户确认。\\n', 'vgname：指定要删除的逻辑卷。\\n', '\\n', '示例：删除逻辑卷/dev/vg1/lv1。\\n', '\\n', '# lvremove /dev/vg1/lv1\\n', '创建并挂载文件系统\\n', '在创建完逻辑卷之后，需要在逻辑卷之上创建文件系统并挂载文件系统到相应目录下。\\n', '\\n', '创建文件系统\\n', '可在root权限下通过mkfs命令创建文件系统。\\n', '\\n', 'mkfs [option] lvname\\n', '其中：\\n', '\\n', 'option：命令参数选项。常用的参数选项有：\\n', '\\n', '-t：指定创建的linux系统类型，如ext2，ext3，ext4等等，默认类型为ext2。\\n', 'lvname：指定要创建的文件系统对应的逻辑卷设备文件名。\\n', '\\n', '示例：在逻辑卷/dev/vg1/lv1上创建ext4文件系统。\\n', '\\n', '# mkfs -t ext4 /dev/vg1/lv1\\n', '手动挂载文件系统\\n', '手动挂载的文件系统仅在当时有效，一旦操作系统重启则会不存在。\\n', '\\n', '可在root权限下通过mount命令挂载文件系统。\\n', '\\n', 'mount lvname mntpath\\n', '其中：\\n', '\\n', 'lvname：指定要挂载文件系统的逻辑卷设备文件名。\\n', 'mntpath：挂载路径。\\n', '示例：将逻辑卷/dev/vg1/lv1挂载到/mnt/data目录。\\n', '\\n', '# mount /dev/vg1/lv1 /mnt/data\\n', '自动挂载文件系统\\n', '手动挂载的文件系统在操作系统重启之后会不存在，需要重新手动挂载文件系统。但若在手动挂载文件系统后在root权限下进行如下设置，可以实现操作系统重启后文件系统自动挂载文件系统。\\n', '\\n', '执行blkid命令查询逻辑卷的UUID，逻辑卷以/dev/vg1/lv1为例。\\n', '\\n', '# blkid /dev/vg1/lv1\\n', '查看打印信息，打印信息中包含如下内容，其中 uuidnumber 是一串数字，为UUID， fstype 为文件系统。\\n', '\\n', '/dev/vg1/lv1: UUID=\" uuidnumber \" TYPE=\" fstype \"\\n', '\\n', '执行vi /etc/fstab命令编辑fstab文件，并在最后加上如下内容。\\n', '\\n', 'UUID=uuidnumber  mntpath                   fstype    defaults        0 0\\n', '内容说明如下：\\n', '\\n', '第一列：UUID，此处填写1查询的 uuidnumber 。\\n', '第二列：文件系统的挂载目录 mntpath 。\\n', '第三列：文件系统的文件格式，此处填写1查询的 fstype 。\\n', '第四列：挂载选项，此处以“defaults”为例；\\n', '第五列：备份选项，设置为“1”时，系统自动对该文件系统进行备份；设置为“0”时，不进行备份。此处以“0”为例；\\n', '第六列：扫描选项，设置为“1”时，系统在启动时自动对该文件系统进行扫描；设置为“0”时，不进行扫描。此处以“0”为例。\\n', '验证自动挂载功能。\\n', '\\n', '执行umount命令卸载文件系统，逻辑卷以/dev/vg1/lv1为例。\\n', '\\n', '# umount /dev/vg1/lv1\\n', '执行如下命令，将/etc/fstab文件所有内容重新加载。\\n', '\\n', '# mount -a\\n', '执行如下命令，查询文件系统挂载信息，挂载目录以/mnt/data为例。\\n', '\\n', '# mount | grep /mnt/data\\n', '查看打印信息，若信息中包含如下信息表示自动挂载功能生效。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_安装etcd.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E5%AE%89%E8%A3%85etcd.html", "text_entry": "['安装 etcd\\n', '准备环境\\n', '使能 etcd 使用的端口：\\n', '\\n', 'firewall-cmd --zone=public --add-port=2379/tcp\\n', 'firewall-cmd --zone=public --add-port=2380/tcp\\n', '安装 etcd 二进制\\n', '当前是通过 rpm 包安装\\n', '\\n', 'rpm -ivh etcd*.rpm\\n', '准备目录\\n', '\\n', 'mkdir -p /etc/etcd /var/lib/etcd\\n', 'cp ca.pem /etc/etcd/\\n', 'cp kubernetes-key.pem /etc/etcd/\\n', 'cp kubernetes.pem /etc/etcd/\\n', '# 关闭selinux\\n', 'setenforce 0\\n', '# 禁用/etc/etcd/etcd.conf文件的默认配置\\n', '# 注释掉即可，例如：ETCD_LISTEN_CLIENT_URLS=\"http://localhost:2379\"\\n', '编写 etcd.service 文件\\n', '以 k8smaster0 机器为例：\\n', '\\n', '$ cat /usr/lib/systemd/system/etcd.service\\n', '[Unit]\\n', 'Description=Etcd Server\\n', 'After=network.target\\n', 'After=network-online.target\\n', 'Wants=network-online.target\\n', '\\n', '[Service]\\n', 'Type=notify\\n', 'WorkingDirectory=/var/lib/etcd/\\n', 'EnvironmentFile=-/etc/etcd/etcd.conf\\n', '# set GOMAXPROCS to number of processors\\n', 'ExecStart=/bin/bash -c \"ETCD_UNSUPPORTED_ARCH=arm64 /usr/bin/etcd --name=k8smaster0 --cert-file=/etc/etcd/kubernetes.pem --key-file=/etc/etcd/kubernetes-key.pem --peer-cert-file=/etc/etcd/kubernetes.pem --peer-key-file=/etc/etcd/kubernetes-key.pem --trusted-ca-file=/etc/etcd/ca.pem --peer-trusted-ca-file=/etc/etcd/ca.pem --peer-client-cert-auth --client-cert-auth --initial-advertise-peer-urls https://192.168.122.154:2380 --listen-peer-urls https://192.168.122.154:2380 --listen-client-urls https://192.168.122.154:2379,https://127.0.0.1:2379 --advertise-client-urls https://192.168.122.154:2379 --initial-cluster-token etcd-cluster-0 --initial-cluster k8smaster0=https://192.168.122.154:2380,k8smaster1=https://192.168.122.155:2380,k8smaster2=https://192.168.122.156:2380 --initial-cluster-state new --data-dir /var/lib/etcd\"\\n', '\\n', 'Restart=always\\n', 'RestartSec=10s\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '注意:\\n', '\\n', 'arm64上面需要增加启动设置ETCD_UNSUPPORTED_ARCH=arm64；\\n', '由于本文把etcd和k8s control部署在相同机器，所以使用了kubernetes.pem和kubernetes-key.pem证书来启动；\\n', 'ca证书，在整个部署流程里面使用了一个，etcd可以生成自己的ca，然后用自己的ca签名其他证书，但是需要在apiserver访问etcd的client用该ca签名的证书；\\n', 'initial-cluster需要把所有部署etcd的配置加上；\\n', '为了提高etcd的存储效率，可以使用ssd硬盘的目录，作为data-dir；\\n', '启动服务\\n', '\\n', '$ systemctl enable etcd\\n', '$ systemctl start etcd\\n', '然后，依次部署其他机器即可。\\n', '\\n', '验证基本功能\\n', '$  ETCDCTL_API=3 etcdctl -w table endpoint status --endpoints=https://192.168.122.155:2379,https://192.168.122.156:2379,https://192.168.122.154:2379   --cacert=/etc/etcd/ca.pem   --cert=/etc/etcd/kubernetes.pem   --key=/etc/etcd/kubernetes-key.pem\\n', '+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\\n', '|           ENDPOINT           |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFTAPPLIED INDEX | ERRORS |\\n', '+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\\n', '| https://192.168.122.155:2379 | b50ec873e253ebaa |  3.4.14 |  262 kB |     false |      false |       819 |         21 |           21 |        |\\n', '| https://192.168.122.156:2379 | e2b0d126774c6d02 |  3.4.14 |  262 kB |      true |      false |       819 |         21 |           21 |        |\\n', '| https://192.168.122.154:2379 | f93b3808e944c379 |  3.4.14 |  328 kB |     false |      false |       819 |         21 |           21 |        |\\n', '+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理虚拟机.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E6%9C%BA.html", "text_entry": "['管理虚拟机\\n', '管理虚拟机\\n', '虚拟机生命周期\\n', '总体介绍\\n', '管理命令\\n', '示例\\n', '在线修改虚拟机配置\\n', '查询虚拟机信息\\n', '登录虚拟机\\n', '使用VNC密码登录\\n', '配置VNC TLS登录\\n', '虚拟机安全启动\\n', '总体介绍\\n', '安全启动实践\\n', '虚拟机生命周期\\n', '总体介绍\\n', '概述\\n', '为了更好地利用硬件资源，降低成本，用户需要合理地管理虚拟机。本节介绍虚拟机生命周期过程中的基本操作，包括虚拟机创建、使用、删除等，指导用户更好地管理虚拟机。\\n', '\\n', '虚拟机状态\\n', '虚拟机主要有如下几种状态：\\n', '\\n', '未定义（undefined）：虚拟机未定义或未创建，即libvirt认为该虚拟机不存在。\\n', '关闭状态（shut off）：虚拟机已经被定义但未运行，或者虚拟机被终止。\\n', '运行中（running）：虚拟机处于运行状态。\\n', '暂停（paused）：虚拟机运行被挂起，其运行状态被临时保存在内存中，可以恢复到运行状态。\\n', '保存（saved）：与暂停（paused）状态类似，其运行状态被保存在持久性存储介质中，可以恢复到运行状态。\\n', '崩溃（crashed）：通常是由于内部错误导致虚拟机崩溃，不可恢复到运行状态。\\n', '状态转换\\n', '虚拟机不同状态之间可以相关转换，但必须满足一定规则。虚拟机不同状态之间的转换常用规则如图1所示。\\n', '\\n', '图 1 状态转换图\\n', '\\n', '\\n', '虚拟机标识\\n', '在libvirt中，完成创建的虚拟机实例称做一个“domain”，其描述了虚拟机的CPU、内存、网络设备、存储设备等各种资源的配置信息。在同一个主机上，每个domain具有唯一标识，通过虚拟机名称Name、UUID、Id表示，对应含义请参见表1。在虚拟机生命周期期间，可以通过虚拟机标识对特定虚拟机进行操作。\\n', '\\n', '表 1 domain标识说明\\n', '\\n', '\\n', '标识\\n', '\\n', '含义\\n', '\\n', 'Name\\n', '\\n', '虚拟机名称\\n', '\\n', 'UUID\\n', '\\n', '通用唯一识别码\\n', '\\n', 'Id\\n', '\\n', '虚拟机运行标识\\n', '\\n', '说明：\\n', '关闭状态的虚拟机无此标识。\\n', '\\n', ' 说明：\\n', '可通过virsh命令查询虚拟机Id和UUID，操作方法请参见查询虚拟机信息章节内容。\\n', '\\n', '管理命令\\n', '概述\\n', '用户可以使用virsh命令工具管理虚拟机生命周期。本节介绍生命周期相关的命令以指导用户使用。\\n', '\\n', '前提条件\\n', '执行虚拟机生命周期操作之前，需要查询虚拟机状态以确定可以执行对应操作。状态之间的基本转换关系请参见\"总体介绍\"中的\"状态转换\"的内容。\\n', '具备管理员权限。\\n', '准备好虚拟机XML配置文件。\\n', '命令使用说明\\n', '用户可以使用virsh命令管理虚拟机生命周期，命令格式为：\\n', '\\n', 'virsh <operate> <obj> <options>\\n', '各参数含义如下：\\n', '\\n', 'operate：管理虚拟机生命周期对应操作，例如创建、销毁、启动等。\\n', 'obj：命令操作对象，如指定需要操作的虚拟机。\\n', 'options：命令选项，该参数可选。\\n', '虚拟机生命周期管理各命令如表1所示。其中VMInstanse为虚拟机名称、虚拟机ID或者虚拟机UUID，XMLFile是虚拟机XML配置文件，DumpFile为转储文件，请根据实际情况修改。\\n', '\\n', '表 1 虚拟机生命周期管理命令\\n', '\\n', '\\n', '命令\\n', '\\n', '含义\\n', '\\n', 'virsh define <XMLFile>\\n', '\\n', '定义持久化虚拟机，定义完成后虚拟机处于关闭状态，虚拟机被看作为一个domian实例\\n', '\\n', 'virsh create <XMLFile>\\n', '\\n', '创建一个临时性虚拟机，创建完成后虚拟机处于运行状态\\n', '\\n', 'virsh start <VMInstanse>\\n', '\\n', '启动虚拟机\\n', '\\n', 'virsh shutdown <VMInstanse>\\n', '\\n', '关闭虚拟机。启动虚拟机关机流程，若关机失败可使用强制关闭\\n', '\\n', 'virsh destroy <VMInstanse>\\n', '\\n', '强制关闭虚拟机\\n', '\\n', 'virsh reboot <VMInstanse>\\n', '\\n', '重启虚拟机\\n', '\\n', 'virsh save <VMInstanse> <DumpFile>\\n', '\\n', '将虚拟机的运行状态转储到文件中\\n', '\\n', 'virsh restore <DumpFile>\\n', '\\n', '从虚拟机状态转储文件恢复虚拟机\\n', '\\n', 'virsh suspend <VMInstanse>\\n', '\\n', '暂停虚拟机的运行，使虚拟机处于pasued状态\\n', '\\n', 'virsh resume <VMInstanse>\\n', '\\n', '唤醒虚拟机，将处于paused状态的虚拟机恢复到运行状态\\n', '\\n', 'virsh undefine <VMInstanse>\\n', '\\n', '销毁持久性虚拟机，虚拟机生命周期完结，不能继续对该虚拟机继续操作\\n', '\\n', '示例\\n', '本节给出虚拟机生命周期管理相关命令的示例。\\n', '\\n', '创建虚拟机\\n', '\\n', '虚拟机XML配置文件为openEulerVM.xml，命令和回显如下：\\n', '\\n', '# virsh define openEulerVM.xml\\n', 'Domain openEulerVM defined from openEulerVM.xml\\n', '启动虚拟机\\n', '\\n', '启动名称为openEulerVM的虚拟机，命令和回显如下：\\n', '\\n', '# virsh start openEulerVM\\n', 'Domain openEulerVM started\\n', '重启虚拟机\\n', '\\n', '重启名称为openEulerVM的虚拟机，命令和回显如下：\\n', '\\n', '# virsh reboot openEulerVM\\n', 'Domain openEulerVM is being rebooted\\n', '关闭虚拟机\\n', '\\n', '关闭名称为openEulerVM的虚拟机，命令和回显如下：\\n', '\\n', '# virsh shutdown openEulerVM\\n', 'Domain openEulerVM is being shutdown\\n', '销毁虚拟机\\n', '\\n', '若虚拟机启动时未使用nvram文件，销毁虚拟机命令如下：\\n', '\\n', '# virsh undefine <VMInstanse>\\n', '若虚拟机启动时使用了nvram文件，销毁该虚拟机需要指定nvram的处理策略，命令如下：\\n', '\\n', '# virsh undefine <VMInstanse> <strategy>\\n', '其中<strategy>为销毁虚拟机的策略，可取值：\\n', '\\n', 'nvram：销毁虚拟机的同时删除其对应的nvram文件。\\n', '\\n', 'keep-nvram：销毁虚拟机，但保留其对应的nvram文件。\\n', '\\n', '例如，删除虚拟机openEulerVM及其nvram文件，命令和回显如下：\\n', '\\n', '# virsh undefine openEulerVM --nvram\\n', 'Domain openEulerVM has been undefined\\n', '在线修改虚拟机配置\\n', '概述\\n', '虚拟机创建之后用户可以修改虚拟机的配置信息，称为在线修改虚拟机配置。在线修改配置以后，新的虚拟机配置文件会被持久化，并在虚拟机关闭、重新启动后生效。\\n', '\\n', '修改虚拟机配置命令格式如下：\\n', '\\n', 'virsh edit <VMInstance>\\n', 'virsh edit命令通过编辑“domain”对应的XML配置文件，完成对虚拟机配置的更新。virsh edit使用vi程序作为默认的编辑器，可以通过修改环境变量“EDITOR”或“VISUAL”指定编辑器类型。virsh edit默认优先使用“VISUAL”环境变量指定的文本编辑器。\\n', '\\n', '操作步骤\\n', '（可选）设置virsh edit命令的编辑器为vim。\\n', '\\n', '# export VISUAL=vim\\n', '使用virsh edit打开虚拟机名称为openEulerVM对应的XML配置文件。\\n', '\\n', '# virsh edit openEulerVM\\n', '修改虚拟机配置文件。\\n', '\\n', '保存虚拟机配置文件并退出。\\n', '\\n', '关闭虚拟机。\\n', '\\n', '# virsh shutdown openEulerVM\\n', '启动虚拟机使配置修改生效。\\n', '\\n', '# virsh start openEulerVM\\n', '查询虚拟机信息\\n', '概述\\n', '管理员在管理虚拟机的过程中经常需要知道一些虚拟机信息，libvirt提供了一套命令行工具用于查询虚拟机的相关信息。本章介绍相关命令的使用方法，便于管理员来获取虚拟机的各种信息。\\n', '\\n', '前提条件\\n', '查询虚拟机信息需要：\\n', '\\n', 'libvirtd服务处于运行状态。\\n', '\\n', '命令行操作需要拥有管理员权限。\\n', '\\n', '查询主机上的虚拟机信息\\n', '查询主机上处于运行和暂停状态的虚拟机列表。\\n', '\\n', '# virsh list\\n', '例如，下述回显说明当前主机上存在3台虚拟机，其中openEulerVM01、openEulerVM02处于运行状态，openEulerVM03处于暂停状态。\\n', '\\n', ' Id    Name                           State\\n', '----------------------------------------------------\\n', ' 39    openEulerVM01                   running\\n', ' 40    openEulerVM02                   running\\n', ' 69    openEulerVM03                   paused\\n', '查询主机上已经定义的所有虚拟机信息列表。\\n', '\\n', '# virsh list --all\\n', '例如，下述回显说明当前主机上定义了4台虚拟机，其中虚拟机openEulerVM01处于运行状态，openEulerVM02处于暂停状态，openEulerVM03和openEulerVM04处于关机状态。\\n', '\\n', ' Id    Name                           State\\n', '----------------------------------------------------\\n', ' 39    openEulerVM01                  running\\n', ' 69    openEulerVM02                  paused\\n', ' -     openEulerVM03                  shut off\\n', ' -     openEulerVM04                  shut off\\n', '查询虚拟机基本信息\\n', 'Libvirt组件提供了一组查询虚拟机状态信息的命令，包括虚拟机运行状态、设备信息或者调度属性等，使用方法请参见表1。\\n', '\\n', '表 1 查询虚拟机基本信息\\n', '\\n', '\\n', '查询的信息内容\\n', '\\n', '命令行\\n', '\\n', '说明\\n', '\\n', '基本信息\\n', '\\n', 'virsh dominfo <VMInstance>\\n', '\\n', '包括虚拟机ID、UUID，虚拟机规格等信息。\\n', '\\n', '当前状态\\n', '\\n', 'virsh domstate <VMInstance>\\n', '\\n', '可以使用--reason选项查询虚拟机变为当前状态的原因。\\n', '\\n', '调度信息\\n', '\\n', 'virsh schedinfo <VMInstance>\\n', '\\n', '包括vCPU份额等信息。\\n', '\\n', 'vCPU数目\\n', '\\n', 'virsh vcpucount <VMInstance>\\n', '\\n', '查询虚拟机vCPU的个数。\\n', '\\n', '虚拟块设备状态\\n', '\\n', 'virsh domblkstat <VMInstance>\\n', '\\n', '查询块设备名称可以使用virsh domblklist命令。\\n', '\\n', '虚拟网卡状态\\n', '\\n', 'virsh domifstat <VMInstance>\\n', '\\n', '查询网卡名称可以使用virsh domiflist命令。\\n', '\\n', 'I/O线程\\n', '\\n', 'virsh iothreadinfo <VMInstance>\\n', '\\n', '查询虚拟机I/O线程及其CPU亲和性信息。\\n', '\\n', '示例\\n', '使用virsh dominfo查询一个创建好的虚拟机的基本信息，从查询结果可知，虚拟机ID为5，UUID为ab472210-db8c-4018-9b3e-fc5319a769f7，内存大小为8GiB，vCPU数目为4个等。\\n', '\\n', '# virsh dominfo openEulerVM\\n', 'Id:             5\\n', 'Name:           openEulerVM\\n', 'UUID:           ab472210-db8c-4018-9b3e-fc5319a769f7\\n', 'OS Type:        hvm\\n', 'State:          running\\n', 'CPU(s):         4\\n', 'CPU time:       6.8s\\n', 'Max memory:     8388608 KiB\\n', 'Used memory:    8388608 KiB\\n', 'Persistent:     no\\n', 'Autostart:      disable\\n', 'Managed save:   no\\n', 'Security model: none\\n', 'Security DOI:   0\\n', '使用virsh domstate查询虚拟机的当前状态，从查询结果可知，虚拟机openEulerVM当前处于运行状态。\\n', '\\n', '# virsh domstate openEulerVM\\n', 'running\\n', '使用virsh schedinfo查询虚拟机的调度信息，从查询结果可知，虚拟机CPU预留份额为1024。\\n', '\\n', '# virsh schedinfo openEulerVM\\n', 'Scheduler      : posix\\n', 'cpu_shares     : 1024\\n', 'vcpu_period    : 100000\\n', 'vcpu_quota     : -1\\n', 'emulator_period: 100000\\n', 'emulator_quota : -1\\n', 'global_period  : 100000\\n', 'global_quota   : -1\\n', 'iothread_period: 100000\\n', 'iothread_quota : -1\\n', '使用virsh vcpucount查询虚拟机的vCPU数目，从查询结构可知，虚拟机有4个CPU。\\n', '\\n', '# virsh vcpucount openEulerVM\\n', 'maximum      live           4\\n', 'current      live           4\\n', '使用virsh domblklist查询虚拟机磁盘设备信息，从查询结构可知，虚拟机有2个磁盘，sda是qcow2格式的虚拟磁盘，sdb是一个cdrom设备。\\n', '\\n', ' # virsh domblklist openEulerVM\\n', ' Target   Source\\n', '---------------------------------------------------------------------\\n', ' sda      /home/openeuler/vm/openEuler_aarch64.qcow2\\n', ' sdb      /home/openeuler/vm/openEuler-20.09-aarch64-dvd.iso\\n', '使用virsh domiflist查询虚拟机网卡信息，从查询结果可知，虚拟机有1张网卡，对应的后端是vnet0在主机br0网桥上，MAC地址为00:05:fe:d4:f1:cc。\\n', '\\n', '# virsh domiflist openEulerVM\\n', 'Interface  Type       Source     Model       MAC\\n', '-------------------------------------------------------\\n', 'vnet0      bridge     br0        virtio      00:05:fe:d4:f1:cc\\n', '使用virsh iothreadinfo查询虚拟机I/O线程信息，从查询结果可知虚拟机有5个I/O线程，在物理CPU7-10上进行调度。\\n', '\\n', '# virsh iothreadinfo openEulerVM\\n', ' IOThread ID     CPU Affinity\\n', '---------------------------------------------------\\n', ' 3               7-10\\n', ' 4               7-10\\n', ' 5               7-10\\n', ' 1               7-10\\n', ' 2               7-10\\n', '登录虚拟机\\n', '本章介绍使用VNC登录虚拟机的方法。\\n', '\\n', '使用VNC密码登录\\n', '概述\\n', '当虚拟机操作系统安装部署完成之后，用户可以通过VNC协议远程登录虚拟机，从而对虚拟机进行管理操作。\\n', '\\n', '前提条件\\n', '使用RealVNC、TightVNC等客户端登录虚拟机，在登录虚拟机之前需要获取如下信息：\\n', '\\n', '虚拟机所在主机的IP地址。\\n', '\\n', '确保客户端所在的环境可以访问到主机的网络。\\n', '\\n', '虚拟机的VNC侦听端口，该端口一般在客户机启动时自动分配，一般为5900 + x（x为正整数，按照虚拟机启动的顺序递增，且5900对用户不可见）。\\n', '\\n', '如果VNC设置了密码，还需要获取虚拟机的VNC密码。\\n', '\\n', ' 说明：\\n', '为虚拟机VNC配置密码，需要编辑虚拟机XML配置文件，即为graphics元素新增一个passwd属性，属性的值为要配置的密码。例如，将虚拟机的VNC密码配置为n8VfjbFK的XML配置参考如下：\\n', '\\n', \"   <graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0' keymap='en-us' passwd='n8VfjbFK'>  \\n\", \"     <listen type='address' address='0.0.0.0'/>  \\n\", '   </graphics>  \\n', '操作步骤\\n', '查询虚拟机使用的VNC端口号。例如名称为openEulerVM的虚拟机，命令如下：\\n', '\\n', '# virsh vncdisplay openEulerVM\\n', ':3\\n', ' 说明：\\n', '登录 VNC 需要配置防火墙规则，允许 VNC 端口的连接。参考命令如下，其中X为数值“5900 + 端口号” ，例如本例中为5903。\\n', '\\n', 'firewall-cmd --zone=public --add-port=X/tcp  \\n', '打开VncViewer软件，输入主机IP和端口号。格式为“主机IP:端口号”，例如：“10.133.205.53:3”。\\n', '\\n', '单击“确定”输入VNC密码（可选），登录到虚拟机VNC进行操作。\\n', '\\n', '配置VNC-TLS登录\\n', '概述\\n', 'VNC服务端和客户端默认采用明文方式进行数据传输，因此通信内容可能被第三方截获。为了提升安全性，openEuler支持VNC服务端配置TLS模式进行加密认证。TLS（Tansport Layer Security）即传输层安全，可以实现VNC服务端和客户端之间加密通信，从而防止通信内容被第三方截获。\\n', '\\n', ' 说明：\\n', '\\n', '使用TLS加密认证模式需要VNC客户端支持TLS模式（例如TigerVNC），否则无法连接到VNC客户端。\\n', 'TLS加密认证模式配置粒度为主机服务器级别，开启该特性后，主机上正在运行的所有虚拟机对应的VNC客户端都将开启TLS加密认证模式。\\n', '操作步骤\\n', 'VNC开启TLS加密认证模式的操作步骤如下：\\n', '\\n', '登录VNC服务端所在主机登录VNC服务端所在主机，开启或修改服务端配置文件/etc/libvirt/qemu.conf中对应的配置项。相关配置内容如下所示：\\n', '\\n', 'vnc_listen = \"x.x.x.x\"          # \"x.x.x.x\"为VNC的侦听地址，请用户根据实际配置，VNC服务端只允许该地址或地址段范围内的客户端连接请求\\n', 'vnc_tls = 1                     # 配置为1，表示开启VNC TLS支持\\n', 'vnc_tls_x509_cert_dir = \"/etc/pki/libvirt-vnc\"        #指定证书存放的路径为/etc/pki/libvirt-vnc\\n', 'vnc_tls_x509_verify = 1                               #配置为1，表示TLS认证使用X509证书\\n', '为VNC创建证书和私钥文件。此处以GNU TLS为例进行说明。\\n', '\\n', ' 说明：\\n', '使用GNU TLS，请提前安装好gnu-utils软件包。\\n', '\\n', '制作证书颁发机构CA（Certificate Authority）的证书文件。\\n', '\\n', '# certtool --generate-privkey > ca-key.pem\\n', '制作自签名的CA证书公私钥。其中Your organization name为机构名，由用户指定。\\n', '\\n', '# cat > ca.info<<EOF\\n', 'cn = Your organization name \\n', 'ca\\n', 'cert_signing_key\\n', 'EOF\\n', '# certtool --generate-self-signed \\\\\\n', '         --load-privkey ca-key.pem \\\\\\n', '         --template ca.info \\\\\\n', '         --outfile ca-cert.pem\\n', '上述生成文件，ca-cert.pem是生成的CA公钥，ca-key.pem是生成的CA私钥，需要由CA妥善保管防止泄露。\\n', '\\n', '为VNC服务端颁发证书。其中Client Organization Name为实际的服务名称，例如cleint.foo.com，需要用户根据实际指定。\\n', '\\n', '# cat > server.info<<EOF\\n', 'cn = Server Organization Name\\n', 'tls_www_server\\n', 'encryption_key\\n', 'signing_key\\n', 'EOF\\n', '# certtool --generate-privkey > server-key.pem\\n', '# certtool --generate-certificate \\\\\\n', '           --load-ca-certificate ca-cert.pem \\\\\\n', '           --load-ca-privkey ca-key.pem \\\\\\n', '           --load-privkey server-key.pem \\\\\\n', '           --template server.info \\\\\\n', '           --outfile server-cert.pem\\n', '上述生成文件，server-key.pem是VNC服务端的私钥，server-cert.pem是VNC服务端的公钥。\\n', '\\n', '为VNC客户端颁发证书。\\n', '\\n', '# cat > client.info<<EOF\\n', 'cn = Client Organization Name\\n', 'tls_www_client\\n', 'encryption_key\\n', 'signing_key\\n', 'EOF\\n', '# certtool --generate-privkey > client-key.pem\\n', '# certtool --generate-certificate \\\\\\n', '           --load-ca-certificate ca-cert.pem \\\\\\n', '           --load-ca-privkey ca-key.pem \\\\\\n', '           --load-privkey client-key.pem \\\\\\n', '           --template client.info \\\\\\n', '           --outfile client-cert.pem\\n', '上述生成文件，client-key.pem是VNC客户端的私钥，client-cert.pem是VNC客户端的公钥，生成的公私钥对需要拷贝到VNC客户端。\\n', '\\n', '关闭需要被登录的虚拟机，重启VNC服务端所在主机的libvirtd服务。\\n', '\\n', '# systemctl restart libvirtd\\n', '将生成的服务端证书放置到VNC服务端指定目录并将证书的权限改为只允许当前用户读写。\\n', '\\n', '# sudo mkdir -m 750 /etc/pki/libvirt-vnc\\n', '# cp ca-cert.pem /etc/pki/libvirt-vnc/ca-cert.pem\\n', '# cp server-cert.pem /etc/pki/libvirt-vnc/server-cert.pem\\n', '# cp server-key.pem /etc/pki/libvirt-vnc/server-key.pem\\n', '# chmod 0600 /etc/pki/libvirt-vnc/*\\n', '将生成的客户端证书ca-cert.pem，client-cert.pem和client-key.pem拷贝到VNC客户端。配置VNC客户端的TLS证书后即可使用VNC TLS登录。\\n', '\\n', ' 说明：\\n', '\\n', 'VNC客户端证书的配置请参见各客户端对应的使用说明，由用户自行配置。\\n', '登录虚拟机的方式请参见“使用VNC密码登录”。\\n', '虚拟机安全启动\\n', '总体介绍\\n', '概述\\n', '安全启动（Secure Boot）就是利用公私钥对启动部件进行签名和验证。启动过程中，前一个部件验证后一个部件的数字签名，验证通过后，运行后一个部件，验证不通过则启动失败。安全启动的作用是检测设备启动阶段固件（Fireware）以及软件是否被篡改，防止恶意软件侵入和修改。通过安全启动可以保证系统启动过程中各个部件的完整性，防止没有经过认证的部件被加载运行，从而防止对系统及用户数据产生安全威胁。安全启动是在UEFI启动方式上实现的，Legacy启动方式不支持安全启动。根据UEFI规定，主板出厂的时候可以内置一些可靠的公钥。任何想要在这块主板上加载的操作系统或者硬件驱动程序，都必须通过这些公钥的认证。物理机上的安全启动由物理BIOS完成，虚拟机的安全启动通过软件模拟。虚拟机安全启动流程与host安全启动流程一致，都遵循开源UEFI规范。虚拟化平台上的UEFI由edk组件提供，虚拟机启动时qemu将UEFI镜像映射到内存中，为虚拟机模拟固件启动流程，安全启动正是虚拟机启动过程中edk提供的一个安全保护能力，用来保护虚拟机OS内核不被篡改。安全启动验签顺序：UEFI BIOS->shim->grub->vmlinuz（依次验签通过并加载）。\\n', '\\n', '中文\\t英文\\t缩略语\\t中文定义/描述\\n', '安全启动\\tSecure boot\\tSecure boot\\t安全启动就是启动过程中，前一个部件验证后一个部件的数字签名，验证通过后，运行后一个部件，验证不通过就停下来。通过安全启动可以保证系统启动过程中各个部件的完整性。\\n', '平台密钥\\tPlatform key\\tPK\\tOEM厂商所有，必须为 RSA 2048 或更强，PK为平台拥有者和平台固件之间建立可信关系。平台拥有者将PK的公钥部分PKpub注册到平台固件中，平台拥有者可以使用PK的私有部分PKpriv来改变平台的拥有权或者注册KEK密钥。\\n', '密钥交换密钥\\tKey exchange key\\tKEK\\tKEK为平台固件和OS之间创建可信关系。每一个操作系统和与平台固件通信的第三方应用在平台固件中注册KEK密钥的公共部分KEKpub。\\n', '签名数据库\\tDatabase white list\\tDB\\t存储验证shim、grub、vmlinuz等组件的密钥。\\n', '签名吊销数据库\\tDatabase black list\\tDBx\\t存储吊销的密钥。\\n', '功能说明\\n', '本次实现的虚拟机安全启动特性基于edk开源项目。非安全启动模式下，Linux基本流程如下：\\n', '\\n', '图 1 系统启动流程图\\n', '\\n', '\\n', '\\n', '安全启动模式下UEFI BIOS启动后加载的首个组件是系统镜像中的shim，shim与UEFI BIOS进行交互获取存储在UEFI BIOS变量db里面的密钥对grub进行验证，加载grub后同样调用密钥和认证接口对kernel进行验证。Linux启动流程如下：\\n', '\\n', '图 2 安全启动流程图\\n', '\\n', '\\n', '\\n', '从整体处理流程上来看，安全启动特性包含多个关键场景，根据场景分析和系统分解，安全启动特性涉及以下几个子系统：UEFI BIOS校验shim，shim校验grub，grub校验kernel。UEFI BIOS对shim进行验证，验证通过则启动shim，不通过则提示错误，无法启动。Shim需要在镜像编译制作过程中使用私钥进行签名，公钥证书导入UEFI BIOS变量区DB中。Shim启动后验证启动grub，验证通过则启动grub，不通过则提示错误，无法启动。Grub需要在镜像编译制作过程中进行签名，使用和shim一样的公私钥对。Grub启动后检查调用shim注册在UEFI BIOS的认证接口和密钥对kernel进行验证，通过则启动内核，不通过则提示错误，grub需要在镜像编译制作过程中进行签名，使用和shim一样的公私钥对。\\n', '\\n', '约束限制\\n', '在不支持安全启动的UEFI BIOS上运行，对现有功能没有影响，业务无感知。\\n', '安全启动特性依赖UEFI BIOS，必须在UEFI支持此功能的条件下才能发挥作用。\\n', '在UEFI BIOS开启安全启动的情况下，如果相关部件没有签名或签名不正确，则无法正常启动系统。\\n', '在UEFI BIOS关闭安全启动的情况下，启动过程的验证功能都会被关闭。\\n', '安全启动验证链后半段，即shim->grub->kernel引导内核启动这部分的验证链由操作系统镜像实现，若操作系统不支持引导内核安全启动过程，则虚拟机安全启动失败。\\n', '当前不提供x86架构使用nvram文件配置虚拟机安全启动\\n', '安全启动实践\\n', '虚拟机安全启动依赖于UEFI BIOS的实现，UEFI BIOS镜像通过edk rpm包安装，本节以AArch64为例对虚拟机安全启动进行配置。\\n', '\\n', '虚拟机配置\\n', 'edk rpm包中的组件安装于/usr/share/edk2/aarch64目录下，包括QEMU_EFI-pflash.raw和vars-template-pflash.raw。虚拟机启动UEFI BIOS部分xml配置如下：\\n', '\\n', '<os>\\n', \"    <type arch='aarch64' machine='virt'>hvm</type>\\n\", \"    <loader readonly='yes' type='pflash'>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw</loader>\\n\", \"    <nvram template='/usr/share/edk2/aarch64/vars-template-pflash.raw'>/path/to/QEMU-VARS.fd</nvram>\\n\", '</os>\\n', '其中/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw为UEFI BIOS镜像路径。/usr/share/edk2/aarch64/vars-template-pflash.raw为nvram镜像模板路径，/path/to/QEMU-VARS.fd为当前虚拟机nvram镜像文件路径，用于保存UEFI BIOS系统中的环境变量。\\n', '\\n', '证书导入\\n', '虚拟机安全启动时的证书从BIOS界面导入，在证书导入前需要将证书文件导入到虚拟机中。可以通过挂载磁盘的方式将证书文件所在目录挂载到虚拟机中，例如制作包含证书的镜像，并在虚拟机的配置文件xml中配置挂载该镜像：\\n', '\\n', '制作证书文件镜像\\n', '\\n', \"dd of='/path/to/data.img' if='/dev/zero' bs=1M count=64\\n\", 'mkfs.vfat -I /path/to/data.img\\n', 'mkdir /path/to/mnt\\n', 'mount path/to/data.img /path/to/mnt/\\n', 'cp -a /path/to/certificates/* /path/to/mnt/\\n', 'umount /path/to/mnt/\\n', '其中，/path/to/certificates/为证书文件所在路径，/path/to/data.img为证书文件镜像所在路径，/path/to/mnt/为镜像挂载路径。\\n', '\\n', '在虚拟机xml文件中配置挂载该镜像\\n', '\\n', '<devices>\\n', \"\\t<disk type='file' device='disk'>\\n\", \"\\t\\t<driver name='qemu' type='raw' cache='none' io='native'/>\\n\", \"\\t\\t<source file='/path/to/data.img'/>\\n\", \"\\t\\t<target dev='sdc' bus='scsi'/>\\n\", \"\\t\\t<boot order='2'/>\\n\", '\\t\\t<readonly/>\\n', '\\t</disk>\\n', '</devices>\\n', '启动虚拟机，导入PK证书，流程如下(KEK证书，DB证书导入方式相同)：\\n', '\\n', '虚拟机启动后，点击F2进入bios界面\\n', '\\n', '图 1 进入bios界面\\n', '\\n', '\\n', '\\n', '图 2 进入Device Manager\\n', '\\n', '\\n', '\\n', '图 3 进入Custom Secure Boot Options\\n', '\\n', '\\n', '\\n', '图 4 进入PK Options\\n', '\\n', '\\n', '\\n', '图 5 Enroll PK\\n', '\\n', '\\n', '\\n', '在File Explorer界面可以看到很多磁盘目录，其中包括我们通过磁盘挂载的证书文件目录\\n', '\\n', '图 6 File Explorer\\n', '\\n', '\\n', '\\n', '在磁盘目录中选择要导入的PK证书\\n', '\\n', '图 7 进入证书所在磁盘\\n', '\\n', '\\n', '\\n', '图 8 选择Commit Changes and Exit保存导入证书\\n', '\\n', '\\n', '\\n', '导入证书后，UEFI BIOS将证书信息以及安全启动属性写入nvram配置文件/path/to/QEMU-VARS.fd中，虚拟机下一次启动时会从/path/to/QEMU-VARS.fd文件中读取相关配置并初始化证书信息以及安全启动属性，自动导入证书并开启安全启动。同样，我们可以将/path/to/QEMU-VARS.fd作为其他相同配置虚拟机的UEFI BIOS启动配置模板文件，通过修改nvram template字段使其他虚拟机启动时自动导入证书并开启安全启动选项，虚拟机xml配置修改如下：\\n', '\\n', '<os>\\n', \"    <type arch='aarch64' machine='virt'>hvm</type>\\n\", \"    <loader readonly='yes' type='pflash'>/usr/share/edk2/aarch64/QEMU_EFI-pflash.raw</loader>\\n\", \"    <nvram template='/path/to/QEMU-VARS.fd'></nvram>\\n\", '</os>\\n', '安全启动观测\\n', '正确配置虚拟机并导入PK、KEK、DB证书后，虚拟机将以安全启动的方式运行。可以通过在虚拟机配置文件xml中配置串口日志文件观测虚拟机是否为安全启动，串口日志文件的配置方式如：\\n', '\\n', \"<serial type='file'>\\n\", \"\\t<source path='/path/to/log_file' append='on'/>\\n\", '</serial>\\n', '虚拟机加载系统镜像成功后，当串口日志文件中出现\"UEFI Secure Boot is enabled\"信息时，表明虚拟机当前为安全启动。\\n', '\\n', '\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_可信计算.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97.html", "text_entry": "['可信计算\\n', '可信计算\\n', '可信计算基础\\n', '可信计算\\n', '内核完整性度量（IMA）\\n', '概述\\n', '约束限制\\n', '使用场景\\n', '操作指导\\n', 'FAQ\\n', '附录\\n', '可信计算基础\\n', '可信计算\\n', '不同国际组织对可信（Trusted）做了不同的定义。\\n', '\\n', '可信计算组织（TCG）的定义：\\n', '\\n', '一个实体是可信的，它的行为总是以预期的方式达到预期的目标。\\n', '\\n', '国际标准化组织与国际电子技术委员会定义（1999）：\\n', '\\n', '参与计算的组件、操作或过程在任意的条件下是可预测的，并能够抵御病毒和一定程度的物理干扰。\\n', '\\n', 'IEEE Computer Society Technical Committee on Dependable Computing 定义：\\n', '\\n', '所谓可信，是指计算机系统所提供的服务是可被论证其是可信赖的，可信赖主要是指系统的可靠性和可用性。\\n', '\\n', '简而言之，可信就是系统按照预定的设计和策略运行，不做其他事情。\\n', '\\n', '一个可信计算系统由信任根、可信硬件平台、可信操作系统和可信应用组成，它的基本思想是首先创建一个安全信任根（TCB），然后建立从硬件平台、操作系统到应用的信任链，在这条信任链上从根开始，前一级认证后一级，实现信任的逐级扩展，从而实现一个安全可信的计算环境。\\n', '\\n', '\\n', '\\n', '相比于传统安全机制的“头痛医头，脚痛医脚”，发现一个病毒消灭一个病毒，可信计算采用的是白名单机制，即只允许经过认证的内核、内核模块、应用程序等在系统上运行，如果发现程序已发生更改（或本来就是一个未知的程序），就拒绝其执行。\\n', '\\n', '内核完整性度量（IMA）\\n', '概述\\n', 'IMA\\n', 'IMA，全称 Integrity Measurement Architecture（完整性度量架构），是内核中的一个子系统，能够基于自定义策略对通过 execve()、mmap() 和 open() 系统调用访问的文件进行度量，度量结果可被用于本地/远程证明，或者和已有的参考值比较以控制对文件的访问。\\n', '\\n', '根据 IMA wiki 的定义，内核完整性子系统的功能可以被分为三部分：\\n', '\\n', '度量（measure）：检测对文件的意外或恶意修改，无论远程还是本地。\\n', '评估（appraise）：度量文件并与一个存储在扩展属性中的参考值作比较，控制本地文件完整性。\\n', '审计（audit）：将度量结果写到系统日志中，用于审计。\\n', '可以看到，相比于 IMA 度量作为一个“只记录不干涉”的观察员，IMA 评估更像是一位严格的保安人员，它的职责是拒绝对所有“人证不一”的程序的访问。\\n', '\\n', 'EVM\\n', 'EVM，全称 Extended Verification Module（扩展验证模块），它的作用就是将系统当中某个文件的安全扩展属性，包括 security.ima 、security.selinux 等合起来计算一个哈希值，然后使用 TPM 中存的密钥或其他可信环境中的密钥对其进行签名，签名之后的值存在 security.evm 中，这个签名后的值是不能被篡改的，如果被篡改，再次访问的时候就会验签失败。\\n', '\\n', '总而言之，EVM 的作用就是通过对安全扩展属性计算摘要和签名并将其存储在 security.evm 中，提供对安全扩展属性的离线保护。\\n', '\\n', 'IMA Digest Lists\\n', 'IMA Digest Lists（IMA 摘要列表扩展）是 openEuler 对内核原生完整性保护机制的增强，它取代了原生 IMA 机制为文件完整性提供保护。\\n', '\\n', '“摘要列表”（digest lists）是一种特殊格式的二进制数据文件，它与 rpm 包一一对应，记录了 rpm 包中受保护文件（即可执行文件和动态库文件）的哈希值。\\n', '\\n', '当正确配置启动参数后，内核将维护一个哈希表（对用户空间不可见），并通过 securityfs 对外提供更新哈希表的接口（digest_list_data 和 digest_list_data_del）。摘要列表在构建阶段经过私钥签名，通过接口上传到内核时，需经过内核中的公钥验证。\\n', '\\n', '\\n', '\\n', '在开启 IMA 评估的情况下，每当访问一个可执行文件或动态库文件，就会调用内核中的钩子，计算文件内容和扩展属性的哈希值，并在内核哈希表中进行搜索，如果匹配就允许文件的执行，否则就拒绝访问。\\n', '\\n', '1599719649188\\n', '\\n', '相比内核社区原生 IMA 机制，openEuler 内核提供的 IMA 摘要列表扩展从安全性、性能、易用性三个方面进行了改良，助力完整性保护机制在生产环境下落地：\\n', '\\n', '具备完整的信任链，安全性好\\n', '\\n', '原生 IMA 机制要求在现网环境下预先生成并标记文件扩展属性，访问文件时将文件扩展属性作为参考值，信任链不完整。\\n', '\\n', 'IMA 摘要列表扩展将文件参考摘要值保存在内核空间中，构建阶段通过摘要列表的形式携带在发布的 rpm 包中，安装 rpm 包的同时导入摘要列表并执行验签，确保了参考值来自于软件发行商，实现了完整的信任链。\\n', '\\n', '惊艳的性能\\n', '\\n', '由于 TPM 芯片是一种低速芯片，因此 PCR 扩展操作成为了 IMA 度量场景的性能瓶颈。摘要列表扩展在确保安全性的前提下，减少了不必要的 PCR 扩展操作，相比原生 IMA 性能提升高达 65%。\\n', '\\n', 'IMA 评估场景下，摘要列表扩展将签名验证统一移动到启动阶段进行，避免每次访问文件时都执行验签，相比原生 IMA 评估场景提升运行阶段文件访问的性能约 20%。\\n', '\\n', '快速部署，平滑升级\\n', '\\n', '原生 IMA 机制在初次部署或每次更新软件包时，都需要切换到 fix 模式手动标记文件扩展属性后再重启进入 enforce 模式，才能正常访问安装的程序。\\n', '\\n', '摘要列表扩展可实现安装完成后开箱即用，且允许直接在 enforce 模式下安装或升级 rpm 包，无需重启和手动标记即可使用，实现了用户感知最小化，适合现网环境下的快速部署和平滑升级。\\n', '\\n', '需要注意的是，IMA 摘要列表扩展将原生 IMA 的验签过程提前到启动阶段进行，也引入了一个假设，即内核空间的内存无法被篡改，这就使得 IMA 也依赖于其他安全机制（内核模块安全启动和内存动态度量）以保护内核内存的完整性。\\n', '\\n', '但无论社区原生 IMA 机制还是 IMA 摘要列表扩展，都只是可信计算信任链中的一环，无法孤立地保证系统的安全性，安全自始至终都是一个构建纵深防御的系统工程。\\n', '\\n', '约束限制\\n', '当前 IMA 评估模式仅支持保护系统中的不可变文件（包括可执行文件和动态库文件）。\\n', 'IMA 提供的是应用层的完整性度量，它的安全性依赖于之前环节的可信。\\n', '当前阶段 IMA 不支持第三方应用摘要列表的导入。\\n', '启动日志中可能存在 Unable to open file: /etc/keys/x509_ima.der 字样，该报错来自于开源社区，不影响 IMA 摘要列表特性的使用。\\n', 'ARM 版本中 IMA 开启日志模式可能存在一些 audit 报错信息，这是由于 modprobe 在摘要列表未导入时加载内核模块所致，不影响正常功能。\\n', '使用场景\\n', 'IMA measurement\\n', 'IMA 度量的目的是检测对系统文件的意外或恶意修改，度量结果可被用于本地证明或远程证明。\\n', '\\n', '如果系统中存在 TPM 芯片，度量结果将被扩展到 TPM 芯片的指定 PCR 寄存器中，由于 PCR 扩展的单向性以及 TPM 芯片的硬件安全性，用户无法修改已被扩展的度量结果，这就确保了度量结果的真实性。\\n', '\\n', 'IMA 度量的文件范围和触发条件可以由用户通过 IMA 策略自行配置。\\n', '\\n', '默认情况下 IMA 不启用，但系统会前往 /etc/ima/ 路径下寻找 ima-policy 策略文件，如果找到，就会按照策略在启动时度量系统中的文件。如果不想手动编写策略文件，也可以在启动参数中配置 ima_policy=tcb 使用默认策略（更多策略参数请参考附录“IMA启动参数”章节）。\\n', '\\n', '系统当前加载的 IMA 策略可以在 /sys/kernel/security/ima/policy 文件中查看，IMA 度量日志则位于/sys/kernel/security/ima/ascii_runtime_measurements 文件中，如下所示：\\n', '\\n', '$ head /sys/kernel/security/ima/ascii_runtime_measurements\\n', '10 ddee6004dc3bd4ee300406cd93181c5a2187b59b ima-ng sha1:9797edf8d0eed36b1cf92547816051c8af4e45ee boot_aggregate\\n', '10 180ecafba6fadbece09b057bcd0d55d39f1a8a52 ima-ng sha1:db82919bf7d1849ae9aba01e28e9be012823cf3a /init\\n', '10 ac792e08a7cf8de7656003125c7276968d84ea65 ima-ng sha1:f778e2082b08d21bbc59898f4775a75e8f2af4db /bin/bash\\n', '10 0a0d9258c151356204aea2498bbca4be34d6bb05 ima-ng sha1:b0ab2e7ebd22c4d17d975de0d881f52dc14359a7 /lib64/ld-2.27.so\\n', '10 0d6b1d90350778d58f1302d00e59493e11bc0011 ima-ng sha1:ce8204c948b9fe3ae67b94625ad620420c1dc838 /etc/ld.so.cache\\n', '10 d69ac2c1d60d28b2da07c7f0cbd49e31e9cca277 ima-ng sha1:8526466068709356630490ff5196c95a186092b8 /lib64/libreadline.so.7.0\\n', '10 ef3212c12d1fbb94de9534b0bbd9f0c8ea50a77b ima-ng sha1:f80ba92b8a6e390a80a7a3deef8eae921fc8ca4e /lib64/libc-2.27.so\\n', '10 f805861177a99c61eabebe21003b3c831ccf288b ima-ng sha1:261a3cd5863de3f2421662ba5b455df09d941168 /lib64/libncurses.so.6.1\\n', '10 52f680881893b28e6f0ce2b132d723a885333500 ima-ng sha1:b953a3fa385e64dfe9927de94c33318d3de56260 /lib64/libnss_files-2.27.so\\n', '10 4da8ce3c51a7814d4e38be55a2a990a5ceec8b27 ima-ng sha1:99a9c095c7928ecca8c3a4bc44b06246fc5f49de /etc/passwd\\n', '每一条记录从左到右分别是：\\n', '\\n', 'PCR：用于扩展度量结果的 PCR 寄存器，默认是 10，只在系统装了 TPM 芯片的情况下有意义。\\n', '模板哈希值：最终被用于扩展的哈希值，组合了文件内容哈希和文件路径的长度和值。\\n', '模板：扩展度量值的模板，如 ima-ng。\\n', '文件内容哈希值：被度量的文件内容的哈希值。\\n', '文件路径：被度量的文件路径。\\n', '本版本使能了ko压缩特性，当加载被压缩ko文件时，如需IMA使能appraise func=MODULE_CHECK策略，需要在启动参数配置module.sig_enforce=1。\\n', 'IMA appraisal\\n', 'IMA 评估的目的是通过与标准参考值的比较，控制对本地文件的访问。\\n', '\\n', 'IMA 首先使用安全扩展属性 security.ima 和 security.evm 存储文件完整性度量的参考值：\\n', '\\n', 'security.ima：存储文件内容的哈希值；\\n', 'security.evm：存储文件扩展属性的哈希值签名。\\n', '访问受保护文件时，将会触发内核中的钩子，依次验证文件扩展属性和内容的完整性：\\n', '\\n', '使用内核 keyring 中的公钥对文件 security.evm 扩展属性中的签名值验签，与当前文件扩展属性的哈希值比较，如果匹配就证明文件的扩展属性是完整的（包括 security.ima）。\\n', '在文件扩展属性完整的前提下，将文件 security.ima 扩展属性的内容与当前文件内容的摘要值比较，如果匹配就允许对文件的访问。\\n', '同样，IMA 评估的文件范围和触发条件也可以由用户通过 IMA 策略自行配置。\\n', '\\n', 'IMA Digest Lists\\n', 'IMA 摘要列表扩展当前提供对以下三种启动参数组合的支持：\\n', '\\n', 'IMA measurement 度量模式：\\n', '\\n', 'ima_policy=exec_tcb ima_digest_list_pcr=11\\n', 'IMA appraisal 日志模式 + IMA measurement 度量模式：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=log evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', 'IMA appraisal 强制模式 + IMA measurement 度量模式：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=enforce-evm evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', '操作指导\\n', '原生 IMA 场景初次部署\\n', '第一次启动时，需要在启动参数中配置：\\n', '\\n', 'ima_appraise=fix ima_policy=appraise_tcb\\n', 'fix 模式会允许系统在没有参考值的情况下启动，appraise_tcb 对应了一种 IMA 策略，具体可参考附录中的“IMA 启动参数”章节。\\n', '\\n', '接下来，你需要访问所有需要被校验的文件，从而为它们添加 IMA 扩展属性：\\n', '\\n', \"$ time find / -fstype ext4 -type f -uid 0 -exec dd if='{}' of=/dev/null count=0 status=none \\\\;\\n\", '该过程会花费一定时间，请耐心等待。命令执行完成后，你可以从受保护文件的扩展属性中看到参考值已被标记：\\n', '\\n', '$ getfattr -m - -d /sbin/init\\n', '# file: sbin/init\\n', 'security.ima=0sAXr7Qmun5mkGDS286oZxCpdGEuKT\\n', 'security.selinux=\"system_u:object_r:init_exec_t\"\\n', '最后，配置以下启动参数并重新启动系统：\\n', '\\n', 'ima_appraise=enforce ima_policy=appraise_tcb\\n', '摘要列表场景初次部署\\n', '配置内核参数进入 log 模式。\\n', '\\n', '编辑 /boot/efi/EFI/euleros/grub.cfg 文件，加入以下参数：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=log evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', '使用 reboot 重启系统进入 log 模式，该模式下已开启完整性校验，但不会因校验失败而无法启动。\\n', '\\n', '安装依赖包。\\n', '\\n', '使用 yum 安装 digest-list-tools 和 ima-evm-utils，确认不低于以下版本：\\n', '\\n', '$ yum install digest-list-tools ima-evm-utils\\n', '$ rpm -qa | grep digest-list-tools\\n', 'digest-list-tools-0.3.93-1.oe1.x86_64\\n', '$ rpm -qa | grep ima-evm-utils\\n', 'ima-evm-utils-1.2.1-9.oe1.x86_64\\n', '如果安装了 plymouth 包，需要编辑 /usr/libexec/plymouth/plymouth-populate-initrd 脚本文件，在第 147 行的 cp 命令后增加 -a：\\n', '\\n', '    ...\\n', '    ddebug \"Installing $_src\"\\n', ' cp -a --sparse=always -pfL \"$PLYMOUTH_SYSROOT$_src\" \"${initdir}/$target\"\\n', '}\\n', '执行 dracut 重新生成 initrd：\\n', '\\n', '$ dracut -f -e xattr\\n', '编辑 /boot/efi/EFI/euleros/grub.cfg 文件，将 ima_appraise=log 改为 ima_appraise=enforce-evm：\\n', '\\n', 'ima_template=ima-sig ima_policy=\"exec_tcb|appraise_exec_tcb|appraise_exec_immutable\" initramtmpfs ima_hash=sha256 ima_appraise=enforce-evm evm=allow_metadata_writes evm=x509 ima_digest_list_pcr=11 ima_appraise_digest_list=digest\\n', '使用 reboot 重启即可完成初次部署。\\n', '\\n', '在 OBS 上进行摘要列表构建\\n', 'OBS 全称 Open Build Service，是一种编译系统，最早在 openSUSE 用于软件包的构建，能够支持多架构的分布式编译。\\n', '\\n', '进行摘要列表构建之前，首先确保您的工程包含以下 rpm 包，且来自 openEuler：\\n', '\\n', 'digest-list-tools\\n', 'pesign-obs-integration\\n', 'selinux-policy\\n', 'rpm\\n', 'openEuler-rpm-config\\n', '在交付件工程中增加 Project Config：\\n', '\\n', 'Preinstall: pesign-obs-integration digest-list-tools selinux-policy-targeted\\n', 'Macros:\\n', '%__brp_digest_list /usr/lib/rpm/openEuler/brp-digest-list %{buildroot}\\n', ':Macros\\n', '在 Preinstall 中新增 digest-list-tools 用于生成摘要列表，pesign-obs-integration 用于生成摘要列表的签名，新增 selinux-policy-targeted 用于确保生成摘要列表时构建环境内 SELinux 标签正确。\\n', '在 Macros 中定义宏 %__brp_digest_list，rpm 将在构建阶段通过这个宏执行命令为编译完成的二进制文件生成摘要列表。这个宏可以作为一个开关控制工程中的摘要列表是否生成。\\n', '配置完成后，OBS 会自动执行全量构建，正常情况下构建完成后，软件包中会新增以下两个文件：\\n', '\\n', '/etc/ima/digest_lists/0-metadata_list-compact-[包名]-[版本号]\\n', '/etc/ima/digest_lists.tlv/0-metadata_list-compact_tlv-[包名]-[版本号]\\n', '在 Koji 上进行摘要列表构建\\n', 'Koji 是 Fedora 社区的编译系统，openEuler 社区将在后续支持，敬请期待。\\n', '\\n', 'FAQ\\n', '为什么进入 enforce 模式后系统无法启动或启动后命令无法执行/服务不正常？\\n', '\\n', 'enforce 模式下 IMA 会对文件访问做控制，如果访问文件的内容或扩展属性不完整，就会被拒绝访问，当影响启动的关键命令无法执行时，就会造成系统无法启动。\\n', '\\n', '请确认是否存在以下问题：\\n', '\\n', '摘要列表是否被加入到 initrd 中？\\n', '\\n', '初次部署时是否执行了 dracut 命令将摘要列表加入内核？如果摘要列表没有加入 initrd，启动阶段就无法导入摘要列表，从而导致启动失败。\\n', '\\n', '是否使用官方提供的 rpm 包？\\n', '\\n', '如果使用的是非 openEuler 官方提供的 rpm 包，rpm 包可能没有携带摘要列表，或者对摘要列表签名的私钥与内核中的验签公钥不匹配，从而导致摘要列表没有被导入内核。\\n', '\\n', '如果原因还不明确，可以进入 log 模式启动，从错误日志中寻找原因：\\n', '\\n', '$ dmesg | grep appraise\\n', '为什么 enforce 模式下没有对系统文件做访问控制？\\n', '\\n', '系统没有按照预期对文件执行访问控制，首先查看启动参数中的 IMA 策略是否已被正确配置：\\n', '\\n', '$ cat /proc/cmdline\\n', '...ima_policy=exec_tcb|appraise_exec_tcb|appraise_exec_immutable...\\n', '其次查看当前内核中 IMA 策略是否已生效：\\n', '\\n', '$ cat /sys/kernel/security/ima/policy\\n', '如果 policy 文件是空的，证明策略没有设置成功，系统也就不会进行访问控制。\\n', '\\n', '初次部署完成后，安装/升级/卸载软件包后还需要手动执行 dracut 生成 initrd 吗？\\n', '\\n', '不需要。rpm 包提供的 digest_list.so 插件能够在 rpm 包粒度提供摘要列表的自动更新，可以实现用户对摘要列表的无感知。\\n', '\\n', '附录\\n', 'IMA securityfs 接口说明\\n', '原生 IMA 提供的 securityfs 接口如下：\\n', '\\n', '注：以下接口路径都位于 /sys/kernel/security/ 目录下。\\n', '\\n', '路径\\t权限\\t说明\\n', 'ima/policy\\t600\\tIMA 策略接口\\n', 'ima/ascii_runtime_measurement\\t440\\tascii 码形式表示的 IMA 度量结果\\n', 'ima/binary_runtime_measurement\\t440\\t二进制形式表示的 IMA 度量结果\\n', 'ima/runtime_measurement_count\\t440\\t度量结果数量统计\\n', 'ima/violations\\t440\\tIMA 度量结果冲突数\\n', 'evm\\t660\\tEVM 模式，即校验文件扩展属性完整性的方式\\n', '其中，/sys/kernel/security/evm 的取值有以下三种：\\n', '\\n', '0：EVM 未初始化；\\n', '1：使用 HMAC（对称加密）方式校验扩展属性完整性；\\n', '2：使用公钥验签（非对称加密）方式校验扩展属性完整性；\\n', '6：关闭扩展属性完整性校验（openEuler 使用此方式）。\\n', 'IMA 摘要列表扩展额外提供的 securityfs 接口如下：\\n', '\\n', '路径\\t权限\\t说明\\n', 'ima/digests_count\\t440\\t显示系统哈希表中的总摘要数量（IMA+EVM）\\n', 'ima/digest_list_data\\t200\\t摘要列表新增接口\\n', 'ima/digest_list_data_del\\t200\\t摘要列表删除接口\\n', 'IMA 策略语法\\n', '每条 IMA 策略语句都必须以 action 关键字代表的动作开头，后接筛选条件：\\n', '\\n', 'action：表示该条策略具体的动作，一条策略只能选一个 action。\\n', '\\n', '注：实际书写时可忽略 action 字样，直接书写 dont_measure，不需要写成 action=dont_measure。\\n', '\\n', 'func：表示被度量或鉴定的文件类型，常和 mask 匹配使用，一条策略只能选一个 func。\\n', '\\n', 'FILE_CHECK 只能同 MAY_EXEC、MAY_WRITE、MAY_READ 匹配使用。\\n', 'MODULE_CHECK、MMAP_CHECK、BPRM_CHECK 只能同 MAY_EXEC 匹配使用。\\n', '匹配关系以外的组合不会产生效果。\\n', 'mask：表示文件在做什么操作时将被度量或鉴定，一条策略只能选一个 mask。\\n', '\\n', 'fsmagic：表示文件系统类型的十六进制魔数，定义在 /usr/include/linux/magic.h 文件中。\\n', '\\n', '注：默认情况下度量所有文件系统，除非使用 dont_measure/dont_appraise 标记不度量某文件系统。\\n', '\\n', 'fsuuid：表示系统设备 uuid 的 16 位的十六进制字符串。\\n', '\\n', 'objtype：表示文件类型，一条策略只能选一个文件类型。\\n', '\\n', '注：objtype 相比 func 而言，划分的粒度更细，比如 obj_type=nova_log_t 表示 nova log 类型的文件。\\n', '\\n', 'uid：表示哪个用户（用用户 id 表示）对文件进行操作，一条策略只能选一个 uid。\\n', '\\n', 'fowner：表示文件的属主（用用户 id 表示）是谁，一条策略只能选一个 fowner。\\n', '\\n', '关键字的具体取值及说明如下：\\n', '\\n', '关键字\\t值\\t说明\\n', 'action\\tmeasure\\t开启 IMA 度量\\n', 'dont_measure\\t禁用 IMA 度量\\n', 'appraise\\t开启 IMA 评估\\n', 'dont_appraise\\t禁用 IMA 评估\\n', 'audit\\t开启审计\\n', 'func\\tFILE_CHECK\\t将要被打开的文件\\n', 'MODULE_CHECK\\t将要被装载的内核模块文件\\n', 'MMAP_CHECK\\t将要被映射到进程内存空间的动态库文件\\n', 'BRPM_CHECK\\t将要被执行的文件（不含通过 /bin/hash 等程序打开的脚本文件）\\n', 'POLICY_CHECK\\t将要被作为补充 IMA 策略装载的文件\\n', 'FIRMWARE_CHECK\\t将要被加载到内存中的固件\\n', 'DIGEST_LIST_CHECK\\t将要被加载到内核中的摘要列表文件\\n', 'KEXEC_KERNEL_CHECK\\t将要切换的 kexec 内核\\n', 'mask\\tMAY_EXEC\\t执行文件\\n', 'MAY_WRITE\\t写文件。不建议使用，受限于 echo、vim 等开源机制（修改本质是新建临时文件再重命名），并不是每次修改都会触发 MAY_WRITE 的 IMA 度量。\\n', 'MAY_READ\\t读文件\\n', 'MAY_APPEND\\t扩展文件属性\\n', 'fsmagic\\tfsmagic=xxx\\t表示文件系统类型的十六进制魔数\\n', 'fsuuid\\tfsuuid=xxx\\t表示系统设备 uuid 的 16 位的十六进制字符串\\n', 'fowner\\tfowner=xxx\\t文件属主的用户 id\\n', 'uid\\tuid=xxx\\t操作文件的用户 id\\n', 'obj_type\\tobj_type=xxx_t\\t表示文件的类型（基于 SELinux 标签）\\n', 'pcr\\tpcr=<num>\\t选择 TPM 中用于扩展度量值的 PCR（默认为 10）\\n', 'appraise_type\\timasig\\t基于签名进行 IMA 评估\\n', 'meta_immutable\\t基于签名进行文件扩展属性的评估（支持摘要列表）\\n', '注：PATH_CHECK 等同于 FILE_CHECK，FILE_MMAP 等同于 MMAP_CHECK，不在本表提及。\\n', '\\n', 'IMA 原生启动参数\\n', '原生 IMA 的内核启动参数列表如下：\\n', '\\n', '参数名称\\t取值\\t功能\\n', 'ima_appraise\\toff\\t关闭 IMA 评估模式，在访问文件时不进行完整性校验，也不为文件生成新的参考值。\\n', 'enforce\\t开启 IMA 评估强制模式，在访问文件时进行完整性校验，即计算文件摘要值并与参考值比对，如果比对失败就拒绝对文件的访问。IMA 会为新文件生成新的参考值。\\n', 'fix\\t开启 IMA 修复模式，在该模式下允许更新受保护文件的参考值。\\n', 'log\\t开启 IMA 评估日志模式，在访问文件时进行完整性校验，但即使校验失败也允许执行命令，只进行日志记录。\\n', 'ima_policy\\ttcb\\t度量所有文件执行、动态库映射、内核模块导入以及设备驱动加载，此外，root 用户读文件的行为也会被度量。\\n', 'appraise_tcb\\t对所有 root 属主的文件进行评估。\\n', 'secure_boot\\t对所有内核模块导入、硬件驱动加载、kexec 内核切换以及 IMA 策略进行评估，前提是这些文件都具有 IMA 签名，\\n', 'ima_tcb\\t无\\t等价于 ima_policy=tcb\\n', 'ima_appraise_tcb\\t无\\t等价于 ima_policy=appraise_tcb\\n', 'ima_hash\\tsha1/md5/…\\tIMA 摘要算法，默认为 sha1\\n', 'ima_template\\tima\\tIMA 度量扩展模板\\n', 'ima-ng\\tIMA 度量扩展模板\\n', 'ima-sig\\tIMA 度量扩展模板\\n', 'integrity_audit\\t0\\t基础完整性审计信息（默认）\\n', '1\\t额外完整性审计信息\\n', '注：ima_policy 参数可以同时指定多个值，例如 ima_policy=tcb|appraise_tcb，启动后系统的 IMA 策略就是这两种参数对应的策略的总和。\\n', '\\n', '启动参数 ima_policy=tcb 对应的 IMA 策略为：\\n', '\\n', '# PROC_SUPER_MAGIC = 0x9fa0\\n', 'dont_measure fsmagic=0x9fa0\\n', '# SYSFS_MAGIC = 0x62656572\\n', 'dont_measure fsmagic=0x62656572\\n', '# DEBUGFS_MAGIC = 0x64626720\\n', 'dont_measure fsmagic=0x64626720\\n', '# TMPFS_MAGIC = 0x01021994\\n', 'dont_measure fsmagic=0x1021994\\n', '# DEVPTS_SUPER_MAGIC=0x1cd1\\n', 'dont_measure fsmagic=0x1cd1\\n', '# BINFMTFS_MAGIC=0x42494e4d\\n', 'dont_measure fsmagic=0x42494e4d\\n', '# SECURITYFS_MAGIC=0x73636673\\n', 'dont_measure fsmagic=0x73636673\\n', '# SELINUX_MAGIC=0xf97cff8c\\n', 'dont_measure fsmagic=0xf97cff8c\\n', '# SMACK_MAGIC=0x43415d53\\n', 'dont_measure fsmagic=0x43415d53\\n', '# CGROUP_SUPER_MAGIC=0x27e0eb\\n', 'dont_measure fsmagic=0x27e0eb\\n', '# CGROUP2_SUPER_MAGIC=0x63677270\\n', 'dont_measure fsmagic=0x63677270\\n', '# NSFS_MAGIC=0x6e736673\\n', 'dont_measure fsmagic=0x6e736673 \\n', 'measure func=MMAP_CHECK mask=MAY_EXEC \\n', 'measure func=BPRM_CHECK mask=MAY_EXEC \\n', 'measure func=FILE_CHECK mask=MAY_READ uid=0 \\n', 'measure func=MODULE_CHECK \\n', 'measure func=FIRMWARE_CHECK\\n', '启动参数 ima_policy=tcb_appraise 对应的 IMA 策略为：\\n', '\\n', '# PROC_SUPER_MAGIC = 0x9fa0\\n', 'dont_appraise fsmagic=0x9fa0\\n', '# SYSFS_MAGIC = 0x62656572\\n', 'dont_appraise fsmagic=0x62656572\\n', '# DEBUGFS_MAGIC = 0x64626720 \\n', 'dont_appraise fsmagic=0x64626720 \\n', '# TMPFS_MAGIC = 0x01021994\\n', 'dont_appraise fsmagic=0x1021994\\n', '# RAMFS_MAGIC\\n', 'dont_appraise fsmagic=0x858458f6 \\n', '# DEVPTS_SUPER_MAGIC=0x1cd1\\n', 'dont_appraise fsmagic=0x1cd1\\n', '# BINFMTFS_MAGIC=0x42494e4d\\n', 'dont_appraise fsmagic=0x42494e4d \\n', '# SECURITYFS_MAGIC=0x73636673\\n', 'dont_appraise fsmagic=0x73636673\\n', '# SELINUX_MAGIC=0xf97cff8c\\n', 'dont_appraise fsmagic=0xf97cff8c \\n', '# SMACK_MAGIC=0x43415d53\\n', 'dont_appraise fsmagic=0x43415d53 \\n', '# NSFS_MAGIC=0x6e736673\\n', 'dont_appraise fsmagic=0x6e736673 \\n', '# CGROUP_SUPER_MAGIC=0x27e0eb\\n', 'dont_appraise fsmagic=0x27e0eb \\n', '# CGROUP2_SUPER_MAGIC=0x63677270\\n', 'dont_appraise fsmagic=0x63677270 \\n', 'appraise fowner=0\\n', '启动参数 ima_policy=secure_boot 对应的 IMA 策略为：\\n', '\\n', 'appraise func=MODULE_CHECK appraise_type=imasig \\n', 'appraise func=FIRMWARE_CHECK appraise_type=imasig \\n', 'appraise func=KEXEC_KERNEL_CHECK appraise_type=imasig \\n', 'appraise func=POLICY_CHECK appraise_type=imasig\\n', 'IMA 摘要列表启动参数\\n', 'IMA 摘要列表特性额外引入的内核启动参数如下：\\n', '\\n', '参数名称\\t取值\\t功能\\n', 'integrity\\t0\\tIMA 特性总开关关闭（默认）\\n', '1\\tIMA 特性总开关打开\\n', 'ima_appraise\\toff\\t关闭 IMA 评估模式\\n', 'enforce-evm\\tIMA 评估强制模式，在访问文件时进行完整性校验并进行访问控制\\n', 'ima_appraise_digest_list\\tdigest\\t当 EVM 被禁用时，使用摘要列表进行 IMA appraise，摘要列表同时保护文件内容和扩展属性\\n', 'digest-nometadata\\t在EVM摘要值不存在的情况下，仅基于IMA摘要值进行完整性校验（不保护文件扩展属性）\\n', 'evm\\tfix\\t允许任何对扩展属性的修改（即使修改会导致扩展属性完整性校验失败）\\n', 'ignore\\t只有在扩展属性不存在或不正确的情况下才允许修改\\n', 'ima_policy\\texec_tcb\\tIMA 度量策略，详见下文策略说明。\\n', 'appraise_exec_tcb\\tIMA 评估策略，详见下文策略说明。\\n', 'appraise_exec_immutable\\tIMA 评估策略，详见下文策略说明。\\n', 'ima_digest_list_pcr\\t11\\t使用 PCR 11 替代 PCR 10，仅使用摘要列表进行度量\\n', '+11\\t依然保留 PCR 10 的度量，在有TPM芯片时也往TPM芯片写度量结果\\n', 'initramtmpfs\\t无\\t添加对 tmpfs 的支持\\n', '启动参数 ima_policy=exec_tcb 对应的 IMA 策略为：\\n', '\\n', 'dont_measure fsmagic=0x9fa0 \\n', 'dont_measure fsmagic=0x62656572 \\n', 'dont_measure fsmagic=0x64626720 \\n', 'dont_measure fsmagic=0x1cd1 \\n', 'dont_measure fsmagic=0x42494e4d \\n', 'dont_measure fsmagic=0x73636673 \\n', 'dont_measure fsmagic=0xf97cff8c \\n', 'dont_measure fsmagic=0x43415d53 \\n', 'dont_measure fsmagic=0x27e0eb \\n', 'dont_measure fsmagic=0x63677270 \\n', 'dont_measure fsmagic=0x6e736673 \\n', 'measure func=MMAP_CHECK mask=MAY_EXEC \\n', 'measure func=BPRM_CHECK mask=MAY_EXEC \\n', 'measure func=MODULE_CHECK \\n', 'measure func=FIRMWARE_CHECK \\n', 'measure func=POLICY_CHECK \\n', 'measure func=DIGEST_LIST_CHECK \\n', 'measure parser\\n', '启动参数 ima_policy=appraise_exec_tcb 对应的 IMA 策略为：\\n', '\\n', 'appraise func=MODULE_CHECK appraise_type=imasig \\n', 'appraise func=FIRMWARE_CHECK appraise_type=imasig \\n', 'appraise func=KEXEC_KERNEL_CHECK appraise_type=imasig \\n', 'appraise func=POLICY_CHECK appraise_type=imasig \\n', 'appraise func=DIGEST_LIST_CHECK appraise_type=imasig \\n', 'dont_appraise fsmagic=0x9fa0 \\n', 'dont_appraise fsmagic=0x62656572 \\n', 'dont_appraise fsmagic=0x64626720 \\n', 'dont_appraise fsmagic=0x858458f6 \\n', 'dont_appraise fsmagic=0x1cd1 \\n', 'dont_appraise fsmagic=0x42494e4d \\n', 'dont_appraise fsmagic=0x73636673 \\n', 'dont_appraise fsmagic=0xf97cff8c \\n', 'dont_appraise fsmagic=0x43415d53 \\n', 'dont_appraise fsmagic=0x6e736673 \\n', 'dont_appraise fsmagic=0x27e0eb \\n', 'dont_appraise fsmagic=0x63677270\\n', '启动参数 ima_policy=appraise_exec_immutable 对应的 IMA 策略为：\\n', '\\n', 'appraise func=BPRM_CHECK appraise_type=imasig appraise_type=meta_immutable \\n', 'appraise func=MMAP_CHECK \\n', 'appraise parser appraise_type=imasig\\n', 'IMA 内核编译选项详解\\n', '原生 IMA 提供的编译选项如下：\\n', '\\n', '编译选项\\t功能\\n', 'CONFIG_INTEGRITY\\tIMA/EVM 总编译开关\\n', 'CONFIG_INTEGRITY_SIGNATURE\\t使能 IMA 签名校验\\n', 'CONFIG_INTEGRITY_ASYMMETRIC_KEYS\\t使能 IMA 非对称签名校验\\n', 'CONFIG_INTEGRITY_TRUSTED_KEYRING\\t使能 IMA/EVM 密钥环\\n', 'CONFIG_INTEGRITY_AUDIT\\t编译 IMA audit 审计模块\\n', 'CONFIG_IMA\\tIMA 总编译开关\\n', 'CONFIG_IMA_WRITE_POLICY\\t允许在运行阶段更新 IMA 策略\\n', 'CONFIG_IMA_MEASURE_PCR_IDX\\t允许指定 IMA 度量 PCR 序号\\n', 'CONFIG_IMA_LSM_RULES\\t允许配置 LSM 规则\\n', 'CONFIG_IMA_APPRAISE\\tIMA 评估总编译开关\\n', 'IMA_APPRAISE_BOOTPARAM\\t启用 IMA 评估启动参数\\n', 'CONFIG_EVM\\tEVM 总编译开关\\n', 'IMA 摘要列表扩展额外提供的编译选项如下：\\n', '\\n', '编译选项\\t功能\\n', 'CONFIG_DIGEST_LIST\\t开启 IMA 摘要列表特性开关\\n', 'IMA 性能参考数据\\n', '下图对比了不开启 IMA、开启原生 IMA、开启 IMA 摘要列表特性时的性能：']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_安装、升级与卸载_升级.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%8D%87%E7%BA%A7.html", "text_entry": "['升级\\n', '若为相同大版本之间的升级，例如从2.x.x版本升级到2.x.x版本，请执行如下命令：\\n', '\\n', '# sudo yum update -y iSulad\\n', '若为不同大版本之间的升级，例如从1.x.x版本升级到2.x.x版本，请先保存当前的配置文件/etc/isulad/daemon.json，并卸载已安装的iSulad软件包，然后安装待升级的iSulad软件包，随后恢复配置文件。\\n', '\\n', ' 说明：\\n', '\\n', '可通过** sudo rpm -qa |grep iSulad** 或 **isula version** 命令确认当前iSulad的版本号。\\n', '相同大版本之间，如果希望手动升级，请下载iSulad及其所有依赖库的RPM包进行升级，参考命令如下：\\n', '# sudo rpm -Uhv iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm  \\n', '若升级失败，可通过–force选项进行强制升级，参考命令如下：\\n', '\\n', '# sudo rpm -Uhv --force iSulad-xx.xx.xx-YYYYmmdd.HHMMSS.gitxxxxxxxx.aarch64.rpm  \\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_使用KAE加速引擎.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E4%BD%BF%E7%94%A8KAE%E5%8A%A0%E9%80%9F%E5%BC%95%E6%93%8E.html", "text_entry": "['使用KAE加速引擎\\n', '使用KAE加速引擎\\n', '简介\\n', '应用场景\\n', '安装、升级和卸载\\n', '安装加速器软件包\\n', '升级加速器软件包\\n', '卸载加速器软件包\\n', '日志查询\\n', '加速引擎的应用\\n', 'KAE引擎使用示例代码\\n', '通过OpenSSL配置文件openssl.cnf使用KAE引擎\\n', '故障处理\\n', '初始化失败\\n', '安装完加速器引擎之后，查找不到加速器设备\\n', '升级加速器驱动失败\\n', '简介\\n', 'KAE加速引擎为openEuler的一个软件加速库，搭载在Kunpeng 920处理器上联合提供硬件加速引擎功能，包含了对称加密、非对称加密和数字签名，用于加速SSL/TLS应用，可以显著降低处理器消耗，提高处理器效率。此外，用户通过OpenSSL标准接口可实现业务快速迁移。\\n', '\\n', 'KAE加速引擎支持以下算法：\\n', '\\n', '摘要算法SM3, 支持异步模式。\\n', '\\n', '对称加密算法SM4，支持异步模式，支持CTR/XTS/CBC模式。\\n', '\\n', '对称加密算法AES, 支持异步模式，支持ECB/CTR/XTS/CBC模式。\\n', '\\n', '非对称算法RSA，支持异步模式，支持 Key Sizes 1024/2048/3072/4096。\\n', '\\n', '密钥协商算法DH, 支持异步模式，支持 Key Sizes 768/1024/1536/2048/3072/4096。\\n', '\\n', '应用场景\\n', 'KAE加速引擎主要有以下应用场景，如表1所示。\\n', '\\n', '表 1 应用场景\\n', '\\n', '\\n', '场景\\n', '\\n', '数据\\n', '\\n', '大数据\\n', '\\n', '流数据\\n', '\\n', '数据加密\\n', '\\n', '块数据\\n', '\\n', '智能安防\\n', '\\n', '视频流数据\\n', '\\n', 'Web服务\\n', '\\n', '握手连接\\n', '\\n', '安装、升级和卸载\\n', '安装加速器软件包\\n', '安装前准备\\n', '环境要求\\n', 'TaiShan 200服务器，开启加速引擎功能\\n', ' 说明：\\n', '\\n', '需要导入加速器许可证，具体操作请参考《TaiShan 机架服务器 iBMC (V500及以上) 用户指南》中“许可证管理”章节。\\n', '物理机场景使用加速器需要关闭SMMU，具体操作请参考《TaiShan 200服务器BIOS参数参考》。\\n', 'CPU：Kunpeng 920\\n', '操作系统：openEuler-22.03_LTS-aarch64-dvd.iso\\n', 'KAE加速引擎软件说明\\n', '表 2 加速引擎的rpm软件包\\n', '\\n', '\\n', '软件包名称\\n', '\\n', '软件包说明\\n', '\\n', 'kae_driver-版本号-1.OS类型.aarch64.rpm\\n', '\\n', '加速器驱动，包含内容：uacce.ko、hisi_qm.ko、hisi_sec2.ko、hisi_hpre.ko内核模块\\n', '\\n', '支持：SM3/SM4/AES/RSA/DH算法\\n', '\\n', 'libwd-版本号-1.OS类型.aarch64.rpm\\n', '\\n', '包含内容：libwd.so动态链接库\\n', '\\n', '提供接口给KAE引擎\\n', '\\n', 'libkae-版本号-1.OS类型.aarch64.rpm\\n', '\\n', '依赖：libwd rpm包\\n', '\\n', '包含内容：libkae.so动态库\\n', '\\n', '支持：SM3/SM4/AES/RSA/DH等算法\\n', '\\n', '安装加速器软件包\\n', '前提条件\\n', '已在本地安装远程SSH登录工具\\n', '\\n', '已安装openEuler操作系统\\n', '\\n', 'RPM工具能正常使用。\\n', '\\n', '已安装OpenSSL 1.1.1a或以上版本。\\n', '\\n', '使用如下命令查询OpenSSL的版本号\\n', '\\n', 'openssl version\\n', '安装步骤\\n', '以root帐号登录openEuler OS命令行界面。\\n', '\\n', '新建目录用于存放加速器引擎软件包。\\n', '\\n', '使用SSH远程登录工具，将所有加速引擎软件包拷贝到已建好的目录下。\\n', '\\n', '在存放加速引擎软件包目录下，使用rpm -ivh命令安装加速器引擎软件包。\\n', '\\n', ' 说明：\\n', '由于libkae包的安装依赖libwd包，所以libwd的安装必须先于libkae。\\n', '\\n', 'rpm -ivh uacce*.rpm hisi*.rpm libwd-*.rpm libkae*.rpm\\n', 'Verifying...                          ################################# [100%]\\n', 'Preparing...                          ################################# [100%]\\n', 'checking installed modules\\n', 'uacce modules start to install\\n', 'Updating / installing...\\n', '   1:uacce-1.2.10-4.oe1               ################################# [ 14%]\\n', 'uacce modules installed\\n', '   2:libwd-1.2.10-3.oe1               ################################# [ 29%]\\n', '   3:libkae-1.2.10-3.oe1              ################################# [ 43%]\\n', 'checking installed modules\\n', 'hisi_hpre modules start to install\\n', '   4:hisi_hpre-1.2.10-4.oe1           ################################# [ 57%]\\n', 'hisi_hpre modules installed\\n', 'checking installed modules\\n', 'hisi_rde modules start to install\\n', '   5:hisi_rde-1.2.10-4.oe1            ################################# [ 71%]\\n', 'hisi_rde modules installed\\n', 'checking installed modules\\n', 'hisi_sec2 modules start to install\\n', '   6:hisi_sec2-1.2.10-4.oe1           ################################# [ 86%]\\n', 'hisi_sec2 modules installed\\n', 'checking installed modules\\n', 'hisi_zip modules start to install\\n', '   7:hisi_zip-1.2.10-4.oe1            ################################# [100%]\\n', 'hisi_zip modules installed\\n', '使用rpm -qa命令，查看加速器软件包是否已正常安装到系统内。使用rpm -ql命令 ，查看软件包的文件是否正确。示例如下。\\n', '\\n', 'rpm -qa|grep -E \"hisi|uacce|libwd|libkae\"\\n', 'hisi_rde-1.2.10-4.oe1.aarch64\\n', 'hisi_sec2-1.2.10-4.oe1.aarch64\\n', 'libkae-1.2.10-3.oe1.aarch64\\n', 'hisi_hpre-1.2.10-4.oe1.aarch64\\n', 'uacce-1.2.10-4.oe1.aarch64\\n', 'libwd-1.2.10-3.oe1.aarch64\\n', 'hisi_zip-1.2.10-4.oe1.aarch64\\n', 'rpm -ql uacce hisi* libwd* libkae\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_qm.ko\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/uacce.ko\\n', '/etc/modprobe.d/hisi_hpre.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_hpre.ko\\n', '/etc/modprobe.d/hisi_rde.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_rde.ko\\n', '/etc/modprobe.d/hisi_sec2.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_sec2.ko\\n', '/etc/modprobe.d/hisi_zip.conf\\n', '/lib/modules/4.19.90-2003.4.0.0036.oe1.aarch64/extra/hisi_zip.ko\\n', '/usr/include/warpdrive/config.h\\n', '/usr/include/warpdrive/include/uacce.h\\n', '/usr/include/warpdrive/smm.h\\n', '/usr/include/warpdrive/wd.h\\n', '/usr/include/warpdrive/wd_bmm.h\\n', '/usr/include/warpdrive/wd_cipher.h\\n', '/usr/include/warpdrive/wd_comp.h\\n', '/usr/include/warpdrive/wd_dh.h\\n', '/usr/include/warpdrive/wd_digest.h\\n', '/usr/include/warpdrive/wd_rsa.h\\n', '/usr/lib64/libwd.so.1.2.10\\n', '/usr/local/lib/engines-1.1/libkae.so.1.2.10\\n', '重启系统或通过命令行手动依次加载加速器引擎驱动到内核，并查看是否加载成功。\\n', '\\n', '# modprobe uacce \\n', '# lsmod | grep uacce \\n', '# modprobe hisi_qm\\n', '# lsmod | grep hisi_qm \\n', '# modprobe hisi_qm\\n', '# modprobe hisi_sec2 #加载hisi_sec2驱动时将根据/etc/modprobe.d/hisi_sec2.conf 下的配置文件加载到内核\\n', '# modprobe hisi_hpre #加载hisi_hpre驱动时将根据/etc/modprobe.d/hisi_hpre.conf 下的配置文件加载到内核\\n', '设置环境变量\\n', '通过以下命令导出环境变量：如果用户指定安装路径，则下面/usr/local应根据实际安装路径进行修改。\\n', '\\n', 'export OPENSSL_ENGINES=/usr/local/lib/engines-1.1\\n', '安装后检查\\n', '执行rpm -qa命令查看加速器引擎软件包是否安装成功。\\n', '\\n', '打印信息中包含“ 软件包名-版本号- ”表示该软件包安装成功。示例如下。\\n', '\\n', 'rpm -qa|grep -E \"hisi|uacce|libwd|libkae\"\\n', 'hisi_rde-1.2.10-4.oe1.aarch64\\n', 'hisi_sec2-1.2.10-4.oe1.aarch64\\n', 'libkae-1.2.10-3.oe1.aarch64\\n', 'hisi_hpre-1.2.10-4.oe1.aarch64\\n', 'uacce-1.2.10-4.oe1.aarch64\\n', 'libwd-1.2.10-3.oe1.aarch64\\n', 'hisi_zip-1.2.10-4.oe1.aarch64\\n', '安装后操作\\n', 'OpenSSL加速器引擎测试\\n', '用户可以通过以下命令测试部分加速器功能。\\n', '\\n', '使用OpenSSL的软件算法测试RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed rsa2048\\n', '...\\n', '                 sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.001384s 0.000035s   724.1  28365.8.\\n', '使用KAE引擎的测试RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -engine kae rsa2048\\n', '....\\n', '                 sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.000355s 0.000022s   2819.0  45478.4\\n', ' 说明：\\n', '使用KAE引擎加速后签名性能从724.1 sign/s提升到2819sign/s。\\n', '\\n', '使用OpenSSL的软件算法测试异步RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -async_jobs 36 rsa2048 \\n', '....\\n', '                  sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.001318s 0.000032s    735.7  28555\\n', '使用KAE引擎的测试异步RSA性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -engine kae -elapsed -async_jobs 36 rsa2048 \\n', '.... \\n', '                  sign    verify    sign/s verify/s\\n', 'rsa 2048 bits 0.000018s 0.000009s  54384.1 105317.0\\n', ' 说明：\\n', '使用KAE引擎加速后异步RSA签名性能从735.7 sign/s提升到 54384.1sign/s。\\n', '\\n', '使用OpenSSL的软件算法测试SM4 CBC模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp sm4-cbc\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', '....\\n', \"Doing sm4-cbc for 3s on 10240 size blocks: 2196 sm4-cbc's in 3.00s  ....\\n\", 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'sm4-cbc          82312.53k    85196.80k    85284.18k    85000.85k    85284.18k    85261.26k\\n', '使用KAE引擎的测试SM4 CBC模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -engine kae -evp sm4-cbc\\n', 'engine \"kae\" set. \\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', '...\\n', \"Doing sm4-cbc for 3s on 1048576 size blocks: 11409 sm4-cbc's in 3.00s\\n\", '...\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'sm4-cbc         383317.33k   389427.20k   395313.15k   392954.73k   394264.58k   394264.58k\\n', ' 说明：\\n', '使用KAE加速后SM4 CBC模式在输入数据块大小为8M时，从82312.53k/s提升到383317.33k/s。\\n', '\\n', '使用OpenSSL的软件算法测试SM3模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp sm3\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing sm3 for 3s on 102400 size blocks: 1536 sm3's in 3.00s\\n\", '....\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'sm3              50568.53k    52428.80k    52428.80k    52428.80k    52428.80k    52428.80k\\n', '使用KAE引擎测试SM3模式性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -engine kae -evp sm3\\n', 'engine \"kae\" set.\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing sm3 for 3s on 102400 size blocks: 19540 sm3's in 3.00s\\n\", '....\\n', 'type            51200 bytes  102400 bytes  1048576 bytes 2097152 bytes 4194304 bytes 8388608 bytes\\n', 'sm3             648243.20k   666965.33k   677030.57k   678778.20k   676681.05k   668292.44k\\n', ' 说明：\\n', '使用KAE加速后SM3算法在输入数据块大小为8M时，从52428.80 k/s提升到668292.44k/s。\\n', '\\n', '使用OpenSSL软件算法测试AES算法CBC模式异步性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp aes-128-cbc -async_jobs 4\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing aes-128-cbc for 3s on 51200 size blocks: 65773 aes-128-cbc's in 3.00s\\n\", \"Doing aes-128-cbc for 3s on 102400 size blocks: 32910 aes-128-cbc's in 3.00s\\n\", '....\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'aes-128-cbc    1122525.87k  1123328.00k  1120578.22k  1121277.27k  1119879.17k  1115684.86k\\n', '使用的KEA引擎测试AES算法CBC模式异步性能。\\n', '\\n', 'linux-rmw4:/usr/local/bin # ./openssl speed -elapsed -evp aes-128-cbc -async_jobs 4 -engine kae\\n', 'engine \"kae\" set.\\n', 'You have chosen to measure elapsed time instead of user CPU time.\\n', \"Doing aes-128-cbc for 3s on 51200 size blocks: 219553 aes-128-cbc's in 3.00s\\n\", \"Doing aes-128-cbc for 3s on 102400 size blocks: 117093 aes-128-cbc's in 3.00s\\n\", '....\\n', 'type          51200 bytes 102400 bytes1048576 bytes2097152 bytes4194304 bytes8388608 bytes\\n', 'aes-128-cbc    3747037.87k  3996774.40k  1189085.18k  1196774.74k  1196979.11k  1199570.94k\\n', ' 说明：\\n', '\\n', 'AES仅支持数据长度为256KB及以下场景的异步使用。\\n', '使用KAE加速后AES算法在输入数据块为100K大小时，从1123328.00k/s提升到3996774.40 k/s 。\\n', '升级加速器软件包\\n', '使用场景\\n', '当需要更新加速器软件版本时可以使用rpm -Uvh方式进行升级。\\n', '\\n', '操作步骤\\n', '从openEuler社区下载最新版本的加速引擎软件包。\\n', '\\n', '使用SSH远程登录工具，以root帐号进入Linux操作系统命令行界面。\\n', '\\n', '将下载下来的最新版本的软件包都放在某个路径下。\\n', '\\n', '在存放软件包的路径下使用rpm -Uvh 命令升级加速器驱动包及引擎库包。示例如下。\\n', '\\n', '命令和信息回显如下所示。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '使用rpm -qa 命令查询是否升级成功。确认查询到的版本是最新的升级后版本。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '重启系统或通过命令行手动卸载旧版本驱动，然后加载新版本驱动，并查看是否加载成功\\n', '\\n', '卸载旧驱动\\n', '# lsmod | grep uacce \\n', 'uacce                 262144  3 hisi_hpre,hisi_sec2,hisi_qm \\n', '# \\n', '# rmmod hisi_hpre \\n', '# rmmod hisi_sec2 \\n', '# rmmod hisi_qm \\n', '# rmmod uacce \\n', '# lsmod | grep uacce \\n', '# \\n', '加载新驱动# modprobe uacce \\n', '# modprobe hisi_qm# modprobe hisi_sec2 #加载hisi_sec2驱动时将根据/etc/modprobe.d/hisi_sec2.conf 下的配置文件加载到内核\\n', '# modprobe hisi_hpre  #加载hisi_hpre驱动时将根据/etc/modprobe.d/hisi_hpre.conf 下的配置文件加载到内核\\n', '# lsmod | grep uacce \\n', 'uacce                36864  3 hisi_sec2,hisi_qm,hisi_hpre\\n', '卸载加速器软件包\\n', '使用场景\\n', '用户不再使用加速引擎软件，或进行新版本加速引擎软件的安装。\\n', '\\n', '操作步骤\\n', '使用SSH远程登录工具，以root帐号进入Linux操作系统命令行界面。\\n', '\\n', '重启系统或通过命令行手动将已加载到内核的驱动卸载掉，并查看是否卸载成功。\\n', '\\n', '# lsmod | grep uacce \\n', 'uacce                36864  3 hisi_sec2,hisi_qm,hisi_hpre \\n', '# rmmod hisi_hpre \\n', '# rmmod hisi_sec2  \\n', '# rmmod hisi_qm \\n', '# rmmod uacce \\n', '# lsmod | grep uacce \\n', '#\\n', '通过rpm -e 命令卸载加速引擎软件包。示例如下。\\n', '\\n', ' 说明：\\n', '由于存在依赖关系，卸载libwd前须先卸载libkae引擎软件包。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '使用rpm -qa |grep 软件包名命令查询是否卸载成功。\\n', '\\n', '\\n', '\\n', '日志查询\\n', '加速器引擎涉及日志信息如表3所示。\\n', '\\n', '表 3 日志信息\\n', '\\n', '\\n', '目录\\n', '\\n', '文件名\\n', '\\n', '文件内容说明\\n', '\\n', '/var/log/\\n', '\\n', 'kae.log\\n', '\\n', 'OpenSSL引擎日志默认打印等级为error级别，如需要设置日志级别按照如下操作：\\n', '\\n', 'export KAE_CONF_ENV=/var/log/\\n', '在/var/log/下创建文件kae.cnf\\n', '在kae.cnf 文件中设置如下：\\n', '[LogSection]\\n', '\\n', 'debug_level=error #取值内容none/error/info/warning/debug\\n', '\\n', '说明：\\n', '正常情况下不建议开启info或debug级别日志，否则会导致加速器性能的下降。\\n', '\\n', '/var/log/\\n', '\\n', 'message/syslog\\n', '\\n', '内核日志路径为/var/log/message。\\n', '说明：\\n', '或通过dmesg > /var/log/dmesg.log日志收集内核相关日志，包含驱动及内核态日志。\\n', '\\n', '加速引擎的应用\\n', ' 说明：\\n', '如果用户未购买引擎许可证，建议用户不要通过kae引擎调用相应算法，否则可能会影响openssl加密算法的性能。\\n', '\\n', 'KAE引擎使用示例代码\\n', '#include <stdio.h> \\n', '\\n', '#include <stdlib.h> \\n', '\\n', '/* OpenSSL headers */ \\n', '\\n', '#include <openssl/bio.h> \\n', '\\n', '#include <openssl/ssl.h> \\n', '\\n', '#include <openssl/err.h> \\n', '\\n', '#include <openssl/engine.h> \\n', '\\n', 'int main(int argc, char **argv) \\n', '\\n', '{ \\n', '\\n', '    /* Initializing OpenSSL */ \\n', '\\n', '    SSL_load_error_strings(); \\n', '\\n', '    ERR_load_BIO_strings(); \\n', '\\n', '    OpenSSL_add_all_algorithms(); \\n', '\\n', '    /*You can use ENGINE_by_id Function to get the handle of the Huawei Accelerator Engine*/ \\n', '\\n', '    ENGINE *e = ENGINE_by_id(\"kae\"); \\n', '\\n', '    /*使能加速器异步功能，可选配置，设置为“0”表示不使能，设置为“1”表示使能，默认使能异步功能*/ \\n', '\\n', '    ENGINE_ctrl_cmd_string(e, \"KAE_CMD_ENABLE_ASYNC\", \"1\", 0) \\n', '\\n', '    ENGINE_init(e); \\n', '\\n', '\\n', '    RSA *rsa = RSA_new_method(e);#指定引擎用于RSA加解密 \\n', '\\n', '    /*The user code*/ \\n', '\\n', '    …… \\n', '\\n', '; \\n', '\\n', '    ENGINE_free(e); \\n', '\\n', '; \\n', '\\n', '}\\n', '通过OpenSSL配置文件openssl.cnf使用KAE引擎\\n', '新建openssl.cnf 需要添加如下配置信息\\n', '\\n', 'openssl_conf=openssl_def \\n', '[openssl_def] \\n', 'engines=engine_section \\n', '[engine_section] \\n', 'kae=kae_section \\n', '[kae_section] \\n', 'engine_id=kae \\n', 'dynamic_path=/usr/local/lib/engines-1.1/kae.so \\n', 'KAE_CMD_ENABLE_ASYNC=1    # 0，表示不使能异步功能，1表示使能异步功能，默认使能 \\n', 'default_algorithms=ALL \\n', 'init=1\\n', '导出OPENSSL_CONF环境变量：\\n', '\\n', 'export OPENSSL_CONF=/home/app/openssl.cnf  #该路径为openssl.cnf存放路径\\n', '使用OpenSSL配置文件示例如下：\\n', '\\n', '#include <stdio.h>  \\n', '\\n', '#include <stdlib.h>  \\n', '\\n', '/* OpenSSL headers */  \\n', '\\n', '#include <openssl/bio.h>  \\n', '\\n', '#include <openssl/ssl.h>  \\n', '\\n', '#include <openssl/err.h>  \\n', '\\n', '#include <openssl/engine.h>  \\n', '\\n', 'int main(int argc, char **argv)  \\n', '\\n', '{  \\n', '\\n', '    /* Initializing OpenSSL */  \\n', '\\n', '    SSL_load_error_strings();  \\n', '\\n', '    ERR_load_BIO_strings();  \\n', '\\n', '#Load openssl configure \\n', '\\n', 'OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);    OpenSSL_add_all_algorithms();  \\n', '\\n', '    /*You can use ENGINE_by_id Function to get the handle of the Huawei Accelerator Engine*/  \\n', '\\n', '    ENGINE *e = ENGINE_by_id(\"kae\"); \\n', '\\n', '    /*The user code*/  \\n', '\\n', '    ……  \\n', '\\n', ';  \\n', '\\n', '    ENGINE_free(e);  \\n', '\\n', ';\\n', '}\\n', '故障处理\\n', '初始化失败\\n', '故障现象\\n', '加速器引擎没有完全加载成功。\\n', '\\n', '处理步骤\\n', '检查加速器驱动是否加载成功，运行lsmod 命令查看uacce.ko、qm.ko 、sgl.ko 、hisi_sec2.ko 、hisi_hpre.ko 、hisi_zip.ko、 hisi_rde.ko是否在位。\\n', '\\n', '# lsmod | grep uacce\\n', 'uacce                  262144  2 hisi_hpre,hisi_qm,hisi_sec2,hisi_zip,hisi_rde\\n', '检查/usr/lib64（RPM方式安装时目录）或者/usr/local/lib（源码方式安装时目录）和OpenSSL安装目录是否有加速器引擎库，且建立正确的软连接。\\n', '\\n', ' [root@localhost home]# ll /usr/local/lib/engines-1.1/ |grep kae \\n', '#查询kae是否正确安装并建立软连接，如果有正确安装显示如下内容\\n', '# ll /usr/local/lib/engines-1.1/ |grep kae\\n', 'lrwxrwxrwx. 1 root root     22 Nov 12 02:33 kae.so -> kae.so.1.0.1\\n', 'lrwxrwxrwx. 1 root root     22 Nov 12 02:33 kae.so.0 -> kae.so.1.0.1\\n', '-rwxr-xr-x. 1 root root 112632 May 25  2019 kae.so.1.0.1\\n', '[[root@localhost home]#\\n', ' [root@localhost home]# ll /usr/lib64/ | grep libwd  \\n', ' #查询libwd是否正确安装并建立软连接，如果有正确安装显示如下内容\\n', 'lrwxrwxrwx.  1 root root       14 Nov 12 02:33 libwd.so -> libwd.so.1.0.1\\n', 'lrwxrwxrwx.  1 root root       14 Nov 12 02:33 libwd.so.0 -> libwd.so.1.0.1\\n', '-rwxr-xr-x.  1 root root   137120 May 25  2019 libwd.so.1.0.1\\n', '[root@localhost home]#\\n', '检查OpenSSL引擎库的路径是否能通过export命令进行导出。\\n', '\\n', '# echo $OPENSSL_ENGINES \\n', '# export OPENSSL_ENGINES=/usr/local/lib/engines-1.1\\n', '#  echo $OPENSSL_ENGINES\\n', '/usr/local/lib/engines-1.1\\n', '安装完加速器引擎之后，查找不到加速器设备\\n', '故障现象\\n', '安装完加速器引擎之后，查找不到加速器设备。\\n', '\\n', '解决方法\\n', '检查虚拟文件系统下是否有相应设备。正常情况下有如下相应的加速器设备。\\n', '\\n', '# ls -al /sys/class/uacce/\\n', 'total 0\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 03:45 hisi_hpre-2 -> ../../devices/pci0000:78/0000:78:00.0/0000:79:00.0/uacce/hisi_hpre-2\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 03:45 hisi_hpre-3 -> ../../devices/pci0000:b8/0000:b8:00.0/0000:b9:00.0/uacce/hisi_hpre-3\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_rde-4 -> ../../devices/pci0000:78/0000:78:01.0/uacce/hisi_rde-4\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_rde-5 -> ../../devices/pci0000:b8/0000:b8:01.0/uacce/hisi_rde-5\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 08:39 hisi_sec-0 -> ../../devices/pci0000:74/0000:74:01.0/0000:76:00.0/uacce/hisi_sec-0\\n', 'lrwxrwxrwx. 1 root root 0 Nov 14 08:39 hisi_sec-1 -> ../../devices/pci0000:b4/0000:b4:01.0/0000:b6:00.0/uacce/hisi_sec-1\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_zip-6 -> ../../devices/pci0000:74/0000:74:00.0/0000:75:00.0/uacce/hisi_zip-6\\n', 'lrwxrwxrwx. 1 root root 0 Nov 17 22:09 hisi_zip-7 -> ../../devices/pci0000:b4/0000:b4:00.0/0000:b5:00.0/uacce/hisi_zip-7\\n', '若要使用hpre设备但是在1中未查询到，请按初始化失败排查加速器软件是否已正确安装。\\n', '\\n', '若2已确认加速器软件正确安装，请排查通过lspci命令查看物理设备是否存在。\\n', '\\n', '# lspci | grep HPRE\\n', '79:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon HPRE Engine (rev 21)\\n', 'b9:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon HPRE Engine (rev 21)\\n', '## lspci | grep SEC\\n', '76:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon SEC Engine (rev 21)\\n', 'b6:00.0 Network and computing encryption device: Huawei Technologies Co., Ltd. HiSilicon SEC Engine (rev 21)\\n', '## lspci | grep RDE\\n', '78:01.0 RAID bus controller: Huawei Technologies Co., Ltd. HiSilicon RDE Engine (rev 21)\\n', 'b8:01.0 RAID bus controller: Huawei Technologies Co., Ltd. HiSilicon RDE Engine (rev 21)\\n', '## lspci | grep ZIP\\n', '75:00.0 Processing accelerators: Huawei Technologies Co., Ltd. HiSilicon ZIP Engine (rev 21)\\n', 'b5:00.0 Processing accelerators: Huawei Technologies Co., Ltd. HiSilicon ZIP Engine (rev 21)\\n', '#\\n', '若3未查询到相应的物理设备，请确认以下，不分先后：\\n', '\\n', '确认是否已导入加速器许可证，若未导入，请请参考《TaiShan 机架服务器 iBMC (V500及以上) 用户指南》中“许可证管理”章节，导入加速器许可证。导入加速器许可证之后，需要掉电重启BMC，使能License。\\n', '确认BMC和BIOS版本是否支持加速器特性。\\n', '升级加速器驱动失败\\n', '故障现象\\n', '升级加速器驱动后，重启系统驱动版本仍为旧版本。\\n', '\\n', '可能原因\\n', '在升级加速器驱动前，系统更新了其他驱动包，这些驱动包可能重新更新了引导文件系统initramfs，将未升级前的加速器驱动一起更新到了initramfs文件系统中。例如系统更新了网卡驱动，或者人为更新了initramfs文件系统，导致系统重启时优先从initramfs文件系统中加载加速器驱动。\\n', '\\n', '处理步骤\\n', '升级加速器驱动版本后，通过执行dracut --force命令重新更新initramfs文件系统。']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_对接iSula安全容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%AF%B9%E6%8E%A5iSula%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8.html", "text_entry": "['对接iSula安全容器\\n', '概述\\n', '为了给容器提供更好的隔离环境，提高系统安全性，可以使用 iSula 安全容器，即将 StratoVirt 对接 iSula 安全容器。\\n', '\\n', '对接iSula安全容器\\n', '前提条件\\n', '已安装 iSulad 和 kata-containers，并确保 iSulad 支持 containerd-kata-shim-v2 容器运行时和 devicemapper 存储驱动。\\n', '\\n', '此处给出安装 iSulad 和 kata-containers 并进行相应配置的参考方法。\\n', '\\n', '配置 yum 源，使用 root 权限安装 iSulad 和 kata-containers ：\\n', '\\n', '# yum install iSulad\\n', '# yum install kata-containers\\n', '制作并配置存储 Storage：\\n', '\\n', '需要用户规划好磁盘如/dev/sdxx,该磁盘会被格式化。\\n', '\\n', ' # pvcreate /dev/sdxx\\n', ' # vgcreate isulaVG0 /dev/sdxx\\n', ' # lvcreate --wipesignatures y -n thinpool isulaVG0 -l 95%VG\\n', ' # lvcreate --wipesignatures y -n thinpoolmeta isulaVG0 -l 1%VG\\n', ' # lvconvert -y --zero n -c 512K --thinpool isulaVG0/thinpool --poolmetadata isulaVG0/thinpoolmeta\\n', '在配置文件 /etc/lvm/profile/isulaVG0-thinpool.profile 中添加如下：\\n', '\\n', 'activation {\\n', '    thin_pool_autoextend_threshold=80\\n', '    thin_pool_autoextend_percent=20\\n', '}\\n', '更改配置文件/etc/isulad/daemon.json中的storage-driver 和 storage-opts 如下：将默认存储驱动类型 overlay 配置成 devicemapper 。\\n', '\\n', '\"storage-driver\": \"devicemapper\",\\n', '\"storage-opts\": [\\n', ' \"dm.thinpooldev=/dev/mapper/isulaVG0-thinpool\",\\n', ' \"dm.fs=ext4\",\\n', ' \"dm.min_free_space=10%\"\\n', '],\\n', '重启 isulad ：\\n', '\\n', ' # systemctl daemon-reload\\n', ' # systemctl restart isulad\\n', '确认 iSula 存储驱动是否配置成功：\\n', '\\n', ' # isula info\\n', '若回显有如下信息，说明配置成功。\\n', '\\n', 'Storage Driver: devicemapper\\n', '对接指导\\n', 'StratoVirt 通过对接 kata-containers来接入 isula 容器生态，此处给出对接 kata-containers 的操作指导。\\n', '\\n', '对接轻量虚拟机\\n', '修改 kata 配置文件（默认路径为 /usr/share/defaults/kata-containers/configuration.toml，也可以参考同一目录下的configration-stratovirt.toml进行配置） 。将安全容器的 hypervisor 类型修改为 stratovirt，kernel 修改为 kata-containers 的 kernel 镜像绝对路径，initrd 修改为 kata-containers 的 initrd 镜像文件（使用 yum 安装 kata-containers 时，默认会下载这两个镜像文件并存放在 /var/lib/kata/ 目录，配置时也可以使用其他镜像 ）。\\n', '\\n', '替换的配置内容参考如下：\\n', '\\n', '[hypervisor.stratovirt]\\n', 'path = \"/usr/bin/stratovirt\"\\n', 'kernel = \"/var/lib/kata/kernel\"\\n', 'initrd = \"/var/lib/kata/kata-containers-initrd.img\"\\n', 'machine_type = \"microvm\"\\n', 'block_device_driver = \"virtio-mmio\"\\n', 'use_vsock = true\\n', 'enable_netmon = true\\n', 'internetworking_model=\"tcfilter\"\\n', 'sandbox_cgroup_with_emulator = false\\n', 'disable_new_netns = false\\n', 'disable_block_device_use = false\\n', 'disable_vhost_net = true\\n', '使用 root 权限和 isula 命令运行 busybox 安全容器，完成 StratoVirt 和 安全容器的对接。\\n', '\\n', '# isula run -tid --runtime \"io.containerd.kata.v2\" --net=none --name test busybox:latest sh\\n', '使用 isula ps 确认安全容器 test 正常运行，然后通过以下命令进入 test 容器。\\n', '\\n', '# isula exec -ti test sh\\n', '通过虚拟机快照加速安全容器的启动速度，降低虚拟机内存开销。\\n', '\\n', '修改 kata 配置文件 configuration.toml，将配置项 enable_template 设置为 true，即允许虚拟机通过制作快照方式进行启动：\\n', '\\n', '[factory]\\n', '# VM templating support. Once enabled, new VMs are created from template\\n', '# using vm cloning. They will share the same initial kernel, initramfs and\\n', '# agent memory by mapping it readonly. It helps speeding up new container\\n', '# creation and saves a lot of memory if there are many kata containers running\\n', '# on the same host.\\n', '#\\n', '# When disabled, new VMs are created from scratch.\\n', '#\\n', '# Note: Requires \"initrd=\" to be set (\"image=\" is not supported).\\n', '#\\n', '# Default false\\n', 'enable_template = true\\n', '配置项 enable_template 设置为 true 后，kata-containers 创建安全容器时，将会检查默认路径（/run/vc/vm/template）下是否存在快照文件，如果存在，直接以该快照文件启动虚拟机，如果不存在，则会创建虚拟机快照，创建完成后，以该快照文件启动虚拟机。\\n', '\\n', '通过安全组件 ozone 进一步增强安全容器的隔离性。\\n', '\\n', '修改 kata 配置文件 configuration.toml，将配置项 ozone_path 设置为 ozone 可执行文件的路径（如果使用 yum 安装 stratovirt，ozone 可执行文件默认在 /usr/bin 目录下）。配置该项后，将打开 ozone 安全沙箱功能，作为虚拟化层隔离被攻击者突破后的保险，进一步增强 StratoVirt 安全容器的隔离性:\\n', '\\n', '# Path for the ozone specific to stratovirt\\n', '# If the ozone path is set, stratovirt will be launched in\\n', '# ozone secure environment. It is disabled by default.\\n', 'ozone_path = \"/usr/bin/ozone\"\\n', '至此，可以在 test 容器内运行容器命令。\\n', '\\n', '对接标准虚拟机\\n', '使用 StratoVirt 标准虚拟机作为安全容器的 sandbox，需要额外修改少量配置。具体步骤如下：\\n', '\\n', '配置参考如下：\\n', '\\n', '[hypervisor.stratovirt]\\n', 'path = \"/usr/bin/stratovirt\"\\n', 'kernel = \"/var/lib/kata/kernel\"\\n', 'initrd = \"/var/lib/kata/kata-containers-initrd.img\"\\n', '# x86_64 架构\\n', 'machine_type = \"q35\"\\n', '# aarch64 架构\\n', 'machine_type = \"virt\"\\n', 'block_device_driver = \"virtio-blk\"\\n', 'pcie_root_port = 2\\n', 'use_vsock = true\\n', 'enable_netmon = true\\n', 'internetworking_model = \"tcfilter\"\\n', 'sandbox_cgroup_with_emulator = false\\n', 'disable_new_netns = false\\n', 'disable_block_device_use = false\\n', 'disable_vhost_net = true\\n', '上述配置中，需要根据主机架构，修改对应的虚拟机机型。需要将 block_device_driver 驱动类型改为 virtio-blk。另外，StratoVirt 只支持将设备热插到root port，根据需要热插的设备数量，合理设置 pcie_root_port 值。\\n', '\\n', '安装启动标准虚拟机需要的固件\\n', '\\n', 'x86_64 架构：\\n', '\\n', '# yum install -y edk2-ovmf\\n', 'aarch64 架构：\\n', '\\n', '# yum install -y edk2-aarch64\\n', '编译替换为 kata-containers 2.x 版本二进制\\n', '\\n', '当前只为 kata-containers 2.x 版本（对应 kata-containers 源码仓的 openEuler-21.09 分支）适配了 StratoVirt 标准虚拟机作为 sandbox。因此，需要手动下载 kata-containers 源码，编译并替换 /usr/bin 目录下的 containerd-shim-kata-v2 二进制文件。\\n', '\\n', '# mkdir -p /root/go/src/github.com/\\n', '# cd /root/go/src/github.com/\\n', '# git clone https://gitee.com/src-openeuler/kata-containers.git\\n', '# cd kata-containers\\n', '# git checkout openEuler-21.09\\n', '# ./apply-patches\\n', '# cd src/runtime\\n', '# make\\n', '编译出的二进制位 containerd-shim-kata-v2，需要将默认 /usr/bin/ 目录的 kata 二进制备份后替换：\\n', '\\n', '# cp /usr/bin/containerd-shim-kata-v2 /usr/bin/containerd-shim-kata-v2.bk\\n', '# cp containerd-shim-kata-v2 /usr/bin/containerd-shim-kata-v2\\n', '使用 root 权限 和 isula 命令运行 busybox 安全容器，完成 StratoVirt 和 安全容器的对接。\\n', '\\n', '# isula run -tid --runtime \"io.containerd.kata.v2\" --net=none --name test busybox:latest sh\\n', '使用 isula ps 确认安全容器 test 正常运行，然后通过以下命令进入 test 容器。\\n', '\\n', '# isula exec -ti test sh\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_管理安全容器的生命周期.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%AE%A1%E7%90%86%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html", "text_entry": "['管理安全容器的生命周期\\n', '管理安全容器的生命周期\\n', '启动安全容器\\n', '停止安全容器\\n', '删除安全容器\\n', '在容器中执行一条新的命令\\n', '启动安全容器\\n', '用户可以使用docker-engine或者iSulad作为安全容器的容器引擎，两者的调用方式类似，请用户自行选择一种方式启动安全容器。\\n', '\\n', '启动安全容器的操作步骤如下：\\n', '\\n', '确保安全容器组件已经正确安装部署。\\n', '\\n', '准备容器镜像。假设容器镜像为busybox，使用docker-engine和iSula容器引擎下载容器镜像的命令分别如下：\\n', '\\n', 'docker pull busybox\\n', 'isula pull busybox\\n', '启动一个安全容器。使用docker-engine和iSula容器引擎启动安全容器的命令分别如下：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none busybox <command>\\n', 'isula run -tid --runtime kata-runtime --network none busybox <command>\\n', ' 说明：\\n', '安全容器网络使用仅支持CNI网络，不支持CNM网络，不支持使用-p和–expose暴露容器端口，使用安全容器时需指定参数–net=none。\\n', '\\n', '启动一个Pod\\n', '\\n', '启动pause容器并根据回显获取pod的sandbox-id。使用docker-engine和iSula容器引擎启动的命令分别如下：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox <pause-image> <command>\\n', 'isula run -tid --runtime kata-runtime --network none --annotation io.kubernetes.cri.container-type=sandbox <pause-image> <command>\\n', '  \\n', '\\n', '创建业务容器并加入到这个pod中。使用docker-engine和iSula容器引擎创建的命令分别如下：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=container --annotation io.kubernetes.sandbox.id=<sandbox-id> busybox <command>\\n', 'isula run -tid --runtime kata-runtime --network none --annotation io.kubernetes.cri.container-type=container --annotation io.kubernetes.cri.sandbox-id=<sandbox-id> busybox <command>\\n', '–annotation用于容器类型的标注，这里的docker-engine和isula提供该字段，上游社区的开源docker引擎则不提供。\\n', '\\n', '停止安全容器\\n', '停止一个安全容器。\\n', '\\n', 'docker stop <contaienr-id>\\n', '停止一个Pod。\\n', '\\n', 'Pod停止需要注意顺序，pause容器与Pod生命周期相同，因此先停止业务容器后再停止pause容器。\\n', '\\n', '删除安全容器\\n', '删除前请确保容器已经停止：\\n', '\\n', 'docker rm <container-id>\\n', '如果需要强制删除一个正在运行的容器，可以使用**-f**强制删除：\\n', '\\n', 'docker rm -f <container-id>\\n', '在容器中执行一条新的命令\\n', '由于pause容器仅作为占位容器，如果启动一个Pod时，请在业务容器内执行新的命令，pause容器并没有相应的指令；如果只启动一个容器时，则可以直接执行新增命令：\\n', '\\n', 'docker exec -ti <container-id> <command>\\n', ' 说明：\\n', '\\n', '如遇到docker exec -ti进入容器的同时，另一终端执行docker restart或者docker stop命令造成exec界面卡住的情况，可使用Ctrl+P+Q退出docker exec操作界面。\\n', '如果使用-d参数则命令在后台执行，不会打印错误信息，其退出码也不能作为命令执行是否正确的判断依据。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_安全性和隔离性.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E6%80%A7.html", "text_entry": "['安全性和隔离性\\n', '安全性和隔离性\\n', 'user namespace多对多\\n', '用户权限控制\\n', 'proc文件系统隔离（lxcfs）\\n', 'user-namespace多对多\\n', '功能描述\\n', 'user namespace是将容器的root映射到主机的普通用户，使得容器中的进程和用户在容器里有特权，但是在主机上就是普通权限，防止容器中的进程逃逸到主机上，进行非法操作。更进一步，使用user namespace技术后，容器和主机使用不同的uid和gid，保证容器内部的用户资源和主机资源进行隔离，例如文件描述符等。\\n', '\\n', '系统容器支持通过–user-remap接口参数将不同容器的user namespace映射到宿主机不同的user namespace，实现容器user namespace隔离。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--user-remap\\n', '\\n', '参数格式为<uid>:<gid>:<offset>，参数说明如下：\\n', '\\n', 'uid、gid为整数型，且必须大于等于0。\\n', 'offset为整数型，且必须大于0，并且小于65536。取值不能太小，否则容器无法启动。\\n', 'uid加上offset的值必须小于等于232-1，gid加上offset的值必须小于等于232-1，否则容器启动会报错。\\n', '约束限制\\n', '如果系统容器指定了–user-remap，那么rootfs目录必须能够被–user-remap指定的uid/gid用户所访问，否则会导致容器user namespace无法访问rootfs，容器启动失败。\\n', '容器内所有的id都应该能映射到主机rootfs，某些目录/文件可能是从主机mount到容器，比如/dev/pts目录下面的设备文件，如果offset值太小可能会导致mount失败。\\n', 'uid、gid和offset的值由上层调度平台控制，容器引擎只做合法性检查。\\n', '–user-remap只适用于系统容器。\\n', '–user-remap和–privileged不能共存，否则容器启动会报错。\\n', '如果uid或gid指定为0，则–user-remap参数不生效。\\n', '使用指导\\n', ' 说明：\\n', '指定–user-remap参数前，请先将rootfs下所有目录和文件的uid和gid做整体偏移，偏移量为–user-remap指定uid和gid的偏移量。\\n', '例如将dev目录的uid和gid整体uid和gid偏移100000的参考命令为：\\n', 'chown 100000:100000 dev\\n', '\\n', '系统容器启动指定–user-remap参数：\\n', '\\n', '[root@localhost ~]# isula run -tid --user-remap 100000:100000:65535 --system-container --external-rootfs /home/root-fs none /sbin/init\\n', 'eb9605b3b56dfae9e0b696a729d5e1805af900af6ce24428fde63f3b0a443f4a\\n', '分别在宿主机和容器内查看/sbin/init进程信息：\\n', '\\n', '[root@localhost ~]# isula exec eb ps aux | grep /sbin/init\\n', 'root         1  0.6  0.0  21624  9624 ?        Ss   15:47   0:00 /sbin/init\\n', '[root@localhost ~]# ps aux | grep /sbin/init\\n', '100000    4861  0.5  0.0  21624  9624 ?        Ss   15:47   0:00 /sbin/init\\n', 'root      4948  0.0  0.0 213032   808 pts/0    S+   15:48   0:00 grep --color=auto /sbin/init\\n', '可以看到/sbin/init进程在容器内的owner是root用户，但是在宿主机的owner是uid=100000这个用户。\\n', '\\n', '在容器内创建一个文件，然后在宿主机上查看文件的owner：\\n', '\\n', '[root@localhost ~]# isula exec -it eb bash\\n', '[root@localhost /]# echo test123 >> /test123\\n', '[root@localhost /]# exit\\n', 'exit\\n', '[root@localhost ~]# ll /home/root-fs/test123\\n', '-rw-------. 1 100000 100000 8 Aug  2 15:52 /home/root-fs/test123\\n', '可以看到，在容器内生成了一个文件，它的owner是root，但是在宿主机上看到的owner是id=100000这个用户。\\n', '\\n', '用户权限控制\\n', '功能描述\\n', '容器引擎支持通过TLS认证方式来认证用户的身份，并依此控制用户的权限，当前容器引擎可以对接authz插件实现权限控制。\\n', '\\n', '接口说明\\n', '通过配置iSulad容器引擎启动参数来指定权限控制插件，daemon配置文件默认为/etc/isulad/daemon.json。\\n', '\\n', '\\n', '配置参数\\n', '\\n', '示例\\n', '\\n', '说明\\n', '\\n', '--authorization-plugin\\n', '\\n', '\"authorization-plugin\": \"authz-broker\"\\n', '\\n', '用户权限认证插件，当前只支持authz-broker。\\n', '\\n', '约束限制\\n', 'authz需要配置用户权限策略，策略文件默认为/var/lib/authz-broker/policy.json，该配置文件支持动态修改，修改完即时生效，不需要重启插件服务。\\n', '由于容器引擎为root用户启动，放开一般用户使用的一些命令可能会导致该用户不当获得过大权限，需谨慎配置。目前container_attach、container_create和container_exec_create动作可能会有风险。\\n', '对于某些复合操作，比如isula exec、isula attach等命令依赖isula inspect是否有权限，如果用户没有inspect权限会直接报错。\\n', '采用SSL/TLS 加密通道在增加安全性的同时也会带来性能损耗，如增加延时，消耗较多的CPU资源，除了数据传输外，加解密需要更大吞吐量，因此在并发场景下，相比非TLS通信，其并发量有一定程度上的下降。经实测，在ARM服务器（Cortex-A72 64核）接近空载情况下，采用TLS并发起容器，其最大并发量在200~250范围内。\\n', '服务端指定–tlsverify时，认证文件默认配置路径为/etc/isulad。且默认文件名分别为ca.pem、cert.pem、key.pem。\\n', '使用示例\\n', '确认宿主机安装了authz插件，如果需要安装，安装并启动authz插件服务命令如下：\\n', '\\n', '[root@localhost ~]# yum install authz\\n', '[root@localhost ~]# systemctl start authz\\n', '要启动该功能，首先需要配置容器引擎和用户的TLS证书。可以使用OPENSSL来生成需要的证书，具体步骤如下：\\n', '\\n', '#SERVERSIDE\\n', '\\n', '# Generate CA key\\n', 'openssl genrsa -aes256 -passout \"pass:$PASSWORD\" -out \"ca-key.pem\" 4096\\n', '# Generate CA\\n', 'openssl req -new -x509 -days $VALIDITY -key \"ca-key.pem\" -sha256 -out \"ca.pem\" -passin \"pass:$PASSWORD\" -subj \"/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$COMMON_NAME/emailAddress=$EMAIL\"\\n', '# Generate Server key\\n', 'openssl genrsa -out \"server-key.pem\" 4096\\n', '\\n', '# Generate Server Certs.\\n', 'openssl req -subj \"/CN=$COMMON_NAME\" -sha256 -new -key \"server-key.pem\" -out server.csr\\n', '\\n', 'echo \"subjectAltName = DNS:localhost,IP:127.0.0.1\" > extfile.cnf\\n', 'echo \"extendedKeyUsage = serverAuth\" >> extfile.cnf\\n', '\\n', 'openssl x509 -req -days $VALIDITY -sha256 -in server.csr -passin \"pass:$PASSWORD\" -CA \"ca.pem\" -CAkey \"ca-key.pem\" -CAcreateserial -out \"server-cert.pem\" -extfile extfile.cnf\\n', '\\n', '#CLIENTSIDE\\n', '\\n', 'openssl genrsa -out \"key.pem\" 4096\\n', 'openssl req -subj \"/CN=$CLIENT_NAME\" -new -key \"key.pem\" -out client.csr\\n', 'echo \"extendedKeyUsage = clientAuth\" > extfile.cnf\\n', 'openssl x509 -req -days $VALIDITY -sha256 -in client.csr -passin \"pass:$PASSWORD\" -CA \"ca.pem\" -CAkey \"ca-key.pem\" -CAcreateserial -out \"cert.pem\" -extfile extfile.cnf\\n', \"若要直接使用以上过程作为脚本，需替换各变量为配置数值。生成CA时使用的参数若为空则写为“''”。PASSWORD、COMMON_NAME、CLIENT_NAME、VALIDITY为必选项。\\n\", '\\n', '容器引擎启动时添加TLS相关参数和认证插件相关参数，并保证认证插件的运行。此外，为了使用TLS认证，容器引擎必须使用TCP侦听的方式启动，不能使用传统的unix socket的方式启动。容器demon端配置如下：\\n', '\\n', '{\\n', '    \"tls\": true,\\n', '    \"tls-verify\": true,\\n', '    \"tls-config\": {\\n', '           \"CAFile\": \"/root/.iSulad/ca.pem\",\\n', '           \"CertFile\": \"/root/.iSulad/server-cert.pem\",\\n', '           \"KeyFile\":\"/root/.iSulad/server-key.pem\"\\n', '    },\\n', '    \"authorization-plugin\": \"authz-broker\"\\n', '}\\n', '然后需要配置策略，对于基本授权流程，所有策略都位于一个配置文件下/var/lib/authz-broker/policy.json。该配置文件支持动态修改，更改时不需要重新启动插件，只需要向authz进程发送SIGHUP信号。文件格式是每行一个策略JSON对象。每行只有一个匹配。具体的策略配置示例如下：\\n', '\\n', '所有用户都可以运行所有iSulad命令：{“name”:“policy_0”,“users”:[\"\"],“actions”:[\"\"]}。\\n', 'Alice可以运行所有iSulad命令：{“name”:“policy_1”,“users”:[“alice”],“actions”:[\"\"]}。\\n', '空用户都可以运行所有iSulad命令： {“name”:“policy_2”,“users”:[\"\"],“actions”:[\"\"]}。\\n', 'Alice和Bob可以创建新的容器：{“name”:“policy_3”,“users”:[“alice”,“bob”],“actions”:[“container_create”]}。\\n', 'service_account可以读取日志并运行docker top：{“name”:“policy_4”,“users”:[“service_account”],“actions”:[“container_logs”,“container_top”]}。\\n', 'Alice可以执行任何container操作：{“name”:“policy_5”,“users”:[“alice”],“actions”:[“container”]}。\\n', 'Alice可以执行任何container操作，但请求的种类只能是get：{“name”:“policy_5”,“users”:[“alice”],“actions”:[“container”], “readonly”:true }。\\n', ' 说明：\\n', '\\n', '配置中匹配action支持正则表达式。\\n', 'users不支持正则表达式。\\n', 'users不能有重复用户，即同一用户不能被多条规则匹配。\\n', '配置并更新完之后，客户端配置TLS参数连接容器引擎，即是以受限的权限访问。\\n', '\\n', '[root@localhost ~]#  isula version --tlsverify --tlscacert=/root/.iSulad/ca.pem --tlscert=/root/.iSulad/cert.pem --tlskey=/root/.iSulad/key.pem  -H=tcp://127.0.0.1:2375\\n', '如果想默认配置TLS认证进行客户端连接，可以将文件移动到~/.iSulad，并设置 ISULAD_HOST和ISULAD_TLS_VERIFY变量（而不是每次调用时传递 -H=tcp://$HOST:2375和–tlsverify）。\\n', '\\n', '[root@localhost ~]# mkdir -pv ~/.iSulad\\n', '[root@localhost ~]# cp -v {ca,cert,key}.pem ~/.iSulad \\n', '[root@localhost ~]# export ISULAD_HOST=localhost:2375 ISULAD_TLS_VERIFY=1\\n', '[root@localhost ~]# isula version\\n', 'proc文件系统隔离（lxcfs）\\n', '场景描述\\n', '容器虚拟化带来轻量高效，快速部署的同时，也因其隔离性不够彻底，给用户带来一定程度的使用不便。由于Linux内核namespace本身还不够完善，因此容器在隔离性方面也存在一些缺陷。例如，在容器内部proc文件系统中可以看到宿主机上的proc信息（如meminfo, cpuinfo，stat， uptime等）。利用lxcfs工具可以将容器内的看到宿主机/proc文件系统的内容，替换成本容器实例的相关/proc内容，以便容器内业务获取正确的资源数值。\\n', '\\n', '接口说明\\n', '系统容器对外提供两个工具包：一个是lxcfs软件，另外一个是配合lxcfs一起使用的lxcfs-tools工具。其中lxcfs作为宿主机daemon进程常驻，lxcfs-tools通过hook机制将宿主机的lxcfs文件系统绑定挂载到容器。\\n', '\\n', 'lxcfs-tools命令行格式如下：\\n', '\\n', 'lxcfs-tools [OPTIONS] COMMAND [COMMAND_OPTIONS]\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '参数\\n', '\\n', 'remount\\n', '\\n', '将lxcfs重新mount到容器中\\n', '\\n', '--all：对所有的容器执行remout lxcfs操作\\n', '\\n', '--container-id：remount lxcfs到特定的容器ID\\n', '\\n', 'umount\\n', '\\n', '将lxcfs从容器中umount掉\\n', '\\n', '--all：对所有的容器执行umout lxcfs操作\\n', '\\n', '--container-id：对特定容器执行umount lxcfs操作\\n', '\\n', 'check-lxcfs\\n', '\\n', '检查lxcfs服务是否运行\\n', '\\n', '无\\n', '\\n', 'prestart\\n', '\\n', '在lxcfs服务启动前将/var/lib/lxcfs目录mount到容器中\\n', '\\n', '无\\n', '\\n', '约束限制\\n', '当前只支持proc文件系统下的cpuinfo, meminfo, stat, diskstats, partitions，swaps和uptime文件，其他的文件和其他内核API文件系统（比如sysfs）未做隔离 。\\n', '安装rpm包后会在/var/lib/isulad/hooks/hookspec.json生成样例json文件，用户如果需要增加日志功能，需要在定制时加入–log配置。\\n', 'diskstats只能显示支持cfq调度的磁盘信息，无法显示分区信息。容器内设备会被显示为/dev目录下的名字。若不存在则为空。此外，容器根目录所在设备会被显示为sda。\\n', '挂载lxcfs时必须使用slave参数。若使用shared参数，可能会导致容器内挂载点泄露到主机，影响主机运行 。\\n', 'lxcfs支持服务优雅降级使用，若lxcfs服务crash或者不可用，容器内查看到的cpuinfo, meminfo, stat, diskstats, partitions, swaps和uptime均为host信息，容器其它业务功能不受影响。\\n', 'lxcfs底层依赖fuse内核模块以及libfuse库，因此需要内核支持fuse。\\n', 'lxcfs当前仅支持容器内运行64位的app，如果容器内运行32位的app可能会导致app读取到的cpuinfo信息不符合预期。\\n', 'lxcfs只是对容器cgroup进行资源视图模拟，对于容器内的系统调用（例如sysconf）获取到的仍然是主机的信息，lxcfs无法做到内核隔离。\\n', 'lxcfs使用隔离后的cpuinfo显示的cpu信息具有如下特征：\\n', 'processor：从0开始依次递增。\\n', 'physical id：从0开始依次递增。\\n', 'sibliing：固定为1。\\n', 'core id：固定为0。\\n', 'cpu cores：固定为1。\\n', '使用示例\\n', '首先需要安装lxcfs和lxcfs-tools这两个包，并启动lxcfs服务。\\n', '\\n', '[root@localhost ~]# yum install lxcfs lxcfs-tools \\n', '[root@localhost ~]# systemctl start lxcfs\\n', '容器启动完成之后查看容器内是否存在lxcfs挂载点。\\n', '\\n', '[root@localhost ~]# isula run -tid -v /var/lib/lxc:/var/lib/lxc --hook-spec /var/lib/isulad/hooks/hookspec.json --system-container --external-rootfs /home/root-fs none init\\n', 'a8acea9fea1337d9fd8270f41c1a3de5bceb77966e03751346576716eefa9782\\n', '[root@localhost ~]# isula exec a8 mount | grep lxcfs\\n', 'lxcfs on /var/lib/lxc/lxcfs type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/cpuinfo type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/diskstats type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/meminfo type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/partitions type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/stat type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/swaps type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', 'lxcfs on /proc/uptime type fuse.lxcfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other)\\n', '执行update命令更新容器的cpu和mem资源配置，然后查看容器资源。根据如下回显可知，容器资源视图显示的是容器真实资源数据而不是宿主机的数据。\\n', '\\n', '[root@localhost ~]# isula update --cpuset-cpus 0-1 --memory 1G a8\\n', 'a8\\n', '[root@localhost ~]# isula exec a8 cat /proc/cpuinfo\\n', 'processor       : 0\\n', 'BogoMIPS        : 100.00\\n', 'cpu MHz         : 2400.000\\n', 'Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid\\n', 'CPU implementer : 0x41\\n', 'CPU architecture: 8\\n', 'CPU variant     : 0x0\\n', 'CPU part        : 0xd08\\n', 'CPU revision    : 2\\n', '\\n', 'processor       : 1\\n', 'BogoMIPS        : 100.00\\n', 'cpu MHz         : 2400.000\\n', 'Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid\\n', 'CPU implementer : 0x41\\n', 'CPU architecture: 8\\n', 'CPU variant     : 0x0\\n', 'CPU part        : 0xd08\\n', 'CPU revision    : 2\\n', '\\n', '[root@localhost ~]# isula exec a8 free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           1024          17         997           7           8        1006\\n', 'Swap:          4095           0        4095\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_搭建服务_搭建repo服务器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%90%AD%E5%BB%BArepo%E6%9C%8D%E5%8A%A1%E5%99%A8.html", "text_entry": "['搭建repo服务器\\n', ' 说明：\\n', 'openEuler提供了多种repo源供用户在线使用，各repo源含义可参考系统安装。若用户无法在线获取openEuler repo源，则可使用openEuler提供的ISO发布包创建为本地openEuler repo源。本章节中以openEuler-22.03-LTS-aarch64-dvd.iso发布包为例，请根据实际需要的ISO发布包进行修改。\\n', '\\n', '搭建repo服务器\\n', '概述\\n', '创建/更新本地repo源\\n', '获取ISO发布包\\n', '挂载ISO创建repo源\\n', '创建本地repo源\\n', '更新repo源\\n', '部署远端repo源\\n', 'nginx安装与配置\\n', '启动nginx服务\\n', 'repo源部署\\n', '使用repo源\\n', 'repo配置为yum源（软件源）\\n', 'repo优先级\\n', 'dnf相关命令\\n', '概述\\n', '将openEuler提供的ISO发布包openEuler-22.03-LTS-aarch64-dvd.iso创建为repo源，如下以使用nginx进行repo源部署，提供http服务为例进行说明。\\n', '\\n', '创建/更新本地repo源\\n', '使用mount挂载，将openEuler的ISO发布包openEuler-22.03-LTS-aarch64-dvd.iso创建为repo源，并能够对repo源进行更新。\\n', '\\n', '获取ISO发布包\\n', '请从如下网址获取openEuler的ISO发布包：\\n', '\\n', 'https://repo.openeuler.org/openEuler-22.03-LTS/ISO/\\n', '\\n', '挂载ISO创建repo源\\n', '在root权限下使用mount命令挂载ISO发布包。\\n', '\\n', '示例如下：\\n', '\\n', '# mount /home/openEuler/openEuler-22.03-LTS-aarch64-dvd.iso /mnt/\\n', '挂载好的mnt目录如下：\\n', '\\n', '.\\n', '│── boot.catalog\\n', '│── docs\\n', '│── EFI\\n', '│── images\\n', '│── Packages\\n', '│── repodata\\n', '│── TRANS.TBL\\n', '└── RPM-GPG-KEY-openEuler\\n', '其中，Packages为rpm包所在的目录，repodata为repo源元数据所在的目录，RPM-GPG-KEY-openEuler为openEuler的签名公钥。\\n', '\\n', '创建本地repo源\\n', '可以拷贝ISO发布包中相关文件至本地目录以创建本地repo源，示例如下：\\n', '\\n', '# mount /home/openEuler/openEuler-22.03-LTS-aarch64-dvd.iso /mnt/\\n', '$ mkdir -p ~/srv/repo/\\n', '$ cp -r /mnt/Packages ~/srv/repo/\\n', '$ cp -r /mnt/repodata ~/srv/repo/\\n', '$ cp -r /mnt/RPM-GPG-KEY-openEuler ~/srv/repo/\\n', '从而本地repo目录如下：\\n', '\\n', '.\\n', '│── Packages\\n', '│── repodata\\n', '└── RPM-GPG-KEY-openEuler\\n', 'Packages为rpm包所在的目录，repodata为repo源元数据所在的目录，RPM-GPG-KEY-openEuler为openEuler的签名公钥。\\n', '\\n', '更新repo源\\n', '更新repo源有两种方式：\\n', '\\n', '通过新版本的ISO更新已有的repo源，与创建repo源的方式相同，即挂载ISO发布包或重新拷贝ISO发布包至本地目录。\\n', '\\n', '在repo源的Packages目录下添加rpm包，然后通过createrepo命令更新repo源\\n', '\\n', '$ createrepo --update --workers=10 ~/srv/repo\\n', '其中，--update表示更新，--workers表示线程数，可自定义。\\n', '\\n', ' 说明：\\n', '若命令打印信息为“createrepo：未找到命令”，则表示未安装createrepo软件，可在root权限下执行dnf install createrepo进行安装。\\n', '\\n', '部署远端repo源\\n', '安装openEuler操作系统，在openEuler上通过nginx部署repo源。\\n', '\\n', 'nginx安装与配置\\n', '请自行下载nginx工具并在root权限下安装nginx。\\n', '\\n', '安装nginx之后，在root权限下配置/etc/nginx/nginx.conf。\\n', '\\n', ' 说明：\\n', '文档中的配置内容仅供参考，请用户根据实际情况（例如安全加固需要）进行配置。\\n', '\\n', 'user  nginx;\\n', 'worker_processes  auto;                          # 建议设置为core-1\\n', 'error_log  /var/log/nginx/error.log  warn;       # log存放位置\\n', 'pid        /var/run/nginx.pid;\\n', '\\n', 'events {\\n', '    worker_connections  1024;\\n', '}\\n', '\\n', 'http {\\n', '    include       /etc/nginx/mime.types;\\n', '    default_type  application/octet-stream;\\n', '\\n', '    log_format  main  \\'$remote_addr - $remote_user [$time_local] \"$request\" \\'\\n', '                      \\'$status $body_bytes_sent \"$http_referer\" \\'\\n', '                      \\'\"$http_user_agent\" \"$http_x_forwarded_for\"\\';\\n', '\\n', '    access_log  /var/log/nginx/access.log  main;\\n', '    sendfile        on;\\n', '    keepalive_timeout  65;\\n', '\\n', '    server {\\n', '        listen       80;\\n', '        server_name  localhost;                 # 服务器名（url）\\n', '        client_max_body_size 4G;\\n', '        root         /usr/share/nginx/repo;                 # 服务默认目录\\n', '\\n', '        location / {\\n', '            autoindex            on;            # 开启访问目录下层文件\\n', '            autoindex_exact_size on;\\n', '            autoindex_localtime  on; \\n', '        }\\n', '\\n', '    }\\n', '\\n', '}\\n', '启动nginx服务\\n', '在root权限下通过systemd启动nginx服务：\\n', '\\n', '# systemctl enable nginx\\n', '# systemctl start nginx\\n', 'nginx是否启动成功可通过下面命令查看：\\n', '\\n', '$ systemctl status nginx\\n', '图1表示nginx服务启动成功\\n', '\\n', '图 1 nginx服务启动成功\\n', '\\n', '\\n', '若nginx服务启动失败，查看错误信息：\\n', '\\n', '$ systemctl status nginx.service --full\\n', '图 2 nginx服务启动失败\\n', '\\n', '\\n', '如图2所示nginx服务创建失败，是由于目录/var/spool/nginx/tmp/client_body创建失败，在root权限下手动进行创建，类似的问题也这样处理：\\n', '\\n', '# mkdir -p /var/spool/nginx/tmp/client_body\\n', '# mkdir -p /var/spool/nginx/tmp/proxy\\n', '# mkdir -p /var/spool/nginx/tmp/fastcgi\\n', '# mkdir -p /usr/share/nginx/uwsgi_temp\\n', '# mkdir -p /usr/share/nginx/scgi_temp\\n', 'repo源部署\\n', '在root权限下创建nginx配置文件/etc/nginx/nginx.conf中指定的目录/usr/share/nginx/repo：\\n', '\\n', '# mkdir -p /usr/share/nginx/repo\\n', '在root权限下修改目录/usr/share/nginx/repo的权限：\\n', '\\n', '# chmod -R 755 /usr/share/nginx/repo\\n', '设置防火墙规则，开启nginx设置的端口（此处为80端口），在root权限下通过firewall设置端口开启：\\n', '\\n', '# firewall-cmd --add-port=80/tcp --permanent\\n', '# firewall-cmd --reload\\n', '在root权限下查询80端口是否开启成功，输出为yes则表示80端口开启成功：\\n', '\\n', '# firewall-cmd --query-port=80/tcp\\n', '也可在root权限下通过iptables来设置80端口开启：\\n', '\\n', '# iptables -I INPUT -p tcp --dport 80 -j ACCEPT\\n', 'nginx服务设置好之后，即可通过ip直接访问网页，如图3：\\n', '\\n', '图 3 nginx部署成功\\n', '\\n', '\\n', '通过下面几种方式将repo源放入到/usr/share/nginx/repo下：\\n', '\\n', '在root权限下拷贝镜像中相关文件至/usr/share/nginx/repo下，并修改目录权限。\\n', '\\n', '# mount /home/openEuler/openEuler-22.03-LTS-aarch64-dvd.iso  /mnt/\\n', '# cp -r /mnt/Packages /usr/share/nginx/repo\\n', '# cp -r /mnt/repodata /usr/share/nginx/repo\\n', '# cp -r /mnt/RPM-GPG-KEY-openEuler /usr/share/nginx/repo\\n', '# chmod -R 755 /usr/share/nginx/repo\\n', 'openEuler-22.03-LTS-aarch64-dvd.iso存放在/home/openEuler目录下。\\n', '\\n', '使用root在/usr/share/nginx/repo下创建repo源的软链接。\\n', '\\n', '# ln -s /mnt /usr/share/nginx/repo/os\\n', '/mnt为已经创建好的repo源，/usr/share/nginx/repo/os将指向/mnt。\\n', '\\n', '使用repo源\\n', 'repo可配置为yum源，yum（全称为 Yellow dog Updater, Modified）是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载和安装。\\n', '\\n', 'repo配置为yum源（软件源）\\n', '构建好的repo可以配置为yum源使用，在/etc/yum.repos.d/目录下使用root权限创建***.repo的配置文件（必须以.repo为扩展名），分为本地和http服务器配置yum源两种方式：\\n', '\\n', '配置本地yum源\\n', '\\n', '在/etc/yum.repos.d目录下创建openEuler.repo文件，使用构建的本地repo源作为yum源，openEuler.repo的内容如下：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=file:///home/openEuler/srv/repo\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=file:///home/openEuler/srv/repo/RPM-GPG-KEY-openEuler\\n', ' 说明：\\n', '\\n', '[repoid]中的repoid为软件仓库（repository）的ID号，所有.repo配置文件中的各repoid不能重复，必须唯一。示例中repoid设置为base。\\n', 'name为软件仓库描述的字符串。\\n', 'baseurl为软件仓库的地址。\\n', 'enabled为是否启用该软件源仓库，可选值为1和0。默认值为1，表示启用该软件源仓库。\\n', 'gpgcheck可设置为1或0，1表示进行gpg（GNU Private Guard）校验，0表示不进行gpg校验，gpgcheck可以确定rpm包的来源是有效和安全的。\\n', 'gpgkey为验证签名用的公钥。\\n', '配置http服务器yum源\\n', '\\n', '在/etc/yum.repos.d目录下创建openEuler.repo文件。\\n', '\\n', '若使用用户部署的http服务端的repo源作为yum源，openEuler.repo的内容如下：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=http://192.168.139.209/\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=http://192.168.139.209/RPM-GPG-KEY-openEuler\\n', ' 说明：\\n', '“192.168.139.209”为示例地址，请用户根据实际情况进行配置。\\n', '\\n', '若使用openEuler提供的openEuler repo源作为yum源，以AArch64架构的OS repo源为例，openEuler.repo的内容如下：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=http://repo.openeuler.org/openEuler-22.03-LTS/OS/aarch64/\\n', 'enabled=1\\n', 'gpgcheck=1\\n', 'gpgkey=http://repo.openeuler.org/openEuler-22.03-LTS/OS/aarch64/RPM-GPG-KEY-openEuler\\n', 'repo优先级\\n', '当有多个repo源时，可通过在.repo文件的priority参数设置repo的优先级（如果不设置，默认优先级是99，当相同优先级的源中存在相同rpm包时，会安装最新的版本）。其中，1为最高优先级，99为最低优先级，如给openEuler.repo配置优先级为2：\\n', '\\n', '[base]\\n', 'name=base\\n', 'baseurl=http://192.168.139.209/\\n', 'enabled=1\\n', 'priority=2\\n', 'gpgcheck=1\\n', 'gpgkey=http://192.168.139.209/RPM-GPG-KEY-openEuler\\n', 'dnf相关命令\\n', 'dnf命令在安装升级时能够自动解析包的依赖关系，一般的使用方式如下：\\n', '\\n', 'dnf <command> <packages name>\\n', '常用的命令如下：\\n', '\\n', '安装，需要在root权限下执行。\\n', '\\n', '# dnf install <packages name>\\n', '升级，需要在root权限下执行。\\n', '\\n', '# dnf update <packages name>\\n', '回退，需要在root权限下执行。\\n', '\\n', '# dnf downgrade <packages name>\\n', '检查更新\\n', '\\n', '$ dnf check-update\\n', '卸载，需要在root权限下执行。\\n', '\\n', '# dnf remove <packages name>\\n', '查询\\n', '\\n', '$ dnf search <packages name>\\n', '本地安装，需要在root权限下执行。\\n', '\\n', '# dnf localinstall <absolute path to package name>\\n', '查看历史记录\\n', '\\n', '$ dnf history\\n', '清除缓存目录\\n', '\\n', '$ dnf clean all\\n', '更新缓存\\n', '\\n', '$ dnf makecache']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_内核参数.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0.html", "text_entry": "['内核参数\\n', '内核参数\\n', '加固内核参数\\n', '加固内核参数\\n', '说明\\n', '内核参数决定配置和应用特权的状态。内核提供用户可配置的系统控制，这一系统控制可微调或配置，该功能特性可通过控制各种可配置的内核参数，来提高操作系统的安全特性。比如：通过微调或配置网络选项，可有效提高系统的安全性。\\n', '\\n', '实现\\n', '将表3中的加固项写入/etc/sysctl.conf文件中。\\n', '\\n', ' 说明：\\n', '写入方式如下：\\n', '\\n', 'net.ipv4.icmp_echo_ignore_broadcasts = 1  \\n', 'net.ipv4.conf.all.rp_filter = 1  \\n', 'net.ipv4.conf.default.rp_filter = 1  \\n', '表 3 内核参数加固策略说明\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '加固建议\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'net.ipv4.icmp_echo_ignore_broadcasts\\n', '\\n', '是否接受ICMP广播报文。加固策略为不接受。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.rp_filter\\n', '\\n', '验证数据包使用的实际源地址是否与路由表相关，以及使用该特定源IP地址的数据包是否通过接口获取其响应。加固策略为启用该项。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.rp_filter\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.ip_forward\\n', '\\n', 'IP Forwarding可阻止未授权的IP数据包渗透至网络。加固策略为禁用该特性。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.accept_source_route\\n', '\\n', 'accept_source_route指允许数据包的发送者指定数据包的发送路径，以及返回给发送者的数据包所走的路径。加固策略为禁用该特性。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.accept_source_route\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.accept_redirects\\n', '\\n', '是否发送ICMP重定向报文。加固策略为禁止发送。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.accept_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv6.conf.all.accept_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv6.conf.default.accept_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.send_redirects\\n', '\\n', '是否将ICMP重定向报文发送至其他主机。只有当主机作为路由时，应启用该策略。加固策略为禁用该项。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.send_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.icmp_ignore_bogus_error_responses\\n', '\\n', '忽略伪造的ICMP数据包，不会将其记录到日志，将节省大量的硬盘空间。加固策略为启用该项。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'net.ipv4.tcp_syncookies\\n', '\\n', 'SYN Attack是一种通过占用系统资源迫使系统重启的DoS攻击。加固策略为开启TCP-SYN cookie保护。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'kernel.dmesg_restrict\\n', '\\n', '加固dmesg信息，仅允许管理员查看。\\n', '\\n', '1\\n', '\\n', '是\\n', '\\n', 'kernel.sched_autogroup_enabled\\n', '\\n', '该选项决定内核是否对线程进行自动分组调度。开启后调度组之间互相竞争时间片，调度组内的线程再竞争调度组分配到的时间片。加固策略为不启用该项。\\n', '\\n', '0\\n', '\\n', '否\\n', '\\n', 'kernel.sysrq\\n', '\\n', '禁用魔术键。\\n', '\\n', '说明：\\n', '建议禁用魔术键，避免由于直接发送命令到内核对系统造成影响，增强内核安全性。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.all.secure_redirects\\n', '\\n', '设置系统是接收来自任何主机的ICMP重定向消息还是从默认网关列表中的网关处接收ICMP重定向消息。加固策略为采用前者。\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', 'net.ipv4.conf.default.secure_redirects\\n', '\\n', '0\\n', '\\n', '是\\n', '\\n', '加载sysctl.conf文件中设置的内核参数。\\n', '\\n', 'sysctl -p  /etc/sysctl.conf\\n', '其它安全建议\\n', 'net.ipv4.icmp_echo_ignore_all：忽略ICMP请求。\\n', '\\n', '出于安全考虑，建议开启此项（当前默认值为0，开启将值设为1）。\\n', '\\n', '但开启后会忽略所有接收到的icmp echo请求的包(会导致机器无法ping通)，建议用户根据实际组网场景决定是否开启此项。\\n', '\\n', 'net.ipv4.conf.all.log_martians/net.ipv4.conf.default.log_martians：对于仿冒/源路由/重定向数据包开启日志记录。\\n', '\\n', '出于安全考虑，建议开启此项（当前默认值为0，开启将值设为1）。\\n', '\\n', '但是开启后会记录带有不允许的地址的数据到内核日志中，存在冲日志风险，建议用户根据实际使用场景决定是否开启此项。\\n', '\\n', 'net.ipv4.tcp_timestamps：关闭tcp_timestamps。\\n', '\\n', '出于安全考虑，建议关闭tcp_timestamps（当前默认值为1，关闭将值设为0）。\\n', '\\n', '但是关闭此项会影响TCP超时重发的性能，建议用户根据实际使用场景决定是否关闭此项。\\n', '\\n', 'net.ipv4.tcp_max_syn_backlog：决定了SYN_RECV状态队列的数量。\\n', '\\n', '该参数决定了SYN_RECV状态队列的数量，超过这个数量，系统将不再接受新的TCP连接请求，一定程度上可以防止系统资源耗尽。建议由用户根据实际使用场景配置合适的值。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_安装StratoVirt.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%AE%89%E8%A3%85StratoVirt.html", "text_entry": "['安装StratoVirt\\n', '软硬件要求\\n', '最低硬件要求\\n', '处理器架构：仅支持AArch64和x86_64处理器架构。AArch64需要ARMv8及更高版本且支持虚拟化扩展；x86_64支持VT-x。\\n', '\\n', '2核CPU\\n', '\\n', '4GiB内存\\n', '\\n', '16GiB可用磁盘空间\\n', '\\n', '软件要求\\n', '操作系统：openEuler 22.03 LTS\\n', '\\n', '安装组件\\n', '使用StratoVirt虚拟化，需要安装StratoVirt。安装前，请确保已经配置了openEuler yum源。\\n', '\\n', '使用root权限，安装StratoVirt组件，参考命令如下。\\n', '\\n', '# yum install stratovirt\\n', '查看是否安装成功。\\n', '\\n', '$ stratovirt -version\\n', 'StratoVirt 2.1.0\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理用户和用户组.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84.html", "text_entry": "['管理用户\\n', '在Linux中，每个普通用户都有一个账户，包括用户名、密码和主目录等信息。除此之外，还有一些系统本身创建的特殊用户，它们具有特殊的意义，其中最重要的是管理员账户，默认用户名是root。同时Linux也提供了用户组，使每一个用户至少属于一个组，从而便于权限管理。\\n', '\\n', '用户和用户组管理是系统安全管理的重要组成部分，本章主要介绍openEuler提供的用户管理和组管理命令，以及为普通用户分配特权的方法。\\n', '\\n', '管理用户\\n', '管理用户\\n', '增加用户\\n', '修改用户账号\\n', '删除用户\\n', '管理员账户授权\\n', '管理用户组\\n', '增加用户组\\n', '修改用户组\\n', '删除用户组\\n', '将用户加入用户组或从用户组中移除\\n', '切换用户组\\n', '管理用户\\n', '增加用户\\n', 'useradd命令\\n', '在root权限下，通过useradd命令可以为系统添加新用户信息，其中 options 为相关参数， username 为用户名称。\\n', '\\n', 'useradd [options] username\\n', '用户信息文件\\n', '与用户账号信息有关的文件如下：\\n', '\\n', '/etc/passwd：用户账号信息文件。\\n', '/etc/shadow：用户账号信息加密文件。\\n', '/etc/group：组信息文件。\\n', '/etc/default/useradd：定义默认设置文件。\\n', '/etc/login.defs：系统广义设置文件。\\n', '/etc/skel：默认的初始配置文件目录。\\n', '创建用户实例\\n', '例如新建一个用户名为userexample的用户，在root权限下执行如下命令：\\n', '\\n', '# useradd userexample\\n', ' 说明：\\n', '没有任何提示，表明用户建立成功。这时请使用passwd命令设置用户的密码，没有设置密码的新账号不能登录系统。\\n', '\\n', '使用id命令查看新建的用户信息，命令如下：\\n', '\\n', '# id userexample\\n', 'uid=502(userexample)    gid=502(userexample)    groups=502(userexample)\\n', '修改用户userexample的密码：\\n', '\\n', '# passwd userexample\\n', '建议在修改用户密码时满足密码复杂度要求，密码的复杂度的要求如下：\\n', '\\n', '口令长度至少8个字符。\\n', '口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种。\\n', '口令不能和账号一样。\\n', '口令不能使用字典词汇。\\n', '查询字典 在已装好的openEuler环境中，可以通过如下命令导出字典库文件dictionary.txt，用户可以查询密码是否在该字典中。\\n', 'cracklib-unpacker /usr/share/cracklib/pw_dict > dictionary.txt\\n', '修改字典\\n', '修改上面导出的字典文件，执行如下命令更新系统字典库。\\n', '# create-cracklib-dict dictionary.txt\\n', '在原字典库基础上新增其他字典内容custom.txt。\\n', '# create-cracklib-dict dictionary.txt custom.txt\\n', '根据提示两次输入新用户的密码，完成密码更改。过程如下：\\n', '\\n', '# passwd userexample\\n', 'Changing password for user userexample.\\n', 'New password:\\n', 'Retype new password:\\n', 'passwd: all authentication tokens updated successfully.\\n', ' 说明：\\n', '若打印信息中出现“BAD PASSWORD: The password fails the dictionary check - it is too simplistic/sytematic”，表示设置的密码过于简单，建议设置复杂度较高的密码。\\n', '\\n', '修改用户账号\\n', '修改密码\\n', '普通用户可以用passwd修改自己的密码，只有管理员才能用passwd username为其他用户修改密码。\\n', '\\n', '修改用户shell设置\\n', '使用chsh命令可以修改自己的shell，只有管理员才能用chsh username为其他用户修改shell设置。\\n', '\\n', '用户也可以使用usermod命令修改shell信息，在root权限下执行如下命令，其中 new_shell_path 为目标shell路径，username 为要修改用户的用户名，请根据实际情况修改：\\n', '\\n', 'usermod -s new_shell_path username\\n', '例如，将用户userexample的shell改为csh，命令如下：\\n', '\\n', '# usermod -s /bin/csh userexample\\n', '修改主目录\\n', '修改主目录，可以在root权限下执行如下命令，其中 new_home_directory 为已创建的目标主目录的路径，username 为要修改用户的用户名，请根据实际情况修改：\\n', '\\n', 'usermod -d new_home_directory username\\n', '如果想将现有主目录的内容转移到新的目录，应该使用-m选项，命令如下：\\n', '\\n', 'usermod -d new_home_directory -m username\\n', '修改UID\\n', '修改用户ID，在root权限下执行如下命令，其中 UID 代表目标用户ID，username 代表用户名，请根据实际情况修改：\\n', '\\n', 'usermod -u UID username\\n', '该用户主目录中所拥有的文件和目录都将自动修改UID设置。但是，对于主目录外所拥有的文件，只能使用chown命令手动修改所有权。\\n', '\\n', '修改账号的有效期\\n', '如果使用了影子口令，则可以在root权限下，执行如下命令来修改一个账号的有效期，其中 MM 代表月份，DD 代表某天，YY 代表年份，username 代表用户名，请根据实际情况修改：\\n', '\\n', 'usermod -e MM/DD/YY username\\n', '删除用户\\n', '在root权限下，使用userdel命令可删除现有用户。\\n', '\\n', '例如，删除用户Test，命令如下：\\n', '\\n', '# userdel Test\\n', '如果想同时删除该用户的主目录以及其中所有内容，要使用-r参数递归删除。\\n', '\\n', ' 说明：\\n', '不建议直接删除已经进入系统的用户，如果需要强制删除，请使用 userdel -f Test 命令。\\n', '\\n', '管理员账户授权\\n', '使用sudo命令可以允许普通用户执行管理员账户才能执行的命令。\\n', '\\n', 'sudo命令允许已经在/etc/sudoers文件中指定的用户运行管理员账户命令。例如，一个已经获得许可的普通用户可以运行如下命令：\\n', '\\n', 'sudo /usr/sbin/useradd newuserl\\n', '实际上，sudo的配置完全可以指定某个已经列入/etc/sudoers文件的普通用户可以做什么，不可以做什么。\\n', '\\n', '/etc/sudoers的配置行如下所示。\\n', '\\n', '空行或注释行（以#字符打头）：无具体功能的行。\\n', '\\n', '可选的主机别名行：用来创建主机列表的简称。必须以Host_Alias关键词开头，列表中的主机必须用逗号隔开，如：\\n', '\\n', 'Host_Alias  linux=ted1,ted2\\n', '其中ted1和ted2是两个主机名，可使用linux（别名）称呼它们。\\n', '\\n', '可选的用户别名行：用来创建用户列表的简称。用户别名行必须以User_Alias关键词开头，列表中的用户名必须以逗号隔开。其格式同主机别名行。\\n', '\\n', '可选的命令别名行：用来创建命令列表的简称。必须以Cmnd_Alias开头，列表中的命令必须用逗号隔开。\\n', '\\n', '可选的运行方式别名行：用来创建用户列表的简称。不同的是，使用这样的别名可以告诉sudo程序以列表中某一用户的身份来运行程序。\\n', '\\n', '必要的用户访问说明行。\\n', '\\n', '用户访问的说明语法如下：\\n', '\\n', 'user host = [ run as user ] command list\\n', '在user处指定一个真正的用户名或定义过的别名，host也可以是一个真正的主机名或者定义过的主机别名。默认情况下，sudo执行的所有命令都是以root身份执行。如果您想使用其他身份可以指定。command list可以是以逗号分隔的命令列表，也可以是一个已经定义过的别名，如：\\n', '\\n', 'ted1   ted2=/sbin/shutdown\\n', '这一句说明ted1可以在ted2主机上运行关机命令。\\n', '\\n', 'newuser1 ted1=(root) /usr/sbin/useradd,/usr/sbin/userdel\\n', '这一句说明ted1主机上的newuser1可以以root用户权限执行useradd，userdel命令。\\n', '\\n', ' 说明：\\n', '\\n', '可以在一行定义多个别名，中间用冒号 (:) 隔开。\\n', '可在命令或命令别名之前加上感叹号 (!)，使该命令或命令别名无效。\\n', '有两个关键词：ALL和NOPASSWD。ALL意味着“所有”（所有文件、所有主机或所有命令），NOPASSWD意味着不用密码。\\n', '通过修改用户访问，将普通用户的访问权限修改为同root一样，则可以给普通用户分配特权。\\n', '下面是一个sudoers文件的例子：\\n', '\\n', '#sudoers files\\n', '#User alias specification\\n', 'User_Alias ADMIN=ted1:POWERUSER=globus,ted2\\n', '#user privilege specification\\n', 'ADMIN ALL=ALL\\n', 'POWERUSER ALL=ALL,!/bin/su\\n', '其中：\\n', '\\n', 'User_Alias ADMIN=ted1:POWERUSER=globus,ted2\\n', '\\n', '定义了两个别名ADMIN和POWERUSER\\n', '\\n', 'ADMIN ALL=ALL\\n', '\\n', '说明在所有主机上，ADMIN用户都可以以root身份执行所有命令\\n', '\\n', 'POWERUSER ALL=ALL,!/bin/su\\n', '\\n', '给POWERUSER用户除了运行su命令外等同ADMIN的权限\\n', '\\n', '管理用户组\\n', '增加用户组\\n', 'groupadd命令\\n', '在root权限下，通过groupadd命令可以为系统添加新用户组信息，其中 options 为相关参数， groupname 为用户组名称。\\n', '\\n', 'groupadd [options] groupname\\n', '用户组信息文件\\n', '与用户组信息有关的文件如下：\\n', '\\n', '/etc/gshadow：用户组信息加密文件。\\n', '/etc/group：组信息文件。\\n', '/etc/login.defs：系统广义设置文件。\\n', '创建用户组实例\\n', '例如新建一个用户组名为groupexample的用户，在root权限下执行如下命令：\\n', '\\n', '# groupadd groupexample\\n', '修改用户组\\n', '修改GID\\n', '修改用户组ID，在root权限下执行如下命令，其中 GID 代表目标用户组ID， groupname 代表用户组，请根据实际情况修改：\\n', '\\n', 'groupmod -g GID groupname\\n', '修改用户组名\\n', '修改用户组名，在root权限下执行如下命令，其中 newgroupname 代表新用户组名， oldgroupname 代表已经存在的待修改的用户组名，请根据实际情况修改：\\n', '\\n', 'groupmod -n newgroupname oldgroupname\\n', '删除用户组\\n', '在root权限下，使用groupdel命令可删除用户组。\\n', '\\n', '例如，删除用户组Test，命令如下：\\n', '\\n', '# groupdel Test\\n', ' 说明：\\n', 'groupdel不能直接删除用户的主组，如果需要强制删除用户主组，请使用 groupdel -f Test 命令。\\n', '\\n', '将用户加入用户组或从用户组中移除\\n', '在root权限下，使用gpasswd命令将用户加入用户组或从用户组中移除。\\n', '\\n', '例如，将用户 userexample 加入用户组 Test ，命令如下：\\n', '\\n', '# gpasswd -a userexample Test\\n', '例如，将用户 userexample 从 Test 用户组中移除，命令如下：\\n', '\\n', '# gpasswd -d userexample Test\\n', '切换用户组\\n', '一个用户同时属于多个用户组时，则在用户登录后，使用newgrp命令可以切换到其他用户组，以便具有其他用户组的权限。\\n', '\\n', '例如，将用户 userexample 切换到 Test 用户组，命令如下：\\n', '\\n', '$ newgrp Test']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_安装指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AF%BC.html", "text_entry": "['安装指导\\n', ' 说明：\\n', '系统容器的安装需要使用root权限。\\n', '\\n', '首先需要安装iSulad容器引擎。\\n', '\\n', '# yum install iSulad\\n', '安装系统容器依赖包。\\n', '\\n', '# yum install syscontainer-tools authz lxcfs-tools lxcfs\\n', '查看iSulad是否已经启动。\\n', '\\n', '# systemctl status isulad\\n', '开启lxcfs和authz服务。\\n', '\\n', '# systemctl start lxcfs\\n', '# systemctl start authz\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_为安全容器配置资源.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E4%B8%BA%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE%E8%B5%84%E6%BA%90.html", "text_entry": "['为安全容器配置资源\\n', '为安全容器配置资源\\n', '资源共享\\n', '限制CPU资源\\n', '限制内存资源\\n', '限制Blkio资源\\n', '限制文件描述符资源\\n', '安全容器运行于虚拟化隔离的轻量级虚拟机内，因此资源的配置应分为两部分：对轻量级虚拟机的资源配置，即Host资源配置；对虚拟机内容器的配置，即Guest容器资源配置。以下资源配置均分为这两部分。\\n', '\\n', '资源共享-27\\n', '由于安全容器运行于虚拟化隔离的轻量虚拟机内，故无法访问Host上某些namespace下的资源，因此启动时不支持–net host，–ipc host，–pid host，–uts host。\\n', '\\n', '当启动一个Pod时，同一个Pod中的所有容器默认共享同一个net namespace和ipc namespace。如果同一个Pod中的容器需要共享pid namespace，则可以通过Kubernetes进行配置，Kubernetes 1.11版本该值为默认关闭。\\n', '\\n', '限制CPU资源\\n', '配置轻量级虚拟机CPU运行资源\\n', '\\n', '对轻量级虚拟机的CPU资源配置即虚拟机运行的vcpu配置，安全容器使用–annotation com.github.containers.virtcontainers.sandbox_cpu配置轻量级虚拟机运行CPU资源，该参数仅可配置在pause容器上：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_cpu=<cpu-nums> <pause-image> <command>\\n', '举例：\\n', '\\n', '# 启动一个pause容器\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_cpu=4 busybox sleep 999999\\n', 'be3255a3f66a35508efe419bc52eccd3b000032b9d8c9c62df611d5bdc115954\\n', '\\n', '# 进入容器查看CPU信息，查看CPU个数是否与com.github.containers.virtcontainers.sandbox_cpu配置的CPU个数相等\\n', 'docker exec be32 lscpu\\n', 'Architecture:        aarch64\\n', 'Byte Order:          Little Endian\\n', 'CPU(s):              4\\n', 'On-line CPU(s) list: 0-3\\n', 'Thread(s) per core:  1\\n', 'Core(s) per socket:  1\\n', 'Socket(s):           4\\n', ' 说明：\\n', 'CPU个数可以设置的最大值为当前OS上可供运行的CPU值（除去隔离核），最小值为0.5个CPU。\\n', '\\n', '配置容器CPU运行资源\\n', '\\n', '配置容器CPU运行资源与开源docker容器配置CPU运行资源的方式相同，可以通过docker run命令中CPU资源限制相关的参数进行配置：\\n', '\\n', '\\n', '参数\\n', '\\n', '含义\\n', '\\n', '--cpu-shares\\n', '\\n', '设置容器能使用的CPU时间比例。\\n', '\\n', '--cpus\\n', '\\n', '设置容器可以使用的 CPU 个数。\\n', '\\n', '--cpu-period\\n', '\\n', '设置容器进程的调度周期。\\n', '\\n', '--cpu-quota\\n', '\\n', '设置每个容器进程调度周期内能够使用的CPU时间。\\n', '\\n', '--cpuset-cpus\\n', '\\n', '设置容器进程可以使用的CPU列表。\\n', '\\n', '说明：\\n', '安全容器使用 --cpuset-cpus 参数绑定CPU时，CPU的编号不能超过安全容器对应的轻量级虚机中CPU的个数减1（轻量级虚机中CPU的编号从0开始）。\\n', '\\n', '--cpuset-mems\\n', '\\n', '设定该容器进程可以访问的内存节点。\\n', '\\n', '说明：\\n', '安全容器不支持多NUMA架构和配置，使用NUMA memory的--cpuset-mems参数只能配置为0。\\n', '\\n', '配置CPU热插拔功能\\n', '\\n', ' 说明：\\n', '安全容器CPU热插拔功能需要虚拟化组件qemu支持CPU热插拔。\\n', '\\n', 'kata-runtime配置文件config.toml中enable_cpu_memory_hotplug选项负责开启和禁用CPU和内存热插拔。默认取值为false，表示禁用CPU和内存热插拔功能；取值为true，表示开启CPU和内存热插拔功能。\\n', '\\n', 'kata-runtime中复用了**–cpus**选项实现了CPU热插拔的功能，通过统计Pod中所有容器的**–cpus**选项的和，然后确定需要热插多少个CPU到轻量级虚机中。\\n', '\\n', '举例：\\n', '\\n', '# 启动一个pause容器，轻量级虚机默认分配了1个vcpu\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox busybox sleep 999999\\n', '77b40fb72f63b11dd3fcab2f6dabfc7768295fced042af8c7ad9c0286b17d24f\\n', '\\n', '# 查看启动完pause容器后轻量级虚机中CPU个数\\n', 'docker exec 77b40fb72f6 lscpu\\n', 'Architecture:          x86_64\\n', 'CPU op-mode(s):        32-bit, 64-bit\\n', 'Byte Order:            Little Endian\\n', 'CPU(s):                1\\n', 'On-line CPU(s) list:   0\\n', 'Thread(s) per core:    1\\n', 'Core(s) per socket:    1\\n', 'Socket(s):             1\\n', '\\n', '# 在同一个Pod中启动新的容器并通过--cpus设置容器需要的CPU数量为4\\n', 'docker run -tid --runtime kata-runtime --network none --cpus 4 --annotation io.kubernetes.docker.type=container --annotation io.kubernetes.sandbox.id=77b40fb72f63b11dd3fcab2f6dabfc7768295fced042af8c7ad9c0286b17d24f busybox sleep 999999\\n', '7234d666851d43cbdc41da356bf62488b89cd826361bb71d585a049b6cedafd3\\n', '\\n', '# 查看当前轻量级虚机中CPU的个数\\n', 'docker exec 7234d6668 lscpu\\n', 'Architecture:          x86_64\\n', 'CPU op-mode(s):        32-bit, 64-bit\\n', 'Byte Order:            Little Endian\\n', 'CPU(s):                4\\n', 'On-line CPU(s) list:   0-3\\n', 'Thread(s) per core:    1\\n', 'Core(s) per socket:    1\\n', 'Socket(s):             4\\n', '\\n', '# 删除热插了CPU的容器后，查看轻量级虚机中CPU的个数\\n', 'docker rm -f 7234d666851d\\n', '7234d666851d\\n', '\\n', 'docker exec 77b40fb72f6  lscpu\\n', 'Architecture:          x86_64\\n', 'CPU op-mode(s):        32-bit, 64-bit\\n', 'Byte Order:            Little Endian\\n', 'CPU(s):                1\\n', 'On-line CPU(s) list:   0\\n', 'Thread(s) per core:    1\\n', 'Core(s) per socket:    1\\n', 'Socket(s):             1\\n', '  \\n', '\\n', '  \\n', '\\n', ' 说明：\\n', '由于pause容器只是一个占位容器没有工作负载，所以轻量级虚机启动时默认分配的1个CPU可以被其它容器共享，因此上面例子中启动的新容器只需要再热插3个CPU到轻量级虚机中即可。\\n', '\\n', '当停止热插了CPU的容器后，启动容器时热插进去的CPU也会被拔出。\\n', '限制内存资源\\n', '配置轻量级虚拟机MEM运行资源\\n', '\\n', '对轻量级虚拟机的MEM资源配置即虚拟机运行的内存进行配置，安全容器使用–annotation com.github.containers.virtcontainers.sandbox_mem配置轻量级虚拟机运行MEM资源，该参数仅可配置在pause容器上：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_mem=<memory-size> <pause-image> <command>\\n', '举例：\\n', '\\n', '# 启动一个pause容器，通过--annotation com.github.containers.virtcontainers.sandbox_mem=4G为轻量级虚机分配4G内存\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.sandbox_mem=4G busybox sleep 999999\\n', '1532c3e59e7a45cd6b419aa1db07dd0069b0cdd93097f8944177a25e457e4297\\n', '\\n', '# 查看轻量级虚机中内存信息，查看内存大小是否与com.github.containers.virtcontainers.sandbox_mem配置的内存大小相等\\n', 'docker exec 1532c3e free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           3950          20        3874          41          55        3858\\n', 'Swap:             0           0           0\\n', ' 说明：\\n', '\\n', '如果没有通过–annotation com.github.containers.virtcontainers.sandbox_mem显示地设置轻量级虚机的内存大小，则轻量级虚机默认使用的内存大小为1GB。\\n', '安全容器一个Pod的最小内存规格是1GB，支持的最大内存规格是256GB。如果用户分配的内存规格超过256GB，可能会出现未定义的错误，安全容器暂不支持超过256GB的大内存场景。\\n', '配置容器MEM运行资源\\n', '\\n', '配置容器MEM运行资源与开源docker容器配置MEM运行资源的方式相同，可以通过docker run命令中MEM资源限制相关的参数进行配置：\\n', '\\n', '\\n', '参数\\n', '\\n', '含义\\n', '\\n', '-m/--memory\\n', '\\n', '设置容器进程可以使用的内存大小。\\n', '\\n', '说明：\\n', '当内存热插拔开关关闭时，-m的取值要小于等于轻量级虚机启动时分配的内存大小。\\n', '配置MEM热插功能\\n', '\\n', '同配置CPU热插拔功能一样，MEM的热插功能也是由kata-runtime配置文件config.toml中enable_cpu_memory_hotplug选项配置，用法参见3。\\n', '\\n', ' 说明：\\n', '内存资源当前只支持热插，不支持内存热拔。\\n', '\\n', 'kata-runtime中复用了**-m**选项实现了MEM热插的功能，通过统计Pod中所有容器的**-m**选项的和，然后确定需要热插多少内存到轻量级虚机中，例如，\\n', '\\n', '举例：\\n', '\\n', '# 启动一个pause容器，轻量级虚机默认分配了1GB内存\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox busybox sleep 999999\\n', '99b78508ada3fa7dcbac457bb0f6e3784e64e7f7131809344c5496957931119f\\n', '\\n', '# 查看启动完pause容器后轻量级虚机中的内存大小\\n', 'docker exec 99b78508ada free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:            983          18         914          36          50         908\\n', 'Swap:             0           0           0\\n', '\\n', '# 在同一个Pod中启动新的容器并通过-m设置容器需要的内存大小为4G\\n', 'docker run -tid --runtime kata-runtime --network none -m 4G --annotation io.kubernetes.docker.type=container --annotation io.kubernetes.sandbox.id=99b78508ada3fa7dcbac457bb0f6e3784e64e7f7131809344c5496957931119f busybox sleep 999999\\n', 'c49461745a712b2ef3127fdf43b2cbb034b7614e6060b13db12b7a5ff3c830c8\\n', '\\n', '# 查看当前轻量级虚机中内存的大小\\n', 'docker exec c49461745 free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           4055          69        3928          36          57        3891\\n', 'Swap:             0           0           0\\n', '\\n', '# 删除热插了CPU的容器后，查看轻量级虚机中内存的大小\\n', 'docker rm -f c49461745\\n', 'c49461745\\n', '\\n', '# 因为热插的内存暂不支持热拔功能，所以轻量级虚机中在删除热插内存容器之后还是拥有4GB的内存\\n', 'docker exec 99b78508ada free -m\\n', '              total        used        free      shared  buff/cache   available\\n', 'Mem:           4055          69        3934          36          52        3894\\n', 'Swap:             0           0           0\\n', ' 说明：\\n', '由于pause容器只是一个占位容器没有工作负载，所以轻量级虚机启动时分配的内存可以被其它容器共享使用，因此上面例子中启动的新容器只需要再热插3GB的内存到轻量级虚机中即可。\\n', '\\n', '限制Blkio资源\\n', '配置轻量级虚拟机Blkio运行资源\\n', '\\n', '对轻量级虚拟机的BlkIio资源配置，安全容器使用–annotation com.github.containers.virtcontainers.blkio_cgroup配置轻量级虚拟机使用的块设备的blkio资源，该参数仅可配置在pause容器上：\\n', '\\n', 'docker run -tid --runtime --network none --annotation io.kubernetes.docker.type=podsandbox --annotation com.github.containers.virtcontainers.blkio_cgroup=<blkio json格式字符串> <pause-image> <command>\\n', '其中–annotation com.github.containers.virtcontainers.blkio_cgroup的取值要符合下面BlkioCgroup结构体的定义：\\n', '\\n', \"// BlkioCgroup for Linux cgroup 'blkio' data exchange\\n\", 'type BlkioCgroup struct {\\n', '\\t// Items specifies per cgroup values\\n', '\\tItems []BlockIOCgroupItem `json:\"blkiocgroup,omitempty\"`\\n', '}\\n', '\\n', 'type BlockIOCgroupItem struct {\\n', '\\t// Path represent path of blkio device\\n', '\\tPath string `json:\"path,omitempty\"`\\n', '\\t// Limits specifies the blkio type and value\\n', '\\tLimits []IOLimit `json:\"limits,omitempty\"`\\n', '}\\n', '\\n', 'type IOLimit struct {\\n', '\\t// Type specifies IO type\\n', '\\tType string `json:\"type,omitempty\"`\\n', '\\t// Value specifies rate or weight value\\n', '\\tValue uint64 `json:\"value,omitempty\"`\\n', '}\\n', 'IOLimit结构体中Type字段取值列表为：\\n', '\\n', '// BlkioThrottleReadBps is the key to fetch throttle_read_bps\\n', 'BlkioThrottleReadBps = \"throttle_read_bps\"\\n', '\\n', '// BlkioThrottleWriteBps is the key to fetch throttle_write_bps\\n', 'BlkioThrottleWriteBps = \"throttle_write_bps\"\\n', '\\n', '// BlkioThrottleReadIOPS is the key to fetch throttle_read_iops\\n', 'BlkioThrottleReadIOPS = \"throttle_read_iops\"\\n', '\\n', '// BlkioThrottleWriteIOPS is the key to fetch throttle_write_iops\\n', 'BlkioThrottleWriteIOPS = \"throttle_write_iops\"\\n', '\\n', '// BlkioWeight is the key to fetch blkio_weight\\n', 'BlkioWeight = \"blkio_weight\"\\n', '\\n', '// BlkioLeafWeight is the key to fetch blkio_leaf_weight\\n', 'BlkioLeafWeight = \"blkio_leaf_weight\"\\n', '举例：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation com.github.containers.virtcontainers.blkio_cgroup=\\'{\"blkiocgroup\":[{\"path\":\"/dev/sda\",\"limits\":[{\"type\":\"throttle_read_bps\",\"value\":400},{\"type\":\"throttle_write_bps\",\"value\":400},{\"type\":\"throttle_read_iops\",\"value\":700},{\"type\":\"throttle_write_iops\",\"value\":699}]},{\"limits\":[{\"type\":\"blkio_weight\",\"value\":78}]}]}\\' busybox sleep 999999\\n', '上面命令表示对启动的安全容器所使用的/dev/sda磁盘进行blkio限流，分别将throttle_read_bps限速为400bps，throttle_write_bps限速为400bps，throttle_read_iops限速为700次/秒，throttle_write_iops限速为699次/秒，以及所在blkio cgroup组的权重值设置为78。\\n', '\\n', '限制文件描述符资源\\n', '为了避免在容器中打开大量9p共享目录中的文件导致主机上文件描述符资源耗尽，使得安全容器无法正常提供服务，安全容器支持自定义配置安全容器qemu进程最多可以打开的文件描述符数量限制。\\n', '\\n', '安全容器通过复用docker run命令中的**–files-limit**选项来设置安全容器qemu进程最多可以打开文件描述符，该参数仅可配置在pause容器上，使用方法如下所示：\\n', '\\n', 'docker run -tid --runtime kata-runtime --network none --annotation io.kubernetes.docker.type=podsandbox --files-limit <max-open-files> <pause-image> bash\\n', ' 说明：\\n', '\\n', '如果**–files-limit**选项的取值小于安全容器默认设置的最小值1024且不为0时，安全容器qemu进程最多可以打开的文件描述符数量会被设置为最小值1024。\\n', '如果**–files-limit**选项的取值为0时，安全容器qemu进程最多可以打开的文件描述符数量为系统可以打开文件描述符的最大值/proc/sys/fs/file-max除以400后得到的默认值。\\n', '如果启动安全容器时没有显示指定**–files-limit**可以打开的文件描述符的上限，安全容器qemu进程可以打开的文件描述符数量的上限和系统默认值保持一致。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_StratoVirt用户指南_准备使用环境.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/StratoVirt/%E5%87%86%E5%A4%87%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83.html", "text_entry": "['准备环境\\n', '使用说明\\n', 'StratoVirt仅支持运行于x86_64和AArch64处理器架构下并启动相同架构的Linux虚拟机。\\n', '建议在 openEuler 22.03 LTS 版本编译、调测和部署该版本 StratoVirt。\\n', 'StratoVirt支持以非root权限运行。\\n', '环境要求\\n', '运行StratoVirt需要具备如下环境：\\n', '\\n', '/dev/vhost-vsock设备（用于实现mmio）\\n', 'nmap工具\\n', 'Kernel镜像和rootfs镜像\\n', '准备设备和工具\\n', 'StratoVirt运行需要实现mmio设备，所以运行之前确保存在设备/dev/vhost-vsock\\n', '\\n', '查看该设备是否存在：\\n', '\\n', '$ ls /dev/vhost-vsock\\n', '/dev/vhost-vsock\\n', '若该设备不存在，请执行如下命令生成/dev/vhost-vsock设备。\\n', '\\n', '$ modprobe vhost_vsock\\n', '为了能够使用QMP命令，需要安装nmap工具，在配置yum源的前提下，可执行如下命令安装nmap。\\n', '\\n', '# yum install nmap\\n', '准备镜像\\n', '制作kernel镜像\\n', '当前版本的StratoVirt仅支持x86_64和AArch64平台的PE格式内核镜像。此格式内核映像可通过以下方法生成。\\n', '\\n', '获取openEuler的kernel源代码，参考命令如下：\\n', '\\n', '$ git clone https://gitee.com/openeuler/kernel.git\\n', '$ cd kernel\\n', '查看并切换kernel的版本到openEuler-22.03-LTS，参考命令如下：\\n', '\\n', '$ git checkout openEuler-22.03-LTS\\n', '配置并编译Linux kernel。目前有两种方式可以生成配置文件：1. 使用推荐配置（获取配置文件），将指定版本的推荐文件复制到kernel路径下并重命名为.config， 并执行命令make olddefconfig更新到最新的默认配置（否则后续编译可能有选项需要手动选择）。2. 通过以下命令进行交互，根据提示完成kernel配置，可能会提示缺少指定依赖，按照提示使用yum install命令进行安装。\\n', '\\n', '$ make menuconfig\\n', '使用下面的命令制作并转换kernel镜像为PE格式，转化后的镜像为vmlinux.bin。\\n', '\\n', '$ make -j vmlinux && objcopy -O binary vmlinux vmlinux.bin\\n', '如果想在x86平台使用bzImzge格式的kernel，可以使用如下命令进行编译。\\n', '\\n', '$ make -j bzImage\\n', '\\u200b\\n', '\\n', '制作rootfs镜像\\n', 'rootfs镜像是一种文件系统镜像，在StratoVirt启动时可以装载带有init的ext4格式的镜像。下面是制作ext4 rootfs镜像的简单方法。\\n', '\\n', '准备一个大小合适的文件（例如在/home中创建10GiB空间大小的文件）。\\n', '\\n', '$ cd /home\\n', '$ dd if=/dev/zero of=./rootfs.ext4 bs=1G count=10\\n', '在此文件上创建空的ext4文件系统。\\n', '\\n', '$ mkfs.ext4 ./rootfs.ext4\\n', '挂载文件镜像。创建/mnt/rootfs，使用root权限，将rootfs.ext4挂载到/mnt/rootfs目录。\\n', '\\n', '$ mkdir /mnt/rootfs\\n', '# 返回刚刚创建文件系统的目录（如/home）\\n', '$ cd /home\\n', '$ sudo mount ./rootfs.ext4 /mnt/rootfs && cd /mnt/rootfs\\n', '获取对应处理器架构的最新alpine-mini rootfs。\\n', '\\n', '对于AArch64处理器架构，从alpine网站获取最新alpine-mini rootfs，例如：alpine-minirootfs-3.16.0-aarch64.tar.gz ，参考命令如下：\\n', '$ wget http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/aarch64/alpine-minirootfs-3.16.0-aarch64.tar.gz\\n', '$ tar -zxvf alpine-minirootfs-3.16.0-aarch64.tar.gz\\n', '$ rm alpine-minirootfs-3.16.0-aarch64.tar.gz\\n', '对于x86_64处理器架构，从alpine网站获取指定架构最新alpine-mini rootfs，例如：alpine-minirootfs-3.16.0-x86_64.tar.gz，参考命令如下：\\n', '$ wget http://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/x86_64/alpine-minirootfs-3.16.0-x86_64.tar.gz\\n', '$ tar -zxvf alpine-minirootfs-3.16.0-x86_64.tar.gz\\n', '$ rm alpine-minirootfs-3.16.0-x86_64.tar.gz\\n', '为ext4文件镜像制作一个简单的/sbin/init，参考命令如下：\\n', '\\n', '$ rm sbin/init; touch sbin/init && cat > sbin/init <<EOF\\n', '#! /bin/sh\\n', 'mount -t devtmpfs dev /dev\\n', 'mount -t proc proc /proc\\n', 'mount -t sysfs sysfs /sys\\n', 'ip link set up dev lo\\n', '\\n', 'exec /sbin/getty -n -l /bin/sh 115200 /dev/ttyS0\\n', 'poweroff -f\\n', 'EOF\\n', '\\n', 'sudo chmod +x sbin/init\\n', '卸载rootfs镜像。\\n', '\\n', '$ cd /home; umount /mnt/rootfs\\n', '至此， rootfs制作成功，已可使用ext4 rootfs镜像文件rootfs.ext4，该文件在/home目录下。\\n', '\\n', '获取标准启动所需固件\\n', '固件 (firmware) 是指设备内部保存的设备驱动程序。操作系统只有通过固件才能按照标准启动的方式进行启动。 StratoVirt 当前只支持在 x86_64 和 aarch64 架构下按照 UEFI (Unified Extensible Firmware Interface) 接口进行标准启动。\\n', '\\n', 'EDK II 是实现了 UEFI 标准的开源软件，StratoVirt 使用 EDK II 作为标准启动的固件。因此需要获取EDK II的固件文件。可以通过 yum 命令来进行 EDK II 固件文件的安装，具体命令如下。\\n', '\\n', 'x86_64 架构上运行以下命令：\\n', '\\n', '$ sudo yum install -y edk2-ovmf\\n', 'aarch64 架构上运行以下命令：\\n', '\\n', '$ sudo yum install -y edk2-aarch64\\n', 'EDK II 的固件包括两个文件：一个文件用于保存可执行代码，另一个文件用于保存启动配置信息。安装成功之后，在 x86_64 架构上，固件文件 OVMF_CODE.fd 与固件配置文件 OVMF_VARS.fd 会保存在 /usr/share/edk2/ovmf 路径下；在 aarch64 架构上, 固件文件 QEMU_EFI-pflash.raw 和固件配置文件 vars-template-pflash.raw 则是保存在 /usr/share/edk2/aarch64 路径下。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_namespace化内核参数可写.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/namespace%E5%8C%96%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%8F%AF%E5%86%99.html", "text_entry": "['namespace化内核参数可写\\n', '功能描述\\n', '对于运行在容器内的业务，如数据库，大数据，包括普通应用，有对部分内核参数进行设置和调整的需求，以满足最佳的业务运行性能和可靠性。内核参数要么不允许修改，要么全部允许修改（特权容器）：\\n', '\\n', '在不允许用户在容器内修改时，只提供了–sysctl外部接口，而且容器内不能灵活修改参数值。\\n', '\\n', '在允许用户在容器内修改时，部分内核参数是全局有效的，某个容器修改后，会影响主机上所有的程序，安全性降低。\\n', '\\n', '  \\n', '\\n', '系统容器提供–ns-change-opt参数，可以指定namespace化的内核参数在容器内动态设置，当前仅支持net、ipc。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--ns-change-opt\\n', '\\n', '字符串变量。\\n', '仅支持配置net、ipc：\\n', 'net：支持/proc/sys/net目录下所有namespace化参数。\\n', '\\n', 'ipc：支持的namespace化参数列表如下：\\n', '\\n', '/proc/sys/kernel/msgmax\\n', '\\n', '/proc/sys/kernel/msgmnb\\n', '\\n', '/proc/sys/kernel/msgmni\\n', '\\n', '/proc/sys/kernel/sem\\n', '\\n', '/proc/sys/kernel/shmall\\n', '\\n', '/proc/sys/kernel/shmmax\\n', '\\n', '/proc/sys/kernel/shmmni\\n', '\\n', '/proc/sys/kernel/shm_rmid_forced\\n', '\\n', '/proc/sys/fs/mqueue/msg_default\\n', '\\n', '/proc/sys/fs/mqueue/msg_max\\n', '\\n', '/proc/sys/fs/mqueue/msgsize_default\\n', '\\n', '/proc/sys/fs/mqueue/msgsize_max\\n', '\\n', '/proc/sys/fs/mqueue/queues_max\\n', '\\n', '支持通知指定多个namespce配置，多个配置间通过逗号隔开，例如：--ns-change-opt=net,ipc。\\n', '约束限制\\n', '如果容器启动同时指定了–privileged（特权容器）和–ns-change-opt，则–ns-change-opt不生效。\\n', '使用示例\\n', '启动容器， 指定–ns-change-opt=net：\\n', '\\n', '[root@localhost ~]# isula run -tid --ns-change-opt net --system-container --external-rootfs /root/myrootfs none init\\n', '4bf44a42b4a14fdaf127616c90defa64b4b532b18efd15b62a71cbf99ebc12d2\\n', '[root@localhost ~]# isula exec -it 4b mount | grep /proc/sys\\n', 'proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/net type proc (rw,nosuid,nodev,noexec,relatime)\\n', '可以看到容器内/proc/sys/net挂载点为rw，说明net相关的namespace化的内核参数具有读写权限。\\n', '\\n', '再启动一个容器，指定–ns-change-opt=ipc：\\n', '\\n', '[root@localhost ~]# isula run -tid --ns-change-opt ipc --system-container --external-rootfs /root/myrootfs none init\\n', 'c62e5e5686d390500dab2fa76b6c44f5f8da383a4cbbeac12cfada1b07d6c47f\\n', '[root@localhost ~]# isula exec -it c6 mount | grep /proc/sys\\n', 'proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shmmax type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shmmni type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shmall type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/shm_rmid_forced type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/msgmax type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/msgmni type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/msgmnb type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/kernel/sem type proc (rw,nosuid,nodev,noexec,relatime)\\n', 'proc on /proc/sys/fs/mqueue type proc (rw,nosuid,nodev,noexec,relatime)\\n', '可以看到容器内ipc相关的内核参数挂载点为rw，说明ipc相关的namespace化的内核参数具有读写权限。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_Docker容器_容器管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-3.html", "text_entry": "['容器管理\\n', '容器管理\\n', '创建容器\\n', '创建容器使用hook-spec\\n', '创建容器配置健康检查\\n', '停止与删除容器\\n', '容器信息查询\\n', '修改操作\\n', '创建容器\\n', '下载镜像\\n', '运行docker命令需要root权限，当你使用普通用户登录时，需要用sudo权限执行docker命令。\\n', '\\n', '[root@localhost ~]# docker pull busybox\\n', '该命令行将在docker官方的镜像库中下载busybox:latest（命令行中没指定TAG，所以使用默认的TAG名latest），镜像在下载过程中将检测所依赖的层本地是否存在，如果存在就跳过。从私有镜像库下载镜像时，请带上registry描述，例如：假如建立了一个私有镜像库，地址为192.168.1.110:5000，里面有一些常用镜像。使用下面命令行从私有镜像库中下载镜像。\\n', '\\n', '[root@localhost ~]# docker pull 192.168.1.110:5000/busybox\\n', '从私有镜像库中下载下来的image名字带有镜像库地址的信息名字比较长，可以用docker tag命令生成一个名字简单点的image。\\n', '\\n', '[root@localhost ~]# docker tag 192.168.1.110:5000/busybox busybox\\n', '可以通过docker images命令查看本地镜像列表。\\n', '\\n', '运行一个简单的应用\\n', '[root@localhost ~]# docker run busybox /bin/echo \"Hello world\"\\n', 'Hello world\\n', '该命令行使用busybox:latest（命令行中没有指定tag，所以使用默认的tag名latest）镜像创建了一个容器，在容器内执行了echo “Hello world”。使用下面命令行可以查看刚才创建的这个容器。\\n', '\\n', '[root@localhost ~]# docker ps -l\\n', 'CONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS                     PORTS               NAMES\\n', 'd8c0a3315bc0        busybox \"/bin/echo \\'Hello wo…\"   5 seconds ago       Exited (0) 3 seconds ago                       practical_franklin\\n', '创建一个交互式的容器\\n', '[root@localhost ~]# docker run -it busybox /bin/bash\\n', 'root@bf22919af2cf:/# ls \\n', 'bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var \\n', 'root@bf22919af2cf:/# pwd \\n', '/\\n', '-ti选项分配一个伪终端给容器并可以使用STDIN进行交互，可以看到这时可以在容器内执行一些命令。这时的容器看起来完全是一个独立的linux虚拟机。使用exit命令退出容器。\\n', '\\n', '后台运行容器\\n', '执行下面命令行，-d指示这个容器在后台运行，--name=container1 指定容器的名字为container1。\\n', '\\n', '[root@localhost ~]# docker run -d --name=container1 busybox /bin/sh -c \"while true;do echo hello world;sleep 1;done\"\\n', '7804d3e16d69b41aac5f9bf20d5f263e2da081b1de50044105b1e3f536b6db1c\\n', '命令行的执行结果是返回了这个容器的ID，没有返回命令的执行结果hello world，此时容器在后台运行，可以用docker ps命令查看正在运行的容器:\\n', '\\n', '[root@localhost ~]# docker ps\\n', 'CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES\\n', '7804d3e16d69        busybox \"/bin/sh -c \\'while tr\"   11 seconds ago      Up 10 seconds                           container1\\n', '用docker logs查看容器运行的输出：\\n', '\\n', '[root@localhost ~]# docker logs container1\\n', 'hello world\\n', 'hello world\\n', 'hello world\\n', '...\\n', '容器网络连接\\n', '默认情况下，容器可以访问外部网络，而外部网络访问容器时需要通过端口映射，下面以在docker中运行私有镜像库服务registry为例。下面的命令行中-P使registry镜像中开放的端口暴露给主机。\\n', '\\n', '[root@localhost ~]# docker run --name=container_registry -d -P registry \\n', 'cb883f6216c2b08a8c439b3957fb396c847a99079448ca741cc90724de4e4731 \\n', 'container_registry这个容器已经启动了，但是并不知道容器中的服务映射到主机的哪个端口，通过docker port查看端口映射。\\n', '\\n', '[root@localhost ~]# docker port container_registry \\n', '5000/tcp -> 0.0.0.0:49155 \\n', '从输出可以看出，容器内的5000端口映射到了主机的49155端口。通过主机IP:49155就可以访问registry服务了，在浏览器中输入http://localhost:49155就可以返回registry的版本信息。\\n', '\\n', '在运行registry镜像的时候还可以直接指定端口映射如：\\n', '\\n', 'docker run --name=container_registry -d -p 5000:5000 registry \\n', '通过-p 5000:5000指定容器的5000端口映射到主机的5000端口。\\n', '\\n', '注意事项\\n', '启动容器不能单独加-a stdin\\n', '\\n', '启动容器时，不能单独加-a stdin，必须要同时加上-a stdout或者-a stderr，否则会导致终端即使在容器退出后也会卡住。\\n', '\\n', '避免使用已有容器的长id、短id作为新容器的name\\n', '\\n', '创建容器时，避免使用已有容器A的长id或短id作为新容器B的name。若使用容器A的长id作为容器B的name，当使用容器B的name作为指定容器进行操作时，docker匹配到的是容器A。若使用容器A的短id作为容器B的name，当使用容器A的短id作为指定容器进行相关操作时，docker匹配到的是容器B。这是因为，docker在匹配容器时，先精确匹配所有容器的长id。若未匹配成功，再根据container_name进行精确匹配；若还未匹配成功，直接对容器id进行模糊匹配。\\n', '\\n', '使用sh/bash等依赖标准输入输出的容器应该使用`-ti`参数，避免出现异常\\n', '\\n', '正常情况：不用`-ti`参数启动sh/bash等进程容器，容器会马上退出。\\n', '\\n', '出现这种问题的原因在于，docker会先创建一个匹配用于容器内业务的stdin，在不设置-ti等交互式参数时，docker会在容器启动后关闭该pipe，而业务容器进程sh/bash在检测到stdin被关闭后会直接退出。\\n', '\\n', '异常情况：如果在上述过程中的特定阶段（关闭该pipe之前）强制杀死docker daemon，会导致该pipe的daemon端没有被及时关闭，这样即使不带`-ti`的sh/bash进程也不会退出，导致异常场景，这种容器就需要手动清理。\\n', '\\n', 'Daemon重启后会接管原有的容器stream，而不带`-ti`参数的容器可能就无法处理（因为正常情况下这些容器不存在stream需要接管）；真实业务下几乎不存在这种使用方式(不带 `-ti`的sh/bash没有任何作用)，为了避免这类问题发生，限制交互类容器应该使用 `-ti`参数。\\n', '\\n', '容器存储卷\\n', '\\n', '启动容器时如果通过`-v`参数将主机上的文件挂载到容器中，在主机或容器中使用vi或sed命令修改文件可能会使文件inode发生改变，从而导致主机和容器内的文件不同步。容器中挂载文件时应该尽量避免使用这种文件挂载的方式（或不与vi和sed同时使用），也可以通过挂载文件上层目录来避免该问题。在docker挂载卷时“nocopy”选项可以避免将容器内挂载点目录下原有的文件拷贝到主机源目录下，但是这个选项只能在挂载匿名卷时使用，不能在bind mount的场景下使用。\\n', '\\n', '避免使用可能会对host造成影响的选项\\n', '\\n', '--privileged 选项会让容器获得所有权限，容器可以做挂载操作和修改/proc、/sys等目录，可能会对host造成影响，普通容器需要避免使用该选项。\\n', '\\n', '共享host的namespace，比如--pid host/--ipc host/--net host等选项可以让容器跟host共享命名空间，同样会导致容器影响host的结果，需要避免使用。\\n', '\\n', 'kernel memory cgroup不稳定，禁止使用\\n', '\\n', 'kernel memory cgroup在小于4.0版本的Linux内核上仍属于实验阶段，运行起来不稳定，虽然Docker的Warning说是小于4.0就可以，但是我们评估认为，kmemcg在高版本内核仍然不稳定，所以不管是低版本还是高版本，均禁止使用。\\n', '\\n', '当docker run --kernel-memory时，会产生如下告警：\\n', '\\n', \"WARNING: You specified a kernel memory limit on a kernel older than 4.0. Kernel memory limits are experimental on older kernels, it won't work as expected as expected and can cause your system to be unstable.\\n\", 'blkio-weight参数在支持blkio精确控制的内核下不可用\\n', '\\n', '--blkio-weight-device 可以实现容器内更为精确的blkio控制，该控制需要指定磁盘设备，可以通过docker --blkio-weight-device参数实现。同时在这种内核下docker不再提供--blkio-weight方式限制容器blkio，使用该参数创建容器将会报错:\\n', '\\n', 'docker: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused \"process_linux.go:398: container init caused \\\\\"process_linux.go:369: setting cgroup config for ready process caused \\\\\\\\\\\\\"blkio.weight not supported, use weight_device instead\\\\\\\\\\\\\"\\\\\"\"\\n', '使用--blkio-weight-device需要磁盘支持CFQ调度策略\\n', '\\n', '--blkio-weight-device参数需要磁盘工作于完全公平队列调度（CFQ：Completely Fair Queuing）的策略时才能工作。\\n', '\\n', '通过查看磁盘scheduler文件（/sys/block/<磁盘>/queue/scheduler）可以获知磁盘支持的策略以及当前所采用的策略，如查看sda：\\n', '\\n', '# cat /sys/block/sda/queue/scheduler noop [deadline] cfq \\n', '当前sda支持三种调度策略：noop, deadline, cfq，并且正在使用deadline策略。通过echo修改策略为cfq：\\n', '\\n', '# echo cfq > /sys/block/sda/queue/scheduler\\n', '容器基础镜像中systemd使用限制\\n', '\\n', '通过基础镜像创建的容器在使用过程中，容器基础镜像中的systemd仅用于系统容器，普通容器不支持使用。\\n', '\\n', '并发性能\\n', 'docker内部的消息缓冲有一个上限，超过这个上限就会将消息丢弃，因此在并发执行命令时建议不要超过1000条命令，否则有可能会造成docker内部消息丢失，从而造成容器无法启动等严重问题。\\n', '并发创建容器并对容器执行restart时会偶现“oci runtime error: container init still running”报错，这是因为containerd对事件等待队列进行了性能优化，容器stop过程中执行runc delete，尝试在1s内kill掉容器的init进程，如果1s内init进程还没有被kill掉的话runc会返回该错误。由于containerd的GC（垃圾回收机制）每隔10s会回收之前runc delete的残留资源， 所以并不影响下次对容器的操作，一般出现上述报错的话等待4~5s之后再次启动容器即可。\\n', '安全特性解读\\n', 'docker默认的权能配置分析\\n', '\\n', '原生的docker默认配置如下，默认进程携带的Cap如下:\\n', '\\n', '\"CAP_CHOWN\", \\n', '\"CAP_DAC_OVERRIDE\", \\n', '\"CAP_FSETID\", \\n', '\"CAP_FOWNER\", \\n', '\"CAP_MKNOD\", \\n', '\"CAP_NET_RAW\", \\n', '\"CAP_SETGID\", \\n', '\"CAP_SETUID\", \\n', '\"CAP_SETFCAP\", \\n', '\"CAP_SETPCAP\", \\n', '\"CAP_NET_BIND_SERVICE\", \\n', '\"CAP_SYS_CHROOT\", \\n', '\"CAP_KILL\", \\n', '\"CAP_AUDIT_WRITE\",\\n', '默认的seccomp配置是白名单，不在白名单的syscall默认会返回SCMP_ACT_ERRNO，根据给docker不同的Cap开放不同的系统调用，不在上面的权限，默认docker都不会给到容器。\\n', '\\n', 'CAP_SYS_MODULE\\n', '\\n', 'CAP_SYS_MODULE这个Cap是让容器可以插入ko，增加该Cap可以让容器逃逸，甚至破坏内核。因为容器最大的隔离是Namespace，在ko中只要把他的Namespace指向init_nsproxy即可。\\n', '\\n', 'CAP_SYS_ADMIN\\n', '\\n', 'sys_admin权限给容器带来的能力有：\\n', '\\n', '文件系统（mount，umount，quotactl）\\n', 'namespace设置相关的（setns，unshare，clone new namespace）\\n', 'driver ioctl\\n', '对pci的控制，pciconfig_read, pciconfig_write, pciconfig_iobase\\n', 'sethostname\\n', 'CAP_NET_ADMIN\\n', '\\n', '容器中有访问网络接口的和sniff网络流量的权限，容器可以获取到所有容器包括host的网络流量，对网络隔离破坏极大。\\n', '\\n', 'CAP_DAC_READ_SEARCH\\n', '\\n', '该权限开放了，两个系统调用open_by_handle_at，name_to_handle_at，如果host上没有selinux保护，容器中可通过暴力搜索file_handle结构的inode号，进而可以打开host上的任意文件，影响文件系统的隔离性。\\n', '\\n', 'CAP_SYS_RAWIO\\n', '\\n', '容器中可对host写入io端口，可造成host内核崩溃。\\n', '\\n', 'CAP_SYS_PTRACE\\n', '\\n', '容器中有ptrace权限，可对容器的进程进行ptrace调试。现runc已经修补该漏洞，但有些工具比如nsenter和docker-enter并没有改保护，容器中可对这些工具执行的进程进行调试，获取这些工具带入的资源信息（Namespace、fd等），另外， ptrace可以绕过seccomp，极大增加内核攻击面。\\n', '\\n', 'Docker Cap接口 --cap-add all\\n', '\\n', '–cap-add all表示赋予容器所有的权能，包括本节提到的比较危险的权能，使得容器可以逃逸。\\n', '\\n', '不要禁用docker的seccomp特性\\n', '\\n', \"默认的docker有一个seccomp的配置，配置中使用的是白名单，不在配置的sys_call会被seccomp禁掉，使用接口–security-opt 'seccomp:unconfined'可以禁止使用seccomp特性。如果禁用seccomp或使用自定义seccomp配置但过滤名单不全，都会增加容器对内核的攻击面。\\n\", '\\n', '不要配置/sys和/proc目录可写\\n', '\\n', '/sys和/proc目录包含了linux维护内核参数、设备管理的接口，容器中配置该目录可写可能会导致容器逃逸。\\n', '\\n', 'Docker开放Cap --CAP_AUDIT_CONTROL\\n', '\\n', '容器可以通过控制系统audit系统，并且通过AUDIT_TTY_GET/AUDIT_TTY_SET等命令可以获取审计系统中记录的tty执行输入记录，包括root密码。\\n', '\\n', 'CAP_BLOCK_SUSPEND和CAP_WAKE_ALARM\\n', '\\n', '容器可拥有阻塞系统挂起(epoll)的能力。\\n', '\\n', 'CAP_IPC_LOCK\\n', '\\n', '容器拥有该权限后，可以突破ulimit中的max locked memory限制，任意mlock超大内存块，造成一定意义的DoS攻击。\\n', '\\n', 'CAP_SYS_LOG\\n', '\\n', '容器拥有该权限后，可以dmesg读取系统内核日志，突破内核kaslr防护。\\n', '\\n', 'CAP_SYS_NICE\\n', '\\n', '容器拥有该权限后，可以改变进程的调度策略和优先级，造成一定意义的DoS攻击。\\n', '\\n', 'CAP_SYS_RESOURCE\\n', '\\n', '容器可以绕过对其的一些资源限制，比如磁盘空间资源限制、keymaps数量限制、pipe-size-max限制等，造成一定意义的DoS攻击。\\n', '\\n', 'CAP_SYS_TIME\\n', '\\n', '容器可以改变host上的时间。\\n', '\\n', 'Docker默认Cap风险分析\\n', '\\n', 'Docker默认的Cap，包含了CAP_SETUID和CAP_FSETID，如host和容器共享目录，容器可对共享目录的二进制文件进行+s设置，host上的普通用户可使用其进行提权CAP_AUDIT_WRITE，容器可以对host写入，容器可以对host写入日志，host需配置日志防爆措施。\\n', '\\n', 'Docker和host共享namespace参数，比如 --pid，--ipc, --uts\\n', '\\n', '该参数为容器和host共享namespace空间，容器和host的namespace隔离没有了，容器可对host进行攻击。比如，使用--pid 和host共享pid namespace，容器中可以看到host上的进程pid号，可以随意杀死host的进程。\\n', '\\n', '--device 把host的敏感目录或者设备，映射到容器中\\n', '\\n', 'Docker管理面有接口可以把host上的目录或者设备映射到容器中，比如--device，-v等参数，不要把host上的敏感目录或者设备映射到容器中。\\n', '\\n', '创建容器使用hook-spec\\n', '原理及使用场景\\n', 'docker支持hook的扩展特性，hook应用与底层runc的执行过程中，遵循OCI标准：https://github.com/opencontainers/runtime-spec/blob/master/config.html#hooks 。\\n', '\\n', 'hook主要有三种类型：prestart，poststart，poststop。分别作用于容器内用户应用程序启动之前，容器应用程序启动之后，容器应用程序停止之后。\\n', '\\n', '接口参考\\n', '当前为docker run和create命令增加了参数“–hook-spec”，后面接spec文件的绝对路径，可以指定容器启动时的需要添加的hook，这些hook会自动附加在docker自己动态创建的hook后面（当前docker只有一个libnetwork的prestart hook），随容器的启动/销毁过程执行用户指定的程序。\\n', '\\n', 'spec的结构体定义为：\\n', '\\n', '// Hook specifies a command that is run at a particular event in the lifecycle of a container\\n', 'type Hook struct{       \\n', '               Path    string   `json:\"path\"`    \\n', '               Args    []string `json:\"args,omitempty\"`    \\n', '               Env     []string `json:\"env,omitempty\"`      \\n', '               Timeout *int     `json:\"timeout,omitempty\"`\\n', '}\\n', '// Hooks for container setup and teardown\\n', 'type  Hooks struct{\\n', '               // Prestart is a list of hooks to be run before the container process is executed.\\n', '               // On Linux, they are run after the container namespaces are created.         \\n', '               Prestart []Hook `json:\"prestart,omitempty\"`\\n', '               // Poststart is a list of hooks to be run after the container process is started.         \\n', '               Poststart []Hook `json:\"poststart,omitempty\"`\\n', '               // Poststop is a list of hooks to be run after the container process exits.         \\n', '               Poststop []Hook `json:\"poststop,omitempty\"`\\n', '}\\n', 'Spec文件的path、args、env 都是必填信息；\\n', 'Timeout选填(建议配置)，参数类型为int，不接受浮点数，范围为[1, 120]。\\n', 'Spec内容应该是json格式的，格式不对会报错，示例参考前面。\\n', '使用的时候既可以`docker run --hook-spec /tmp/hookspec.json xxx`, 也可以 `docker create --hook-spec /tmp/hookspec.json xxx && docker start xxx`。\\n', '为容器定制特有的hook\\n', '以启动过程中添加一个网卡的过程来说明。下面是相应的hook spec文件内容：\\n', '\\n', '{\\n', '    \"prestart\": [\\n', '         {\\n', '             \"path\": \"/var/lib/docker/hooks/network-hook\",             \\n', '             \"args\": [\"network-hook\", \"tap0\", \"myTap\"],             \\n', '             \"env\": [],\\n', '             \"timeout\": 5\\n', '         }\\n', '     ],\\n', '     \"poststart\":[],     \\n', '     \"poststop\":[]\\n', '}\\n', '指定prestart hook增加一个网络hook的执行。路径是/var/lib/docker/hooks/network-hook，args代表程序的参数，第一个参数一般是程序名字，第二个是程序接受的参数。对于network-hook这个hook程序，需要两个参数，第一个是主机上的网卡名字，第二个是在容器内的网卡重命名。\\n', '\\n', '  \\n', '\\n', '注意事项\\n', '\\n', 'hook path必须为docker的graph目录（--graph）下的hooks文件夹下，默认一般为 /var/lib/docker/hooks，可以通过docker info命令查看root路径。\\n', '\\n', '[root@localhost ~]# docker info \\n', '... \\n', 'Docker Root Dir: /var/lib/docker \\n', '...\\n', '这个路径可能会跟随用户手动配置，以及user namespace的使用（daemon –userns-remap）而变化。 path进行软链接解析后，必须以Docker Root Dir/hooks开头（如本例中使用 /var/lib/docker/hooks开头），否则会直接报错。\\n', '\\n', 'hooks path必须指定绝对路径，因为这个是由daemon处理，相对路径对daemon无意义。同时绝对路径也更满足安全要求。\\n', '\\n', 'hook程序打印到stderr的输出会打印给客户端并对容器的声明周期产生影响（比如启动失败），而输出到stdout的打印信息会被直接忽略。\\n', '\\n', '严禁在hook里反向调用docker的指令。\\n', '\\n', '配置的hook执行文件必须要有可执行权限，否则hook执行会报错。\\n', '\\n', '使用hook时，执行时间应尽量短。如果hook中的prestart时间过长（超过2分钟），则会导致容器启动超时失败，如果hook中的poststop时间过长（超过2分钟），也会导致容器异常。\\n', '\\n', '目前已知的异常如下：执行docker stop命令停止容器时，2分钟超时执行清理时，由于hook还没执行结束，因此会等待hook执行结束（该过程持有锁），从而导致和该容器相关的操作都会卡住，需要等到hook执行结束才能恢复。另外，由于docker stop命令的2分钟超时处理是异步的过程，因此即使docker stop命令返回了成功，容器的状态也依然是up状态，需要等到hook执行完后状态才会修改为exited。\\n', '\\n', '使用建议\\n', '\\n', '建议配置hook的Timeout超时时间阈值，超时时间最好在5s以内。\\n', '建议不要配置过多hook，每个容器建议prestart、poststart、poststop这三个hook都只配置一个，过多hook会导致启动时间长。\\n', '建议用户识别多个hook之间的依赖关系，如果存在依赖关系，在组合hook配置文件时要根据依赖关系灵活调整顺序，hook的执行顺序是按照配置的spec文件上的先后顺序。\\n', '多个hook-spec\\n', '当有多个hook配置文件，要运行多个hook时，用户必须自己手工将多个hook配置文件组合成一个配置文件，使用--hook-spec参数指定此合并后的配置文件，方可生效所有的hook；如果配置多个--hook-spec参数，则只有最后一个生效。\\n', '\\n', '配置举例：\\n', '\\n', 'hook1.json内容如下：\\n', '\\n', '# cat /var/lib/docker/hooks/hookspec.json \\n', '{\\n', '    \"prestart\": [\\n', '        {\\n', '            \"path\": \"/var/lib/docker/hooks/lxcfs-hook\",             \\n', '            \"args\": [\"lxcfs-hook\", \"--log\", \"/var/log/lxcfs-hook.log\"],             \\n', '            \"env\": []\\n', '        }\\n', '     ],     \\n', '     \"poststart\":[],     \\n', '     \"poststop\":[]\\n', '}\\n', 'hook2.json内容如下：\\n', '\\n', '# cat /etc/isulad-tools/hookspec.json \\n', '{\\n', '      \"prestart\": [\\n', '         {\\n', '               \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '               \"args\": [\"docker-hooks\", \"--state\", \"prestart\"],             \\n', '               \"env\": []\\n', '         }\\n', '       ],     \\n', '       \"poststart\":[],     \\n', '       \"poststop\":[\\n', '          {\\n', '               \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '               \"args\": [\"docker-hooks\", \"--state\", \"poststop\"],             \\n', '               \"env\": []\\n', '          }\\n', '        ]\\n', '}\\n', '手工合并后的json内容如下：\\n', '\\n', '{\\n', '       \"prestart\":[\\n', '          {\\n', '                \"path\": \"/var/lib/docker/hooks/lxcfs-hook\",             \\n', '                \"args\": [\"lxcfs-hook\", \"--log\", \"/var/log/lxcfs-hook.log\"],             \\n', '                \"env\": []\\n', '           },         \\n', '           {\\n', '                \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '                \"args\": [\"docker-hooks\", \"--state\", \"prestart\"],             \\n', '                \"env\": []\\n', '           }\\n', '        ],     \\n', '        \"poststart\":[],     \\n', '        \"poststop\":[\\n', '            {\\n', '                \"path\": \"/docker-root/hooks/docker-hooks\",             \\n', '                \"args\": [\"docker-hooks\", \"--state\", \"poststop\"],             \\n', '                \"env\": []\\n', '            }\\n', '         ]\\n', '}\\n', '需要注意的是，docker daemon会按照数组顺序依次读取hook配置文件中prestart等action中的hook二进制，进行执行动作。用户需要识别多个hook之间的依赖关系，如果有依赖关系，在组合hook配置文件时要根据依赖关系灵活调整顺序。\\n', '\\n', '为所有容器定制默认的hook\\n', 'Docker daemon同样可以接收–hook-spec的参数，–hook-spec的语义与docker create/run的–hook-spec参数相同，这里不再复述。也可以在/etc/docker/daemon.json里添加hook配置：\\n', '\\n', '{\\n', '     \"hook-spec\": \"/tmp/hookspec.json\"\\n', '}\\n', '容器在运行时，会首先执行daemon定义的–hook-spec中指定的hooks，然后再执行每个容器单独定制的hooks。\\n', '\\n', '创建容器配置健康检查\\n', 'Docker提供了用户定义的对容器进行健康检查的功能。在Dockerfile中配置HEALTHCHECK CMD选项，或在容器创建时配置--health-cmd选项，在容器内部周期性地执行命令，通过命令的返回值来监测容器的健康状态。\\n', '\\n', '配置方法\\n', '在Dockerfile中添加配置，如：\\n', '\\n', 'HEALTHCHECK --interval=5m --timeout=3s --health-exit-on-unhealthy=true \\\\\\n', '   CMD curl -f http://localhost/ || exit 1\\n', '可配置的选项：\\n', '\\n', '–interval=DURATION，默认 30s，相邻两次命令执行的间隔时间。另外，容器启动后，经过interval时间进行第一次检查。\\n', '\\n', '–timeout=DURATION，默认 30s，单次检查命令执行的时间上限，超时则任务命令执行失败。\\n', '\\n', '–start-period=DURATION，默认 0s，容器初始化时间。初始化期间也会执行健康检查，健康检查失败不会计入最大重试次数。但是，如果在初始化期间运行状况检查成功，则认为容器已启动。之后所有连续的检查失败都将计入最大重试次数。\\n', '\\n', '–retries=N，默认 3，健康检查失败最大的重试次数。\\n', '\\n', '–health-exit-on-unhealthy=BOOLEAN，默认false，检测到容器非健康时是否杀死容器\\n', '\\n', 'CMD，必选，在容器内执行的命令。返回值为0表示成功，非0表示失败。\\n', '\\n', '在配置了HEALTHCHECK后创建镜像，HEALTHCHECK相关配置会被写入镜像的配置中。通过docker inspect可以看到。如：\\n', '\\n', '\"Healthcheck\": {\\n', '    \"Test\": [\\n', '        \"CMD-SHELL\",\\n', '        \"/test.sh\"\\n', '    ]\\n', '},\\n', '在容器创建时的配置：\\n', '\\n', 'docker run -itd --health-cmd \"curl -f http://localhost/ || exit 1\" --health-interval 5m --health-timeout 3s --health-exit-on-unhealthy centos bash\\n', '可配置的选项：\\n', '\\n', '--health-cmd，必选，在容器内执行的命令。返回值为0表示成功，非0表示失败。\\n', '\\n', '--health-interval，默认 30s，最大为int64上限（纳秒）相邻两次命令执行的间隔时间。\\n', '\\n', '--health-timeout，默认 30s，最大为int64上限（纳秒），单次检查命令执行的时间上限，超时则任务命令执行失败。\\n', '\\n', '--health-start-period，默认 0s，最大为int64上限（纳秒），容器初始化时间。\\n', '\\n', '--health-retries，默认 3，最大为int32上限，健康检查失败最大的重试次数。\\n', '\\n', '--health-exit-on-unhealthy，默认false，检测到容器非健康时是否杀死容器。\\n', '\\n', '容器启动后，HEALTHCHECK相关配置会被写入容器的配置中。通过docker inspect可以看到。如：\\n', '\\n', '\"Healthcheck\": {\\n', '    \"Test\": [\\n', '        \"CMD-SHELL\",\\n', '        \"/test.sh\"\\n', '    ]\\n', '},\\n', '检查规则\\n', '容器启动后，容器状态中显示health:starting。\\n', '经过start-period时间后开始，以interval为间隔周期性在容器中执行CMD。即：当一次命令执行完毕后，经过interval时间，执行下一次命令。\\n', '若CMD命令在timeout限制的时间内执行完毕，并且返回值为0，则视为一次检查成功，否则视为一次检查失败。检查成功后，容器状态变为health:healthy。\\n', '若CMD命令连续retries次检查失败，则容器状态变为health:unhealthy。失败后容器也会继续进行健康检查。\\n', '容器状态为health:unhealthy时，任意一次检查成功会使得容器状态变为health:healthy。\\n', '设置–health-exit-on-unhealthy的情况下，如果容器因为非被杀死退出（退出返回值137）后，健康检查只有容器在重新启动后才会继续生效。\\n', 'CMD执行完毕或超时时，docker daemon会将这次检查的起始时间、返回值和标准输出记录到容器的配置文件中。最多记录最新的5条数据。此外，容器的配置文件中还存储着健康检查的相关参数。\\n', '通过docker ps可以看到容器状态。\\n', '\\n', '[root@bac shm]# docker ps\\n', 'CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                         PORTS               NAMES\\n', '7de2228674a2        testimg             \"bash\"              About an hour ago   Up About an hour (unhealthy)                       cocky_davinci\\n', '运行中的容器的健康检查状态也会被写入容器配置中。通过docker inspect可以看到。\\n', '\\n', '\"Health\": {\\n', '    \"Status\": \"healthy\",\\n', '    \"FailingStreak\": 0,\\n', '    \"Log\": [\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:15.481414707-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:15.556908311-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:18.557297462-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:18.63035891-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        ......\\n', '}\\n', ' 说明：\\n', '\\n', '容器内健康检查的状态信息最多保存5条。会保存最后得到的5条记录。\\n', '容器内健康检查相关配置同时最多只能有一条生效。Dockerfile中配置的靠后的条目会覆盖靠前的；容器创建时的配置会覆盖镜像中的。\\n', '在Dockerfile中可以通过 HEALTHCHECK NONE来取消引用的镜像中的健康检查配置。在容器运行时可以通过配置–no-healthcheck来取消镜像中的健康检查配置。不允许在启动时同时配置健康检查相关选项与–no-healthcheck选项。\\n', '带有健康检查配置的容器启动后，若docker daemon退出，则健康检查不会执行，一直等待。docker daemon再次启动后，容器健康状态会变为starting。之后检查规则同上。\\n', '构建容器镜像时若健康检查相关参数配置为空，则按照默认值处理。\\n', '容器启动时若健康检查相关参数配置为0，则按照默认值处理。\\n', '停止与删除容器\\n', '用docker stop停止名为container1的容器：\\n', '\\n', '[root@localhost ~]# docker stop container1\\n', '也可以用docker kill来杀死容器达到停止容器的目的：\\n', '\\n', '[root@localhost ~]# docker kill container1\\n', '当容器停止之后，可以使用docker rm删除容器：\\n', '\\n', '[root@localhost ~]# docker rm container1\\n', '当然，使用docker rm -f 强制删除容器也是可以的：\\n', '\\n', '[root@localhost ~]# docker rm -f container1\\n', '注意事项\\n', '禁止使用docker rm -f XXX 删除容器。如果使用强制删除，docker rm会忽略过程中的错误，可能导致容器相关元数据残留。如果使用普通删除，如果删除过程出错，则会删除失败，不会导致元数据残留。\\n', '避免使用docker kill命令。docker kill命令发送相关信号给容器内业务进程，依赖于容器内业务进程对信号的处理策略，可能导致业务进程的信号处理行为与指令的预期不符合的情况。\\n', 'docker stop处于restarting状态的容器可能容器不会马上停止。如果一个容器使用了重启规则，当容器处于restarting状态时，docker stop这个容器时有很低的概率会立即返回，容器仍然会在重启规则的作用下再次启动。\\n', '不能用docker restart重启加了–rm参数的容器。加了–rm参数的容器在退出时，容器会主动删除，如果重启一个加了–rm的参数的容器， 可能会导致一些异常情况，比如启动容器时，同时加了–rm与-ti参数，对容器执行restart操作，可能会概率性卡住无法退出。\\n', 'docker stop/restart 指定t参数且t<0时，请确保自己容器的应用会处理stop信号\\n', 'Stop的原理：（Restart会调用Stop流程）\\n', '\\n', 'Stop会首先给容器发送Stop 信号（15）\\n', '然后等待一定的时间（这个时间就是用户输入的 t）\\n', '过了一定时间，如果容器还活着，那么就发送kill信号（9）使容器强制退出\\n', '输入参数t（单位s）的含义：\\n', '\\n', 't<0 : 表示死等，不管多久都等待程序优雅退出，既然用户这么输入了，表示对自己的应用比较放心，认为自己的程序有合理的stop信号的处理机制\\n', 't=0 ： 表示不等，立即发送kill -9 到容器\\n', 't>0 ： 表示等一定的时间，如果容器还未退出，就发送kill -9 到容器\\n', '所以如果用户使用t<0 (比如t=-1)，请确保自己容器的应用会正确处理signal 15，如果容器忽略了该信号，会导致docker stop一直卡住。\\n', '\\n', '如果容器处于Dead状态，可能底层文件系统处于busy状态，需要手动删除\\n', 'Docker在执行容器删除时，先停止容器的相关进程，之后将容器状态更改为Dead，最后执行容器rootfs的删除操作。当文件系统或者device mapper处于忙碌状态时，最后一步rootfs的删除会失败。docker ps -a查看会发现容器处于Dead状态。Dead状态的容器不能再次启动，需要等待文件系统不繁忙时，手动再次执行docker rm进行删除。\\n', '\\n', '共享pid namespace容器，子容器处于pause状态会使得父容器stop卡住，并影响docker run命令执行\\n', '使用–pid参数创建共享pid namespace的父子容器，在执行docker stop父容器时，如果子容器中有进程无法退出（比如处于D状态、pause状态），会产生父容器docker stop命令等待的情况，需要手动恢复这些进程，才能正常执行命令。\\n', '\\n', '遇到该问题的时候，请对pause状态的容器使用docker inspect 命令查询 PidMode对应的父容器是否为需要docker stop的容器。如果是该容器，请使用docker unpause将子容器解除pause状态，指令即可继续执行。\\n', '\\n', '一般来说，导致该类问题的可能原因是容器对应的pid namespace由于进程残留导致无法被销毁。如果上述方法无法解决问题，可以通过借助linux工具，获取容器内残留进程，确定pid namespace中进程无法退出的原因，解决后容器就可以退出：\\n', '\\n', '获取容器pid namespace id\\n', '\\n', 'docker inspect --format={{.State.Pid}} CONTAINERID | awk \\'{print  \"/proc/\"$1\"/ns/pid\"}\\' |xargs readlink\\n', '获取该namespace下的线程\\n', '\\n', \" ls -l /proc/*/task/*/ns/pid |grep -F PIDNAMESPACE_ID |awk '{print $9}' |awk -F  \\\\/ '{print $5}'\\n\", '容器信息查询\\n', '在任何情况下，容器的状态都不应该以docker命令执行是否成功返回为判断标准。如想查看容器状态，建议使用：\\n', '\\n', 'docker inspect <NAME|ID>\\n', '修改操作\\n', 'docker exec进入容器启动多个进程的注意事项\\n', 'docker exec进入容器执行的第一个命令为 bash 命令时，当退出 exec 时，要保证在这次exec启动的进程都退出了，再执行exit退出，否则会导致exit退出时终端卡主的情况。如果要在exit退出时，exec中启动的进程仍然在后台保持运行，要在启动进程时加上nohup。\\n', '\\n', 'docker rename和docker stats <container_name>的使用冲突\\n', '如果使用docker stats <container_name> 实时监控容器，当使用docker rename重命名容器之后，docker stats中显示的名字将还是原来的名字，不是rename后的名字。\\n', '\\n', 'docker rename操作restarting状态的容器可能会失败\\n', '对一个处于restarting状态的容器执行rename操作的时候，docker会同步修改容器网络的相关配置。由于restarting状态的容器可能还未真正启动起来，网络是不存在的，导致rename操作报错sandbox不存在。建议rename只操作非restarting的稳定状态的容器。\\n', '\\n', 'docker cp\\n', '使用docker cp向容器中拷贝文件时，docker ps以及所有对这个容器的操作都将等待docker cp结束之后才能进行。\\n', '容器以非root用户运行，当使用docker cp命令复制主机上的一个非root权限的文件到容器时，文件在容器中的权限角色会变成root。docker cp与cp命令不同，docker cp会修改复制到容器中文件的uid和gid为root。\\n', 'docker login\\n', '执行docker login后，会将usrer/passwd经 aes（256位）加密后保存在/root/.docker/config.json，同时生成 root.docker/aeskey(权限0600)，用来解密/root/.docker/config.json中的 usrer/passwd。目前不能定时更新aeskey，只能由用户手动删除aeskey来更新。aeskey更新后，不管是否重启过docker daemon，都需要重新login，才可以push。例如：\\n', '\\n', 'root@hello:~/workspace/dockerfile# docker login \\n', \"Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. \\n\", 'Username: example Password: \\n', 'Login Succeeded \\n', 'root@hello:~/workspace/dockerfile# docker push example/empty \\n', 'The push refers to a repository [docker.io/example/empty] \\n', '547b6288eb33: Layer already exists \\n', 'latest: digest: sha256:99d4fb4ce6c6f850f3b39f54f8eca0bbd9e92bd326761a61f106a10454b8900b size: 524 \\n', 'root@hello:~/workspace/dockerfile# rm /root/.docker/aeskey \\n', 'root@hello:~/workspace/dockerfile# docker push example/empty \\n', 'WARNING: Error loading config file:/root/.docker/config.json - illegal base64 data at input byte 0 \\n', 'The push refers to a repository [docker.io/example/empty] \\n', '547b6288eb33: Layer already exists \\n', 'errors: \\n', 'denied: requested access to the resource is denied \\n', 'unauthorized: authentication required \\n', 'root@hello:~/workspace/dockerfile# docker login \\n', \"Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. \\n\", 'Username: example \\n', 'Password: \\n', 'Login Succeeded \\n', 'root@hello:~/workspace/dockerfile# docker push example/empty \\n', 'The push refers to a repository [docker.io/example/empty] \\n', '547b6288eb33: Layer already exists \\n', 'latest: digest: sha256:99d4fb4ce6c6f850f3b39f54f8eca0bbd9e92bd326761a61f106a10454b8900b size: 524']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_使用kickstart自动化安装.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E4%BD%BF%E7%94%A8kickstart%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%89%E8%A3%85.html", "text_entry": "['使用kickstart自动化安装\\n', '使用kickstart自动化安装\\n', '总体介绍\\n', '概述\\n', '优缺点对比\\n', '背景知识\\n', '半自动化安装指导\\n', '环境要求\\n', '操作步骤\\n', '全自动化安装指导\\n', '环境要求\\n', '操作步骤\\n', '总体介绍\\n', '概述\\n', '用户可以使用kickstart工具进行openEuler系统的自动化安装，包括如下两种方式：\\n', '\\n', '半自动化安装：安装人员不需要手动设定操作系统的键盘、语言、分区等具体属性（通过kickstart实现自动化），但是需要手动指定kickstart文件的位置。\\n', '全自动化安装：实现操作系统的安装过程全自动化。\\n', '优缺点对比\\n', '使用kickstart工具进行半自动化安装和全自动化安装的优缺点对比如表1所示，用户可以自行选择安装方式。\\n', '\\n', '表 1 优缺点对比\\n', '\\n', '\\n', '安装方式\\n', '\\n', '优点\\n', '\\n', '缺点\\n', '\\n', '半自动化安装\\n', '\\n', '不需要准备tftp，pxe，dhcp等服务\\n', '\\n', '需要手动指定kickstart文件的位置\\n', '\\n', '全自动化安装\\n', '\\n', '操作系统的全自动化安装\\n', '\\n', '需要配置tftp，dhcpd，pxe等服务\\n', '\\n', '背景知识\\n', 'kickstart\\n', '\\n', 'kickstart是一种无人值守的安装方式。它的工作原理是在安装过程中记录典型的需要人工干预填写的各种参数，并生成一个配置文件（ks.cfg），在安装过程中，安装程序首先会去查找ks配置文件，如果找到合适的参数，就采用所找到的参数；如果没有找到合适的参数，便需要安装者手工设定。所以，如果kickstart文件涵盖了安装过程中需要设定的所有参数，安装者只需要告诉安装程序从何处取ks.cfg文件，就能实现系统安装的自动化。\\n', '\\n', 'kickstart 安装提供一个安装过程自动化的方法，可以是部分自动化，也可以是完全自动化。\\n', '\\n', 'PXE\\n', '\\n', 'PXE（Pre-boot Execution Environment，预启动执行环境），工作于Client/Server的网络模式，支持PXE的客户端在启动过程中，能够从DHCP服务器获取IP结合TFTP等协议可以实现客户端的网络引导和安装。\\n', '\\n', 'TFTP\\n', '\\n', 'TFTP（Trivial File Transfer Protocol，简单文件传输协议），该协议用来实现客户机与服务器之间的简单文件传输，它提供不复杂、开销不大的文件传输服务。\\n', '\\n', '半自动化安装指导\\n', '环境要求\\n', '使用kickstart进行openEuler系统的半自动化安装的环境要求如下：\\n', '\\n', '物理机/虚拟机（虚拟机创建可参考对应厂商的资料）。包括使用kickstart工具进行自动化安装的计算机和被安装的计算机。\\n', 'httpd：存放kickstart文件。\\n', 'ISO： openEuler-22.03_LTS-aarch64-dvd.iso\\n', '操作步骤\\n', '使用kickstart进行openEuler系统的半自动化安装的操作步骤如下：\\n', '\\n', '环境准备\\n', '\\n', ' 说明：\\n', '安装之前，请确保http服务器的防火墙处于关闭状态。关闭防火墙可参照如下命令：\\n', '\\n', 'iptables -F  \\n', 'httpd的安装与服务启动。\\n', '\\n', '# dnf install httpd -y\\n', '# systemctl start httpd\\n', '# systemctl enable httpd\\n', 'kickstart文件的准备。\\n', '\\n', '# mkdir /var/www/html/ks\\n', '# vim /var/www/html/ks/openEuler-ks.cfg ===>根据已安装openEuler系统自动生成的anaconda-ks.cfg修改得到\\n', '====================================\\n', '***以下内容需要根据实际需求进行修改***\\n', '#version=DEVEL\\n', 'ignoredisk --only-use=sda\\n', 'autopart --type=lvm\\n', '# Partition clearing information\\n', 'clearpart --none --initlabel\\n', '# Use graphical install\\n', 'graphical\\n', '# Use CDROM installation media\\n', 'cdrom\\n', '# Keyboard layouts\\n', \"keyboard --vckeymap=cn --xlayouts='cn'\\n\", '# System language\\n', 'lang zh_CN.UTF-8\\n', '\\n', '# Network information\\n', 'network  --bootproto=dhcp --device=enp4s0 --ipv6=auto --activate\\n', 'network  --hostname=openeuler.com\\n', '# Root password\\n', 'rootpw --iscrypted $6$fQE83lxEZ48Or4zc$j7/PlUMHn29yTjCD4Fi44WTZL/RzVGxJ/7MGsZMl6QfE3KjIVT7M4UrhFXbafvRq2lUddAFcyWHd5WRmXfEK20\\n', '# Run the Setup Agent on first boot\\n', 'firstboot --enable\\n', '# Do not configure the X Window System\\n', 'skipx\\n', '# System services\\n', 'services --disabled=\"chronyd\"\\n', '# System timezone\\n', 'timezone Asia/Shanghai --isUtc--nontp\\n', '\\n', '%packages\\n', '@^minimal-environment\\n', '@standard\\n', '\\n', '%end\\n', '\\n', '%anaconda\\n', 'pwpolicy root --minlen=8 --minquality=1 --notstrict --nochanges --notempty\\n', 'pwpolicy user --minlen=8 --minquality=1 --notstrict --nochanges --emptyok\\n', 'pwpolicy luks --minlen=8 --minquality=1 --notstrict --nochanges --notempty\\n', '%end\\n', '\\n', '%post\\n', '#enable kdump\\n', 'sed  -i \"s/ ro / ro crashkernel=1024M,high /\" /boot/efi/EFI/openEuler/grub.cfg\\n', '%end\\n', '=====================================\\n', ' 说明：\\n', '密码密文生成方式：\\n', '\\n', '# python3  \\n', 'Python 3.7.0 (default, Apr  1 2019, 00:00:00)  \\n', '[GCC 7.3.0] on linux  \\n', 'Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.  \\n', '>>> import crypt  \\n', '>>> passwd = crypt.crypt(\"myPasswd\")  \\n', '>>> print (passwd)  \\n', '$6$63c4tDmQGn5SDayV$mZoZC4pa9Jdt6/ALgaaDq6mIExiOO2EjzomB.Rf6V1BkEMJDcMddZeGdp17cMyc9l9ML9ldthytBEPVcnboR/0  \\n', '将ISO镜像文件挂载到需要安装openEuler计算机的光驱上。\\n', '\\n', '另外，也可以选择NFS等网络安装，kickstart文件中需要指定安装源位置（默认是cdrom）。\\n', '\\n', '安装系统\\n', '\\n', '启动系统进入安装选择界面。\\n', '\\n', '在“启动安装”中的“安装引导界面”中选择“Install openEuler 22.03_LTS”，并按下“e”键。\\n', '\\n', '启动参数中追加“inst.ks=http://server ip/ks/openEuler-ks.cfg”。\\n', '\\n', '\\n', '\\n', '按“Ctrl+x”，开始系统的自动安装。\\n', '\\n', '确认系统安装完毕。\\n', '\\n', '系统安装完毕以后会自动重启，如果优先从光驱启动，会再次进入到安装界面，此时关闭计算机，调整启动顺序（优先从硬盘启动）。\\n', '\\n', '\\n', '\\n', '全自动化安装指导\\n', '环境要求\\n', '使用kickstart进行openEuler系统的全自动化安装的环境要求如下：\\n', '\\n', '物理机/虚拟机（虚拟机创建可参考对应厂商的资料）。包括使用kickstart工具进行自动化安装的计算机和被安装的计算机。\\n', 'httpd：存放kickstart文件。\\n', 'tftp：提供vmlinuz和initrd文件。\\n', 'dhcpd/pxe：提供DHCP服务。\\n', 'ISO：openEuler-22.03_LTS-aarch64-dvd.iso。\\n', '操作步骤\\n', '使用kickstart进行openEuler系统的全自动化安装的操作步骤如下：\\n', '\\n', '环境准备\\n', '\\n', ' 说明：\\n', '安装之前，请确保http服务器的防火墙处于关闭状态。关闭防火墙可参照如下命令：\\n', '\\n', 'iptables -F  \\n', 'httpd的安装与服务启动。\\n', '\\n', '# dnf install httpd -y\\n', '# systemctl start httpd\\n', '# systemctl enable httpd\\n', 'tftp的安装与配置。\\n', '\\n', '# dnf install tftp-server -y\\n', '# vim /etc/xinetd.d/tftp\\n', 'service tftp\\n', '{\\n', 'socket_type = dgram\\n', 'protocol = udp\\n', 'wait = yes\\n', 'user = root\\n', 'server = /usr/sbin/in.tftpd\\n', 'server_args = -s /var/lib/tftpboot\\n', 'disable = no\\n', 'per_source = 11\\n', 'cps = 100 2\\n', 'flags = IPv4\\n', '}\\n', '# systemctl start tftp\\n', '# systemctl enable tftp\\n', '# systemctl start xinetd\\n', '# systemctl status xinetd\\n', '# systemctl enable xinetd\\n', '安装源的制作。\\n', '\\n', '# mount openEuler-22.03_LTS-aarch64-dvd.iso /mnt\\n', '# cp -r /mnt/* /var/www/html/openEuler/\\n', '设置和修改kickstart配置文件 openEuler-ks.cfg，参考3安装源的目录，此处选择http安装源。\\n', '\\n', '#vim  /var/www/html/ks/openEuler-ks.cfg\\n', '====================================\\n', '***以下内容根据实际需求进行修改***\\n', '#version=DEVEL\\n', 'ignoredisk --only-use=sda\\n', 'autopart --type=lvm\\n', '# Partition clearing information\\n', 'clearpart --none --initlabel\\n', '# Use graphical install\\n', 'graphical\\n', '# Keyboard layouts\\n', \"keyboard --vckeymap=cn --xlayouts='cn'\\n\", '# System language\\n', 'lang zh_CN.UTF-8\\n', '#Use http installation source\\n', 'url --url=http://192.168.122.1/openEuler/\\n', '%post\\n', '#enable kdump\\n', 'sed  -i \"s/ ro / ro crashkernel=1024M,high /\" /boot/efi/EFI/openEuler/grub.cfg\\n', '%end\\n', '...\\n', '修改pxe配置文件grub.cfg， 可参考如下内容(注意：openEuler当前不支持bls格式的cfg文件)。\\n', '\\n', '# cp -r /mnt/images/pxeboot/* /var/lib/tftpboot/\\n', '# cp /mnt/EFI/BOOT/grubaa64.efi /var/lib/tftpboot/\\n', '# cp /mnt/EFI/BOOT/grub.cfg /var/lib/tftpboot/\\n', '# ls /var/lib/tftpboot/\\n', 'grubaa64.efi  grub.cfg  initrd.img  TRANS.TBL  vmlinuz\\n', '# vim /var/lib/tftpboot/grub.cfg\\n', 'set default=\"1\"\\n', '\\n', 'function load_video {\\n', '  if [ x$feature_all_video_module = xy ]; then\\n', '    insmod all_video\\n', '  else\\n', '    insmod efi_gop\\n', '    insmod efi_uga\\n', '    insmod ieee1275_fb\\n', '    insmod vbe\\n', '    insmod vga\\n', '    insmod video_bochs\\n', '    insmod video_cirrus\\n', '  fi\\n', '}\\n', '\\n', 'load_video\\n', 'set gfxpayload=keep\\n', 'insmod gzio\\n', 'insmod part_gpt\\n', 'insmod ext2\\n', '\\n', 'set timeout=60\\n', '\\n', '\\n', '### BEGIN /etc/grub.d/10_linux ###\\n', \"menuentry 'Install openEuler 22.03_LTS ' --class red --class gnu-linux --class gnu --class os {\\n\", '        set root=(tftp,192.168.1.1)\\n', '        linux /vmlinuz ro inst.geoloc=0 console=ttyAMA0 console=tty0 rd.iscsi.waitnet=0 inst.ks=http://192.168.122.1/ks/openEuler-ks.cfg\\n', '        initrd /initrd.img\\n', '}\\n', 'DHCP的配置（可以使用dnsmasq代替 ）。\\n', '\\n', '# dnf install dhcp -y\\n', '#\\n', '# DHCP Server Configuration file.\\n', '#   see /usr/share/doc/dhcp-server/dhcpd.conf.example\\n', '#   see dhcpd.conf(5) man page\\n', '#\\n', '# vim /etc/dhcp/dhcpd.conf\\n', 'ddns-update-style interim;\\n', 'ignore client-updates;\\n', 'filename \"grubaa64.efi\"; \\u3000\\u3000 # pxelinux 启动文件位置;\\n', 'next-server 192.168.122.1;\\u3000\\u3000# (重要)TFTP Server 的IP地址;\\n', 'subnet 192.168.122.0 netmask 255.255.255.0 {\\n', 'option routers 192.168.122.1; # 网关地址\\n', 'option subnet-mask 255.255.255.0; # 子网掩码\\n', 'range dynamic-bootp 192.168.122.50 192.168.122.200; # 动态ip范围\\n', 'default-lease-time 21600;\\n', 'max-lease-time 43200;\\n', '}\\n', '# systemctl start dhcpd\\n', '# systemctl enable dhcpd\\n', '安装系统\\n', '\\n', '在“Start boot option”界面按下“F2”选择从网络pxe启动，开始自动化安装。\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '\\n', '进入系统全自动化安装界面。\\n', '\\n', '确认系统安装完毕。\\n', '\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_构建指导_容器构建指导.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/%E5%AE%B9%E5%99%A8%E6%9E%84%E5%BB%BA%E6%8C%87%E5%AF%BC.html", "text_entry": "['容器构建指导\\n', '由于openEuler Embedded构建过程需要基于openEuler操作系统，且需要安装较多系统工具和构建工具。为方便开发人员快速搭建构建环境，我们将构建过程所依赖的操作系统和工具封装到一个容器中，这就使得开发人员可以快速搭建一个构建环境，进而投入到代码开发中去，避免在准备环境阶段消耗大量时间。\\n', '\\n', '环境准备\\n', '安装docker\\n', '获取容器镜像\\n', '准备容器构建环境\\n', '版本构建\\n', '下载源码\\n', '编译构建\\n', '构建结果说明\\n', '环境准备\\n', '需要使用docker创建容器环境，为了确保docker成功安装，需满足以下软件硬件要求：\\n', '\\n', '操作系统: 推荐使用Ubuntu、Debian和RHEL（Centos、Fedora等）\\n', '内核: 推荐3.8及以上的内核\\n', '驱动: 内核必须支持一种合适的存储驱动，例如: Device Mapper、AUFS、vfs、btrfs、ZFS\\n', '架构: 运行64位架构的计算机（x86_64和amd64）\\n', '安装docker\\n', '检查当前环境是否已安装docker工具\\n', '运行如下命令，可以看到当前docker版本信息，则说明当前环境已安装docker，无需再次安装。\\n', '\\n', 'docker version\\n', '如果没有安装，可参考官方链接安装\\n', '官网地址: http://www.dockerinfo.net/document，openEuler环境可参考Centos安装Docker。\\n', '\\n', '例如openEuler环境docker安装命令如下：\\n', '\\n', 'sudo yum install docker\\n', '获取容器镜像\\n', '通过docker pull命令拉取华为云中的镜像到宿主机。命令如下：\\n', '\\n', 'docker pull swr.cn-north-4.myhuaweicloud.com/openeuler-embedded/openeuler-container:22.03-lts\\n', '准备容器构建环境\\n', '1.启动容器\\n', '可通过docker run命令启动容器，为了保证容器启动后可以在后台运行，且可以正常访问网络，建议使用如下命令启动：\\n', '\\n', 'docker run -idt --network host swr.cn-north-4.myhuaweicloud.com/openeuler-embedded/openeuler-container:22.03-lts bash\\n', '参数说明:\\n', '\\n', '-i 让容器的标准输入保持打开\\n', '-d 让 Docker 容器在后台以守护态（Daemonized）形式运行\\n', '-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上\\n', '–network 将容器连接到（host）网络\\n', 'swr.cn-north-4.myhuaweicloud.com/openeuler-embedded/openeuler-container 指定镜像名称\\n', 'bash 进入容器的方式\\n', '2.查看已启动的容器id\\n', 'docker ps\\n', '3.进入容器\\n', 'docker exec -it 容器id bash\\n', '构建环境已准备完成，下面就可以在容器中进行构建了。\\n', '\\n', '版本构建\\n', '下载源码\\n', '获取源码下载脚本\\n', 'git clone https://gitee.com/openeuler/yocto-meta-openeuler.git -b openEuler-22.03-LTS -v /usr1/openeuler/src/yocto-meta-openeuler\\n', '通过脚本下载源码\\n', 'cd /usr1/openeuler/src/yocto-meta-openeuler/scripts\\n', 'sh download_code.sh /usr1/openeuler/src\\n', '编译构建\\n', '编译架构: aarch64-std、aarch64-pro、arm-std、raspberrypi4-64\\n', '构建目录: /usr1/build\\n', '源码目录: /usr1/openeuler/src\\n', '编译器所在路径: /usr1/openeuler/gcc/openeuler_gcc_arm64le\\n', ' 说明：\\n', '\\n', '不同的编译架构使用不同的编译器，aarch64-std、aarch64-pro、raspberrypi4-64使用openeuler_gcc_arm64le编译器，arm-std使用openeuler_gcc_arm32le编译器。\\n', '下面以以aarch64-std目标架构编译为例。\\n', '将/usr1目录所属群组改为openeuler，否则切换至openeuler用户构建会存在权限问题。\\n', 'chown -R openeuler:users /usr1\\n', '切换至openeuler用户。\\n', 'su openeuler\\n', '进入构建脚本所在路径，运行编译脚本。\\n', 'cd /usr1/openeuler/src/yocto-meta-openeuler/scripts\\n', 'source compile.sh aarch64-std /usr1/build /usr1/openeuler/gcc/openeuler_gcc_arm64le\\n', 'bitbake openeuler-image\\n', '构建结果说明\\n', '结果件默认生成在构建目录下的output目录下，例如上面aarch64-std的构建结果件生成在/usr1/build/output目录下，如下表：\\n', '\\n', 'filename\\tdescription\\n', 'Image-*\\topenEuler Embedded image\\n', 'openeuler-glibc-x86_64-openeuler-image-*-toolchain-*.sh\\topenEuler Embedded sdk toolchain\\n', 'openeuler-image-qemu-aarch64-*.rootfs.cpio.gz\\topenEuler Embedded file system\\n', 'zImage\\topenEuler Embedded compressed image\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_安全容器_使用方法_监控安全容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%9B%91%E6%8E%A7%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8.html", "text_entry": "['监控安全容器\\n', '描述\\n', 'kata events命令用于显示指定容器状态。包括但不限于容器内存、CPU、Pid、 Blkio、大页内存、网络等信息。\\n', '\\n', '用法\\n', 'kata-runtime events [command options] <container-id>\\n', '参数\\n', '-- interval value：设置查询周期。如果不使用该参数，默认查询周期为5秒。\\n', '--stats： 显示容器信息并退出查询。\\n', '前置条件\\n', '要查询的容器状态必须为running，否则报错：Container ID (<container_id>) does not exist。\\n', '\\n', '该命令只支持查询监控一个容器的状态\\n', '\\n', '示例\\n', '每隔三秒显示容器状态。\\n', '\\n', '$ kata-runtime events --interval 3s 5779b2366f47\\n', '{\\n', '    \"data\": {\\n', '        \"blkio\": {},\\n', '        \"cpu\": {\\n', '            \"throttling\": {},\\n', '            \"usage\": {\\n', '                \"kernel\": 130000000,\\n', '                \"percpu\": [\\n', '                    214098440\\n', '                ],\\n', '                \"total\": 214098440,\\n', '                \"user\": 10000000\\n', '            }\\n', '        },\\n', '        \"hugetlb\": {},\\n', '        \"intel_rdt\": {},\\n', '        \"interfaces\": [\\n', '            {\\n', '                \"name\": \"lo\",\\n', '                \"rx_bytes\": 0,\\n', '                \"rx_dropped\": 0,\\n', '                \"rx_errors\": 0,\\n', '                \"rx_packets\": 0,\\n', '                \"tx_bytes\": 0,\\n', '                \"tx_dropped\": 0,\\n', '                \"tx_errors\": 0,\\n', '                \"tx_packets\": 0\\n', '            }\\n', '        ],\\n', '        \"memory\": {\\n', '            \"cache\": 827392,\\n', '            \"kernel\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 9223372036854771712,\\n', '                \"max\": 421888,\\n', '                \"usage\": 221184\\n', '            },\\n', '            \"kernelTCP\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 0\\n', '            },\\n', '            \"raw\": {\\n', '                \"active_anon\": 49152,\\n', '                \"active_file\": 40960,\\n', '                \"cache\": 827392,\\n', '                \"dirty\": 0,\\n', '                \"hierarchical_memory_limit\": 9223372036854771712,\\n', '                \"hierarchical_memsw_limit\": 9223372036854771712,\\n', '                \"inactive_anon\": 0,\\n', '                \"inactive_file\": 839680,\\n', '                \"mapped_file\": 540672,\\n', '                \"pgfault\": 6765,\\n', '                \"pgmajfault\": 0,\\n', '                \"pgpgin\": 12012,\\n', '                \"pgpgout\": 11803,\\n', '                \"rss\": 4096,\\n', '                \"rss_huge\": 0,\\n', '                \"shmem\": 32768,\\n', '                \"swap\": 0,\\n', '                \"total_active_anon\": 49152,\\n', '                \"total_active_file\": 40960,\\n', '                \"total_cache\": 827392,\\n', '                \"total_dirty\": 0,\\n', '                \"total_inactive_anon\": 0,\\n', '                \"total_inactive_file\": 839680,\\n', '                \"total_mapped_file\": 540672,\\n', '                \"total_pgfault\": 6765,\\n', '                \"total_pgmajfault\": 0,\\n', '                \"total_pgpgin\": 12012,\\n', '                \"total_pgpgout\": 11803,\\n', '                \"total_rss\": 4096,\\n', '                \"total_rss_huge\": 0,\\n', '                \"total_shmem\": 32768,\\n', '                \"total_swap\": 0,\\n', '                \"total_unevictable\": 0,\\n', '                \"total_writeback\": 0,\\n', '                \"unevictable\": 0,\\n', '                \"writeback\": 0\\n', '            },\\n', '            \"swap\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 9223372036854771712,\\n', '                \"max\": 34201600,\\n', '                \"usage\": 1204224\\n', '            },\\n', '            \"usage\": {\\n', '                \"failcnt\": 0,\\n', '                \"limit\": 9223372036854771712,\\n', '                \"max\": 34201600,\\n', '                \"usage\": 1204224\\n', '            }\\n', '        },\\n', '        \"pids\": {\\n', '            \"current\": 1\\n', '        },\\n', '        \"tcp\": {},\\n', '        \"tcp6\": {},\\n', '        \"udp\": {},\\n', '        \"udp6\": {}\\n', '    },\\n', '    \"id\": \"5779b2366f47cd1468ebb1ba7c52cbdde3c7d3a5f2af3eefadc8356700fc860b\",\\n', '    \"type\": \"stats\"\\n', '}\\n', '显示容器状态并立即返回\\n', '\\n', 'kata-runtime events --stats <container_id>\\n', '该命令返回内容的格式与上一条相同，区别为只显示一次信息后便退出。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理进程.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B.html", "text_entry": "['管理进程\\n', '操作系统管理多个用户的请求和多个任务。大多数系统都只有一个CPU和一个主要存储，但一个系统可能有多个二级存储磁盘和多个输入/输出设备。操作系统管理这些资源并在多个用户间共享资源，当用户提出一个请求时，造成好像系统被用户独占的假象。实际上操作系统监控着一个等待执行的任务队列，这些任务包括用户任务、操作系统任务、邮件和打印任务等。本章节将从用户的角度讲述如何控制进程。\\n', '\\n', '管理进程\\n', '查看进程\\n', 'who命令\\n', 'ps命令\\n', 'top命令\\n', 'kill命令\\n', '调度启动进程\\n', '定时运行一批程序（at）\\n', '周期性运行一批程序（cron）\\n', '挂起/恢复进程\\n', '查看进程\\n', 'Linux是一个多任务系统，经常需要对这些进程进行一些调配和管理。要进行管理，首先就要知道现在的进程情况：有哪些进程、进程的状态如何等。Linux提供了多种命令来了解进程的状况。\\n', '\\n', 'who命令\\n', 'who命令主要用于查看当前系统中的用户情况。如果用户想和其他用户建立即时通讯，比如使用talk命令，那么首先要确定的就是该用户确实在线上，不然talk进程就无法建立起来。又如，系统管理员希望监视每个登录的用户此时此刻的所作所为，也要使用who命令。who命令应用起来非常简单，可以比较准确地掌握用户的情况，所以使用非常广泛。\\n', '\\n', '例如查看系统中的用户及其状态。使用如下：\\n', '\\n', '$ who\\n', 'admin     tty1         Jul 28 15:55\\n', 'admin     pts/0        Aug  5 15:46 (192.168.0.110)\\n', 'admin     pts/2        Jul 29 19:52 (192.168.0.110)\\n', 'root     pts/3        Jul 30 12:07 (192.168.0.110)\\n', 'root     pts/4        Jul 31 10:29 (192.168.0.144)\\n', 'root     pts/5        Jul 31 14:52 (192.168.0.11)\\n', 'root     pts/6        Aug  6 10:12 (192.168.0.234)\\n', 'root     pts/8        Aug  6 11:34 (192.168.0.234)\\n', 'ps命令\\n', 'ps命令是最基本又非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等，大部分进程信息都是可以通过执行该命令得到的。\\n', '\\n', 'ps命令最常用的还是用来监控后台进程的工作情况，因为后台进程是不与屏幕、键盘这些标准输入/输出设备进行通信的，所以如果需要检测其状况，就可使用ps命令。ps命令的常见选项如表1所示。\\n', '\\n', '表 1 选项说明\\n', '\\n', '\\n', '选项\\n', '\\n', '描述\\n', '\\n', '-e\\n', '\\n', '显示所有进程。\\n', '\\n', '-f\\n', '\\n', '全格式。\\n', '\\n', '-h\\n', '\\n', '不显示标题。\\n', '\\n', '-l\\n', '\\n', '使用长格式。\\n', '\\n', '-w\\n', '\\n', '宽行输出。\\n', '\\n', '-a\\n', '\\n', '显示终端上的所有进程，包括其他用户的进程。\\n', '\\n', '-r\\n', '\\n', '只显示正在运行的进程。\\n', '\\n', '-x\\n', '\\n', '显示没有控制终端的进程。\\n', '\\n', '例如显示系统中终端上的所有进行进程。命令如下：\\n', '\\n', '$ ps -a\\n', '  PID TTY          TIME CMD\\n', '12175 pts/6    00:00:00 bash\\n', '24526 pts/0    00:00:00 vsftpd\\n', '29478 pts/5    00:00:00 ps\\n', '32461 pts/0    1-01:58:33 sh\\n', 'top命令\\n', 'top命令和ps命令的基本作用是相同的，显示系统当前的进程和其他状况，但是top是一个动态显示过程，即可以通过用户按键来不断刷新进程的当前状态，如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。其实top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序，而且该命令的很多特性都可以通过交互式命令或者在定制文件中进行设定。\\n', '\\n', 'top命令输出的实例如图1所示：\\n', '\\n', '图 1 top显示\\n', '\\n', '\\n', 'kill命令\\n', '当需要中断一个前台进程的时候，通常足使用“Ctrl+c”组合键，而对于后台进程不能用组合键来终止，这时就可以使用kill命令。该命令可以终止前台和后台进程。终止后台进程的原因包括：该进程占用CPU的时间过多、该进程已经死锁等。\\n', '\\n', 'kill命令是通过向进程发送指定的信号来结束进程的。如果没有指定发送的信号，那么默认值为TERM信号。TERM信号将终止所有不能捕获该信号的进程。至于那些可以捕获该信号的进程可能就需要使用KILL信号（它的编号为9），而该信号不能被捕捉。\\n', '\\n', 'kill命令的浯法格式有以下两种方式：\\n', '\\n', 'kill [-s 信号 | -p] [-a] 进程号…\\n', 'kill -l [信号]\\n', '其中进程号可以通过ps命令的输出得到。-s选项是给程序发送指定的信号，详细的信号可以用“kill -l”命令查看；-p选项只显示指定进程的ID号。\\n', '\\n', '杀死pid为1409的进程，在root权限下执行如下命令：\\n', '\\n', '# kill -9 1409\\n', '显示所有的信号及其编号对应关系，示例如下：\\n', '\\n', '$ kill -l\\n', ' 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP\\n', ' 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1\\n', '11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM\\n', '16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\\n', '21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ\\n', '26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR\\n', '31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\\n', '38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\\n', '43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\\n', '48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\\n', '53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7\\n', '58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\\n', '63) SIGRTMAX-1  64) SIGRTMAX\\n', '调度启动进程\\n', '有时候需要对系统进行一些比较费时而且占用资源的维护工作，这些工作适合在深夜进行，这时候用户就可以事先进行调度安排，指定任务运行的时间或者场合，到时候系统会自动完成这些任务。要使用自动启动进程的功能，就需要掌握以下几个启动命令。\\n', '\\n', '定时运行一批程序（at）\\n', 'at命令\\n', '用户使用at命令在指定时刻执行指定的命令序列。该命令至少需要指定一个命令和一个执行时间。at命令可以只指定时间，也可以时间和日期一起指定。\\n', '\\n', 'at命令的语法格式如下：\\n', '\\n', ' at [-V] [-q 队列] [-f 文件名] [-mldbv] 时间\\n', ' at -c 作业 [作业…]\\n', '设置时间\\n', 'at允许使用一套相当复杂的时间指定方法，比如：\\n', '\\n', '接受在当天的hh:mm（小时：分钟）式的时间指定。如果该时间已经过去，那么就放存第二天执行。\\n', '使用midnight（深夜）、noon（中午）、teatime（饮茶时间，一般是下午4点）等比较模糊的词语来指定时间。\\n', '采用12小时计时制，即在时间后面加上AM（上午）或者PM（下午）来说明是上午还是下午。\\n', '指定命令执行的具体日期，指定格式为month day（月日）或者mm/dd/yy（月/日/年）或者dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。\\n', '上面介绍的都是绝对计时法，其实还可以使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为now+count time-units，now就是当前时间，time-units是时间单位，这里可以是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时等。还有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。下面通过一些例子来说明具体用法。\\n', '\\n', '例如指定在今天下午4:30执行某个命令。假设现在时间是中午12:30，2019年6月7日，可用命令格式如下：\\n', '\\n', ' at 4:30pm\\n', ' at 16:30\\n', ' at 16:30 today\\n', ' at now+4 hours\\n', ' at now+ 240 minutes\\n', ' at 16:30 7.6.19\\n', ' at 16:30 6/7/19\\n', ' at 16:30 Jun 7\\n', '以上这些命令表达的意义是完全一样的，所以在安排时间的时候完全可以根据个人喜好和具体情况自由选择。一般采用绝对时间的24小时计时法可以避免由于用户自己的疏忽造成计时错误，例如上例可以写成：at 16:30 6/7/19。\\n', '\\n', '执行权限\\n', '对于at命令来说，需要定时执行的命令是从标准输入或者使用-f选项指定的文件中读取并执行的。如果at命令是从一个使用su命令切换到用户shell中执行的，那么当前用户被认为是执行用户，所有的错误和输出结果都会送给这个用户。但是如果有邮件送出的话，收到邮件的将是原来的用户，也就是登录时shell的所有者。\\n', '\\n', '例如在6月8日上午10点执行slocate -u命令。在root权限下执行命令如下：\\n', '\\n', '# at  10:00  6/8/19\\n', 'at> slocate -u\\n', 'at>\\n', '[1]+   Stopped    at  10:00  6/8/19\\n', '上面的结果中，输入at命令之后，会出现提示符at>，提示用户输入命令，在此输入了slocate -u，然后按回车键。还可以输入多条命令，当所有要执行的命令输入结束后，按Ctrl+d键结束at命令。\\n', '\\n', '在任何情况下，管理员账户都可以使用这个命令。对于其他用户来说，是否可以使用就取决于/etc/at.allow和/etc/at.deny文件。\\n', '\\n', '周期性运行一批程序（cron）\\n', '前面介绍at命令都会在一定时间内完成一定任务，但是它只能执行一次。也就是说，当指定了运行命令后，系统在指定时间完成任务，以后就不再执行了。但是在很多情况下需要周期性重复执行一些命令，这时候就需要使用cron命令来完成任务。\\n', '\\n', '运行机制\\n', '首先cron命令会搜索/var/spool/cron目录，寻找以/etc/passwd文件中的用户名命名的crontab文件，被找到的这种文件将装入内存。比如一个用户名为userexample的用户，对应的crontab文件应该是/var/spool/cron/userexample，即以该用户命名的crontab文件存放在/var/spool/cron目录下面。\\n', '\\n', 'cron命令还将搜索/etc/crontab文件，这个文件是用不同的格式写成的。cron启动以后，它将首先检查是否有用户设置了crontab文件，如果没有就转入睡眠状态，释放系统资源。所以该后台进程占用资源极少，它每分钟被换醒一次，查看当前是否有需要运行的命令。\\n', '\\n', '命令执行结束后，任何输出都将作为邮件发送给crontab的所有者，或者是/etc/crontab文件中MAILTO环境变量中指定的用户。这是cron的工作原理，但是cron命令的执行不需要用户干涉，用户只需要修改crontab中要执行的命令。\\n', '\\n', 'crontab命令\\n', 'crontab命令用于安装、删除或者显示用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行，而且每个用户都可以有自己的crontab文件。\\n', '\\n', 'crontab命令的常用方法如下：\\n', '\\n', 'crontab -u //设置某个用户的cron服务，root用户在执行crontab时需要此参数。\\n', 'crontab -l //列出某个用户cron服务的详细内容。\\n', 'crontab -r //删除某个用户的cron服务。\\n', 'crontab -e //编辑某个用户的cron服务。\\n', '例如root查看自己的cron设置。命令如下：\\n', '\\n', '# crontab -u root -l\\n', 'crontab文件\\n', '在crontab文件中输入需要执行的命令和时间。该文件中每行都包括6个域，其中前5个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下：\\n', '\\n', 'minute hour day-of-month month-of-year day-of-week commands\\n', '对于每一项的说明如所示。\\n', '\\n', '表 2 参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '描述\\n', '\\n', 'minute\\n', '\\n', '分钟（0~59）。\\n', '\\n', 'hour\\n', '\\n', '小时（0~23）。\\n', '\\n', 'day-of-month\\n', '\\n', '一个月的第几天（1~31）。\\n', '\\n', 'month-of-year\\n', '\\n', '一年的第几个月（1~12）。\\n', '\\n', 'day-of-week\\n', '\\n', '一周的星期几（0~6），0代表星期天。\\n', '\\n', 'commands\\n', '\\n', '需要执行的命令。\\n', '\\n', '这些项都不能为空，必须指定值。除了数字还有几个特殊的符号“*”、“/”和“-”、“，”。其中，*代表所有的取值范围内的数字，/代表每的意思，“*/5”表示每5个单位，“-”代表从某个数字到某个数字，“，”分开几个离散时数字。对于要执行的命令，调用的时候需要写出命令的完整路径。\\n', '\\n', '例如晚上18点到22点之间每两个小时，在/tmp/test.txt文件中加入sleepy文本。在crontab文件中对应的行如下：\\n', '\\n', '* 18-22/2 * * * echo \"sleepy\" >> /tmp/test.txt\\n', '每次编辑完某个用户的cron设置后，cron自动在/var/spool/cron下生成一个与此用户同名的文件。此用户的cron信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用crontab -e来编辑。用户也可以另外建立一个文件，使用“cron文件名”命令导入cron设置。\\n', '\\n', '假设有个用户名为userexample，它需要为自己创建的一个crontab文件。步骤如下：\\n', '\\n', '首先可以使用任何文本编辑器建立一个新文件，并将向该文件加入需要运行的命令和要定期执行的时间，假设该文件为 ~/userexample.cron。\\n', '\\n', '然后在root权限下使用crontab命令安装这个文件，使用crontab命令使之成为该用户的crontab文件。命令如下：\\n', '\\n', '# crontab -u userexample ~/userexample.cron\\n', '这样crontab文件就建立好了，可以转到/var/spool/cron目录下面查看，发现多了一个userexample文件。这个文件就是所需的crontab文件。\\n', '\\n', ' 说明：\\n', 'cron启动后，每过一分钟读一次crontab文件，检查是否要执行里面的命令。因此该文件被修改后不需要重新启动cron服务。\\n', '\\n', '编辑配置文件\\n', 'cron服务每分钟不仅要读一次/var/spool/cron内的所有文件，还需要读一次/etc/crontab，因此通过配置这个文件也能得到cron的服务。用crontab配置是针对某个用户的，而编辑/etc/crontab是针对系统的任务。此文件的文件格式如下：\\n', '\\n', 'SHELL=/bin/sh\\n', 'PATH=/usr/bin:/usr/sbin:/sbin:/bin:/usr/lib/news/bin\\n', 'MAILTO=root  //如果出现错误，或者有数据输出，数据作为邮件发给这个账号\\n', 'HOME=/\\n', '#  run-parts\\n', '01  * * * *   root run-parts /etc/cron.hourly     //每个小时执行一次/etc/cron.hourly里的脚本\\n', '02 4 * * *   root run-parts /etc/cron.daily    //每天执行一次/etc/cron.daily里的脚本\\n', '22 4 * * 0  root run-parts /etc/cron.weekly     //每周执行一次/etc/cron.weekly里的脚本\\n', '42 4 1  * *  root run-parts /etc/cron.monthly     //每月执行一次/etc/cron.monthly里的脚本\\n', ' 说明：\\n', '如果去掉run-parts参数，其后面就是运行的某个脚本名，而不是目录名。\\n', '\\n', '挂起/恢复进程\\n', '作业控制允许进程挂起并可以在需要时恢复进程的运行，被挂起的作业恢复后将从中止处开始继续运行。只要在键盘上按Ctrl+Z键，即可挂起当前的前台作业。在键盘上按Ctrl+Z键后，将挂起当前执行的命令cat。使用jobs命令可以显示shell的作业清单，包括具体的作业、作业号以及作业当前所处的状态。\\n', '\\n', '恢复进程执行时，有两种选择：用fg命令将挂起的作业放回到前台执行；用bg命令将挂起的作业放到后台执行。灵活使用上述命令，将给自己带来很大的方便。']"}
{"index": {"_index": "new-open", "_id": "openEuler_内核热升级指南_使用方法.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KernelLiveUpgrade/%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html", "text_entry": "['使用方法\\n', '命令用法\\n', '的使用限制\\n', '加速特性说明及使用\\n', '产生的日志信息\\n', '命令用法\\n', 'nvwa help\\n', '\\n', '打印帮助信息，打印的信息如下:\\n', '\\n', 'NAME:\\n', 'nvwa - a tool used for openEuler kernel update.\\n', '\\n', 'USAGE:\\n', 'nvwa [global options] command [command options] [arguments...]\\n', '\\n', 'VERSION:\\n', '0.1\\n', '\\n', 'COMMANDS:\\n', 'update   specify kernel version for nvwa to update\\n', 'init     init nvwa running environment\\n', 'help, h  Shows a list of commands or help for one command\\n', '\\n', 'GLOBAL OPTIONS:\\n', '--help, -h     show help (default: false)\\n', '--version, -v  print the version (default: false)\\n', 'nvwa update\\n', '\\n', '热升级到内核某一版本，nvwa会去/boot目录下寻找内核镜像和ramfs，kernel的命名格式需为vmlinuz-, rootfs命名格式需为initramfs-.img\\n', '\\n', '需要注意的是，升级过程有可能会失败，如果失败，部分被dump的进程或者服务，将停止运行。\\n', '\\n', 'nvwa init\\n', '\\n', '清除nvwa产生的现场信息以及对systemd的配置修改，用于nvwa执行前或者执行失败后，对现场进行清理\\n', '\\n', '使用限制\\n', '对于需要通过nvwa保存的service，其配置中需要设置标准输出(StandardOutput)和错误输出(StandardError)，以redis为例:\\n', '\\n', '[Unit]\\n', 'Description=Redis persistent key-value database\\n', 'After=network.target\\n', '[Service]\\n', 'ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd\\n', 'Type=notify\\n', 'User=redis\\n', 'Group=redis\\n', 'RuntimeDirectory=redis\\n', 'RuntimeDirectoryMode=0755\\n', 'StandardOutput=file:/root/log1.log\\n', 'StandardError=file:/root/log2.log\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '使用加速特性需要修改cmdline以及分配合适的内存，参见此处\\n', '\\n', '运行过程中需要关闭SELINUX\\n', '\\n', '理论上，仅需要在执行nvwa update之后和系统重启nvwa恢复现场这段时间前需要关闭。稳妥起见，建议全程关闭SELINUX。\\n', '\\n', '加速特性说明及使用\\n', 'cpu park(加速内核重启过程)\\n', '\\n', 'cpu park，是在使用kexec过程，使cpu进入一种忙等的状态，更快的响应主核发送的中断请求，减少状态的变化。\\n', '\\n', '使用cpu park，需要在cmdline中加入\"cpuparkmem=0x200000000\"，其中0x200000000是一段未被其他程序使用的内存起始地址，cpuparkmem将占用从该地址开始，size为1M左右的内存空间。\\n', '\\n', '需要注意的是，在内存允许的情况下，此处的地址选择，建议范围在4G(0x100000000)之后，前4G通常被系统各组件预留，容易冲突。\\n', '\\n', 'quick kexec(加速内核启动过程)\\n', '\\n', 'quick kexec，是对kexec加载镜像过程中的一种加速。\\n', '\\n', '使用quick kexec，需要在配置文件中使能相关选项，更多信息参考«安装与部署»(配置介绍)\\n', '\\n', 'pin_memory(加速现场保存恢复过程)\\n', '\\n', 'pin memory，是对criu进行现场保存恢复过程中的一种加速。\\n', '\\n', '使用pin memory，需要在配置文件中使能相关选项，更多信息参考«安装与部署»(配置介绍)\\n', '\\n', '产生的日志信息\\n', '内核热升级工具产生的日志分为两部分:\\n', '\\n', '运行过程产生的日志\\n', '\\n', '通过service nvwa status查看\\n', '\\n', '保留现场过程中产生的日志\\n', '\\n', '日志位于criu_dir指定的路径对应命名的进程/服务文件夹中\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_动态加载内核模块.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97.html", "text_entry": "['动态加载内核模块\\n', '功能描述\\n', '容器内业务可能依赖某些内核模块，可通过设置环境变量的方式，在系统容器启动前动态加载容器中业务需要的内核模块到宿主机，此特性需要配合syscontainer-hooks一起使用，具体使用可参看\"容器资源动态管理（syscontainer-tools）“章节。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '-e KERNEL_MODULES=module_name1,module_name\\n', '\\n', '字符串变量。\\n', '支持配置多个模块，模块名以逗号分隔。\\n', '约束限制\\n', '如果加载的内核模块是未经过验证的，或者跟宿主机已有模块冲突的场景，会导致宿主机出现不可预知问题，在做加载内核模块时需要谨慎操作。\\n', '动态加载内核模块通过将需要加载的内核模块传递给容器，此功能是依靠syscontainer-tools捕获到容器启动的环境变量实现，依赖syscontainer-tools的正确安装部署。\\n', '加载的内核模块需要手动进行删除。\\n', '使用示例\\n', '启动系统容器时，指定-e KERNEL_MODULES参数，待系统容器启动后，可以看到ip_vs模块被成功加载到内核中。\\n', '\\n', '[root@localhost ~]# lsmod | grep ip_vs\\n', '[root@localhost ~]# isula run -tid -e KERNEL_MODULES=ip_vs,ip_vs_wrr --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/myrootfs none init\\n', 'ae18c4281d5755a1e153a7bff6b3b4881f36c8e528b9baba8a3278416a5d0980\\n', '[root@localhost ~]# lsmod | grep ip_vs\\n', 'ip_vs_wrr              16384  0\\n', 'ip_vs                 176128  2 ip_vs_wrr\\n', 'nf_conntrack          172032  7 xt_conntrack,nf_nat,nf_nat_ipv6,ipt_MASQUERADE,nf_nat_ipv4,nf_conntrack_netlink,ip_vs\\n', 'nf_defrag_ipv6         20480  2 nf_conntrack,ip_vs\\n', 'libcrc32c              16384  3 nf_conntrack,nf_nat,ip_vs\\n', ' 说明：\\n', '\\n', '宿主机需要安装syscontainer-tools。\\n', '需要指定–hooks-spec为syscontainer hooks。']"}
{"index": {"_index": "new-open", "_id": "openEuler_虚拟化用户指南_管理虚拟机可维护性.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Virtualization/%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7.html", "text_entry": "['管理虚拟机可维护性\\n', '虚拟机NMI Watchdog\\n', '概述\\n', 'NMI Watchdog是一种用来检测Linux出现hardlockup（硬死锁）的机制。通过产生NMI不可屏蔽中断，从而在Linux内核关闭中断的代码区间也能打断代码的执行，进一步检测内核是否出现硬死锁。当前ARM架构不支持原生NMI中断，通过使能基于中断优先级的Pseudo-NMI，将PMI（Performance Monitoring Interrupt）中断配置为NMI中断，实现NMI Watchdog（即PMU Watchdog）。\\n', '\\n', '注意事项\\n', '虚拟机内部OS需要支持Pseudo-NMI并配置相应内核参数\\n', '虚拟机上PMU Watchdog的配置方式与host上相同，无需对xml文件进行其他配置\\n', '同样作为NMI Watchdog，SDEI Watchdog的优先级高于PMU Watchdog，因此要禁用SDEI Watchdog才会使能PMU Watchdog；虚拟机不支持SDEI Watchdog，因此要注意通过配置内核参数将其禁用\\n', '操作步骤\\n', '针对ARM架构虚拟机配置NMI Watchdog的操作步骤如下：\\n', '\\n', '在虚拟机的引导配置文件grub.cfg中添加如下参数：nmi_watchdog=1 pmu_nmi_enable hardlockup_cpu_freq=auto irqchip.gicv3_pseudo_nmi=1 disable_sdei_nmi_watchdog\\n', '检查虚拟机内部PMU Watchdog是否加载成功，如果加载成功，内核dmesg日志打印类似如下内容\\n', '[2.1173222] NMI watchdog: CPU0 freq probed as 2399999942 HZ.\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_最大句柄数限制.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%9C%80%E5%A4%A7%E5%8F%A5%E6%9F%84%E6%95%B0%E9%99%90%E5%88%B6.html", "text_entry": "['最大句柄数限制\\n', '功能描述\\n', '系统容器支持对容器内使用文件句柄数进行限制，文件句柄包括普通文件句柄和网络套接字，启动容器时，可以通过指定–files-limit参数限制容器内打开的最大句柄数。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--files-limit\\n', '\\n', '  \\n', '\\n', '整数值，不能为负数。\\n', '指定为0表示不受限制，最大值限制由当前内核files cgroup决定。\\n', '约束限制\\n', '如果--files-limit指定的值太小，可能会导致系统容器无法通过exec执行命令，报\"open too many files\"错误，所以files limit的值应该设置大一些。\\n', '文件句柄包括普通文件句柄和网络套接字。\\n', '使用示例\\n', '使用--files-limit限制容器内打开文件句柄数需要内核支持files cgroup，可以执行以下命令查看：\\n', '\\n', '[root@localhost ~]# cat /proc/1/cgroup | grep files\\n', '10:files:/\\n', '结果显示files，说明内核支持files cgroup。\\n', '\\n', '容器启动指定–files-limit参数，并检查files.limit参数是否成功写入：\\n', '\\n', '[root@localhost ~]# isula run  -tid --files-limit 1024 --system-container  --external-rootfs /tmp/root-fs  empty init 01e82fcf97d4937aa1d96eb8067f9f23e4707b92de152328c3fc0ecb5f64e91d \\n', '[root@localhost ~]# isula exec -it 01e82fcf97d4 bash \\n', '[root@localhost ~]# cat /sys/fs/cgroup/files/files.limit \\n', '1024 \\n', '\\n', '可以看出，容器内文件句柄数被成功限制。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_管理服务.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.html", "text_entry": "['管理服务\\n', '本章介绍如何使用systemd进行系统和服务管理。\\n', '\\n', '管理服务\\n', '简介\\n', '概念介绍\\n', '特性说明\\n', '更快的启动速度\\n', '提供按需启动能力\\n', '采用cgroup特性跟踪和管理进程的生命周期\\n', '启动挂载点和自动挂载的管理\\n', '实现事务性依赖关系管理\\n', '与SysV初始化脚本兼容\\n', '能够对系统进行快照和恢复\\n', '管理系统服务\\n', 'sysvinit命令和systemd命令\\n', '显示所有当前服务\\n', '显示服务状态\\n', '运行服务\\n', '关闭服务\\n', '重启服务\\n', '启用服务\\n', '禁用服务\\n', '改变运行级别\\n', 'Target和运行级别\\n', '查看系统默认启动目标\\n', '查看当前系统所有的启动目标\\n', '改变默认目标\\n', '改变当前目标\\n', '切换到救援模式\\n', '切换到紧急模式\\n', '关闭、暂停和休眠系统\\n', 'systemctl命令\\n', '关闭系统\\n', '重启系统\\n', '使系统待机\\n', '使系统休眠\\n', '简介\\n', 'systemd是在Linux下，与SysV和LSB初始化脚本兼容的系统和服务管理器。systemd使用socket和D-Bus来开启服务，提供基于守护进程的按需启动策略，支持快照和系统状态恢复，维护挂载和自挂载点，实现了各服务间基于从属关系的一个更为精细的逻辑控制，拥有更高的并行性能。\\n', '\\n', '概念介绍\\n', 'systemd开启和监督整个系统是基于unit的概念。unit是由一个与配置文件对应的名字和类型组成的（例如：avahi.service unit有一个具有相同名字的配置文件，是守护进程Avahi的一个封装单元）。unit有多重类型，如表1所示。\\n', '\\n', '表 1 unit说明\\n', '\\n', '\\n', 'unit名称\\n', '\\n', '后缀名\\n', '\\n', '描述\\n', '\\n', 'Service unit\\n', '\\n', '.service\\n', '\\n', '系统服务。\\n', '\\n', 'Target unit\\n', '\\n', '.target\\n', '\\n', '一组systemd units。\\n', '\\n', 'Automount unit\\n', '\\n', '.automount\\n', '\\n', '文件系统挂载点。\\n', '\\n', 'Device unit\\n', '\\n', '.device\\n', '\\n', '内核识别的设备文件。\\n', '\\n', 'Mount unit\\n', '\\n', '.mount\\n', '\\n', '文件系统挂载点。\\n', '\\n', 'Path unit\\n', '\\n', '.path\\n', '\\n', '在一个文件系统中的文件或目录。\\n', '\\n', 'Scope unit\\n', '\\n', '.scope\\n', '\\n', '外部创建的进程。\\n', '\\n', 'Slice unit\\n', '\\n', '.slice\\n', '\\n', '一组用于管理系统进程分层组织的units。\\n', '\\n', 'Socket unit\\n', '\\n', '.socket\\n', '\\n', '一个进程间通信的Socket。\\n', '\\n', 'Swap unit\\n', '\\n', '.swap\\n', '\\n', 'swap设备或者swap文件。\\n', '\\n', 'Timer unit\\n', '\\n', '.timer\\n', '\\n', 'systemd计时器。\\n', '\\n', '所有的可用systemd unit类型，可在如表2所示的路径下查看。\\n', '\\n', '表 2 可用systemd unit类型\\n', '\\n', '\\n', '路径\\n', '\\n', '描述\\n', '\\n', '/usr/lib/systemd/system/\\n', '\\n', '随安装的RPM产生的systemd units。\\n', '\\n', '/run/systemd/system/\\n', '\\n', '在运行时创建systemd units。\\n', '\\n', '/etc/systemd/system/\\n', '\\n', '由系统管理员创建和管理的systemd units。\\n', '\\n', '特性说明\\n', '更快的启动速度\\n', 'systemd提供了比UpStart更激进的并行启动能力，采用了socket/D-Bus activation等技术启动服务，带来了更快的启动速度。\\n', '\\n', '为了减少系统启动时间，systemd的目标是：\\n', '\\n', '尽可能启动更少的进程。\\n', '尽可能将更多进程并行启动。\\n', '提供按需启动能力\\n', '当sysvinit系统初始化的时候，它会将所有可能用到的后台服务进程全部启动运行。并且系统必须等待所有的服务都启动就绪之后，才允许用户登录。这种做法有两个缺点：首先是启动时间过长；其次是系统资源浪费。\\n', '\\n', '某些服务很可能在很长一段时间内，甚至整个服务器运行期间都没有被使用过。比如CUPS，打印服务在多数服务器上很少被真正使用到。您可能没有想到，在很多服务器上SSHD也是很少被真正访问到的。花费在启动这些服务上的时间是不必要的；同样，花费在这些服务上的系统资源也是一种浪费。\\n', '\\n', 'systemd可以提供按需启动的能力，只有在某个服务被真正请求的时候才启动它。当该服务结束，systemd可以关闭它，等待下次需要时再次启动它。\\n', '\\n', '采用cgroup特性跟踪和管理进程的生命周期\\n', 'init系统的一个重要职责就是负责跟踪和管理服务进程的生命周期。它不仅可以启动一个服务，也能够停止服务。这看上去没有什么特别的，然而在真正用代码实现的时候，您或许会发现停止服务比一开始想的要困难。\\n', '\\n', '服务进程一般都会作为守护进程（daemon）在后台运行，为此服务程序有时候会派生（fork）两次。在UpStart中，需要在配置文件中正确地配置expect小节。这样UpStart通过对fork系统调用进行计数，从而获知真正的精灵进程的PID号。\\n', '\\n', 'cgroup已经出现了很久，它主要用来实现系统资源配额管理。cgroup提供了类似文件系统的接口，使用方便。当进程创建子进程时，子进程会继承父进程的cgroup。因此无论服务如何启动新的子进程，所有的这些相关进程都会属于同一个cgroup，systemd只需要简单地遍历指定的cgroup即可正确地找到所有的相关进程，将它们逐一停止即可。\\n', '\\n', '启动挂载点和自动挂载的管理\\n', '传统的Linux系统中，用户可以用/etc/fstab文件来维护固定的文件系统挂载点。这些挂载点在系统启动过程中被自动挂载，一旦启动过程结束，这些挂载点就会确保存在。这些挂载点都是对系统运行至关重要的文件系统，比如HOME目录。和sysvinit一样，systemd管理这些挂载点，以便能够在系统启动时自动挂载它们。systemd还兼容/etc/fstab文件，您可以继续使用该文件管理挂载点。\\n', '\\n', '有时候用户还需要动态挂载点，比如打算访问DVD内容时，才临时执行挂载以便访问其中的内容，而不访问光盘时该挂载点被取消（umount)，以便节约资源。传统地，人们依赖autofs服务来实现这种功能。\\n', '\\n', 'systemd内建了自动挂载服务，无需另外安装autofs服务，可以直接使用systemd提供的自动挂载管理能力来实现autofs的功能。\\n', '\\n', '实现事务性依赖关系管理\\n', '系统启动过程是由很多的独立工作共同组成的，这些工作之间可能存在依赖关系，比如挂载一个NFS文件系统必须依赖网络能够正常工作。systemd虽然能够最大限度地并发执行很多有依赖关系的工作，但是类似“挂载NFS”和“启动网络”这样的工作还是存在天生的先后依赖关系，无法并发执行。对于这些任务，systemd维护一个“事务一致性”的概念，保证所有相关的服务都可以正常启动而不会出现互相依赖，以至于死锁的情况。\\n', '\\n', '与SysV初始化脚本兼容\\n', '和UpStart一样，systemd引入了新的配置方式，对应用程序的开发也有一些新的要求。如果systemd想替代目前正在运行的初始化系统，就必须和现有程序兼容。任何一个Linux发行版都很难为了采用systemd而在短时间内将所有的服务代码都修改一遍。\\n', '\\n', 'systemd提供了和sysvinit以及LSB initscripts兼容的特性。系统中已经存在的服务和进程无需修改。这降低了系统向systemd迁移的成本，使得systemd替换现有初始化系统成为可能。\\n', '\\n', '能够对系统进行快照和恢复\\n', 'systemd支持按需启动，因此系统的运行状态是动态变化的，人们无法准确地知道系统当前运行了哪些服务。systemd快照提供了一种将当前系统运行状态保存并恢复的能力。\\n', '\\n', '比如系统当前正运行服务A和B，可以用systemd命令行对当前系统运行状况创建快照。然后将进程A停止，或者做其他的任意的对系统的改变，比如启动新的进程C。在这些改变之后，运行systemd的快照恢复命令，就可立即将系统恢复到快照时刻的状态，即只有服务A，B在运行。一个可能的应用场景是调试：比如服务器出现一些异常，为了调试用户将当前状态保存为快照，然后可以进行任意的操作，比如停止服务等等。等调试结束，恢复快照即可。\\n', '\\n', '管理系统服务\\n', 'systemd提供systemctl命令来运行、关闭、重启、显示、启用/禁用系统服务。\\n', '\\n', 'sysvinit命令和systemd命令\\n', 'systemd提供systemctl命令与sysvinit命令的功能类似。当前版本中依然兼容service和chkconfig命令，相关说明如表3，但建议用systemctl进行系统服务管理。\\n', '\\n', '表 3 sysvinit命令和systemd命令的对照表\\n', '\\n', '\\n', 'sysvinit命令\\n', '\\n', 'systemd命令\\n', '\\n', '备注\\n', '\\n', 'service network start\\n', '\\n', 'systemctl start network.service\\n', '\\n', '用来启动一个服务 (并不会重启现有的)。\\n', '\\n', 'service network stop\\n', '\\n', 'systemctl stop network.service\\n', '\\n', '用来停止一个服务 (并不会重启现有的)。\\n', '\\n', 'service network restart\\n', '\\n', 'systemctl restart network.service\\n', '\\n', '用来停止并启动一个服务。\\n', '\\n', 'service network reload\\n', '\\n', 'systemctl reload network.service\\n', '\\n', '当支持时，重新装载配置文件而不中断等待操作。\\n', '\\n', 'service network condrestart\\n', '\\n', 'systemctl condrestart network.service\\n', '\\n', '如果服务正在运行那么重启它。\\n', '\\n', 'service network status\\n', '\\n', 'systemctl status network.service\\n', '\\n', '检查服务的运行状态。\\n', '\\n', 'chkconfig network on\\n', '\\n', 'systemctl enable network.service\\n', '\\n', '在下次启动时或满足其他触发条件时设置服务为启用。\\n', '\\n', 'chkconfig network off\\n', '\\n', 'systemctl disable network.service\\n', '\\n', '在下次启动时或满足其他触发条件时设置服务为禁用。\\n', '\\n', 'chkconfig network\\n', '\\n', 'systemctl is-enabled network.service\\n', '\\n', '用来检查一个服务在当前环境下被配置为启用还是禁用。\\n', '\\n', 'chkconfig \\\\-\\\\-list\\n', '\\n', 'systemctl list-unit-files \\\\-\\\\-type=service\\n', '\\n', '输出在各个运行级别下服务的启用和禁用情况。\\n', '\\n', 'chkconfig network \\\\-\\\\-list\\n', '\\n', 'ls /etc/systemd/system/*.wants/network.service\\n', '\\n', '用来列出该服务在哪些运行级别下启用和禁用。\\n', '\\n', 'chkconfig network \\\\-\\\\-add\\n', '\\n', 'systemctl daemon-reload\\n', '\\n', '当您创建新服务文件或者变更设置时使用。\\n', '\\n', '显示所有当前服务\\n', '如果您需要显示当前正在运行的服务，使用命令如下：\\n', '\\n', 'systemctl list-units --type service\\n', '如果您需要显示所有的服务（包括未运行的服务），需要添加-all参数，使用命令如下：\\n', '\\n', 'systemctl list-units --type service --all\\n', '例如显示当前正在运行的服务，命令如下：\\n', '\\n', '$ systemctl list-units --type service\\n', 'UNIT                        LOAD   ACTIVE     SUB     JOB   DESCRIPTION  \\n', 'atd.service                 loaded active     running       Deferred execution scheduler  \\n', 'auditd.service              loaded active     running       Security Auditing Service  \\n', 'avahi-daemon.service        loaded active     running       Avahi mDNS/DNS-SD Stack  \\n', 'chronyd.service             loaded active     running       NTP client/server  \\n', 'crond.service               loaded active     running       Command Scheduler  \\n', 'dbus.service                loaded active     running       D-Bus System Message Bus  \\n', 'dracut-shutdown.service     loaded active     exited        Restore /run/initramfs on shutdown  \\n', 'firewalld.service           loaded active     running       firewalld - dynamic firewall daemon  \\n', 'getty@tty1.service          loaded active     running       Getty on tty1  \\n', 'gssproxy.service            loaded active     running       GSSAPI Proxy Daemon  \\n', 'irqbalance.service          loaded active     running       irqbalance daemon  \\n', 'iscsid.service              loaded activating start   start Open-iSCSI\\n', '显示服务状态\\n', '如果您需要显示某个服务的状态，可执行如下命令：\\n', '\\n', 'systemctl status name.service\\n', '相关状态显示参数说明如表4所示。\\n', '\\n', '表 4 状态参数说明\\n', '\\n', '\\n', '参数\\n', '\\n', '描述\\n', '\\n', 'Loaded\\n', '\\n', '说明服务是否被加载，并显示服务对应的绝对路径以及是否启用。\\n', '\\n', 'Active\\n', '\\n', '说明服务是否正在运行，并显示时间节点。\\n', '\\n', 'Main PID\\n', '\\n', '相应的系统服务的PID值。\\n', '\\n', 'CGroup\\n', '\\n', '相关控制组（CGroup）的其他信息。\\n', '\\n', '如果您需要鉴别某个服务是否运行，可执行如下命令：\\n', '\\n', 'systemctl is-active name.service\\n', 'is-active命令的返回结果如下：\\n', '\\n', '表 5 is-active命令的返回结果\\n', '\\n', '\\n', '状态\\n', '\\n', '含义\\n', '\\n', 'active(running)\\n', '\\n', '有一只或多只程序正在系统中执行\\n', '\\n', 'active(exited)\\n', '\\n', '仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 举例来说，开机或者 是挂载时才会进行一次的 quotaon 功能\\n', '\\n', 'active(waiting)\\n', '\\n', '正在执行当中，不过要等待其他的事件才能继续处理。例如：打印的队列相关服务 就是这种状态，虽然正在启动中，不过也需要真的有队列进来 (打印作业) 这样他才会继续唤醒打印机 服务来进行下一步打印的功能\\n', '\\n', 'inactive\\n', '\\n', '这个服务没有运行\\n', '\\n', '同样，如果您需要判断某个服务是否被启用，可执行如下命令：\\n', '\\n', 'systemctl is-enabled name.service\\n', 'is-enabled命令的返回结果如下：\\n', '\\n', '表 6 is-enabled命令的返回结果\\n', '\\n', '\\n', '状态\\n', '\\n', '含义\\n', '\\n', '\"enabled\"\\n', '\\n', '已经通过 /etc/systemd/system/ 目录下的 Alias= 别名、 .wants/ 或 .requires/ 软连接被永久启用。\\n', '\\n', '\"enabled-runtime\"\\n', '\\n', '已经通过 /run/systemd/system/ 目录下的 Alias= 别名、 .wants/ 或 .requires/ 软连接被临时启用。\\n', '\\n', '\"linked\"\\n', '\\n', '虽然单元文件本身不在标准单元目录中，但是指向此单元文件的一个或多个软连接已经存在于 /etc/systemd/system/ 永久目录中。\\n', '\\n', '\"linked-runtime\"\\n', '\\n', '虽然单元文件本身不在标准单元目录中，但是指向此单元文件的一个或多个软连接已经存在于 /run/systemd/system/ 临时目录中。\\n', '\\n', '\"masked\"\\n', '\\n', '已经被 /etc/systemd/system/ 目录永久屏蔽(软连接指向 /dev/null 文件)，因此 start 操作会失败。\\n', '\\n', '\"masked-runtime\"\\n', '\\n', '已经被 /run/systemd/systemd/ 目录临时屏蔽(软连接指向 /dev/null 文件)，因此 start 操作会失败。\\n', '\\n', '\"static\"\\n', '\\n', '尚未被启用，并且单元文件的 \"[Install]\" 小节中没有可用于 enable 命令的选项。\\n', '\\n', '\"indirect\"\\n', '\\n', '尚未被启用，但是单元文件的 \"[Install]\" 小节中 Also= 选项的值列表非空(也就是列表中的某些单元可能已被启用)、或者它拥有一个不在 Also= 列表中的其他名称的别名软连接。对于模版单元来说，表示已经启用了一个不同于 DefaultInstance= 的实例。\\n', '\\n', '\"disabled\"\\n', '\\n', '尚未被启用，但是单元文件的 \"[Install]\" 小节中存在可用于 enable 命令的选项\\n', '\\n', '\"generated\"\\n', '\\n', '单元文件是被单元生成器动态生成的。被生成的单元文件可能并未被直接启用，而是被单元生成器隐含的启用了。\\n', '\\n', '\"transient\"\\n', '\\n', '单元文件是被运行时API动态临时生成的。该临时单元可能并未被启用。\\n', '\\n', '\"bad\"\\n', '\\n', '单元文件不正确或者出现其他错误。 is-enabled 不会返回此状态，而是会显示一条出错信息。 list-unit-files 命令有可能会显示此单元。\\n', '\\n', '例如查看gdm.service服务状态，命令如下：\\n', '\\n', '# systemctl status gdm.service\\n', 'gdm.service - GNOME Display Manager   Loaded: loaded (/usr/lib/systemd/system/gdm.service; enabled)   Active: active (running) since Thu 2013-10-17 17:31:23 CEST; 5min ago\\n', ' Main PID: 1029 (gdm)\\n', '   CGroup: /system.slice/gdm.service\\n', '           ├─1029 /usr/sbin/gdm\\n', '           ├─1037 /usr/libexec/gdm-simple-slave --display-id /org/gno...           \\n', '           └─1047 /usr/bin/Xorg :0 -background none -verbose -auth /r...Oct 17 17:31:23 localhost systemd[1]: Started GNOME Display Manager.\\n', '运行服务\\n', '如果您需要运行某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl start name.service\\n', '例如运行httpd服务，命令如下：\\n', '\\n', '# systemctl start httpd.service\\n', '关闭服务\\n', '如果您需要关闭某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl stop name.service\\n', '例如关闭蓝牙服务，命令如下：\\n', '\\n', '# systemctl stop bluetooth.service\\n', '重启服务\\n', '如果您需要重启某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl restart name.service\\n', '执行命令后，当前服务会被关闭，但马上重新启动。如果您指定的服务，当前处于关闭状态，执行命令后，服务也会被启动。\\n', '\\n', '例如重启蓝牙服务，命令如下：\\n', '\\n', '# systemctl restart bluetooth.service\\n', '启用服务\\n', '如果您需要在开机时启用某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl enable name.service\\n', '例如设置httpd服务开机时启动，命令如下：\\n', '\\n', '# systemctl enable httpd.service\\n', \"ln -s '/usr/lib/systemd/system/httpd.service' '/etc/systemd/system/multi-user.target.wants/httpd.service'\\n\", '禁用服务\\n', '如果您需要在开机时禁用某个服务，请在root权限下执行如下命令：\\n', '\\n', 'systemctl disable name.service\\n', '例如在开机时禁用蓝牙服务启动，命令如下：\\n', '\\n', '# systemctl disable bluetooth.service\\n', 'Removed /etc/systemd/system/bluetooth.target.wants/bluetooth.service.\\n', 'Removed /etc/systemd/system/dbus-org.bluez.service.\\n', '改变运行级别\\n', 'Target和运行级别\\n', 'systemd用目标（target）替代了运行级别的概念，提供了更大的灵活性，如您可以继承一个已有的目标，并添加其他服务，来创建自己的目标。表7列举了systemd下的目标和常见runlevel的对应关系。\\n', '\\n', '表 7 运行级别和systemd目标\\n', '\\n', '\\n', '运行级别\\n', '\\n', 'systemd目标（target）\\n', '\\n', '描述\\n', '\\n', '0\\n', '\\n', 'runlevel0.target，poweroff.target\\n', '\\n', '关闭系统。\\n', '\\n', '1, s, single\\n', '\\n', 'runlevel1.target，rescue.target\\n', '\\n', '单用户模式。\\n', '\\n', '2, 4\\n', '\\n', 'runlevel2.target，runlevel4.target，multi-user.target\\n', '\\n', '用户定义/域特定运行级别。默认等同于3。\\n', '\\n', '3\\n', '\\n', 'runlevel3.target，multi-user.target\\n', '\\n', '多用户，非图形化。用户可以通过多个控制台或网络登录。\\n', '\\n', '5\\n', '\\n', 'runlevel5.target，graphical.target\\n', '\\n', '多用户，图形化。通常为所有运行级别3的服务外加图形化登录。\\n', '\\n', '6\\n', '\\n', 'runlevel6.target，reboot.target\\n', '\\n', '重启系统。\\n', '\\n', 'emergency\\n', '\\n', 'emergency.target\\n', '\\n', '紧急Shell\\n', '\\n', '查看系统默认启动目标\\n', '查看当前系统默认的启动目标，命令如下：\\n', '\\n', 'systemctl get-default\\n', '查看当前系统所有的启动目标\\n', '查看当前系统所有的启动目标，命令如下：\\n', '\\n', 'systemctl list-units --type=target\\n', '改变默认目标\\n', '改变系统默认的目标，在root权限下执行如下命令：\\n', '\\n', 'systemctl set-default name.target\\n', '改变当前目标\\n', '改变当前系统的目标，在root权限下执行如下命令：\\n', '\\n', 'systemctl isolate name.target\\n', '切换到救援模式\\n', '改变当前系统为救援模式，在root权限下执行如下命令：\\n', '\\n', 'systemctl rescue\\n', '这条命令和“systemctl isolate rescue.target”类似。命令执行后会在串口有如下打印信息：\\n', '\\n', 'You are in rescue mode. After logging in, type \"journalctl -xb\" to viewsystem logs, \"systemctl reboot\" to reboot, \"systemctl default\" or \"exit\"to boot into default mode.\\n', 'Give root password for maintenance\\n', '(or press Control-D to continue):\\n', ' 说明：\\n', '用户需要重启系统，从救援模式进入正常模式。\\n', '\\n', '切换到紧急模式\\n', '改变当前系统为紧急模式，在root权限下执行如下命令：\\n', '\\n', 'systemctl emergency\\n', '这条命令和“systemctl isolate emergency.target”类似。命令执行后会在串口有如下打印信息：\\n', '\\n', 'You are in emergency mode. After logging in, type \"journalctl -xb\" to viewsystem logs, \"systemctl reboot\" to reboot, \"systemctl default\" or \"exit\"to boot into default mode.\\n', 'Give root password for maintenance\\n', '(or press Control-D to continue):\\n', ' 说明：\\n', '用户需要重启系统，从紧急模式进入正常模式。\\n', '\\n', '关闭、暂停和休眠系统\\n', 'systemctl命令\\n', 'systemd通过systemctl命令可以对系统进行关机、重启、休眠等一系列操作。当前仍兼容部分Linux常用管理命令，对应关系如表8。建议用户使用systemctl命令进行操作。\\n', '\\n', '表 8 命令对应关系\\n', '\\n', '\\n', 'Linux常用管理命令\\n', '\\n', 'systemctl命令\\n', '\\n', '描述\\n', '\\n', 'halt\\n', '\\n', 'systemctl halt\\n', '\\n', '关闭系统\\n', '\\n', 'poweroff\\n', '\\n', 'systemctl poweroff\\n', '\\n', '关闭电源\\n', '\\n', 'reboot\\n', '\\n', 'systemctl reboot\\n', '\\n', '重启\\n', '\\n', '关闭系统\\n', '关闭系统并下电，在root权限下执行如下命令：\\n', '\\n', 'systemctl poweroff\\n', '关闭系统但不下电机器，在root权限下执行如下命令：\\n', '\\n', 'systemctl halt\\n', '执行上述命令会给当前所有的登录用户发送一条提示消息。如果不想让systemd发送该消息，您可以添加“--no-wall”参数。具体命令如下：\\n', '\\n', 'systemctl --no-wall poweroff\\n', '重启系统\\n', '重启系统，在root权限下执行如下命令：\\n', '\\n', 'systemctl reboot\\n', '执行上述命令会给当前所有的登录用户发送一条提示消息。如果不想让systemd发送该消息，您可以添加“--no-wall”参数。具体命令如下：\\n', '\\n', 'systemctl --no-wall reboot\\n', '使系统待机\\n', '使系统待机，在root权限下执行如下命令：\\n', '\\n', 'systemctl suspend\\n', '使系统休眠\\n', '使系统休眠，在root权限下执行如下命令：\\n', '\\n', 'systemctl hibernate\\n', '使系统待机且处于休眠状态，在root权限下执行如下命令：\\n', '\\n', 'systemctl hybrid-sleep']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在树莓派_安装方式介绍.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E4%BB%8B%E7%BB%8D-1.html", "text_entry": "['安装方式介绍\\n', ' 须知：\\n', '\\n', '硬件仅支持树莓派 3B/3B+/4B。\\n', '采用刷写镜像到 SD 卡方式安装。本章节提供 Windows/Linux/Mac 上刷写镜像的操作方法。\\n', '本章节使用的镜像是参考“安装准备”获取 openEuler 的树莓派版本镜像。\\n', '安装方式介绍\\n', 'Windows 下刷写镜像\\n', '格式化 SD 卡\\n', '写入 SD 卡\\n', 'Linux 下刷写镜像\\n', '查看磁盘分区信息\\n', '卸载 SD 卡挂载点\\n', '写入 SD 卡\\n', 'Mac 下刷写镜像\\n', '查看磁盘分区信息\\n', '卸载 SD 卡挂载点\\n', '写入 SD 卡\\n', 'Windows 下刷写镜像\\n', '本节以 Windows 10 为例，介绍如何在 Windows 环境下将镜像刷写到 SD 卡。\\n', '\\n', '格式化 SD 卡\\n', '请按照以下步骤格式化 SD 卡：\\n', '\\n', '下载并安装格式化 SD 卡工具，以下操作以 SD Card Formatter 格式化工具为例。\\n', '\\n', '打开 SD Card Formatter，在 “Select card” 中选择需要格式化的 SD 卡的盘符。\\n', '\\n', '若 SD 卡之前未安装过镜像，盘符只有一个。在 “Select card” 中选择需要格式化的 SD 卡对应盘符。\\n', '\\n', '若 SD 卡之前安装过镜像，盘符会有一个或多个。例如，SD 卡对应三个盘符：E、G、H。在 “Select card” 中选择需要格式化的 SD 卡对应 boot 分区盘符 E。\\n', '\\n', '在 “Formatting options” 中选择格式化方式。默认为 “Qick format”。\\n', '\\n', '单击“Format”开始格式化。界面通过进度条显示格式化进度。\\n', '\\n', '格式化完成后会弹出 “Formatting was successfully completed” 的提示框，单击“确定”完成格式化。\\n', '\\n', '写入 SD 卡\\n', ' 须知：\\n', '如果获取的是压缩后的镜像文件“openEuler-22.03_LTS-raspi-aarch64.img.xz”，需要先将压缩文件解压得到 “openEuler-22.03_LTS-raspi-aarch64.img”镜像文件。\\n', '\\n', '请按照以下步骤将“openEuler-22.03_LTS-raspi-aarch64.img”镜像文件写入 SD 卡：\\n', '\\n', '下载并安装刷写镜像的工具，以下操作以 Win32 Disk Imager 工具为例。\\n', '右键选择“以管理员身份运行”，打开 Win32 Disk Imager。\\n', '在“映像文件”中选择 img 格式的镜像文件路径。\\n', '在“设备”中选择待写入的 SD 卡盘符。\\n', '单击“写入”。界面通过任务进度条显示写入 SD 卡的进度。\\n', '写入完成后会弹出 “写入成功” 的提示框，单击“OK”完成写入。\\n', 'Linux 下刷写镜像\\n', '本节介绍如何在 Linux 环境下将镜像刷写到SD卡。\\n', '\\n', '查看磁盘分区信息\\n', '在 root 权限下执行 fdisk -l 获取 SD 卡磁盘信息，例如 SD 卡对应磁盘为 /dev/sdb。\\n', '\\n', '卸载 SD 卡挂载点\\n', '执行 df -lh 命令查看当前已挂载的卷。\\n', '\\n', '如果 SD 卡对应的分区未挂载，则跳过该步骤；如果 SD 卡对应分区已挂载，如 SD 卡对应的两个分区 /dev/sdb1 和 /dev/sdb3 已挂载，则需要卸载对应分区，在 root 权限下执行以下命令：\\n', '\\n', 'umount /dev/sdb1\\n', '\\n', 'umount /dev/sdb3\\n', '\\n', '写入 SD 卡\\n', '如果获取的是压缩后的镜像，需要先执行 xz -d openEuler-22.03_LTS-raspi-aarch64.img.xz 命令将压缩文件解压得到“openEuler-22.03_LTS-raspi-aarch64.img”镜像文件；否则，跳过该步骤。\\n', '\\n', '将镜像 openEuler-22.03_LTS-raspi-aarch64.img 刷写入 SD 卡，在 root 权限下执行以下命令：\\n', '\\n', 'dd bs=4M if=openEuler-22.03_LTS-raspi-aarch64.img of=/dev/sdb\\n', '\\n', ' 说明： 一般情况下，将块大小设置为 4M。如果写入失败或者写入的镜像无法使用，可以尝试将块大小设置为 1M 重新写入，但是设置为 1M 比较耗时。\\n', '\\n', 'Mac 下刷写镜像\\n', '本节介绍如何在 Mac 环境下将镜像刷写到SD卡。\\n', '\\n', '查看磁盘分区信息\\n', '在 root 权限下执行 diskutil list 获取 SD 卡磁盘信息，例如 SD 卡对应磁盘为 /dev/disk3。\\n', '\\n', '卸载 SD 卡挂载点\\n', '执行 df -lh 命令查看当前已挂载的卷。\\n', '\\n', '如果 SD 卡对应的分区未挂载，则跳过该步骤；如果 SD 卡对应分区已挂载，如 SD 卡对应的两个分区 /dev/disk3s1 和 /dev/disk3s3 已挂载，则需要卸载对应分区，在 root 权限下执行以下命令：\\n', '\\n', 'diskutil umount /dev/disk3s1\\n', '\\n', 'diskutil umount /dev/disk3s3\\n', '\\n', '写入 SD 卡\\n', '如果获取的是压缩后的镜像，需要先执行 xz -d openEuler-22.03_LTS-raspi-aarch64.img.xz 命令将压缩文件解压得到“openEuler-22.03_LTS-raspi-aarch64.img”镜像文件；否则，跳过该步骤。\\n', '\\n', '将镜像 openEuler-22.03_LTS-raspi-aarch64.img 刷入 SD 卡，在 root 权限下执行以下命令：\\n', '\\n', 'dd bs=4m if=openEuler-22.03_LTS-raspi-aarch64.img of=/dev/sdb\\n', '\\n', ' 说明： 一般情况下，将块大小设置为 4m。如果写入失败或者写入的镜像无法使用，可以尝试将块大小设置为 1m 重新写入，但是设置为 1m 比较耗时。']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_通过systemd启动容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E9%80%9A%E8%BF%87systemd%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8.html", "text_entry": "['通过systemd启动容器\\n', '功能描述\\n', '系统容器与普通容器最大的差异就在于容器启动的init进程，普通容器无法通过systemd启动系统服务，而系统容器具备这个能力，通过在启动容器时指定--system-container参数可以使能systemd服务。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--system-container\\n', '\\n', '布尔变量，取值为true、false，未指定值时表示true。\\n', '指定某个容器类型是否属于系统容器，必须使能。\\n', '约束限制\\n', 'systemd服务需要调用一些特殊系统调用，包括mount、umount2、unshare、reboot以及name_to_handle_at，所以在不开启特权容器标签的情况下，系统容器打开了调用上述接口的权限。\\n', '系统容器都是init启动，init进程不响应表示正常退出的SIGTERM信号，stop默认在10s之后才会强制杀死容器。如果需要快速结束，可以手动指定stop的超时时间。\\n', '--system-container必须配合--external-rootfs参数一起使用。\\n', '系统容器内支持运行各类服务，服务的启停通过systemctl来管理，服务之间可能会出现相互依赖关系导致异常情况下某些服务进程出现D/Z状态，使得容器无法正常退出。\\n', '系统容器内的某些服务进程可能会影响其它操作结果，例如容器内若运行了NetworkManager服务，可能会影响向容器添加网卡的行为（网卡添加成功然后被NetworkManger停掉），导致不可预期的结果。\\n', '系统容器和主机暂时无法实现udev事件隔离，所以fstab配置也暂不支持。\\n', 'systemd服务可能和libcgroup提供的cgconfig服务在功能上出现冲突，建议在容器内去掉libcgroup相关的包或者配置cgconfig服务的Delegate值为no。\\n', '使用示例\\n', '指定--system-container和--external-rootfs参数启动系统容器。\\n', '\\n', '[root@localhost ~]# isula run -tid -n systest01 --system-container --external-rootfs /root/myrootfs none init\\n', '执行以上命令后容器成功运行，通过exec进容器查看进程信息，可看到systemd服务已启动。\\n', '\\n', '[root@localhost ~]# isula exec -it systest01 bash\\n', '[root@localhost /]# ps -ef\\n', 'UID        PID  PPID  C STIME TTY          TIME CMD\\n', 'root         1     0  2 06:49 ?        00:00:00 init\\n', 'root        14     1  2 06:49 ?        00:00:00 /usr/lib/systemd/systemd-journal\\n', 'root        16     1  0 06:49 ?        00:00:00 /usr/lib/systemd/systemd-network\\n', 'dbus        23     1  0 06:49 ?        00:00:00 /usr/bin/dbus-daemon --system --\\n', 'root        25     0  0 06:49 ?        00:00:00 bash\\n', 'root        59    25  0 06:49 ?        00:00:00 ps –ef\\n', '容器内执行systemctl命令查看服务状态，可看到服务被systemd管理。\\n', '\\n', '[root@localhost /]# systemctl status dbus\\n', '● dbus.service - D-Bus System Message Bus\\n', '   Loaded: loaded (/usr/lib/systemd/system/dbus.service; static; vendor preset:\\n', 'disabled)\\n', '   Active: active (running) since Mon 2019-07-22 06:49:38 UTC; 2min 5\\n', '8s ago\\n', '     Docs: man:dbus-daemon(1)\\n', ' Main PID: 23 (dbus-daemon)\\n', '   CGroup: /system.slice/dbus.service\\n', '           └─23 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidf\\n', 'ile --systemd-activation --syslog-only\\n', '\\n', 'Jul 22 06:49:38 localhost systemd[1]: Started D-Bus System Message Bus.\\n', '容器内通过systemctl stop/start服务，可看到服务被systemd管理。\\n', '\\n', '[root@localhost /]# systemctl stop dbus\\n', 'Warning: Stopping dbus.service, but it can still be activated by:\\n', '  dbus.socket\\n', '[root@localhost /]# systemctl start dbus']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_CRI接口.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/CRI%E6%8E%A5%E5%8F%A3.html", "text_entry": "['CRI接口\\n', 'CRI接口\\n', '描述\\n', '接口\\n', 'Runtime服务\\n', 'RunPodSandbox\\n', 'StopPodSandbox\\n', 'RemovePodSandbox\\n', 'PodSandboxStatus\\n', 'ListPodSandbox\\n', 'CreateContainer\\n', 'StartContainer\\n', 'StopContainer\\n', 'RemoveContainer\\n', 'ListContainers\\n', 'ContainerStatus\\n', 'UpdateContainerResources\\n', 'ExecSync\\n', 'Exec\\n', 'Attach\\n', 'ContainerStats\\n', 'ListContainerStats\\n', 'UpdateRuntimeConfig\\n', 'Status\\n', 'Image服务\\n', 'ListImages\\n', 'ImageStatus\\n', 'PullImage\\n', 'RemoveImage\\n', 'ImageFsInfo\\n', '约束\\n', '描述\\n', 'CRI API 接口是由kubernetes 推出的容器运行时接口，CRI定义了容器和镜像的服务接口。ISulad使用CRI接口，实现和kubernetes 的对接。\\n', '\\n', '因为容器运行时与镜像的生命周期是彼此隔离的，因此需要定义两个服务。该接口使用Protocol Buffer定义，基于gRPC。\\n', '\\n', '当前实现CRI版本为v1alpha1版本，官方API描述文件如下：\\n', '\\n', 'https://github.com/kubernetes/kubernetes/blob/release-1.14/pkg/kubelet/apis/cri/runtime/v1alpha2/api.proto，\\n', '\\n', 'ISulad使用的为pass使用的1.14版本API描述文件，与官方API略有出入，以本文档描述的接口为准。\\n', '\\n', ' 说明：\\n', 'CRI接口websocket流式服务，服务端侦听地址为127.0.0.1，端口为10350，端口可通过命令行–websocket-server-listening-port参数接口或者daemon.json配置文件进行配置。\\n', '\\n', '接口\\n', '各接口中可能用到的参数清单如下，部分参数暂不支持配置，已在配置中标出。\\n', '\\n', '接口参数列表\\n', 'DNSConfig\\n', '\\n', '配置sandbox的DNS服务器和搜索域\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'repeated string servers\\n', '\\n', '集群的DNS服务器列表\\n', '\\n', 'repeated string searches\\n', '\\n', '集群的DNS搜索域列表\\n', '\\n', 'repeated string options\\n', '\\n', 'DNS可选项列表，参考https://linux.die.net/man/5/resolv.conf\\n', '\\n', 'Protocol\\n', '\\n', '协议的enum值列表\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'TCP = 0\\n', '\\n', 'TCP协议\\n', '\\n', 'UDP = 1\\n', '\\n', 'UDP协议\\n', '\\n', 'PortMapping\\n', '\\n', '指定sandbox的端口映射配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'Protocol protocol\\n', '\\n', '端口映射使用的协议\\n', '\\n', 'int32 container_port\\n', '\\n', '容器内的端口号\\n', '\\n', 'int32 host_port\\n', '\\n', '主机上的端口号\\n', '\\n', 'string host_ip\\n', '\\n', '主机IP地址\\n', '\\n', 'MountPropagation\\n', '\\n', '挂载传播属性的enum列表\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PROPAGATION_PRIVATE = 0\\n', '\\n', '无挂载传播属性，即linux中的private\\n', '\\n', 'PROPAGATION_HOST_TO_CONTAINER = 1\\n', '\\n', '挂载属性能从host传播到容器中，即linux中的rslave\\n', '\\n', 'PROPAGATION_BIDIRECTIONAL = 2\\n', '\\n', '挂载属性能在host和容器中双向传播，即linux中的rshared\\n', '\\n', 'Mount\\n', '\\n', 'Mount指定host上的一个挂载卷挂载到容器中（只支持文件和文件夹)\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_path\\n', '\\n', '容器中的路径\\n', '\\n', 'string host_path\\n', '\\n', '主机上的路径\\n', '\\n', 'bool readonly\\n', '\\n', '是否配置在容器中是只读的， 默认值： false\\n', '\\n', 'bool selinux_relabel\\n', '\\n', '是否设置SELinux标签（不支持配置）\\n', '\\n', 'MountPropagation propagation\\n', '\\n', '挂载传播属性配置（取值0/1/2，分别对应private/rslave/rshared传播属性） 默认值：0\\n', '\\n', 'NamespaceOption\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'bool host_network\\n', '\\n', '是否使用host的网络命名空间\\n', '\\n', 'bool host_pid\\n', '\\n', '是否使用host的PID命名空间\\n', '\\n', 'bool host_ipc\\n', '\\n', '是否使用host的IPC命名空间\\n', '\\n', 'Capability\\n', '\\n', '包含待添加与待删除的权能信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'repeated string add_capabilities\\n', '\\n', '待新增的权能\\n', '\\n', 'repeated string drop_capabilities\\n', '\\n', '待删除的权能\\n', '\\n', 'Int64Value\\n', '\\n', 'int64类型的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 value\\n', '\\n', '实际的int64值\\n', '\\n', 'UInt64Value\\n', '\\n', 'uint64类型的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'uint64 value\\n', '\\n', '实际的uint64值\\n', '\\n', 'LinuxSandboxSecurityContext\\n', '\\n', '配置sandbox的linux安全选项。\\n', '\\n', '注意，这些安全选项不会应用到sandbox中的容器中，也可能不适用于没有任何running进程的sandbox\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'NamespaceOption namespace_options\\n', '\\n', '配置sandbox的命名空间选项\\n', '\\n', 'SELinuxOption selinux_options\\n', '\\n', '配置SELinux选项（不支持）\\n', '\\n', 'Int64Value run_as_user\\n', '\\n', '配置sandbox中进程的uid\\n', '\\n', 'bool readonly_rootfs\\n', '\\n', '配置sandbox的根文件系统是否只读\\n', '\\n', 'repeated int64 supplemental_groups\\n', '\\n', '配置除主GID之外的sandbox的1号进程用户组信息\\n', '\\n', 'bool privileged\\n', '\\n', '配置sandbox是否为特权容器\\n', '\\n', 'string seccomp_profile_path\\n', '\\n', 'seccomp配置文件路径，有效值为：\\n', '\\n', '// unconfined: 不配置seccomp\\n', '\\n', '// localhost/<配置文件的全路径>： 安装在系统上的配置文件路径\\n', '\\n', '// <配置文件的全路径>： 配置文件全路径\\n', '\\n', '// 默认不配置，即unconfined。\\n', '\\n', 'LinuxPodSandboxConfig\\n', '\\n', '设定和Linux主机及容器相关的一些配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string cgroup_parent\\n', '\\n', 'sandbox的cgroup父路径，runtime可根据实际情况使用cgroupfs或systemd的语法。（不支持配置）\\n', '\\n', 'LinuxSandboxSecurityContext security_context\\n', '\\n', 'sandbox的安全属性\\n', '\\n', 'map<string, string> sysctls\\n', '\\n', 'sandbox的linux sysctls配置\\n', '\\n', 'PodSandboxMetadata\\n', '\\n', 'Sandbox元数据包含构建sandbox名称的所有信息，鼓励容器运行时在用户界面中公开这些元数据以获得更好的用户体验，例如，运行时可以根据元数据生成sandbox的唯一命名。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string name\\n', '\\n', 'sandbox的名称\\n', '\\n', 'string uid\\n', '\\n', 'sandbox的UID\\n', '\\n', 'string namespace\\n', '\\n', 'sandbox的命名空间\\n', '\\n', 'uint32 attempt\\n', '\\n', '尝试创建sandbox的次数，默认为0\\n', '\\n', 'PodSandboxConfig\\n', '\\n', '包含创建sandbox的所有必选和可选配置信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxMetadata metadata\\n', '\\n', 'sandbox的元数据，这项信息唯一标识一个sandbox，runtime必须利用此信息确保操作正确，runtime也可以根据此信息来改善用户体验，例如构建可读的sandbox名称。\\n', '\\n', 'string hostname\\n', '\\n', 'sandbox的hostname\\n', '\\n', 'string log_directory\\n', '\\n', '配置sandbox内的容器的日志文件所存储的文件夹\\n', '\\n', 'DNSConfig dns_config\\n', '\\n', 'sandbox的DNS配置\\n', '\\n', 'repeated PortMapping port_mappings\\n', '\\n', 'sandbox的端口映射\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列sandbox的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可更改的，且能够利用PodSandboxStatus接口查询\\n', '\\n', 'LinuxPodSandboxConfig linux\\n', '\\n', '与linux主机相关的可选项\\n', '\\n', 'PodSandboxNetworkStatus\\n', '\\n', '描述sandbox的网络状态\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string ip\\n', '\\n', 'sandbox的ip地址\\n', '\\n', 'string name\\n', '\\n', 'sandbox内的网络接口名\\n', '\\n', 'string network\\n', '\\n', '附加网络的名称\\n', '\\n', 'Namespace\\n', '\\n', '命名空间选项\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'NamespaceOption options\\n', '\\n', 'Linux 命名空间选项\\n', '\\n', 'LinuxPodSandboxStatus\\n', '\\n', '描述Linux sandbox的状态\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'Namespace namespaces\\n', '\\n', 'sandbox命名空间\\n', '\\n', 'PodSandboxState\\n', '\\n', 'sandbox状态值的enum数据\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'SANDBOX_READY = 0\\n', '\\n', 'sandbox处于ready状态\\n', '\\n', 'SANDBOX_NOTREADY = 1\\n', '\\n', 'sandbox处于非ready状态\\n', '\\n', 'PodSandboxStatus\\n', '\\n', '描述Podsandbox的状态信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'PodSandboxMetadata metadata\\n', '\\n', 'sandbox的元数据\\n', '\\n', 'PodSandboxState state\\n', '\\n', 'sandbox的状态值\\n', '\\n', 'int64 created_at\\n', '\\n', 'sandbox的创建时间戳，单位纳秒\\n', '\\n', 'repeated PodSandboxNetworkStatus networks\\n', '\\n', 'sandbox的多平面网络状态\\n', '\\n', 'LinuxPodSandboxStatus linux\\n', '\\n', 'Linux规范的sandbox状态\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列sandbox的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'PodSandboxStateValue\\n', '\\n', '对PodSandboxState的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxState state\\n', '\\n', 'sandbox的状态值\\n', '\\n', 'PodSandboxFilter\\n', '\\n', '用于列出sandbox时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'PodSandboxStateValue state\\n', '\\n', 'sandbox的状态\\n', '\\n', 'map<string, string> label_selector\\n', '\\n', 'sandbox的labels，label只支持完全匹配，不支持正则匹配\\n', '\\n', 'PodSandbox\\n', '\\n', '包含最小化描述一个sandbox的数据\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'PodSandboxMetadata metadata\\n', '\\n', 'sandbox的元数据\\n', '\\n', 'PodSandboxState state\\n', '\\n', 'sandbox的状态值\\n', '\\n', 'int64 created_at\\n', '\\n', 'sandbox的创建时间戳，单位纳秒\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列sandbox的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'KeyValue\\n', '\\n', '键值对的封装\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string key\\n', '\\n', '键\\n', '\\n', 'string value\\n', '\\n', '值\\n', '\\n', 'SELinuxOption\\n', '\\n', '应用于容器的SELinux标签\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string user\\n', '\\n', '用户\\n', '\\n', 'string role\\n', '\\n', '角色\\n', '\\n', 'string type\\n', '\\n', '类型\\n', '\\n', 'string level\\n', '\\n', '级别\\n', '\\n', 'ContainerMetadata\\n', '\\n', 'Container元数据包含构建container名称的所有信息，鼓励容器运行时在用户界面中公开这些元数据以获得更好的用户体验，例如，运行时可以根据元数据生成container的唯一命名。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string name\\n', '\\n', 'container的名称\\n', '\\n', 'uint32 attempt\\n', '\\n', '尝试创建container的次数，默认为0\\n', '\\n', 'ContainerState\\n', '\\n', '容器状态值的enum列表\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'CONTAINER_CREATED = 0\\n', '\\n', 'container创建完成\\n', '\\n', 'CONTAINER_RUNNING = 1\\n', '\\n', 'container处于运行状态\\n', '\\n', 'CONTAINER_EXITED = 2\\n', '\\n', 'container处于退出状态\\n', '\\n', 'CONTAINER_UNKNOWN = 3\\n', '\\n', '未知的容器状态\\n', '\\n', 'ContainerStateValue\\n', '\\n', '封装ContainerState的数据结构\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerState state\\n', '\\n', '容器状态值\\n', '\\n', 'ContainerFilter\\n', '\\n', '用于列出container时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'PodSandboxStateValue state\\n', '\\n', 'container的状态\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'map<string, string> label_selector\\n', '\\n', 'container的labels，label只支持完全匹配，不支持正则匹配\\n', '\\n', 'LinuxContainerSecurityContext\\n', '\\n', '指定应用于容器的安全配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'Capability capabilities\\n', '\\n', '新增或去除的权能\\n', '\\n', 'bool privileged\\n', '\\n', '指定容器是否未特权模式， 默认值：false\\n', '\\n', 'NamespaceOption namespace_options\\n', '\\n', '指定容器的namespace选项\\n', '\\n', 'SELinuxOption selinux_options\\n', '\\n', 'SELinux context(可选配置项) 暂不支持\\n', '\\n', 'Int64Value run_as_user\\n', '\\n', '运行容器进程的UID。 一次只能指定run_as_user与run_as_username其中之一，run_as_username优先生效\\n', '\\n', 'string run_as_username\\n', '\\n', '运行容器进程的用户名。 如果指定，用户必须存在于容器映像中（即在映像内的/etc/passwd中），并由运行时在那里解析; 否则，运行时必须出错\\n', '\\n', 'bool readonly_rootfs\\n', '\\n', '设置容器中根文件系统是否为只读 默认值由config.json配置\\n', '\\n', 'repeated int64 supplemental_groups\\n', '\\n', '容器运行的除主GID外首进程组的列表\\n', '\\n', 'string apparmor_profile\\n', '\\n', '容器的AppArmor配置文件 暂不支持\\n', '\\n', 'string seccomp_profile_path\\n', '\\n', '容器的seccomp配置文件路径\\n', '\\n', 'bool no_new_privs\\n', '\\n', '是否在容器上设置no_new_privs的标志\\n', '\\n', 'LinuxContainerResources\\n', '\\n', '指定Linux容器资源的特定配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 cpu_period\\n', '\\n', 'CPU CFS（完全公平调度程序）周期。 默认值：0\\n', '\\n', 'int64 cpu_quota\\n', '\\n', 'CPU CFS（完全公平调度程序）配额。 默认值：0\\n', '\\n', 'int64 cpu_shares\\n', '\\n', '所占CPU份额（相对于其他容器的相对权重）。 默认值：0\\n', '\\n', 'int64 memory_limit_in_bytes\\n', '\\n', '内存限制（字节）。 默认值：0\\n', '\\n', 'int64 oom_score_adj\\n', '\\n', 'OOMScoreAdj用于调整oom-killer。 默认值：0\\n', '\\n', 'string cpuset_cpus\\n', '\\n', '指定容器使用的CPU核心。 默认值：“”\\n', '\\n', 'string cpuset_mems\\n', '\\n', '指定容器使用的内存节点。 默认值：“”\\n', '\\n', 'Image\\n', '\\n', 'Image信息描述一个镜像的基本数据。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', '镜像ID\\n', '\\n', 'repeated string repo_tags\\n', '\\n', '镜像tag 名称 repo_tags\\n', '\\n', 'repeated string repo_digests\\n', '\\n', '镜像digest信息\\n', '\\n', 'uint64 size\\n', '\\n', '镜像大小\\n', '\\n', 'Int64Value uid\\n', '\\n', '镜像默认用户UID\\n', '\\n', 'string username\\n', '\\n', '镜像默认用户名称\\n', '\\n', 'ImageSpec\\n', '\\n', '表示镜像的内部数据结构，当前，ImageSpec只封装容器镜像名称\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string image\\n', '\\n', '容器镜像名\\n', '\\n', 'StorageIdentifier\\n', '\\n', '唯一定义storage的标识\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string uuid\\n', '\\n', '设备的UUID\\n', '\\n', 'FilesystemUsage\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '收集文件系统信息时的时间戳\\n', '\\n', 'StorageIdentifier storage_id\\n', '\\n', '存储镜像的文件系统UUID\\n', '\\n', 'UInt64Value used_bytes\\n', '\\n', '存储镜像元数据的大小\\n', '\\n', 'UInt64Value inodes_used\\n', '\\n', '存储镜像元数据的inodes个数\\n', '\\n', 'AuthConfig\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string username\\n', '\\n', '下载镜像使用的用户名\\n', '\\n', 'string password\\n', '\\n', '下载镜像使用的密码\\n', '\\n', 'string auth\\n', '\\n', '下载镜像时使用的认证信息，base64编码\\n', '\\n', 'string server_address\\n', '\\n', '下载镜像的服务器地址，暂不支持\\n', '\\n', 'string identity_token\\n', '\\n', '用于与镜像仓库鉴权的令牌信息，暂不支持\\n', '\\n', 'string registry_token\\n', '\\n', '用于与镜像仓库交互的令牌信息，暂不支持\\n', '\\n', 'Container\\n', '\\n', '用于描述容器信息，例如ID, 状态等。\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', '该容器所属的sandbox的ID\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', 'container的元数据\\n', '\\n', 'ImageSpec image\\n', '\\n', '镜像规格\\n', '\\n', 'string image_ref\\n', '\\n', '代表容器使用的镜像，对大多数runtime来产，这是一个image ID值\\n', '\\n', 'ContainerState state\\n', '\\n', 'container的状态\\n', '\\n', 'int64 created_at\\n', '\\n', 'container的创建时间戳，单位为纳秒\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列container的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'ContainerStatus\\n', '\\n', '用于描述容器状态信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', 'container的元数据\\n', '\\n', 'ContainerState state\\n', '\\n', 'container的状态\\n', '\\n', 'int64 created_at\\n', '\\n', 'container的创建时间戳，单位为纳秒\\n', '\\n', 'int64 started_at\\n', '\\n', 'container启动时的时间戳，单位为纳秒\\n', '\\n', 'int64 finished_at\\n', '\\n', 'container退出时的时间戳，单位为纳秒\\n', '\\n', 'int32 exit_code\\n', '\\n', '容器退出码\\n', '\\n', 'ImageSpec image\\n', '\\n', '镜像规格\\n', '\\n', 'string image_ref\\n', '\\n', '代表容器使用的镜像，对大多数runtime来产，这是一个image ID值\\n', '\\n', 'string reason\\n', '\\n', '简要描述为什么容器处于当前状态\\n', '\\n', 'string message\\n', '\\n', '易于人工阅读的信息，用于表述容器处于当前状态的原因\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于标识单个或一系列container的键值对\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'repeated Mount mounts\\n', '\\n', '容器的挂载点信息\\n', '\\n', 'string log_path\\n', '\\n', '容器日志文件路径，该文件位于PodSandboxConfig中配置的log_directory文件夹下\\n', '\\n', 'ContainerStatsFilter\\n', '\\n', '用于列出container stats时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', 'container的ID\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的ID\\n', '\\n', 'map<string, string> label_selector\\n', '\\n', 'container的labels，label只支持完全匹配，不支持正则匹配\\n', '\\n', 'ContainerStats\\n', '\\n', '用于列出container stats时添加过滤条件，多个条件取交集显示\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerAttributes attributes\\n', '\\n', '容器的信息\\n', '\\n', 'CpuUsage cpu\\n', '\\n', 'CPU使用情况\\n', '\\n', 'MemoryUsage memory\\n', '\\n', '内存使用情况\\n', '\\n', 'FilesystemUsage writable_layer\\n', '\\n', '可写层使用情况\\n', '\\n', 'ContainerAttributes\\n', '\\n', '列出container的基本信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string id\\n', '\\n', '容器的ID\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', '容器的metadata\\n', '\\n', 'map<string,string> labels\\n', '\\n', '可用于标识单个或一系列container的键值对\\n', '\\n', 'map<string,string> annotations\\n', '\\n', '存储任意信息的键值对，这些值是不可被runtime更改的\\n', '\\n', 'CpuUsage\\n', '\\n', '列出container的CPU使用信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '时间戳\\n', '\\n', 'UInt64Value usage_core_nano_seconds\\n', '\\n', 'CPU的使用值，单位/纳秒\\n', '\\n', 'MemoryUsage\\n', '\\n', '列出container的内存使用信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '时间戳\\n', '\\n', 'UInt64Value working_set_bytes\\n', '\\n', '内存的使用值\\n', '\\n', 'FilesystemUsage\\n', '\\n', '列出container的读写层信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'int64 timestamp\\n', '\\n', '时间戳\\n', '\\n', 'StorageIdentifier storage_id\\n', '\\n', '可写层目录\\n', '\\n', 'UInt64Value used_bytes\\n', '\\n', '镜像在可写层的占用字节\\n', '\\n', 'UInt64Value inodes_used\\n', '\\n', '镜像在可写层的占用inode数\\n', '\\n', 'Device\\n', '\\n', '指定待挂载至容器的主机卷\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_path\\n', '\\n', '容器内的挂载路径\\n', '\\n', 'string host_path\\n', '\\n', '主机上的挂载路径\\n', '\\n', 'string permissions\\n', '\\n', '设备的Cgroup权限，（r允许容器从指定的设备读取; w允许容器从指定的设备写入; m允许容器创建尚不存在的设备文件)\\n', '\\n', 'LinuxContainerConfig\\n', '\\n', '包含特定于Linux平台的配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'LinuxContainerResources resources\\n', '\\n', '容器的资源规范\\n', '\\n', 'LinuxContainerSecurityContext security_context\\n', '\\n', '容器的Linux容器安全配置\\n', '\\n', 'ContainerConfig\\n', '\\n', '包含用于创建容器的所有必需和可选字段\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerMetadata metadata\\n', '\\n', '容器的元数据。 此信息将唯一标识容器，运行时应利用此信息来确保正确操作。 运行时也可以使用此信息来提升UX（用户体检设计），例如通过构造可读名称。(必选)\\n', '\\n', 'ImageSpec image\\n', '\\n', '容器使用的镜像 (必选)\\n', '\\n', 'repeated string command\\n', '\\n', '待执行的命令 默认值： \"/bin/sh\"\\n', '\\n', 'repeated string args\\n', '\\n', '待执行命令的参数\\n', '\\n', 'string working_dir\\n', '\\n', '命令执行的当前工作路径\\n', '\\n', 'repeated KeyValue envs\\n', '\\n', '在容器中配置的环境变量\\n', '\\n', 'repeated Mount mounts\\n', '\\n', '待在容器中挂载的挂载点信息\\n', '\\n', 'repeated Device devices\\n', '\\n', '待在容器中映射的设备信息\\n', '\\n', 'map<string, string> labels\\n', '\\n', '可用于索引和选择单个资源的键值对。\\n', '\\n', 'map<string, string> annotations\\n', '\\n', '可用于存储和检索任意元数据的非结构化键值映射。\\n', '\\n', 'string log_path\\n', '\\n', '相对于PodSandboxConfig.LogDirectory的路径，用于存储容器主机上的日志（STDOUT和STDERR）。\\n', '\\n', 'bool stdin\\n', '\\n', '是否打开容器的stdin\\n', '\\n', 'bool stdin_once\\n', '\\n', '当某次连接stdin的数据流断开时，是否立即断开其他与stdin连接的数据流（暂不支持）\\n', '\\n', 'bool tty\\n', '\\n', '是否使用伪终端连接容器的stdio\\n', '\\n', 'LinuxContainerConfig linux\\n', '\\n', 'linux系统上容器的特定配置信息\\n', '\\n', 'NetworkConfig\\n', '\\n', 'Runtime的网络配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_cidr\\n', '\\n', 'Pod IP 地址使用的CIDR\\n', '\\n', 'RuntimeConfig\\n', '\\n', 'Runtime的网络配置\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'NetworkConfig network_config\\n', '\\n', 'Runtime的网络配置\\n', '\\n', 'RuntimeCondition\\n', '\\n', '描述runtime的状态信息\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string type\\n', '\\n', 'Runtime状态的类型\\n', '\\n', 'bool status\\n', '\\n', 'Runtime状态\\n', '\\n', 'string reason\\n', '\\n', '简要描述runtime状态变化的原因\\n', '\\n', 'string message\\n', '\\n', '具备可阅读性的信息表明runtime状态变化的原因\\n', '\\n', 'RuntimeStatus\\n', '\\n', 'Runtime的状态\\n', '\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'repeated RuntimeCondition conditions\\n', '\\n', '描述当前runtime状态的列表\\n', '\\n', 'Runtime服务\\n', 'Runtime服务中包含操作pod和容器的接口，以及查询runtime自身配置和状态信息的接口。\\n', '\\n', 'runpodsandbox\\n', '接口原型\\n', 'rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) {}\\n', '接口描述\\n', '创建和启动一个pod sandbox，若运行成功，sandbox处于ready状态。\\n', '\\n', '注意事项\\n', '启动sandbox的默认镜像为rnd-dockerhub.huawei.com/library/pause-${machine}:3.0， 其中${machine}为架构，在x86_64上，machine的值为amd64，在arm64上，machine的值为aarch64，当前rnd-dockerhub仓库上只有amd64和aarch64镜像可供下载，若机器上无此镜像，请确保机器能从rnd-dockerhub下载，若要使用其它镜像，请参考“iSulad部署配置”中的pod-sandbox-image指定镜像。\\n', '由于容器命名以PodSandboxMetadata中的字段为来源，且以下划线\"_“为分割字符，因此限制metadata中的数据不能包含下划线，否则会出现sandbox运行成功，但无法使用ListPodSandbox接口查询的现象。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxConfig config\\n', '\\n', 'sandbox的配置\\n', '\\n', 'string runtime_handler\\n', '\\n', '指定创建sandbox的runtime运行时，当前支持lcr、kata-runtime运行时类型。\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', '成功，返回response数据\\n', '\\n', 'StopPodSandbox\\n', '接口原型\\n', 'rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) {}\\n', '接口描述\\n', '停止pod sandbox，停止sandbox容器，回收分配给sandbox的网络资源（比如IP地址）。如果有任何running的容器属于该sandbox，则必须被强制停止。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', '无\\n', '\\n', '无\\n', '\\n', 'RemovePodSandbox\\n', '接口原型\\n', 'rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) {}\\n', '接口描述\\n', '删除sandbox，如果有任何running的容器属于该sandbox，则必须被强制停止和删除，如果sandbox已经被删除，不能返回错误。\\n', '\\n', '注意事项\\n', '删除sandbox时，不会删除sandbox的网络资源，在删除pod前必须先调用StopPodSandbox才能清理网络资源，调用者应当保证在删除sandbox之前至少调用一次StopPodSandbox。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', '无\\n', '\\n', '无\\n', '\\n', 'PodSandboxStatus\\n', '接口原型\\n', 'rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) {}\\n', '接口描述\\n', '查询sandbox的状态，如果sandbox不存在，返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', 'sandbox的id\\n', '\\n', 'bool verbose\\n', '\\n', '标识是否显示sandbox的一些额外信息。（暂不支持配置）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'PodSandboxStatus status\\n', '\\n', 'sandbox的状态信息\\n', '\\n', 'map<string, string> info\\n', '\\n', 'sandbox的额外信息，key是任意string，value是json格式的字符串，这些信息可以是任意调试内容。当verbose为true时info不能为空。（暂不支持配置）\\n', '\\n', 'ListPodSandbox\\n', '接口原型\\n', 'rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) {}\\n', '接口描述\\n', '返回sandbox信息的列表，支持条件过滤。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'PodSandboxFilter filter\\n', '\\n', '条件过滤参数\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated PodSandbox items\\n', '\\n', 'sandbox信息的列表\\n', '\\n', 'CreateContainer\\n', 'grpc::Status CreateContainer(grpc::ServerContext *context, const runtime::CreateContainerRequest *request, runtime::CreateContainerResponse *reply) {}\\n', '接口描述\\n', '在PodSandbox内创建一个容器。\\n', '\\n', '注意事项\\n', '请求CreateContainerRequest 中的sandbox_config与传递给RunPodSandboxRequest以创建PodSandbox的配置相同。 它再次传递，只是为了方便参考。 PodSandboxConfig是不可变的，在pod的整个生命周期内保持不变。\\n', '由于容器命名以ContainerMetadata中的字段为来源，且以下划线”_“为分割字符，因此限制metadata中的数据不能包含下划线，否则会出现sandbox运行成功，但无法使用ListContainers接口查询的现象。\\n', 'CreateContainerRequest中无runtime_handler字段，创建container时的runtime类型和其对应的sandbox的runtime相同。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string pod_sandbox_id\\n', '\\n', '待在其中创建容器的PodSandbox的ID。\\n', '\\n', 'ContainerConfig config\\n', '\\n', '容器的配置信息\\n', '\\n', 'PodSandboxConfig sandbox_config\\n', '\\n', 'PodSandbox的配置信息\\n', '\\n', '补充\\n', '可用于存储和检索任意元数据的非结构化键值映射。有一些字段由于cri接口没有提供特定的参数，可通过该字段将参数传入\\n', '\\n', '自定义\\n', '\\n', '\\n', '自定义 key:value\\n', '\\n', '描述\\n', '\\n', 'cgroup.pids.max:int64_t\\n', '\\n', '用于限制容器内的进/线程数（set -1 for unlimited）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '创建完成的容器ID\\n', '\\n', 'StartContainer\\n', '接口原型\\n', 'rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) {}\\n', '接口描述\\n', '启动一个容器。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', '无\\n', '\\n', '无\\n', '\\n', 'StopContainer\\n', '接口原型\\n', 'rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) {}\\n', '接口描述\\n', '停止一个running的容器，支持配置优雅停止时间timeout，如果容器已经停止，不能返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', 'int64 timeout\\n', '\\n', '强制停止容器前的等待时间，默认值为0，即强制停止容器。\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'RemoveContainer\\n', '接口原型\\n', 'rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) {}\\n', '接口描述\\n', '删除一个容器，如果容器正在运行，必须强制停止，如果容器已经被删除，不能返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'ListContainers\\n', '接口原型\\n', 'rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) {}\\n', '接口描述\\n', '返回container信息的列表，支持条件过滤。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerFilter filter\\n', '\\n', '条件过滤参数\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated Container containers\\n', '\\n', '容器信息的列表\\n', '\\n', 'ContainerStatus\\n', '接口原型\\n', 'rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) {}\\n', '接口描述\\n', '返回容器状态信息，如果容器不存在，则返回错误。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', 'bool verbose\\n', '\\n', '标识是否显示sandbox的一些额外信息。（暂不支持配置）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'ContainerStatus status\\n', '\\n', '容器的状态信息\\n', '\\n', 'map<string, string> info\\n', '\\n', 'sandbox的额外信息，key是任意string，value是json格式的字符串，这些信息可以是任意调试内容。当verbose为true时info不能为空。（暂不支持配置）\\n', '\\n', 'UpdateContainerResources\\n', '接口原型\\n', 'rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) {}\\n', '接口描述\\n', '该接口用于更新容器资源配置。\\n', '\\n', '注意事项\\n', '该接口仅用于更新容器的资源配置，不能用于更新Pod的资源配置。\\n', '当前不支持更新容器oom_score_adj配置。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', 'LinuxContainerResources linux\\n', '\\n', 'linux资源配置信息\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'ExecSync\\n', '接口原型\\n', 'rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) {}\\n', '接口描述\\n', '以同步的方式在容器中执行命令，采用的gRPC通讯方式。\\n', '\\n', '注意事项\\n', '执行执行一条单独的命令，不能打开终端与容器交互。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器ID\\n', '\\n', 'repeated string cmd\\n', '\\n', '待执行命令\\n', '\\n', 'int64 timeout\\n', '\\n', '停止命令的超时时间（秒）。 默认值：0（无超时限制）。 暂不支持\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'bytes stdout\\n', '\\n', '捕获命令标准输出\\n', '\\n', 'bytes stderr\\n', '\\n', '捕获命令标准错误输出\\n', '\\n', 'int32 exit_code\\n', '\\n', '退出代码命令完成。 默认值：0（成功）。\\n', '\\n', 'Exec\\n', '接口原型\\n', 'rpc Exec(ExecRequest) returns (ExecResponse) {}\\n', '接口描述\\n', '在容器中执行命令，采用的gRPC通讯方式从CRI服务端获取url，再通过获得的url与websocket服务端建立长连接，实现与容器的交互。\\n', '\\n', '注意事项\\n', '执行执行一条单独的命令，也能打开终端与容器交互。stdin/stdout/stderr之一必须是真的。如果tty为真，stderr必须是假的。 不支持多路复用, 在这种情况下, stdout和stderr的输出将合并为单流。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器ID\\n', '\\n', 'repeated string cmd\\n', '\\n', '待执行的命令\\n', '\\n', 'bool tty\\n', '\\n', '是否在TTY中执行命令\\n', '\\n', 'bool stdin\\n', '\\n', '是否流式标准输入\\n', '\\n', 'bool stdout\\n', '\\n', '是否流式标准输出\\n', '\\n', 'bool stderr\\n', '\\n', '是否流式输出标准错误\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string url\\n', '\\n', 'exec流服务器的完全限定URL\\n', '\\n', 'Attach\\n', '用法：docker attach [OPTIONS] CONTAINER\\n', '\\n', '功能：附加到一个运行着的容器\\n', '\\n', '选项：\\n', '\\n', '–no-stdin=false 不附加STDIN\\n', '\\n', '–sig-proxy=true 代理所有到容器内部的信号，不代理SIGCHLD, SIGKILL, SIGSTOP\\n', '\\n', '示例：\\n', '\\n', '$ sudo docker attach attach_test\\n', 'root@2988b8658669:/# ls bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\\n', 'ContainerStats\\n', '接口原型\\n', 'rpc ContainerStats(ContainerStatsRequest) returns (ContainerStatsResponse) {}\\n', '接口描述\\n', '返回单个容器占用资源信息，仅支持runtime类型为lcr的容器。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'string container_id\\n', '\\n', '容器id\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'ContainerStats stats\\n', '\\n', '容器信息。注：disk和inodes只支持oci格式镜像起的容器查询\\n', '\\n', 'ListContainerStats\\n', '接口原型\\n', 'rpc ListContainerStats(ListContainerStatsRequest) returns (ListContainerStatsResponse) {}\\n', '接口描述\\n', '返回多个容器占用资源信息，支持条件过滤\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ContainerStatsFilter filter\\n', '\\n', '条件过滤参数\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated ContainerStats stats\\n', '\\n', '容器信息的列表。注：disk和inodes只支持oci格式镜像启动的容器查询\\n', '\\n', 'UpdateRuntimeConfig\\n', '接口原型\\n', 'rpc UpdateRuntimeConfig(UpdateRuntimeConfigRequest) returns (UpdateRuntimeConfigResponse);\\n', '接口描述\\n', '提供标准的CRI接口，目的为了更新网络插件的Pod CIDR，当前CNI网络插件无需更新Pod CIDR，因此该接口只会记录访问日志。\\n', '\\n', '注意事项\\n', '接口操作不会对系统管理信息修改，只是记录一条日志。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'RuntimeConfig runtime_config\\n', '\\n', '包含Runtime要配置的信息\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'Status\\n', '接口原型\\n', 'rpc Status(StatusRequest) returns (StatusResponse) {};\\n', '接口描述\\n', '获取runtime和pod的网络状态，在获取网络状态时，会触发网络配置的刷新。仅支持runtime类型为lcr的容器。\\n', '\\n', '注意事项\\n', '如果网络配置刷新失败，不会影响原有配置；只有刷新成功时，才会覆盖原有配置。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'bool verbose\\n', '\\n', '是否显示关于Runtime额外的信息（暂不支持）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'RuntimeStatus status\\n', '\\n', 'Runtime的状态\\n', '\\n', 'map<string, string> info\\n', '\\n', 'Runtime额外的信息，info的key为任意值，value为json格式，可包含任何debug信息；只有Verbose为true是才应该被赋值\\n', '\\n', 'Image服务\\n', '提供了从镜像仓库拉取、查看、和移除镜像的gRPC API。\\n', '\\n', 'ListImages\\n', '接口原型\\n', 'rpc ListImages(ListImagesRequest) returns (ListImagesResponse) {}\\n', '接口描述\\n', '列出当前已存在的镜像信息。\\n', '\\n', '注意事项\\n', '为统一接口，对于embedded格式镜像，可以通过cri images查询到。但是因embedded镜像不是标准OCI镜像，因此查询得到的结果有以下限制：\\n', '\\n', '因embedded镜像无镜像ID，显示的镜像ID为镜像的config digest。\\n', '因embedded镜像本身无digest仅有config的digest，且格式不符合OCI镜像规范，因此无法显示digest。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec filter\\n', '\\n', '筛选的镜像名称\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated Image images\\n', '\\n', '镜像信息列表\\n', '\\n', 'ImageStatus\\n', '接口原型\\n', 'rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) {}\\n', '接口描述\\n', '查询指定镜像信息。\\n', '\\n', '注意事项\\n', '查询指定镜像信息，若镜像不存在，则返回ImageStatusResponse，其中Image设置为nil。\\n', '为统一接口，对于embedded格式镜像，因不符合OCI格式镜像，缺少字段，无法通过本接口进行查询。\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec image\\n', '\\n', '镜像名称\\n', '\\n', 'bool verbose\\n', '\\n', '查询额外信息，暂不支持，无额外信息返回\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'Image image\\n', '\\n', '镜像信息\\n', '\\n', 'map<string, string> info\\n', '\\n', '镜像额外信息，暂不支持，无额外信息返回\\n', '\\n', 'PullImage\\n', '接口原型\\n', ' rpc PullImage(PullImageRequest) returns (PullImageResponse) {}\\n', '接口描述\\n', '下载镜像。\\n', '\\n', '注意事项\\n', '当前支持下载public镜像，使用用户名、密码、auth信息下载私有镜像，不支持authconfig中的server_address、identity_token、registry_token字段。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec image\\n', '\\n', '要下载的镜像名称\\n', '\\n', 'AuthConfig auth\\n', '\\n', '下载私有镜像时的验证信息\\n', '\\n', 'PodSandboxConfig sandbox_config\\n', '\\n', '在Pod上下文中下载镜像（暂不支持）\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'string image_ref\\n', '\\n', '返回已下载镜像信息\\n', '\\n', 'RemoveImage\\n', '接口原型\\n', 'rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) {}\\n', '接口描述\\n', '删除指定镜像。\\n', '\\n', '注意事项\\n', '为统一接口，对于embedded格式镜像，因不符合OCI格式镜像，缺少字段，无法通过本接口使用image id进行删除。\\n', '\\n', '参数\\n', '\\n', '参数成员\\n', '\\n', '描述\\n', '\\n', 'ImageSpec image\\n', '\\n', '要删除的镜像名称或者ID\\n', '\\n', '返回值\\n', '无\\n', '\\n', 'ImageFsInfo\\n', '接口原型\\n', 'rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) {}\\n', '接口描述\\n', '查询存储镜像的文件系统信息。\\n', '\\n', '注意事项\\n', '查询到的为镜像元数据下的文件系统信息。\\n', '\\n', '参数\\n', '无\\n', '\\n', '返回值\\n', '\\n', '返回值\\n', '\\n', '描述\\n', '\\n', 'repeated FilesystemUsage image_filesystems\\n', '\\n', '镜像存储文件系统信息\\n', '\\n', '约束\\n', '如果创建sandbox时，PodSandboxConfig参数中配置了log_directory，则所有属于该sandbox的container在创建时必须在ContainerConfig中指定log_path，否则可能导致容器无法使用CRI接口启动，甚至无法使用CRI接口删除。\\n', '\\n', '容器的真实LOGPATH=log_directory/log_path，如果log_path不配置，那么最终的LOGPATH会变为LOGPATH=log_directory。\\n', '\\n', '如果该路径不存在，isulad在启动容器时会创建一个软链接，指向最终的容器日志真实路径，此时log_directory变成一个软链接，此时有两种情况：\\n', '\\n', '第一种情况，如果该sandbox里其它容器也没配置log_path，在启动其它容器时，log_directory会被删除，然后重新指向新启动容器的log_path，导致之前启动的容器日志指向后面启动容器的日志。\\n', '第二种情况，如果该sandbox里其它容器配置了log_path，则该容器的LOGPATH=log_directory/log_path，由于log_directory实际是个软链接，使用log_directory/log_path为软链接指向容器真实日志路径时，创建会失败。\\n', '如果该路径存在，isulad在启动容器时首先会尝试删除该路径（非递归），如果该路径是个文件夹，且里面有内容，删除会失败，从而导致创建软链接失败，容器启动失败，删除该容器时，也会出现同样的现象，导致删除失败。\\n', '\\n', '如果创建sandbox时，PodSandboxConfig参数中配置了log_directory，且container创建时在ContainerConfig中指定log_path，那么最终的LOGPATH=log_directory/log_path，isulad不会递归的创建LOGPATH，因而用户必须保证dirname(LOGPATH)存在，即最终的日志文件的上一级路径存在。\\n', '\\n', '如果创建sandbox时，PodSandboxConfig参数中配置了log_directory，如果有两个或多个container创建时在ContainerConfig中指定了同一个log_path，或者不同的sandbox内的容器最终指向的LOGPATH是同一路径，若容器启动成功，则后启动的容器日志路径会覆盖掉之前启动的容器日志路径。\\n', '\\n', '如果远程镜像仓库中镜像内容发生变化，调用CRI Pull image接口重新下载该镜像时，若本地原来存储有原镜像，则原镜像的镜像名称、TAG会变更为“none”\\n', '\\n', '举例如下：\\n', '\\n', '本地已存储镜像：\\n', '\\n', 'IMAGE                                        TAG                 IMAGE ID            SIZE\\n', 'rnd-dockerhub.huawei.com/pproxyisulad/test   latest              99e59f495ffaa       753kB\\n', '远程仓库中rnd-dockerhub.huawei.com/pproxyisulad/test:latest 镜像更新后，重新下载后：\\n', '\\n', 'IMAGE                                        TAG                 IMAGE ID            SIZE\\n', '<none>                                       <none>              99e59f495ffaa       753kB\\n', 'rnd-dockerhub.huawei.com/pproxyisulad/test   latest              d8233ab899d41       1.42MB\\n', '使用isula images 命令行查询，REF显示为”-\"：\\n', '\\n', 'REF                                               IMAGE ID               CREATED              SIZE       \\n', 'rnd-dockerhub.huawei.com/pproxyisulad/test:latest d8233ab899d41          2019-02-14 19:19:37  1.42MB     \\n', '-                                                 99e59f495ffaa          2016-05-04 02:26:41  753kB\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_账户口令.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/%E5%B8%90%E6%88%B7%E5%8F%A3%E4%BB%A4.html", "text_entry": "['帐户口令\\n', '帐户口令\\n', '屏蔽系统帐户\\n', '限制使用su命令的帐户\\n', '设置口令复杂度\\n', '设置口令有效期\\n', '设置口令的加密算法\\n', '登录失败超过三次后锁定\\n', '加固su命令\\n', '屏蔽系统帐户\\n', '说明\\n', '除了用户帐户外，其他账号称为系统帐户。系统帐户仅系统内部使用，禁止用于登录系统或其他操作，因此屏蔽系统帐户。\\n', '\\n', '实现\\n', '将系统帐户的Shell修改为/sbin/nologin。\\n', '\\n', 'usermod -L -s /sbin/nologin $systemaccount\\n', ' 说明：\\n', '$systemaccount 指系统帐户。\\n', '\\n', '限制使用su命令的帐户\\n', '说明\\n', 'su命令用于在不同帐户之间切换。为了增强系统安全性，有必要对su命令的使用权进行控制，只允许root和wheel群组的帐户使用su命令，限制其他帐户使用。\\n', '\\n', '实现\\n', 'su命令的使用控制通过修改/etc/pam.d/su文件实现，配置如下：\\n', '\\n', 'auth         required      pam_wheel.so use_uid\\n', '表 1 pam_wheel.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'use_uid\\n', '\\n', '基于当前帐户的uid。\\n', '\\n', '设置口令复杂度\\n', '说明\\n', '用户可以通过修改对应配置文件设置口令的复杂度要求，建议用户根据实际情况设置口令复杂度。\\n', '\\n', '实现\\n', '口令复杂度通过/etc/pam.d/password-auth和/etc/pam.d/system-auth文件中的pam_pwquality.so和pam_pwhistory.so模块实现。用户可以通过修改这两个模块中的配置项修改口令复杂度要求。\\n', '\\n', '设置举例\\n', '这里给出一个配置口令复杂度的例子，供用户参考。\\n', '\\n', '密码复杂度要求\\n', '\\n', '口令长度至少8个字符。\\n', '\\n', '口令必须包含如下至少3种字符的组合：\\n', '\\n', '－至少一个小写字母\\n', '\\n', '－至少一个大写字母\\n', '\\n', '－至少一个数字\\n', '\\n', '－至少一个特殊字符：`~!@#$%^&*()-_=+\\\\|[{}];:\\'\",<.>/?和空格\\n', '\\n', '口令不能和帐号或者帐号的倒写一样。\\n', '\\n', '不能修改为过去5次使用过的旧口令。\\n', '\\n', '配置实现\\n', '\\n', '在/etc/pam.d/password-auth和/etc/pam.d/system-auth文件中password配置项的前两行添加如下配置内容：\\n', '\\n', 'password    requisite     pam_pwquality.so minlen=8 minclass=3 enforce_for_root try_first_pass local_users_only retry=3 dcredit=0 ucredit=0 lcredit=0 ocredit=0 \\n', 'password    required      pam_pwhistory.so use_authtok remember=5 enforce_for_root\\n', '配置项说明\\n', '\\n', 'pam_pwquality.so和pam_pwhistory.so的配置项请分别参见表2和表3。\\n', '\\n', '表 2 pam_pwquality.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'minlen=8\\n', '\\n', '口令长度至少包含8个字符\\n', '\\n', 'minclass=3\\n', '\\n', '口令至少包含大写字母、小写字母、数字和特殊字符中的任意3种\\n', '\\n', 'ucredit=0\\n', '\\n', '口令包含任意个大写字母\\n', '\\n', 'lcredit=0\\n', '\\n', '口令包含任意个小写字母\\n', '\\n', 'dcredit=0\\n', '\\n', '口令包含任意个数字\\n', '\\n', 'ocredit=0\\n', '\\n', '口令包含任意个特殊字符\\n', '\\n', 'retry=3\\n', '\\n', '每次修改最多可以尝试3次\\n', '\\n', 'enforce_for_root\\n', '\\n', '本设置对root帐户同样有效\\n', '\\n', '表 3 pam_pwhistory.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'remember=5\\n', '\\n', '口令不能修改为过去5次使用过的旧口令\\n', '\\n', 'enforce_for_root\\n', '\\n', '本设置对root帐户同样有效\\n', '\\n', '设置口令有效期\\n', '说明\\n', '出于系统安全性考虑，建议设置口令有效期限，且口令到期前通知用户更改口令。\\n', '\\n', '实现\\n', '口令有效期的设置通过修改/etc/login.defs文件实现，加固项如表7所示。表中所有的加固项都在文件/etc/login.defs中。表中字段直接通过修改配置文件完成。\\n', '\\n', '表 4 login.defs配置项说明所示\\n', '\\n', '\\n', '加固项\\n', '\\n', '加固项说明\\n', '\\n', '建议加固\\n', '\\n', 'openEuler默认是否已加固为建议值\\n', '\\n', 'PASS_MAX_DAYS\\n', '\\n', '口令最大有效期\\n', '\\n', '90\\n', '\\n', '否\\n', '\\n', 'PASS_MIN_DAYS\\n', '\\n', '两次修改口令的最小间隔时间\\n', '\\n', '0\\n', '\\n', '否\\n', '\\n', 'PASS_WARN_AGE\\n', '\\n', '口令过期前开始提示天数\\n', '\\n', '7\\n', '\\n', '否\\n', '\\n', ' 说明：\\n', 'login.defs是设置用户帐号限制的文件，可配置口令的最大过期天数、最大长度约束等。该文件里的配置对root用户无效。如果/etc/shadow文件里有相同的选项，则以/etc/shadow配置为准，即/etc/shadow的配置优先级高于/etc/login.defs。口令过期后用户重新登录时，提示口令过期并强制要求修改，不修改则无法进入系统。\\n', '\\n', '设置口令的加密算法\\n', '说明\\n', '出于系统安全考虑，口令不允许明文存储在系统中，应该加密保护。在不需要还原口令的场景，必须使用不可逆算法加密。设置口令的加密算法为sha512，openEuler默认已设置。通过上述设置可以有效防范口令泄露，保证口令安全。\\n', '\\n', '实现\\n', '口令的加密算法设置通过修改/etc/pam.d/password-auth和/etc/pam.d/system-auth文件实现，添加如下配置：\\n', '\\n', 'password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok\\n', '表 5 pam_unix.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'sha512\\n', '\\n', '使用sha512算法对口令加密。\\n', '\\n', '登录失败超过三次后锁定\\n', '说明\\n', '为了保障用户系统的安全，建议用户设置口令出错次数的阈值（建议3次），以及由于口令尝试被锁定用户的自动解锁时间（建议300秒）。\\n', '\\n', '用户锁定期间，任何输入被判定为无效，锁定时间不因用户的再次输入而重新计时；解锁后，用户的错误输入记录被清空。通过上述设置可以有效防范口令被暴力破解，增强系统的安全性。\\n', '\\n', ' 说明：\\n', 'openEuler默认口令出错次数的阈值为3次，系统被锁定后自动解锁时间为60秒。\\n', '\\n', '实现\\n', '口令复杂度的设置通过修改/etc/pam.d/password-auth和/etc/pam.d/system-auth文件实现，设置口令最大的出错次数3次，系统锁定后的解锁时间为300秒的配置如下：\\n', '\\n', 'auth        required      pam_faillock.so preauth audit deny=3 even_deny_root unlock_time=300\\n', 'auth        [default=die] pam_faillock.so authfail audit deny=3 even_deny_root unlock_time=300\\n', 'auth        sufficient    pam_faillock.so authsucc audit deny=3 even_deny_root unlock_time=300\\n', '表 6 pam_faillock.so配置项说明\\n', '\\n', '\\n', '配置项\\n', '\\n', '说明\\n', '\\n', 'authfail\\n', '\\n', '捕获用户登录失败的事件。\\n', '\\n', 'deny=3\\n', '\\n', '用户连续登录失败次数超过3次即被锁定。\\n', '\\n', 'unlock_time=300\\n', '\\n', '普通用户自动解锁时间为300秒（即5分钟）。\\n', '\\n', 'even_deny_root\\n', '\\n', '同样限制root帐户。\\n', '\\n', '加固su命令\\n', '说明\\n', '为了增强系统安全性，防止使用“su”切换用户时将当前用户环境变量带入其他环境，openEuler默认已做配置。总是在使用su切换用户时初始化PATH。\\n', '\\n', '实现\\n', '通过修改/etc/login.defs实现，配置如下：\\n', '\\n', 'ALWAYS_SET_PATH=yes']"}
{"index": {"_index": "new-open", "_id": "openEuler_管理员指南_查看系统信息.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Administration/%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF.html", "text_entry": "['查看系统信息\\n', '查看系统信息，命令如下：\\n', '\\n', '$ cat /etc/os-release\\n', '例如，命令和输出如下：\\n', '\\n', '$ cat /etc/os-release\\n', 'NAME=\"openEuler\"\\n', 'VERSION=\"22.03 LTS\"\\n', 'ID=\"openEuler\"\\n', 'VERSION_ID=\"22.03\"\\n', 'PRETTY_NAME=\"openEuler 22.03 LTS\"\\n', 'ANSI_COLOR=\"0;31\"\\n', '查看系统相关的资源信息。\\n', '\\n', '查看CPU信息，命令如下：\\n', '\\n', '$ lscpu\\n', '查看内存信息，命令如下：\\n', '\\n', '$ free\\n', '查看磁盘信息，命令如下：\\n', '\\n', '$ fdisk -l\\n', '查看系统资源实时信息，命令如下：\\n', '\\n', '$ top']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_自动部署集群_工具介绍.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/eggo%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html", "text_entry": "['工具介绍\\n', '本章介绍自动化部署工具的相关内容，建议用户在部署前阅读。\\n', '\\n', '部署方式\\n', 'openEuler 提供的 Kubernetes 集群自动化部署工具使用命令行方式进行集群的一键部署。它提供了如下几种部署方式：\\n', '\\n', '离线部署：本地准备好所有需要用到的 RPM 软件包、二进制文件、插件、容器镜像，并将它们按照一定的格式打包成一个 tar.gz 文件，然后完成对应 YAML 配置文件的编写，即可执行命令实现一键部署。当虚拟机无法访问外部网络时，可以采用该部署方式。\\n', '在线部署：只需要完成对应 YAML 配置文件的编写，所需的RPM 软件包、二进制文件、插件、容器镜像，都在安装部署阶段连接互联网自动下载。该方式需要虚拟机能够访问软件源、集群依赖的镜像仓库，例如 Docker Hub 。\\n', '配置介绍\\n', '使用工具自动化部署 Kubernetes 集群时，使用 YAML 配置文件描述集群部署的信息，此处介绍各配置项含义以及配置示例。\\n', '\\n', '配置项介绍\\n', 'cluster-id：集群名称，请遵循 DNS 域名的命名规范。例如 k8s-cluster\\n', '\\n', 'username：需要部署 k8s 集群的机器的 ssh 登录用户名，所有机器都需要使用同一个用户名。\\n', '\\n', 'private-key-path：ssh 免密登录的秘钥存储文件的路径。private-key-path 和 password 只需要配置其中一项，如果两者都进行了配置，优先使用 private-key-path\\n', '\\n', 'masters：master 节点列表，建议每个 master 节点同时作为 worker 节点。每个 master 节点包含如下配置子项，多个 master 节点配置多组子项内容：\\n', '\\n', 'name：master 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：master 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：master 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'workers：worker 节点列表。每个 worker 节点包含如下配置子项，多个 worker 节点配置多个子项内容：\\n', '\\n', 'name：worker 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：worker 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：worker 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'etcds：etcd 节点的列表。如果该项为空，则会为每个 master 节点部署一个 etcd，否则只会部署配置的 etcd 节点。每个 etcd 节点包含如下配置子项，多个 etcd 节点配置多组子项内容：\\n', '\\n', 'name：etcd 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：etcd 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：etcd 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'loadbalance：loadbalance 节点列表。每个 loadbalance 节点包含如下配置子项，多个 loadbalance 节点配置多组子项内容：\\n', '\\n', 'name：loadbalance 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：loadbalance 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：loadbalance 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'bind-port：负载均衡服务的侦听端口\\n', 'external-ca：是否使用外部 CA 证书，使用则配置为 true，反之，配置为 false\\n', '\\n', 'external-ca-path：外部 CA 证书文件的路径 。仅 external-ca 为 true 时有效\\n', '\\n', 'service：k8s 创建的 service 信息。service 配置包含如下配置子项：\\n', '\\n', 'cidr：k8s 创建的 service 的 IP 地址网段\\n', 'dnsaddr：k8s 创建的 service 的 DNS 地址\\n', 'gateway：k8s创建的 service 的网关地址\\n', 'dns：k8s 创建的 coredns 的配置。dns 配置包含如下配置子项：\\n', 'corednstype：k8s 创建的 coredns 的部署类型，支持 pod 和 binary\\n', 'imageversion：pod 部署类型的 coredns 镜像版本\\n', 'replicas：pod 部署类型的 coredns 副本数量\\n', 'network：k8s 集群网络配置。network 配置包含如下配置子项：\\n', '\\n', 'podcidr：k8s 集群网络的 IP 地址网段\\n', 'plugin：k8s 集群部署的网络插件\\n', 'plugin-args：k8s 集群网络的网络插件的配置文件路径。例如 : {“NetworkYamlPath”: “/etc/kubernetes/addons/calico.yaml”}\\n', 'apiserver-endpoint：进群外部可访问的 APISERVER 服务的地址或域名，如果配置了 loadbalances 则填loadbalance 地址，否则填写第 1 个 master 节点地址。\\n', '\\n', 'apiserver-cert-sans：apiserver 相关证书中需要额外配置的 IP 和域名。它包含如下子配置项\\n', '\\n', 'dnsnames：apiserver 相关证书中需要额外配置的域名数组列表。\\n', 'ips：apiserver 相关证书中需要额外配置的 IP 地址数组列表。\\n', 'apiserver-timeout：apiserver 响应超时时间\\n', '\\n', 'etcd-token：etcd 集群名称\\n', '\\n', 'dns-vip：dns 的虚拟 IP 地址\\n', '\\n', 'dns-domain：DNS 域名后缀\\n', '\\n', 'pause-image：pause 容器的完整镜像名称\\n', '\\n', 'network-plugin：网络插件类型。仅支持配置 cni ，配置为空时使用 k8s 默认网络。\\n', '\\n', 'cni-bin-dir：网络插件地址，多个地址使用 “,” 分隔，例如：/usr/libexec/cni,/opt/cni/bin\\n', '\\n', 'runtime：指定容器运行时类型，目前支持 docker 和 iSulad\\n', '\\n', 'runtime-endpoint：容器运行时 endpoint，当 runtime 为 docker 时，可以不指定\\n', '\\n', 'registry-mirrors：下载容器镜像时，使用的镜像仓库的 mirror 站点地址\\n', '\\n', 'insecure-registries：下载容器镜像时，使用 http 协议下载镜像的镜像仓库地址\\n', '\\n', 'config-extra-args：各个组件（例如 kube-apiserver、etcd）服务启动配置的额外参数。它包含如下子配置项：\\n', '\\n', 'name：组件名称，支持 etcd、kube-apiserver、kube-controller-manager、kube-scheduler、kube-proxy、kubelet\\n', '\\n', 'extra-args：组件的拓展参数，格式为 key: value 格式，注意 key 对应的组件参数前需要加上 “-” 或者 “–” 。\\n', '\\n', 'open-ports：配置需要额外打开的端口，k8s 自身所需端口不需要进行配置，k8s 以外的插件端口需要进行额外配置。\\n', '\\n', 'worker | master | etcd | loadbalance：指定打开端口的节点类型，每项配置包含一个多或者多个 port 和 protocol 子配置项。\\n', 'port：端口地址\\n', 'protocol：端口类型，可选值为 tcp 或者 udp\\n', 'install：配置各种类型节点上需要安装的安装包或者二进制文件的详细信息，注意将对应文件放到在 tar.gz 安装包中。以下给全量配置说明，具体配置请根据实际情况选择。\\n', '\\n', 'package-source：配置安装包的详细信息\\n', 'type：安装包的压缩类型，目前只支持 tar.gz 类型的安装包\\n', 'dstpath：安装包在对端机器上的路径，必须是可用的绝对路径\\n', 'srcpath：不同架构安装包的存放路径，架构必须与机器架构相对应，必须是可用的绝对路径\\n', 'arm64：arm64 架构安装包的路径，配置的机器中存在 arm64 机器场景下需要配置\\n', 'amd64：amd64 类型安装包的路径，配置的机器中存在 x86_64 机器场景下需要配置\\n', '说明：\\n', '\\n', 'install 配置中 etcd、kubernetes-master、kubernetes-worker、network、loadbalance、container、image、dns 中的子配置项相同，都是 name、type、dst，schedule、TimeOut 。其中 dst，schedule、TimeOut 为可选项，用户根据安装的文件决定是否配置。下述仅以 etcd 和 kubernetes-master 节点的配置为例说明。\\n', 'etcd：etcd 类型节点需要安装的包或二进制文件列表\\n', 'name：需要安装的软件包或二进制文件的名称，如果是安装包则只写名称，不填写具体的版本号，安装时会使用 $name* 识别，例如 etcd 。如果为多个软件包，各名称使用 ，分隔 。\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'dst：目的文件夹路径，type 为 bin、file、dir 类型时需要配置。表示将文件/文件夹放到节点的哪个目录下，为了防止用户误配置路径，导致 cleanup 时删除重要文件，此配置必须配置为白名单中的路径。详见 “白名单说明”\\n', 'kubernetes-master：k8s master 类型节点需要安装的包或二进制文件列表\\n', 'kubernetes-worker：k8s worker 类型节点需要安装的包或二进制文件列表\\n', 'network：网络需要安装的包或二进制文件列表\\n', 'loadbalance：loadbalance 类型节点需要安装的包或二进制文件列表\\n', 'container：容器需要安装的包或二进制文件列表\\n', 'image：容器镜像 tar 包\\n', 'dns：k8s coredns 安装包。如果 corednstype 配置为 pod，此处无需配置\\n', 'addition：额外的安装包或二进制文件列表\\n', 'master：以下配置会安装在所有 master 节点\\n', 'name：需要安装的软件包包或二进制文件的名称\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'schedule：仅在 type 为 shell 时有效，代表用户想要执行脚本的时机，支持 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）。\\n', 'TimeOut：脚本执行超时时间，超时时该进程被强制终止运行。未配置默认为 30s\\n', 'worker：配置会安装在所有 worker 节点，具体配置格式和 addition 下的 master 相同\\n', '白名单介绍\\n', 'install 配置中 dst 项的值必须符合白名单规则，配置为白名单对应路径及其子目录。当前白名单如下：\\n', '\\n', '/usr/bin\\n', '/usr/local/bin\\n', '/opt/cni/bin\\n', '/usr/libexec/cni\\n', '/etc/kubernetes\\n', '/usr/lib/systemd/system\\n', '/etc/systemd/system\\n', '/tmp\\n', '配置示例\\n', '此处给出一个 YAML 文件配置示例。从示例可知，同一台机器，可以部署多个类型的节点，但是不同节点的配置必须一致，例如 test0 机器部署了 master 和 worker 类型。\\n', '\\n', 'cluster-id: k8s-cluster\\n', 'username: root\\n', 'private-key-path: /root/.ssh/private.key\\n', 'masters:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', 'workers:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', '- name: test1\\n', '  ip: 192.168.0.3\\n', '  port: 22\\n', '  arch: arm64\\n', 'etcds:\\n', '- name: etcd-0\\n', '  ip: 192.168.0.4\\n', '  port: 22\\n', '  arch: amd64\\n', 'loadbalance:\\n', '  name: k8s-loadbalance\\n', '  ip: 192.168.0.5\\n', '  port: 22\\n', '  arch: amd64\\n', '  bind-port: 8443\\n', 'external-ca: false\\n', 'external-ca-path: /opt/externalca \\n', 'service:\\n', '  cidr: 10.32.0.0/16\\n', '  dnsaddr: 10.32.0.10\\n', '  gateway: 10.32.0.1\\n', '  dns:  \\n', '    corednstype: pod\\n', '    imageversion: 1.8.4\\n', '    replicas: 2\\n', 'network:\\n', '  podcidr: 10.244.0.0/16\\n', '  plugin: calico\\n', '  plugin-args: {\"NetworkYamlPath\": \"/etc/kubernetes/addons/calico.yaml\"}  \\n', 'apiserver-endpoint: 192.168.122.222:6443      \\n', 'apiserver-cert-sans:\\n', '  dnsnames: []\\n', '  ips: []\\n', 'apiserver-timeout: 120s\\n', 'etcd-external: false\\n', 'etcd-token: etcd-cluster\\n', 'dns-vip: 10.32.0.10 \\n', 'dns-domain: cluster.local\\n', 'pause-image: k8s.gcr.io/pause:3.2\\n', 'network-plugin: cni \\n', 'cni-bin-dir: /usr/libexec/cni,/opt/cni/bin\\n', 'runtime: docker\\n', 'runtime-endpoint: unix:///var/run/docker.sock \\n', 'registry-mirrors: []\\n', 'insecure-registries: []\\n', 'config-extra-args:\\n', '  - name: kubelet\\n', '    extra-args:\\n', '      \"--cgroup-driver\": systemd\\n', 'open-ports:\\n', '  worker:\\n', '  - port: 111\\n', '    protocol: tcp\\n', '  - port: 179\\n', '    protocol: tcp\\n', 'install:\\n', '  package-source:\\n', '    type: tar.gz\\n', '    dstpath: \"\"\\n', '    srcpath: \\n', '      arm64: /root/rpms/packages-arm64.tar.gz \\n', '      amd64: /root/rpms/packages-x86.tar.gz\\n', '  etcd:\\n', '  - name: etcd\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  kubernetes-master:\\n', '  - name: kubernetes-client,kubernetes-master\\n', '    type: pkg\\n', '  kubernetes-worker:\\n', '  - name: docker-engine,kubernetes-client,kubernetes-node,kubernetes-kubelet\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: conntrack-tools,socat\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  network:\\n', '  - name: containernetworking-plugins\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  loadbalance:\\n', '  - name: gd,gperftools-libs,libunwind,libwebp,libxslt\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: nginx,nginx-all-modules,nginx-filesystem,nginx-mod-http-image-filter,nginx-mod-http-perl,nginx-mod-http-xslt-filter,nginx-mod-mail,nginx-mod-stream\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  container:\\n', '  - name: emacs-filesystem,gflags,gpm-libs,re2,rsync,vim-filesystem,vim-common,vim-enhanced,zlib-devel\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: libwebsockets,protobuf,protobuf-devel,grpc,libcgroup\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: yajl,lxc,lxc-libs,lcr,clibcni,iSulad\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  image:  \\n', '  - name: pause.tar\\n', '    type: image\\n', '    dst: \"\"\\n', '  dns:    \\n', '  - name: coredns\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  addition:\\n', '    master:\\n', '    - name: prejoin.sh\\n', '      type: shell\\n', '      schedule: \"prejoin\"\\n', '      TimeOut:  \"30s\"\\n', '    - name: calico.yaml\\n', '      type: yaml\\n', '      dst: \"\"\\n', '    worker:\\n', '    - name: docker.service\\n', '      type: file\\n', '      dst: /usr/lib/systemd/system/\\n', '    - name: postjoin.sh\\n', '      type: shell\\n', '      schedule: \"postjoin\"\\n', '安装包结构\\n', '如果是离线部署，需要准备 Kubernetes 以及相关的离线安装包，并遵循特定目录结构存放离线安装包。需要遵循的目录结构如下：\\n', '\\n', 'package\\n', '├── bin\\n', '├── dir\\n', '├── file\\n', '├── image\\n', '├── pkg\\n', '└── packages_notes.md\\n', '上述各目录的含义如下：\\n', '\\n', '离线部署包的目录结构与集群配置 config 中的 package 的类型对应，package 类型有 pkg、repo、bin、file、dir、image、yaml、shell 八种。\\n', '\\n', 'bin 目录存放二进制文件，对应 package 类型 bin 。\\n', '\\n', 'dir 目录存放需要拷贝到目标机器的目录，需要配置 dst 目的地路径，对应 package 类型 dir 。\\n', '\\n', 'file 目录存放 file、yaml、shell 三种类型的文件。其中 file 类型代表需要拷贝到目标机器的文件，同时需要配置 dst 目的地路径；yaml 类型代表用户自定义的 YAML 文件，会在集群部署完成后 apply 该 YAML 文件；shell 类型代表用户想要执行的脚本，同时需要配置 schedule 执行时机，执行时机包括 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）四个阶段。\\n', '\\n', 'image 目录存放需要导入的容器镜像。这些容器镜像必须兼容 docker 的 tar 包格式（例如由 docker 或 isula-build 导出镜像）。\\n', '\\n', 'pkg 目录下存放需要安装的 rpm/deb 包，对应 package 类型 pkg 。建议使用二进制文件，便于跨发行版本的部署。\\n', '\\n', '命令参考\\n', 'openEuler 提供的集群部署工具，使用命令行 eggo 进行集群部署。\\n', '\\n', '部署 k8s 集群\\n', '通过指定的 YAML 配置部署 k8s 集群：\\n', '\\n', 'eggo deploy [ -d ] -f deploy.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t是\\t指定部署 k8s 集群的 YAML 文件路径\\n', '加入单节点\\n', '将指定的单节点加入到 k8s 集群中：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster [ –type master,worker ] –arch arm64 –port 22 [ –name master1] IP\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–type | -t\\t否\\t指定加入节点的类型，支持 master、worker 。多个类型使用 “,” 隔开，默认值为 worker 。\\n', '–arch | -a\\t是\\t指定加入节点的 CPU 架构\\n', '–port | -p\\t是\\t指定 ssh 登录所加入节点的端口号\\n', '–name | -n\\t否\\t指定加入节点的名称\\n', 'IP\\t是\\t加入节点的实际 IP 地址\\n', '加入多节点\\n', '将指定的多个节点加入到 k8s 集群：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster -f nodes.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–file | -f\\t是\\t指定加入节点的 YAML 配置文件路径\\n', '删除节点\\n', '删除 k8s 集群中的一个或者多个节点：\\n', '\\n', 'eggo delete [ -d ] –id k8s-cluster node [node…]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要删除的节点所在的集群名称\\n', 'node\\t是\\t要删除的单个或多个节点的 IP 地址或者节点名称\\n', '删除集群\\n', '删除整个 k8s 集群：\\n', '\\n', 'eggo cleanup [ -d ] –id k8s-cluster [ -f deploy.yaml ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要清除的 k8s 集群名称\\n', '–file | -f\\t否\\t指定清除 k8s 集群的 YAML 文件路径。不指定时，默认使用部署集群时缓存的集群配置。正常情况下，建议不配置该选项，仅异常情况下配置。\\n', '说明\\n', '\\n', '建议使用部署集群时缓存的集群配置删除集群，即正常情况下，不建议配置 –file | -f 参数。当异常导致缓存配置破坏或者丢失时，才配置该参数。\\n', '查询集群\\n', '查询当前所有通过 eggo 部署的 k8s 集群：\\n', '\\n', 'eggo list [ -d ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '生成集群配置文件\\n', '快速生成部署 k8s 集群所需的 YAML 配置文件：\\n', '\\n', 'eggo template -d -f template.yaml -n k8s-cluster -u username -p password –etcd [192.168.0.1,192.168.0.2] –masters [192.168.0.1,192.168.0.2] –workers 192.168.0.3 –loadbalance 192.168.0.4\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t否\\t指定生成的 YAML 文件的路径\\n', '–name | -n\\t否\\t指定 k8s 集群的名称\\n', '–username | -u\\t否\\t指定 ssh 登录所配置节点的用户名\\n', '–password | -p\\t否\\t指定 ssh 登录所配置节点的密码\\n', '–etcd\\t否\\t指定 etcd 节点的 IP 列表\\n', '–masters\\t否\\t指定 master 节点的 IP 列表\\n', '–workers\\t否\\t指定 worker 节点的 IP 列表\\n', '–loadbalance | -l\\t否\\t指定 loadbalance 节点的 IP\\n', '查询帮助信息\\n', '查询 eggo 命令的帮助信息：\\n', '\\n', 'eggo help\\n', '\\n', '查询子命令帮助信息\\n', '查询 eggo 子命令的帮助信息：\\n', '\\n', 'eggo deploy | join | delete | cleanup | list | template -h\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–help| -h\\t是\\t打印帮助信息\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_查询信息.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%9F%A5%E8%AF%A2%E4%BF%A1%E6%81%AF.html", "text_entry": "['查询信息\\n', '查询信息\\n', '查询服务版本信息\\n', '查询系统级信息\\n', '查询信息\\n', '查询服务版本信息\\n', '描述\\n', 'isula version 命令用于查询iSulad服务的版本信息。\\n', '\\n', '用法\\n', 'isula version\\n', '实例\\n', '查询版本信息\\n', '\\n', 'isula version\\n', '如果isulad服务正常运行，则可以查看到客户端、服务端以及OCI config的版本等信息。\\n', '\\n', 'Client:\\n', '  Version:      1.0.31\\n', '  Git commit:   fa7f9902738e8b3d7f2eb22768b9a1372ddd1199\\n', '  Built:        2019-07-30T04:21:48.521198248-04:00\\n', '\\n', 'Server:\\n', '  Version:      1.0.31\\n', '  Git commit:   fa7f9902738e8b3d7f2eb22768b9a1372ddd1199\\n', '  Built:        2019-07-30T04:21:48.521198248-04:00\\n', '\\n', 'OCI config:\\n', '  Version:      1.0.0-rc5-dev\\n', '  Default file: /etc/default/isulad/config.json\\n', '若isulad服务未运行，则仅仅查询到客户端的信息，并提示无法连接到服务端。\\n', '\\n', 'Client:\\n', '  Version:      1.0.31\\n', '  Git commit:   fa7f9902738e8b3d7f2eb22768b9a1372ddd1199\\n', '  Built:        2019-07-30T04:21:48.521198248-04:00\\n', '\\n', 'Can not connect with server.Is the iSulad daemon running on the host?\\n', '因此，isula version命令也常常用来检验isulad是否正常运行。\\n', '\\n', '查询系统级信息\\n', '描述\\n', 'isula info命令用于对系统级信息，以及容器和镜像数目等信息的查询。\\n', '\\n', '用法\\n', 'isula info\\n', '示例\\n', '查询系统级信息，可以展示容器数目，镜像数目，内核版本、操作系统等信息\\n', '\\n', '# isula info\\n', 'Containers: 2\\n', ' Running: 0\\n', ' Paused: 0\\n', ' Stopped: 2\\n', 'Images: 8\\n', 'Server Version: 1.0.31\\n', 'Logging Driver: json-file\\n', 'Cgroup Driverr: cgroupfs\\n', 'Hugetlb Pagesize: 2MB\\n', 'Kernel Version: 4.19\\n', 'Operating System: Fedora 29 (Twenty Nine)\\n', 'OSType: Linux\\n', 'Architecture: x86_64\\n', 'CPUs: 8\\n', 'Total Memory: 7 GB\\n', 'Name: localhost.localdomain\\n', 'iSulad Root Dir: /var/lib/isulad\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_自动部署集群_部署集群.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/eggo%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4.html", "text_entry": "['工具介绍\\n', '本章介绍自动化部署工具的相关内容，建议用户在部署前阅读。\\n', '\\n', '部署方式\\n', 'openEuler 提供的 Kubernetes 集群自动化部署工具使用命令行方式进行集群的一键部署。它提供了如下几种部署方式：\\n', '\\n', '离线部署：本地准备好所有需要用到的 RPM 软件包、二进制文件、插件、容器镜像，并将它们按照一定的格式打包成一个 tar.gz 文件，然后完成对应 YAML 配置文件的编写，即可执行命令实现一键部署。当虚拟机无法访问外部网络时，可以采用该部署方式。\\n', '在线部署：只需要完成对应 YAML 配置文件的编写，所需的RPM 软件包、二进制文件、插件、容器镜像，都在安装部署阶段连接互联网自动下载。该方式需要虚拟机能够访问软件源、集群依赖的镜像仓库，例如 Docker Hub 。\\n', '配置介绍\\n', '使用工具自动化部署 Kubernetes 集群时，使用 YAML 配置文件描述集群部署的信息，此处介绍各配置项含义以及配置示例。\\n', '\\n', '配置项介绍\\n', 'cluster-id：集群名称，请遵循 DNS 域名的命名规范。例如 k8s-cluster\\n', '\\n', 'username：需要部署 k8s 集群的机器的 ssh 登录用户名，所有机器都需要使用同一个用户名。\\n', '\\n', 'private-key-path：ssh 免密登录的秘钥存储文件的路径。private-key-path 和 password 只需要配置其中一项，如果两者都进行了配置，优先使用 private-key-path\\n', '\\n', 'masters：master 节点列表，建议每个 master 节点同时作为 worker 节点。每个 master 节点包含如下配置子项，多个 master 节点配置多组子项内容：\\n', '\\n', 'name：master 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：master 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：master 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'workers：worker 节点列表。每个 worker 节点包含如下配置子项，多个 worker 节点配置多个子项内容：\\n', '\\n', 'name：worker 节点名称，为 k8s 集群看到的该节点名称\\n', 'ip：worker 节点的 IP 地址\\n', 'port：ssh 登录该节点的端口，默认为 22\\n', 'arch：worker 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'etcds：etcd 节点的列表。如果该项为空，则会为每个 master 节点部署一个 etcd，否则只会部署配置的 etcd 节点。每个 etcd 节点包含如下配置子项，多个 etcd 节点配置多组子项内容：\\n', '\\n', 'name：etcd 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：etcd 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：etcd 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'loadbalance：loadbalance 节点列表。每个 loadbalance 节点包含如下配置子项，多个 loadbalance 节点配置多组子项内容：\\n', '\\n', 'name：loadbalance 节点的名称，为 k8s 集群看到的该节点的名称\\n', 'ip：loadbalance 节点的 IP 地址\\n', 'port：ssh 登录的端口\\n', 'arch：loadbalance 节点的 CPU 架构，例如 x86_64 取值为 amd64\\n', 'bind-port：负载均衡服务的侦听端口\\n', 'external-ca：是否使用外部 CA 证书，使用则配置为 true，反之，配置为 false\\n', '\\n', 'external-ca-path：外部 CA 证书文件的路径 。仅 external-ca 为 true 时有效\\n', '\\n', 'service：k8s 创建的 service 信息。service 配置包含如下配置子项：\\n', '\\n', 'cidr：k8s 创建的 service 的 IP 地址网段\\n', 'dnsaddr：k8s 创建的 service 的 DNS 地址\\n', 'gateway：k8s创建的 service 的网关地址\\n', 'dns：k8s 创建的 coredns 的配置。dns 配置包含如下配置子项：\\n', 'corednstype：k8s 创建的 coredns 的部署类型，支持 pod 和 binary\\n', 'imageversion：pod 部署类型的 coredns 镜像版本\\n', 'replicas：pod 部署类型的 coredns 副本数量\\n', 'network：k8s 集群网络配置。network 配置包含如下配置子项：\\n', '\\n', 'podcidr：k8s 集群网络的 IP 地址网段\\n', 'plugin：k8s 集群部署的网络插件\\n', 'plugin-args：k8s 集群网络的网络插件的配置文件路径。例如 : {“NetworkYamlPath”: “/etc/kubernetes/addons/calico.yaml”}\\n', 'apiserver-endpoint：进群外部可访问的 APISERVER 服务的地址或域名，如果配置了 loadbalances 则填loadbalance 地址，否则填写第 1 个 master 节点地址。\\n', '\\n', 'apiserver-cert-sans：apiserver 相关证书中需要额外配置的 IP 和域名。它包含如下子配置项\\n', '\\n', 'dnsnames：apiserver 相关证书中需要额外配置的域名数组列表。\\n', 'ips：apiserver 相关证书中需要额外配置的 IP 地址数组列表。\\n', 'apiserver-timeout：apiserver 响应超时时间\\n', '\\n', 'etcd-token：etcd 集群名称\\n', '\\n', 'dns-vip：dns 的虚拟 IP 地址\\n', '\\n', 'dns-domain：DNS 域名后缀\\n', '\\n', 'pause-image：pause 容器的完整镜像名称\\n', '\\n', 'network-plugin：网络插件类型。仅支持配置 cni ，配置为空时使用 k8s 默认网络。\\n', '\\n', 'cni-bin-dir：网络插件地址，多个地址使用 “,” 分隔，例如：/usr/libexec/cni,/opt/cni/bin\\n', '\\n', 'runtime：指定容器运行时类型，目前支持 docker 和 iSulad\\n', '\\n', 'runtime-endpoint：容器运行时 endpoint，当 runtime 为 docker 时，可以不指定\\n', '\\n', 'registry-mirrors：下载容器镜像时，使用的镜像仓库的 mirror 站点地址\\n', '\\n', 'insecure-registries：下载容器镜像时，使用 http 协议下载镜像的镜像仓库地址\\n', '\\n', 'config-extra-args：各个组件（例如 kube-apiserver、etcd）服务启动配置的额外参数。它包含如下子配置项：\\n', '\\n', 'name：组件名称，支持 etcd、kube-apiserver、kube-controller-manager、kube-scheduler、kube-proxy、kubelet\\n', '\\n', 'extra-args：组件的拓展参数，格式为 key: value 格式，注意 key 对应的组件参数前需要加上 “-” 或者 “–” 。\\n', '\\n', 'open-ports：配置需要额外打开的端口，k8s 自身所需端口不需要进行配置，k8s 以外的插件端口需要进行额外配置。\\n', '\\n', 'worker | master | etcd | loadbalance：指定打开端口的节点类型，每项配置包含一个多或者多个 port 和 protocol 子配置项。\\n', 'port：端口地址\\n', 'protocol：端口类型，可选值为 tcp 或者 udp\\n', 'install：配置各种类型节点上需要安装的安装包或者二进制文件的详细信息，注意将对应文件放到在 tar.gz 安装包中。以下给全量配置说明，具体配置请根据实际情况选择。\\n', '\\n', 'package-source：配置安装包的详细信息\\n', 'type：安装包的压缩类型，目前只支持 tar.gz 类型的安装包\\n', 'dstpath：安装包在对端机器上的路径，必须是可用的绝对路径\\n', 'srcpath：不同架构安装包的存放路径，架构必须与机器架构相对应，必须是可用的绝对路径\\n', 'arm64：arm64 架构安装包的路径，配置的机器中存在 arm64 机器场景下需要配置\\n', 'amd64：amd64 类型安装包的路径，配置的机器中存在 x86_64 机器场景下需要配置\\n', '说明：\\n', '\\n', 'install 配置中 etcd、kubernetes-master、kubernetes-worker、network、loadbalance、container、image、dns 中的子配置项相同，都是 name、type、dst，schedule、TimeOut 。其中 dst，schedule、TimeOut 为可选项，用户根据安装的文件决定是否配置。下述仅以 etcd 和 kubernetes-master 节点的配置为例说明。\\n', 'etcd：etcd 类型节点需要安装的包或二进制文件列表\\n', 'name：需要安装的软件包或二进制文件的名称，如果是安装包则只写名称，不填写具体的版本号，安装时会使用 $name* 识别，例如 etcd 。如果为多个软件包，各名称使用 ，分隔 。\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'dst：目的文件夹路径，type 为 bin、file、dir 类型时需要配置。表示将文件/文件夹放到节点的哪个目录下，为了防止用户误配置路径，导致 cleanup 时删除重要文件，此配置必须配置为白名单中的路径。详见 “白名单说明”\\n', 'kubernetes-master：k8s master 类型节点需要安装的包或二进制文件列表\\n', 'kubernetes-worker：k8s worker 类型节点需要安装的包或二进制文件列表\\n', 'network：网络需要安装的包或二进制文件列表\\n', 'loadbalance：loadbalance 类型节点需要安装的包或二进制文件列表\\n', 'container：容器需要安装的包或二进制文件列表\\n', 'image：容器镜像 tar 包\\n', 'dns：k8s coredns 安装包。如果 corednstype 配置为 pod，此处无需配置\\n', 'addition：额外的安装包或二进制文件列表\\n', 'master：以下配置会安装在所有 master 节点\\n', 'name：需要安装的软件包包或二进制文件的名称\\n', 'type：配置项类型，可选值为 pkg、repo、bin、file、dir、image、yaml、shell 。如果配置为 repo ，请在对应节点上配置 repo 源\\n', 'schedule：仅在 type 为 shell 时有效，代表用户想要执行脚本的时机，支持 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）。\\n', 'TimeOut：脚本执行超时时间，超时时该进程被强制终止运行。未配置默认为 30s\\n', 'worker：配置会安装在所有 worker 节点，具体配置格式和 addition 下的 master 相同\\n', '白名单介绍\\n', 'install 配置中 dst 项的值必须符合白名单规则，配置为白名单对应路径及其子目录。当前白名单如下：\\n', '\\n', '/usr/bin\\n', '/usr/local/bin\\n', '/opt/cni/bin\\n', '/usr/libexec/cni\\n', '/etc/kubernetes\\n', '/usr/lib/systemd/system\\n', '/etc/systemd/system\\n', '/tmp\\n', '配置示例\\n', '此处给出一个 YAML 文件配置示例。从示例可知，同一台机器，可以部署多个类型的节点，但是不同节点的配置必须一致，例如 test0 机器部署了 master 和 worker 类型。\\n', '\\n', 'cluster-id: k8s-cluster\\n', 'username: root\\n', 'private-key-path: /root/.ssh/private.key\\n', 'masters:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', 'workers:\\n', '- name: test0\\n', '  ip: 192.168.0.1\\n', '  port: 22\\n', '  arch: arm64\\n', '- name: test1\\n', '  ip: 192.168.0.3\\n', '  port: 22\\n', '  arch: arm64\\n', 'etcds:\\n', '- name: etcd-0\\n', '  ip: 192.168.0.4\\n', '  port: 22\\n', '  arch: amd64\\n', 'loadbalance:\\n', '  name: k8s-loadbalance\\n', '  ip: 192.168.0.5\\n', '  port: 22\\n', '  arch: amd64\\n', '  bind-port: 8443\\n', 'external-ca: false\\n', 'external-ca-path: /opt/externalca \\n', 'service:\\n', '  cidr: 10.32.0.0/16\\n', '  dnsaddr: 10.32.0.10\\n', '  gateway: 10.32.0.1\\n', '  dns:  \\n', '    corednstype: pod\\n', '    imageversion: 1.8.4\\n', '    replicas: 2\\n', 'network:\\n', '  podcidr: 10.244.0.0/16\\n', '  plugin: calico\\n', '  plugin-args: {\"NetworkYamlPath\": \"/etc/kubernetes/addons/calico.yaml\"}  \\n', 'apiserver-endpoint: 192.168.122.222:6443      \\n', 'apiserver-cert-sans:\\n', '  dnsnames: []\\n', '  ips: []\\n', 'apiserver-timeout: 120s\\n', 'etcd-external: false\\n', 'etcd-token: etcd-cluster\\n', 'dns-vip: 10.32.0.10 \\n', 'dns-domain: cluster.local\\n', 'pause-image: k8s.gcr.io/pause:3.2\\n', 'network-plugin: cni \\n', 'cni-bin-dir: /usr/libexec/cni,/opt/cni/bin\\n', 'runtime: docker\\n', 'runtime-endpoint: unix:///var/run/docker.sock \\n', 'registry-mirrors: []\\n', 'insecure-registries: []\\n', 'config-extra-args:\\n', '  - name: kubelet\\n', '    extra-args:\\n', '      \"--cgroup-driver\": systemd\\n', 'open-ports:\\n', '  worker:\\n', '  - port: 111\\n', '    protocol: tcp\\n', '  - port: 179\\n', '    protocol: tcp\\n', 'install:\\n', '  package-source:\\n', '    type: tar.gz\\n', '    dstpath: \"\"\\n', '    srcpath: \\n', '      arm64: /root/rpms/packages-arm64.tar.gz \\n', '      amd64: /root/rpms/packages-x86.tar.gz\\n', '  etcd:\\n', '  - name: etcd\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  kubernetes-master:\\n', '  - name: kubernetes-client,kubernetes-master\\n', '    type: pkg\\n', '  kubernetes-worker:\\n', '  - name: docker-engine,kubernetes-client,kubernetes-node,kubernetes-kubelet\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: conntrack-tools,socat\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  network:\\n', '  - name: containernetworking-plugins\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  loadbalance:\\n', '  - name: gd,gperftools-libs,libunwind,libwebp,libxslt\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: nginx,nginx-all-modules,nginx-filesystem,nginx-mod-http-image-filter,nginx-mod-http-perl,nginx-mod-http-xslt-filter,nginx-mod-mail,nginx-mod-stream\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  container:\\n', '  - name: emacs-filesystem,gflags,gpm-libs,re2,rsync,vim-filesystem,vim-common,vim-enhanced,zlib-devel\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: libwebsockets,protobuf,protobuf-devel,grpc,libcgroup\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  - name: yajl,lxc,lxc-libs,lcr,clibcni,iSulad\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  image:  \\n', '  - name: pause.tar\\n', '    type: image\\n', '    dst: \"\"\\n', '  dns:    \\n', '  - name: coredns\\n', '    type: pkg\\n', '    dst: \"\"\\n', '  addition:\\n', '    master:\\n', '    - name: prejoin.sh\\n', '      type: shell\\n', '      schedule: \"prejoin\"\\n', '      TimeOut:  \"30s\"\\n', '    - name: calico.yaml\\n', '      type: yaml\\n', '      dst: \"\"\\n', '    worker:\\n', '    - name: docker.service\\n', '      type: file\\n', '      dst: /usr/lib/systemd/system/\\n', '    - name: postjoin.sh\\n', '      type: shell\\n', '      schedule: \"postjoin\"\\n', '安装包结构\\n', '如果是离线部署，需要准备 Kubernetes 以及相关的离线安装包，并遵循特定目录结构存放离线安装包。需要遵循的目录结构如下：\\n', '\\n', 'package\\n', '├── bin\\n', '├── dir\\n', '├── file\\n', '├── image\\n', '├── pkg\\n', '└── packages_notes.md\\n', '上述各目录的含义如下：\\n', '\\n', '离线部署包的目录结构与集群配置 config 中的 package 的类型对应，package 类型有 pkg、repo、bin、file、dir、image、yaml、shell 八种。\\n', '\\n', 'bin 目录存放二进制文件，对应 package 类型 bin 。\\n', '\\n', 'dir 目录存放需要拷贝到目标机器的目录，需要配置 dst 目的地路径，对应 package 类型 dir 。\\n', '\\n', 'file 目录存放 file、yaml、shell 三种类型的文件。其中 file 类型代表需要拷贝到目标机器的文件，同时需要配置 dst 目的地路径；yaml 类型代表用户自定义的 YAML 文件，会在集群部署完成后 apply 该 YAML 文件；shell 类型代表用户想要执行的脚本，同时需要配置 schedule 执行时机，执行时机包括 prejoin（节点加入前）、postjoin（节点加入后）、precleanup（节点退出前）、postcleanup（节点退出后）四个阶段。\\n', '\\n', 'image 目录存放需要导入的容器镜像。这些容器镜像必须兼容 docker 的 tar 包格式（例如由 docker 或 isula-build 导出镜像）。\\n', '\\n', 'pkg 目录下存放需要安装的 rpm/deb 包，对应 package 类型 pkg 。建议使用二进制文件，便于跨发行版本的部署。\\n', '\\n', '命令参考\\n', 'openEuler 提供的集群部署工具，使用命令行 eggo 进行集群部署。\\n', '\\n', '部署 k8s 集群\\n', '通过指定的 YAML 配置部署 k8s 集群：\\n', '\\n', 'eggo deploy [ -d ] -f deploy.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t是\\t指定部署 k8s 集群的 YAML 文件路径\\n', '加入单节点\\n', '将指定的单节点加入到 k8s 集群中：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster [ –type master,worker ] –arch arm64 –port 22 [ –name master1] IP\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–type | -t\\t否\\t指定加入节点的类型，支持 master、worker 。多个类型使用 “,” 隔开，默认值为 worker 。\\n', '–arch | -a\\t是\\t指定加入节点的 CPU 架构\\n', '–port | -p\\t是\\t指定 ssh 登录所加入节点的端口号\\n', '–name | -n\\t否\\t指定加入节点的名称\\n', 'IP\\t是\\t加入节点的实际 IP 地址\\n', '加入多节点\\n', '将指定的多个节点加入到 k8s 集群：\\n', '\\n', 'eggo join [ -d ] –id k8s-cluster -f nodes.yaml\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要加入 k8s 集群名称\\n', '–file | -f\\t是\\t指定加入节点的 YAML 配置文件路径\\n', '删除节点\\n', '删除 k8s 集群中的一个或者多个节点：\\n', '\\n', 'eggo delete [ -d ] –id k8s-cluster node [node…]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要删除的节点所在的集群名称\\n', 'node\\t是\\t要删除的单个或多个节点的 IP 地址或者节点名称\\n', '删除集群\\n', '删除整个 k8s 集群：\\n', '\\n', 'eggo cleanup [ -d ] –id k8s-cluster [ -f deploy.yaml ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–id\\t是\\t指定将要清除的 k8s 集群名称\\n', '–file | -f\\t否\\t指定清除 k8s 集群的 YAML 文件路径。不指定时，默认使用部署集群时缓存的集群配置。正常情况下，建议不配置该选项，仅异常情况下配置。\\n', '说明\\n', '\\n', '建议使用部署集群时缓存的集群配置删除集群，即正常情况下，不建议配置 –file | -f 参数。当异常导致缓存配置破坏或者丢失时，才配置该参数。\\n', '查询集群\\n', '查询当前所有通过 eggo 部署的 k8s 集群：\\n', '\\n', 'eggo list [ -d ]\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '生成集群配置文件\\n', '快速生成部署 k8s 集群所需的 YAML 配置文件：\\n', '\\n', 'eggo template -d -f template.yaml -n k8s-cluster -u username -p password –etcd [192.168.0.1,192.168.0.2] –masters [192.168.0.1,192.168.0.2] –workers 192.168.0.3 –loadbalance 192.168.0.4\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–debug | -d\\t否\\t打印调试信息\\n', '–file | -f\\t否\\t指定生成的 YAML 文件的路径\\n', '–name | -n\\t否\\t指定 k8s 集群的名称\\n', '–username | -u\\t否\\t指定 ssh 登录所配置节点的用户名\\n', '–password | -p\\t否\\t指定 ssh 登录所配置节点的密码\\n', '–etcd\\t否\\t指定 etcd 节点的 IP 列表\\n', '–masters\\t否\\t指定 master 节点的 IP 列表\\n', '–workers\\t否\\t指定 worker 节点的 IP 列表\\n', '–loadbalance | -l\\t否\\t指定 loadbalance 节点的 IP\\n', '查询帮助信息\\n', '查询 eggo 命令的帮助信息：\\n', '\\n', 'eggo help\\n', '\\n', '查询子命令帮助信息\\n', '查询 eggo 子命令的帮助信息：\\n', '\\n', 'eggo deploy | join | delete | cleanup | list | template -h\\n', '\\n', '参数\\t是否必选\\t参数含义\\n', '–help| -h\\t是\\t打印帮助信息\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_容器资源动态管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E5%8A%A8%E6%80%81%E7%AE%A1%E7%90%86.html", "text_entry": "['容器资源动态管理\\n', '普通容器无法支持对容器内的资源进行管理，例如添加一个块设备到容器、插入一块物理/虚拟网卡到容器。系统容器场景下，通过syscontainer-tools工具可以实现动态为容器挂载/卸载块设备，网络设备，路由和卷等资源。\\n', '\\n', '要使用此功能，需要安装syscontainer-tools工具：\\n', '\\n', '[root@localhost ~]# yum install syscontainer-tools\\n', '容器资源动态管理\\n', '设备管理\\n', '网卡管理\\n', '路由管理\\n', '挂卷管理\\n', '设备管理\\n', '功能描述\\n', 'syscontainer-tools支持将宿主机上的块设备（比如磁盘、LVM）或字符设备（比如GPU、binner、fuse）添加到容器中。在容器中使用该设备，例如可以对磁盘进行fdisk格式化，写入fs等操作。在容器不需要设备时，syscontainer-tools可以将设备从容器中删除，归还宿主机。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id> [ARG...]\\n', '其中：\\n', '\\n', 'COMMAND：设备管理相关的命令。\\n', '\\n', 'OPTIONS：设备管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', 'ARG：命令对应的参数。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', '参数说明\\n', '\\n', 'add-device\\n', '\\n', '将宿主机块设备/字符设备添加到容器中。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--blkio-weight-device：设置块设备IO权重（相对权重，10-100之间）。\\n', '--device-read-bps：设置块设备读取速率限制（byte/秒）。\\n', '--device-read-iops：设置块设备读取速率限制（IO/秒）。\\n', '--device-write-bps：设置块设备写入速率限制（byte/秒）。\\n', '--device-write-iops：设置块设备写入速率限制（IO/秒）。\\n', '--follow-partition：如果块设备是基础块设备（主SCSI块磁盘），加入此参数可以添加主磁盘下的所有分区。\\n', '--force：如果容器中已有块设备/字符设备，使用此参数覆盖旧的块设备/字符设备文件。\\n', '--update-config-only：只更新配置文件不实际做添加磁盘动作。\\n', '参数格式为：hostdevice[:containerdevice][:permission] [hostdevice[:containerdevice][:permission] ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：设备在主机上的路径。\\n', '\\n', 'containerdevice：设备在容器中的路径。\\n', '\\n', 'permission：容器内对设备的操作权限。\\n', '\\n', 'remove-device\\n', '\\n', '将块设备/字符设备从容器中删除，还原至宿主机。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--follow-partition：如果块设备是基础块设备（主SCSI块磁盘），加入此参数可以删除容器中主磁盘下的所有分区，还原至宿主机。\\n', '\\n', '参数格式为：hostdevice[:containerdevice] [hostdevice[:containerdevice] ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：设备在主机上的路径。\\n', '\\n', 'containerdevice：设备在容器中的路径。\\n', '\\n', 'list-device\\n', '\\n', '列出容器中所有的块设备/字符设备。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '--sub-partition：如果某磁盘为主磁盘，加入此flag，在显示主磁盘的同时，也显示主磁盘的子分区。\\n', '无\\n', '\\n', 'update-device\\n', '\\n', '更新磁盘Qos。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--device-read-bps：设置块设备读取速率限制（byte/秒），建议设置值大于等于1024。\\n', '--device-read-iops：设置块设备读取速率限制（IO/秒）。\\n', '--device-write-bps：设置块设备写入速率限制（byte/秒），建议设置值大于等于1024。\\n', '--device-write-iops：设置块设备写入速率限制（IO/秒）。\\n', '无\\n', '\\n', '约束限制\\n', '添加/删除设备的时机可以是容器实例非运行状态，完成操作后启动容器，容器内会有体现；也可以在容器运行时（running）动态添加。\\n', '不能在容器内和host上并发进行fdisk对磁盘的格式化写入，会影响容器磁盘使用。\\n', 'add-device将磁盘添加到容器的特定目录时，如果容器内的父目录为多级目录（比如/dev/a/b/c/d/e…）且目录层级不存在，则syscontainer-tools会自动在容器内创建对应目录；当删除时，不会将创建的父目录删除。如果用户下一次add-device到该父目录，则会提示已经存在无法添加成功。\\n', 'add-device添加磁盘、更新磁盘参数时，配置磁盘Qos；当配置磁盘Qos的read/write bps、read/write IOPS值时，不建议配置值过小，当设置过小时，会造成磁盘表现为不可读（实际原因是速度过慢），最终影响业务功能。\\n', '使用–blkio-weight-device来限制指定块设备的权重，如果当前块设备仅支持BFQ模式，可能会报错，提示用户检查当前OS环境是否支持BFQ块设备权重值设置。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', 'eed1096c8c7a0eca6d92b1b3bc3dd59a2a2adf4ce44f18f5372408ced88f8350\\n', '添加一个块设备到容器\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-device ee /dev/sdb:/dev/sdb123\\n', 'Add device (/dev/sdb) to container(ee,/dev/sdb123) done.\\n', '[root@localhost ~]# isula exec ee fdisk -l /dev/sdb123\\n', 'Disk /dev/sdb123: 50 GiB, 53687091200 bytes, 104857600 sectors\\n', 'Units: sectors of 1 * 512 = 512 bytes\\n', 'Sector size (logical/physical): 512 bytes / 512 bytes\\n', 'I/O size (minimum/optimal): 512 bytes / 512 bytes\\n', 'Disklabel type: dos\\n', 'Disk identifier: 0xda58a448\\n', '\\n', 'Device        Boot Start       End   Sectors Size Id Type\\n', '/dev/sdb123p1       2048 104857599 104855552  50G  5 Extended\\n', '/dev/sdb123p5       4096 104857599 104853504  50G 83 Linux\\n', '更新设备信息\\n', '\\n', '[root@localhost ~]# syscontainer-tools update-device --device-read-bps /dev/sdb:10m ee\\n', 'Update read bps for device (/dev/sdb,10485760) done.\\n', '删除设备\\n', '\\n', '[root@localhost ~]# syscontainer-tools remove-device ee /dev/sdb:/dev/sdb123\\n', 'Remove device (/dev/sdb) from container(ee,/dev/sdb123) done.\\n', 'Remove read bps for device (/dev/sdb) done.\\n', '网卡管理\\n', '功能描述\\n', 'syscontainer-tools支持将宿主机上的物理网卡或虚拟网卡插入到容器，在不使用网卡的时候从容器中删除归还给宿主机，并且可以动态修改网卡配置。插入物理网卡即把宿主机上一块网卡直接添加到容器中，插入虚拟网卡则需要先创建一对veth pair，之后将一端插入到容器中。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id>\\n', '其中：\\n', '\\n', 'COMMAND：网卡管理相关的命令。\\n', '\\n', 'OPTIONS：网卡管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', 'add-nic\\n', '\\n', '给容器创建一个网卡。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--type：设置网卡类型，当前只支持eth/veth。\\n', '--name：设置网卡名称，格式为[host:]<container>，host不写是随机名字。\\n', '--ip：设置网卡IP地址。\\n', '--mac：设置网卡mac地址。\\n', '--bridge：设置网卡绑定的网桥。\\n', '--mtu：设置网卡的mtu值，默认1500。\\n', '--update-config-only：如果此flag设置了，只更新配置文件，不会实际做添加网卡的动作。\\n', '--qlen：配置qlen值，默认为1000。\\n', 'remove-nic\\n', '\\n', '从容器中将网卡删除，还原至宿主机。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--type：设置网卡的类型。\\n', '--name：设置网卡的名称，格式为[host:]<container>。\\n', 'list-nic\\n', '\\n', '列出容器中所有的网卡。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '--filter：按照过滤格式输出，比如--filter \\'{\"ip\":\"192.168.3.4/24\", \"Mtu\":1500}\\'。\\n', 'update-nic\\n', '\\n', '更改容器内指定网卡的配置参数。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--name：容器内网卡名（必须项）。\\n', '--ip：设置网卡IP地址。\\n', '--mac：设置网卡mac地址。\\n', '--bridge：设置网卡绑定的网桥。\\n', '--mtu：设置网卡的mtu值。\\n', '--update-config-only：如果此flag设置了，只更新配置文件，不会实际做更新网卡的动作。\\n', '--qlen：配置qlen值。\\n', '约束限制\\n', '支持添加物理网卡（eth）和虚拟网卡（veth）两种类型。\\n', '在添加网卡时可以同时对网卡进行配置，参数包括–ip/–mac/–bridge/–mtu/–qlen。\\n', '支持最多添加8个物理网卡到容器。\\n', '使用syscontainer-tools add-nic向容器添加eth网卡后，如果不加hook，在容器退出前必须手工将nic删除，否则在host上的eth网卡的名字会被更改成容器内的名字。\\n', '对于物理网卡（1822 vf网卡除外），add-nic必须使用原mac地址，update-nic禁止修改mac地址，容器内也不允许修改mac地址。\\n', '使用syscontainer-tools add-nic时，设置mtu值，设置范围跟具体的网卡型号有关。\\n', '使用syscontainer-tools向容器添加网卡和路由时，建议先执行add-nic添加网卡，然后执行add-route添加路由；使用syscontainer-tools从容器删除网卡和路由时，建议先执行remove-route删除路由，然后执行remove-nic删除网卡。\\n', '使用syscontainer-tools添加网卡时，一块网卡只能添加到一个容器中。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本：\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', '2aaca5c1af7c872798dac1a468528a2ccbaf20b39b73fc0201636936a3c32aa8\\n', '添加一个虚拟网卡到容器\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-nic --type \"veth\" --name abc2:bcd2 --ip 172.17.28.5/24 --mac 00:ff:48:13:xx:xx --bridge docker0 2aaca5c1af7c\\n', 'Add network interface to container 2aaca5c1af7c (bcd2,abc2) done  \\n', '添加一个物理网卡到容器\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-nic --type \"eth\" --name eth3:eth1 --ip 172.17.28.6/24  --mtu 1300  --qlen 2100 2aaca5c1af7c\\n', 'Add network interface to container 2aaca5c1af7c (eth3,eth1) done\\n', ' 说明：\\n', '添加虚拟网卡或物理网卡时，请确保网卡处于空闲状态，添加正在使用的网卡会导致系统网络断开。\\n', '\\n', '路由管理\\n', '功能描述\\n', 'syscontainer-tools工具可以对系统容器进行动态添加/删除路由表。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id> [ARG...]\\n', '其中：\\n', '\\n', 'COMMAND：路由管理相关的命令。\\n', '\\n', 'OPTIONS：路由管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', 'ARG：命令对应的参数。\\n', '\\n', '接口说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', '参数说明\\n', '\\n', 'add-route\\n', '\\n', '将网络路由规则添加到容器中。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--update-config-only：添加此参数，只更新配置文件，不做实际的更新路由表的动作。\\n', '\\n', '参数格式：[{rule1}，{rule2}]\\n', '\\n', 'rule样例：\\n', '\\n', '\\'[{\"dest\":\"default\", \"gw\":\"192.168.10.1\"},{\"dest\":\"192.168.0.0/16\",\"dev\":\"eth0\",\"src\":\"192.168.1.2\"}]\\'\\n', '\\n', 'dest：目标网络，如果为空则是默认网关。\\n', 'src：路由源IP。\\n', 'gw：路由网关。\\n', 'dev：网络设备。\\n', 'remove-route\\n', '\\n', '从容器中删除路由。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--update-config-only：设置此参数，只更新配置文件，不做实际从容器中删除路由的动作。\\n', '\\n', '参数格式：[{rule1}，{rule2}]\\n', '\\n', 'rule样例：\\n', '\\n', '\\'[{\"dest\":\"default\", \"gw\":\"192.168.10.1\"},{\"dest\":\"192.168.0.0/16\",\"dev\":\"eth0\",\"src\":\"192.168.1.2\"}]\\'\\n', '\\n', 'dest：目标网络，如果为空则是默认网关。\\n', 'src：路由源IP。\\n', 'gw：路由网关。\\n', 'dev：网络设备。\\n', 'list-route\\n', '\\n', '列出容器中所有的路由规则。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '--filter：按照过滤格式输出，比如--filter \\'{\"ip\":\"192.168.3.4/24\", \"Mtu\":1500}\\'。\\n', '无\\n', '\\n', '约束限制\\n', '使用syscontainer-tools向容器添加网卡和路由时，建议先执行add-nic添加网卡，然后执行add-route添加路由；使用syscontainer-tools从容器删除网卡和路由时，建议先执行remove-route删除路由，然后执行remove-nic删除网卡。\\n', '向容器内添加路由规则时，需确保所添加的路由规则与容器内现有的路由规则不会产生冲突。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本：\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', '0d2d68b45aa0c1b8eaf890c06ab2d008eb8c5d91e78b1f8fe4d37b86fd2c190b\\n', 'syscontainer-tools向系统容器添加一块物理网卡：\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-nic --type \"eth\" --name enp4s0:eth123 --ip 172.17.28.6/24  --mtu 1300  --qlen 2100 0d2d68b45aa0\\n', 'Add network interface (enp4s0) to container (0d2d68b45aa0,eth123) done\\n', \"syscontainer-tools添加一条路由规则到系统容器，注意格式需按照'[{“dest”:“default”, “gw”:“192.168.10.1”},{“dest”:“192.168.0.0/16”,“dev”:“eth0”,“src”:“192.168.1.2”}]'来配置。如果dest为空会自动填成default。\\n\", '\\n', '[root@localhost ~]# syscontainer-tools add-route 0d2d68b45aa0 \\'[{\"dest\":\"172.17.28.0/32\", \"gw\":\"172.17.28.5\",\"dev\":\"eth123\"}]\\'\\n', 'Add route to container 0d2d68b45aa0, route: {dest:172.17.28.0/32,src:,gw:172.17.28.5,dev:eth123} done\\n', '查看容器内是否新增一条路由规则：\\n', '\\n', '[root@localhost ~]# isula exec -it 0d2d68b45aa0 route\\n', 'Kernel IP routing table\\n', 'Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\\n', '172.17.28.0     172.17.28.5     255.255.255.255 UGH   0      0        0 eth123\\n', '172.17.28.0     0.0.0.0         255.255.255.0   U     0      0        0 eth123\\n', '挂卷管理\\n', '功能描述\\n', '普通容器仅支持在创建时指定–volume参数将宿主机的目录/卷挂载到容器实现资源共享，但是无法在容器运行时将挂载到容器中的目录/卷卸载掉，也不支持将宿主机的目录/卷挂载到容器。系统容器可以通过syscontainer-tools工具实现动态将宿主机的目录/卷挂载到容器，以及将容器中的目录/卷进行卸载。\\n', '\\n', '命令格式\\n', 'syscontainer-tools [COMMADN][OPTIONS] <container_id> [ARG...]\\n', '其中：\\n', '\\n', 'COMMAND：路由管理相关的命令。\\n', '\\n', 'OPTIONS：路由管理命令支持的选项。\\n', '\\n', 'container_id：容器id。\\n', '\\n', 'ARG：命令对应的参数。\\n', '\\n', '接口说明\\n', '\\n', '命令\\n', '\\n', '功能说明\\n', '\\n', '选项说明\\n', '\\n', '参数说明\\n', '\\n', 'add-path\\n', '\\n', '将宿主机文件/目录添加到容器中。\\n', '\\n', '无\\n', '\\n', '参数格式为：\\n', '\\n', 'hostpath:containerpath:permission [hostpath:containerpath:permission ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：卷在主机上的路径。\\n', '\\n', 'containerdevice：卷在容器中的路径。\\n', '\\n', 'permission：容器内对挂载路径的操作权限。\\n', '\\n', 'remove-path\\n', '\\n', '将容器中的目录/文件删除，还原到宿主机中。\\n', '\\n', '无\\n', '\\n', '参数格式为：hostpath:containerpath [hostpath:containerpath ...]\\n', '\\n', '其中：\\n', '\\n', 'hostdevice：卷在主机上的路径。\\n', '\\n', 'containerdevice：卷在容器中的路径。\\n', '\\n', 'list-path\\n', '\\n', '列出容器中所有的path目录。\\n', '\\n', '支持的选项如下：\\n', '\\n', '--pretty：按照json格式输出。\\n', '\\n', '无\\n', '\\n', '约束限制\\n', '挂载目录（add-path）的时候必须要指定绝对路径。\\n', '挂载目录（add-path）会在主机上生成/.sharedpath挂载点。\\n', '最多可以向单个容器中添加128个volume，超过128后无法添加成功。\\n', 'add-path不能将主机目录覆盖容器中的根目录目录（/），否则会造成功能影响。\\n', '使用示例\\n', '启动一个系统容器，指定hook spec为syscontainer hook执行配置脚本：\\n', '\\n', '[root@localhost ~]# isula run -tid --hook-spec /etc/syscontainer-tools/hookspec.json --system-container --external-rootfs /root/root-fs none init\\n', 'e45970a522d1ea0e9cfe382c2b868d92e7b6a55be1dd239947dda1ee55f3c7f7\\n', 'syscontainer-tools将宿主机某个目录挂载到容器，实现资源共享：\\n', '\\n', '[root@localhost ~]# syscontainer-tools add-path e45970a522d1 /home/test123:/home/test123\\n', 'Add path (/home/test123) to container(e45970a522d1,/home/test123) done.\\n', '宿主机目录/home/test123创建一个文件，然后在容器内查看文件是否可以访问：\\n', '\\n', '[root@localhost ~]# echo \"hello world\" > /home/test123/helloworld\\n', '[root@localhost ~]# isula exec e45970a522d1 bash\\n', '[root@localhost /]# cat /home/test123/helloworld\\n', 'hello world\\n', 'syscontainer-tools将挂载目录从容器内删除：\\n', '\\n', '[root@localhost ~]# syscontainer-tools remove-path e45970a522d1 /home/test123:/home/test123\\n', 'Remove path (/home/test123) from container(e45970a522d1,/home/test123) done\\n', '[root@localhost ~]# isula exec e45970a522d1 bash\\n', '[root@localhost /]# ls /home/test123/helloworld\\n', \"ls: cannot access '/home/test123/helloworld': No such file or directory\\n\", '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_指定rootfs创建容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%8C%87%E5%AE%9Arootfs%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8.html", "text_entry": "['指定rootfs创建容器\\n', '功能描述\\n', '系统容器不同于普通容器，普通容器需要指定一个容器镜像来启动，而系统容器通过参数 --external-rootfs 指定一个本地的根文件系统rootfs（Root File System）来启动，rootfs包含了容器运行时依赖的操作系统环境。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--external-rootfs\\n', '\\n', '字符串变量。\\n', '容器根文件系统对应的绝对路径，即 rootfs 的路径。\\n', '约束限制\\n', '参数–external-rootfs指定的rootfs目录必须为绝对路径，不能为相对路径。\\n', '参数–external-rootfs指定的rootfs目录必须为一个完整运行的操作系统环境（包含systemd软件包），否则容器会启动失败。\\n', '容器删除时，不会删除–external-rootfs指定的rootfs目录。\\n', '不支持在x86环境上运行基于arm rootfs的容器，也不支持在arm环境上运行基于x86 rootfs的容器。\\n', '同一份rootfs，不建议启动多个容器实例，即同一份rootfs只供一个生命周期内的容器实例使用。\\n', '使用示例\\n', '假设本地rootfs的路径为/root/myrootfs，那么启动一个系统容器的命令如下：\\n', '\\n', '# isula run  -tid --system-container --external-rootfs /root/myrootfs none init\\n', ' 说明：\\n', 'rootfs为自定义的文件系统，请用户自行准备。例如容器镜像的tar包解压后，即为一个rootfs。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_支持OCI hooks.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E6%94%AF%E6%8C%81OCI-hooks.html", "text_entry": "['支持OCI hooks\\n', '描述\\n', '支持在容器的生命周期中，运行OCI标准hooks。包括三种类型的hooks：\\n', '\\n', 'prestart hook：在执行isula start命令之后，而在容器的1号进程启动之前，被执行。\\n', 'poststart hook：在容器1号进程启动之后，而在isula start命令返回之前，被执行。\\n', 'poststop hook：在容器被停止之后，但是在停止命令返回之前，被执行。\\n', 'OCI hooks的配置格式规范如下：\\n', '\\n', 'path：格式是字符串，必须项，必须为绝对路径，指定的文件必须有可执行权限。\\n', 'args：格式是字符串数组，可选项，语义和execv的args一致。\\n', 'env：格式是字符串数组，可选项，语义和环境变量一致，内容为键值对，如：“PATH=/usr/bin”。\\n', 'timeout：格式是整数，可选项，必须大于0，表示钩子执行的超时时间。如果钩子进程运行时间超过配置的时间，那么钩子进程会被杀死。\\n', 'hook的配置为json格式，一般存放在json结尾的文件中，示例如下：\\n', '\\n', '{\\n', '        \"prestart\": [\\n', '            {\\n', '                \"path\": \"/usr/bin/echo\",\\n', '                \"args\": [\"arg1\", \"arg2\"],\\n', '                \"env\":  [ \"key1=value1\"],\\n', '                \"timeout\": 30\\n', '            },\\n', '            {\\n', '                \"path\": \"/usr/bin/ls\",\\n', '                \"args\": [\"/tmp\"]\\n', '            }\\n', '        ],\\n', '        \"poststart\": [\\n', '            {\\n', '                \"path\": \"/usr/bin/ls\",\\n', '                \"args\": [\"/tmp\"],\\n', '                \"timeout\": 5\\n', '            }\\n', '        ],\\n', '        \"poststop\": [\\n', '            {\\n', '                \"path\": \"/tmp/cleanup.sh\",\\n', '                \"args\": [\"cleanup.sh\", \"-f\"]\\n', '            }\\n', '        ]\\n', '}\\n', '接口\\n', 'isulad和isula都提供了hook的接口，isulad提供了默认的hook配置，会作用于所有容器；而isula提供的hook接口，只会作用于当前创建的容器。\\n', '\\n', 'isulad提供的默认OCI hooks配置：\\n', '\\n', '通过/etc/isulad/daemon.json配置文件的hook-spec配置项设置hook配置的文件路径：“hook-spec”: “/etc/default/isulad/hooks/default.json”。\\n', '通过isulad –hook-spec参数设置hook配置的文件路径。\\n', 'isula提供的OCI hooks配置：\\n', '\\n', 'isula create –hook-spec：指定hook配置的json文件的路径。\\n', 'isula run –hook-spec：指定hook配置的json文件的路径。\\n', 'run的配置其实也是在create阶段生效了。\\n', '\\n', '使用限制\\n', 'hook-spec指定的路径必须是绝对路径。\\n', '\\n', 'hook-spec指定的文件必须存在。\\n', '\\n', 'hook-spec指定的路径对应的必须是普通文本文件，格式为json。\\n', '\\n', 'hook-spec指定的文件大小不能超过10MB。\\n', '\\n', 'hooks配置的path字段必须为绝对路径。\\n', '\\n', 'hooks配置的path字段指定文件必须存在。\\n', '\\n', 'hooks配置的path字段指定文件必须有可执行权限。\\n', '\\n', 'hooks配置的path字段指定文件的owner必须是root。\\n', '\\n', 'hooks配置的path字段指定文件必须只有root有写权限。\\n', '\\n', 'hooks配置的timeout必须大于0。\\n', '\\n', '  \\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_容器内rebootshutdown.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E5%86%85reboot-shutdown.html", "text_entry": "['容器内reboot/shutdown\\n', '功能描述\\n', '系统容器支持在容器内执行reboot和shutdown命令。执行reboot命令效果同重启容器一致；执行shutdown命令效果同停止容器一致。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--restart\\n', '\\n', '字符串变量。\\n', '可取指定值：\\n', 'on-reboot：表示重启系统容器。\\n', '\\n', '  \\n', '\\n', '约束限制\\n', 'shutdown功能，依赖于不同的OS，以实际容器运行环境对应OS为准。\\n', '执行“shutdown -h now”命令关闭系统时，不能多次占用console。例如“isula run -ti”命令打开一个console，在另一个host bash中isula attach该容器，会打开另一个console，此时执行shutdown会失败。\\n', '使用示例\\n', '容器启动时指定--restart on-reboot参数，示例如下：\\n', '\\n', '[root@localhost ~]# isula run -tid --restart on-reboot --system-container --external-rootfs /root/myrootfs none init\\n', '106faae22a926e22c828a0f2b63cf5c46e5d5986ea8a5b26de81390d0ed9714f\\n', '进入容器执行reboot命令：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 bash\\n', '[root@localhost /]# reboot\\n', '查看容器是否重启：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 ps aux\\n', 'USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\\n', 'root         1  0.1  0.0  21588  9504 ?        Ss   12:11   0:00 init\\n', 'root        14  0.1  0.0  27024  9376 ?        Ss   12:11   0:00 /usr/lib/system\\n', 'root        17  0.0  0.0  18700  5876 ?        Ss   12:11   0:00 /usr/lib/system\\n', 'dbus        22  0.0  0.0   9048  3624 ?        Ss   12:11   0:00 /usr/bin/dbus-d\\n', 'root        26  0.0  0.0   8092  3012 ?        Rs+  12:13   0:00 ps aux\\n', '进入容器执行shutdown命令：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 bash\\n', '[root@localhost /]# shutdown -h now\\n', '[root@localhost /]# [root@localhost ~]#\\n', '检查容器是否停止：\\n', '\\n', '[root@localhost ~]# isula exec -it 10 bash\\n', 'Error response from daemon: Exec container error;Container is not running:106faae22a926e22c828a0f2b63cf5c46e5d5986ea8a5b26de81390d0e']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_安装与运行.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C.html", "text_entry": "['安装与运行\\n', '本章主要介绍如何获取预先构建好的镜像，如何运行镜像。\\n', '\\n', '安装与运行\\n', '获取镜像\\n', '镜像内容\\n', '运行镜像\\n', '极简运行场景\\n', '使能共享文件系统场景\\n', '使能网络场景\\n', '获取镜像\\n', '当前发布的已构建好的镜像，只支持arm和aarch64两种架构，且只支持qemu中ARM virt-4.0平台，您可以通过如下链接获得相应的镜像：\\n', '\\n', 'qemu_arm：32位arm架构，ARM Cortex A15处理器\\n', 'qemu_aarch64：64位aarch64架构，ARM Cortex A57处理器\\n', '只要相应环境支持qemu仿真器（版本5.0以上），您可以将提供的openEuler Embedded镜像部署在物理裸机、云环境、容器或虚拟机上。\\n', '\\n', '镜像内容\\n', '所下载的镜像，由以下几部分组成：\\n', '\\n', '内核镜像zImage: 基于openEuler社区Linux 5.10代码构建得到。相应的内核配置可通过如下链接获取：\\n', '\\n', 'arm(cortex a15)\\n', 'arm(cortex a57)，针对aarch64架构，额外增加了镜像自解压功能，可以参见相应的patch\\n', '根文件系统镜像\\n', '\\n', 'openeuler-image-qemu-xxx.cpio.gz：标准根文件系统镜像，进行了必要安全加固，增加了audit、cracklib、OpenSSH、Linux PAM、shadow、iSula容器所支持的软件包。\\n', 'SDK(Software Development Kit)工具\\n', '\\n', 'openeuler-glibc-x86_64-xxxxx.sh：openEuler Embedded SDK自解压安装包，SDK包含了进行开发（用户态程序、内核模块等)所必需的工具、库和头文件等。\\n', '运行镜像\\n', '通过运行镜像，一方面您可以体验openEuler Embedded的功能，一方面也可以完成基本的嵌入式Linux开发。\\n', '\\n', '注意事项\\n', '\\n', '建议使用QEMU 5.0以上版本运行镜像，由于一些额外功能（网络、共享文件系统)需要依赖QEMU的virtio-net, virtio-fs等特性，如未在QEMU中使能，则运行时可能会产生错误，此时可能需要从源码重新编译QEMU。\\n', '运行镜像时，建议把内核镜像和根文件系统镜像放在同一目录下。\\n', 'QEMU的下载与安装可以参考QEMU官方网站 , 或者下载源码单独编译安装。安装好后可以运行如下命令确认：\\n', '\\n', 'qemu-system-aarch64 --version\\n', '极简运行场景\\n', '该场景下，QEMU未使能网络和共享文件系统，适合快速的功能体验。\\n', '\\n', '启动QEMU\\n', '针对arm(ARM Cortex A15)，运行如下命令：\\n', '\\n', 'qemu-system-arm -M virt-4.0 -cpu cortex-a15 -nographic -kernel zImage -initrd initrd\\n', '针对aarch64(ARM Cortex A57)，运行如下命令：\\n', '\\n', 'qemu-system-aarch64 -M virt-4.0 -cpu cortex-a57 -nographic -kernel zImage -initrd initrd\\n', ' 说明：\\n', '\\n', '由于标准根文件系统镜像进行了安全加固，因此第一次启动时，需要为登录用户名root设置密码，且密码强度有相应要求， 需要数字、字母、特殊字符组合最少8位，例如openEuler@2021。\\n', '\\n', '检查运行是否成功\\n', 'QEMU运行成功并登录后，将会呈现openEuler Embedded的Shell。\\n', '\\n', '使能共享文件系统场景\\n', '通过共享文件系统，可以使得运行QEMU仿真器的宿主机和openEuler Embedded共享文件，这样在宿主机上交叉编译的程序，拷贝到共享目录中，即可在openEuler Embedded上运行。\\n', '\\n', '假设将宿主机的/tmp目录作为共享目录，并事先在其中创建了名为hello_openeuler.txt的文件，使能共享文件系统功能的操作指导如下：\\n', '\\n', '启动QEMU\\n', '针对arm(ARM Cortex A15)，运行如下命令：\\n', '\\n', 'qemu-system-arm -M virt-4.0 -cpu cortex-a15 -nographic -kernel zImage -initrd initrd -device virtio-9p-device,fsdev=fs1,mount_tag=host -fsdev local,security_model=passthrough,id=fs1,path=/tmp\\n', '针对aarch64(ARM Cortex A57)，运行如下命令：\\n', '\\n', 'qemu-system-aarch64 -M virt-4.0 -cpu cortex-a57 -nographic -kernel zImage -initrd initrd -device virtio-9p-device,fsdev=fs1,mount_tag=host -fsdev local,security_model=passthrough,id=fs1,path=/tmp\\n', '映射文件系统\\n', '在openEuler Embedded启动并登录之后，需要运行如下命令，映射(mount)共享文件系统\\n', '\\n', 'cd /tmp\\n', 'mkdir host\\n', 'mount -t 9p -o trans=virtio,version=9p2000.L host /tmp/host\\n', '即把共享文件系统映射到openEuler Embedded的/tmp/host目录下。\\n', '\\n', '检查共享是否成功\\n', '在openEuler Embedded中，运行如下命令:\\n', '\\n', 'cd /tmp/host\\n', 'ls\\n', '如能发现hello_openeuler.txt，则共享成功。\\n', '\\n', '使能网络场景\\n', '通过QEMU的virtio-net和宿主机上的虚拟网卡，可以实现宿主机和openEuler Embedded之间的网络通信。除了通过virtio-fs实现文件共享外，还可以通过网络的方式，例如 scp 命令，实现宿主机和 openEuler Embedded传输文件。\\n', '\\n', '启动QEMU\\n', '针对arm(ARM Cortex A15)，运行如下命令：\\n', '\\n', 'qemu-system-arm -M virt-4.0 -cpu cortex-a15 -nographic -kernel zImage -initrd initrd -device virtio-net-device,netdev=tap0 -netdev tap,id=tap0,script=/etc/qemu-ifup\\n', '针对aarch64(ARM Cortex A57)，运行如下命令：\\n', '\\n', 'qemu-system-aarch64 -M virt-4.0 -cpu cortex-a57 -nographic -kernel zImage -initrd initrd -device virtio-net-device,netdev=tap0 -netdev tap,id=tap0,script=/etc/qemu-ifup\\n', '宿主上建立虚拟网卡\\n', '在宿主机上需要建立名为tap0的虚拟网卡，可以借助脚本实现，创建qemu-ifup脚本，放在/etc/下，具体内容如下：\\n', '\\n', '#!/bin/bash\\n', 'ifconfig $1 192.168.10.1 up\\n', '其执行需要root权限：\\n', '\\n', 'chmod a+x qemu-ifup\\n', '通过qemu-ifup脚本，宿主机上将创建名为tap0的虚拟网卡，地址为192.168.10.1。\\n', '\\n', '配置openEuler Embedded网卡\\n', 'openEuler Embedded登录后，执行如下命令：\\n', '\\n', 'ifconfig eth0 192.168.10.2\\n', '确认网络连通\\n', '在openEuler Embedded中，执行如下命令：\\n', '\\n', 'ping 192.168.10.1\\n', '如能ping通，则宿主机和openEuler Embedded之间的网络是连通的。']"}
{"index": {"_index": "new-open", "_id": "openEuler_Embedded用户指南_SDK应用开发.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Embedded/SDK%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91.html", "text_entry": "['基于openEuler Embedded的SDK应用开发\\n', '当前发布的镜像除了体验openEuler Embedded的基本功能外，还可以进行基本的应用开发，也即在openEuler Embedded上运行用户自己的程序。本章主要介绍如何基于openEuler Embedded的SDK进行应用开发。\\n', '\\n', '安装SDK\\n', '\\n', '[使用SDK编译hello world样例](#使用SDK编译hello world样例)\\n', '\\n', '使用SDK编译内核模块样例\\n', '\\n', '安装SDK\\n', '执行SDK自解压安装脚本\\n', '运行如下命令：\\n', '\\n', 'sh openeuler-glibc-x86_64-openeuler-image-aarch64-qemu-aarch64-toolchain-22.03.sh\\n', '根据提示输入工具链的安装路径，默认路径是/opt/openeuler/\\\\<openeuler version\\\\>/；若不设置，则按默认路径安装；也可以配置相对路径或绝对路径。\\n', '\\n', '举例如下：\\n', '\\n', 'sh ./openeuler-glibc-x86_64-openeuler-image-armv7a-qemu-arm-toolchain-22.03.sh``\\n', 'openEuler embedded(openEuler Embedded Reference Distro) SDK installer version 22.03\\n', '================================================================\\n', 'Enter target directory for SDK (default: /opt/openeuler/22.03): sdk\\n', 'You are about to install the SDK to \"/usr1/openeuler/sdk\". Proceed [Y/n]? y\\n', 'Extracting SDK...............................................done\\n', 'Setting it up...SDK has been successfully set up and is ready to be used.\\n', 'Each time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g.\\n', '$ . /usr1/openeuler/sdk/environment-setup-armv7a-openeuler-linux-gnueabi\\n', '设置SDK环境变量\\n', '运行source命令。上例中前一步执行结束最后已打印source命令，运行即可。\\n', '\\n', '. /usr1/openeuler/myfiles/sdk/environment-setup-armv7a-openeuler-linux-gnueabi\\n', '查看是否安装成功\\n', '运行如下命令，查看是否安装成功、环境设置成功。\\n', '\\n', 'arm-openeuler-linux-gnueabi-gcc -v\\n', '使用SDK编译hello world样例\\n', '准备代码\\n', '以构建一个hello world程序为例，运行在openEuler Embedded根文件系统镜像中。\\n', '\\n', '创建一个hello.c文件，源码如下：\\n', '\\n', '#include <stdio.h>\\n', '\\n', 'int main(void)\\n', '{\\n', '    printf(\"hello world\\\\n\");\\n', '}\\n', '编写CMakelist.txt，和hello.c文件放在同一个目录。\\n', '\\n', 'project(hello C)\\n', '\\n', 'add_executable(hello hello.c)\\n', '编译生成二进制\\n', '进入hello.c文件所在目录，使用工具链编译，命令如下：\\n', '\\n', 'cmake ..\\n', 'make\\n', '把编译好的hello程序拷贝到openEuler Embedded系统的/tmp/某个目录下（例如/tmp/myfiles/）。如何拷贝可以参考前文所述使能共享文件系统场景。\\n', '\\n', '运行用户态程序\\n', '在openEuler Embedded系统中运行hello程序。\\n', '\\n', 'cd /tmp/myfiles/\\n', './hello\\n', '如运行成功，则会输出\"hello world\"。\\n', '\\n', '使用SDK编译内核模块样例\\n', '准备环境\\n', '在设置好SDK环境的基础之上，编译内核模块还需准备相应环境，但只需要准备一次即可。运行如下命令会创建相应的内核模块编译环境：\\n', '\\n', 'cd <SDK_PATH>/sysroots/<target>-openeuler-linux/usr/src/kernel\\n', 'make  modules_prepare\\n', '准备代码\\n', '以编译一个内核模块为例，运行在openEuler Embedded内核中。\\n', '\\n', '创建一个hello.c文件，源码如下：\\n', '\\n', '#include <linux/init.h>\\n', '#include <linux/module.h>\\n', '\\n', 'static int hello_init(void)\\n', '{\\n', '    printk(\"Hello, openEuler Embedded!\\\\r\\\\n\");\\n', '    return 0;\\n', '}\\n', '\\n', 'static void hello_exit(void)\\n', '{\\n', '    printk(\"Byebye!\");\\n', '}\\n', '\\n', 'module_init(hello_init);\\n', 'module_exit(hello_exit);\\n', '\\n', 'MODULE_LICENSE(GPL);\\n', '编写Makefile，和hello.c文件放在同一个目录：\\n', '\\n', ' KERNELDIR := ${KERNEL_SRC_DIR}\\n', ' CURRENT_PATH := $(shell pwd)\\n', '\\n', ' target := hello\\n', ' obj-m := $(target).o\\n', '\\n', ' build := kernel_modules\\n', '\\n', ' kernel_modules:\\n', ' \\t\\t$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) modules\\n', ' clean:\\n', ' \\t\\t$(MAKE) -C $(KERNELDIR) M=$(CURRENT_PATH) clean\\n', 'KERNEL_SRC_DIR 为SDK中内核源码树的目录，该变量在安装SDK后会被自动设置。\\n', '\\n', '编译生成内核模块\\n', '进入hello.c文件所在目录，使用工具链编译，命令如下：\\n', '\\n', 'make\\n', '将编译好的hello.ko拷贝到openEuler Embedded系统的目录下。\\n', '\\n', '如何拷贝可以参考前文所述使能共享文件系统场景。\\n', '\\n', '插入内核模块\\n', '在openEuler Embedded系统中插入内核模块:\\n', '\\n', 'insmod hello.ko\\n', '如运行成功，则会在内核日志中出现\"Hello, openEuler Embedded!\"。']"}
{"index": {"_index": "new-open", "_id": "openEuler_安全加固指南_加固指导_SELinux配置.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/SecHarden/SELinux%E9%85%8D%E7%BD%AE.html", "text_entry": "['SELinux配置\\n', '概述\\n', '自主访问控制DAC（Discretionary Access Control）基于用户、组和其他权限，决定一个资源是否能被访问的因素是某个资源是否拥有对应用户的权限，它不能使系统管理员创建全面和细粒度的安全策略。SELinux（Security-Enhanced Linux）是Linux内核的一个模块，也是Linux的一个安全子系统。SELinux的实现了强制访问控制MAC（Mandatory Access Control ），每个进程和系统资源都有一个特殊的安全标签，资源能否被访问除了DAC规定的原则外，还需要判断每一类进程是否拥有对某一类资源的访问权限。\\n', '\\n', 'openEuler默认使用SELinux提升系统安全性。SELinux分为三种模式：\\n', '\\n', 'permissive：SELinux仅打印告警而不强制执行。\\n', 'enforcing：SELinux安全策略被强制执行。\\n', 'disabled：不加载SELinux安全策略。\\n', '配置说明\\n', '获取当前SELinux运行状态：\\n', '\\n', '# getenforce\\n', 'Enforcing\\n', 'SELinux开启的前提下，设置运行状态为enforcing模式：\\n', '\\n', '# setenforce 1\\n', '# getenforce\\n', 'Enforcing\\n', 'SELinux开启的前提下，设置运行状态为permissive模式：\\n', '\\n', '# setenforce 0\\n', '# getenforce\\n', 'Permissive\\n', 'SELinux开启的前提下，设置当前SELinux运行状态为disabled（关闭SELinux，需要重启系统）。\\n', '\\n', '修改SELinux配置文件/etc/selinux/config，设置“SELINUX=disabled”。\\n', '# cat /etc/selinux/config | grep \"SELINUX=\"\\n', 'SELINUX=disabled\\n', '重启系统：\\n', '# reboot\\n', '状态切换成功：\\n', '# getenforce\\n', 'Disabled\\n', 'SELinux关闭的前提下，设置SELinux运行状态为permissive：\\n', '\\n', '修改SELinux配置文件/etc/selinux/config，设置“SELINUX=permissive”：\\n', '# cat /etc/selinux/config | grep \"SELINUX=\"\\n', 'SELINUX=permissive\\n', '在根目录下创建.autorelabel文件：\\n', '# touch /.autorelabel\\n', '重启系统，此时系统会重启两次：\\n', '# reboot\\n', '状态切换成功：\\n', '# getenforce\\n', 'Permissive\\n', 'SELinux关闭的前提下，设置SELinux运行状态为enforcing：\\n', '\\n', '按照上一步骤所述，设置SELinux运行状态为permissive。\\n', '修改SELinux配置文件/etc/selinux/config，设置“SELINUX=enforcing”：\\n', '# cat /etc/selinux/config | grep \"SELINUX=\"\\n', 'SELINUX=enforcing\\n', '重启系统：\\n', '# reboot\\n', '状态切换成功：\\n', '# getenforce\\n', 'Enforcing\\n', 'SELinux相关命令\\n', '查询运行SELinux的系统状态。SELinux status表示SELinux的状态，enabled表示启用SELinux，disabled表示关闭SELinux。Current mode表示SELinux当前的安全策略。\\n', '\\n', '# sestatus\\n', 'SELinux status:                 enabled\\n', 'SELinuxfs mount:                /sys/fs/selinux\\n', 'SELinux root directory:         /etc/selinux\\n', 'Loaded policy name:             targeted\\n', 'Current mode:                   enforcing\\n', 'Mode from config file:          enforcing\\n', 'Policy MLS status:              enabled\\n', 'Policy deny_unknown status:     allowed\\n', 'Memory protection checking:     actual (secure)\\n', 'Max kernel policy version:      31\\n', '注意事项\\n', '如用户需使能SELinux功能，建议通过dnf升级方式将selinux-policy更新为最新版本，否则应用程序有可能无法正常运行。升级命令示例：\\n', '\\n', 'dnf update selinux-policy -y\\n', '如果用户由于SELinux配置不当（如误删策略或未配置合理的规则或安全上下文）导致系统无法启动，可以在启动参数中添加selinux=0，关闭SELinux功能，系统即可正常启动。\\n', '\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_特权容器.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E7%89%B9%E6%9D%83%E5%AE%B9%E5%99%A8.html", "text_entry": "['特权容器\\n', '特权容器\\n', '场景说明\\n', '使用限制\\n', '使用指导\\n', '场景说明\\n', 'iSulad默认启动的是普通容器，普通容器适合启动普通进程，其权限非常受限，仅具备/etc/default/isulad/config.json中capabilities所定义的默认权限。当需要特权操作时（比如操作/sys下的设备），需要特权容器完成这些操作，使用该特性，容器内的root将拥有宿主机的root权限， 否则，容器内的root在只是宿主机的普通用户权限。\\n', '\\n', '使用限制\\n', '特权容器为容器提供了所有功能，还解除了设备cgroup控制器强制执行的所有限制，具备以下特性：\\n', '\\n', 'Secomp不block任何系统调用\\n', '\\n', '/sys、/proc路径可写\\n', '\\n', '容器内能访问主机上所有设备\\n', '\\n', '系统的权能将全部打开\\n', '\\n', '普通容器默认权能为：\\n', '\\n', '\\n', 'Capability Key\\n', '\\n', 'Capability Description\\n', '\\n', 'SETPCAP\\n', '\\n', '修改进程权能\\n', '\\n', 'MKNOD\\n', '\\n', '允许使用mknod()系统调用创建特殊文件\\n', '\\n', 'AUDIT_WRITE\\n', '\\n', '向内核审计日志写记录\\n', '\\n', 'CHOWN\\n', '\\n', '对文件的 UIDs 和 GIDs 做任意的修改(参考 chown(2))\\n', '\\n', 'NET_RAW\\n', '\\n', '使用 RAW 和 PACKET sockets；为透明代理绑定任何地址\\n', '\\n', 'DAC_OVERRIDE\\n', '\\n', '忽略文件的DAC访问限制\\n', '\\n', 'FOWNER\\n', '\\n', '忽略文件属主ID必须和进程用户ID相匹配的限制\\n', '\\n', 'FSETID\\n', '\\n', '允许设置文件的setuid位\\n', '\\n', 'KILL\\n', '\\n', '允许对不属于自己的进程发送信号\\n', '\\n', 'SETGID\\n', '\\n', '允许改变进程的组ID\\n', '\\n', 'SETUID\\n', '\\n', '允许改变进程的用户ID\\n', '\\n', 'NET_BIND_SERVICE\\n', '\\n', '允许绑定到小于1024的端口\\n', '\\n', 'SYS_CHROOT\\n', '\\n', '允许使用chroot()系统调用\\n', '\\n', 'SETFCAP\\n', '\\n', '允许向其他进程转移能力以及删除其他进程的能力\\n', '\\n', '当容器为特权模式时，将添加以下权能\\n', '\\n', '\\n', 'Capability Key\\n', '\\n', 'Capability Description\\n', '\\n', 'SYS_MODULE\\n', '\\n', '加载和卸载内核模块\\n', '\\n', 'SYS_RAWIO\\n', '\\n', '允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备\\n', '\\n', 'SYS_PACCT\\n', '\\n', '允许执行进程的BSD式审计\\n', '\\n', 'SYS_ADMIN\\n', '\\n', '允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等\\n', '\\n', 'SYS_NICE\\n', '\\n', '允许提升优先级及设置其他进程的优先级\\n', '\\n', 'SYS_RESOURCE\\n', '\\n', '忽略资源限制\\n', '\\n', 'SYS_TIME\\n', '\\n', '允许改变系统时钟\\n', '\\n', 'SYS_TTY_CONFIG\\n', '\\n', '允许配置TTY设备\\n', '\\n', 'AUDIT_CONTROL\\n', '\\n', '启用和禁用内核审计；修改审计过滤器规则；提取审计状态和过滤规则\\n', '\\n', 'MAC_ADMIN\\n', '\\n', '覆盖强制访问控制 (Mandatory Access Control (MAC))，为Smack Linux安全模块(Linux Security Module (LSM)) 而实现\\n', '\\n', 'MAC_OVERRIDE\\n', '\\n', '允许 MAC 配置或状态改变。为 Smack LSM 而实现\\n', '\\n', 'NET_ADMIN\\n', '\\n', '允许执行网络管理任务\\n', '\\n', 'SYSLOG\\n', '\\n', '执行特权 syslog(2) 操作\\n', '\\n', 'DAC_READ_SEARCH\\n', '\\n', '忽略文件读及目录搜索的DAC访问限制\\n', '\\n', 'LINUX_IMMUTABLE\\n', '\\n', '允许修改文件的IMMUTABLE和APPEND属性标志\\n', '\\n', 'NET_BROADCAST\\n', '\\n', '允许网络广播和多播访问\\n', '\\n', 'IPC_LOCK\\n', '\\n', '允许锁定共享内存片段\\n', '\\n', 'IPC_OWNER\\n', '\\n', '忽略IPC所有权检查\\n', '\\n', 'SYS_PTRACE\\n', '\\n', '允许跟踪任何进程\\n', '\\n', 'SYS_BOOT\\n', '\\n', '允许重新启动系统\\n', '\\n', 'LEASE\\n', '\\n', '允许修改文件锁的FL_LEASE标志\\n', '\\n', 'WAKE_ALARM\\n', '\\n', '触发将唤醒系统的功能，如设置 CLOCK_REALTIME_ALARM 和 CLOCK_BOOTTIME_ALARM 定时器\\n', '\\n', 'BLOCK_SUSPEND\\n', '\\n', '可以阻塞系统挂起的特性\\n', '\\n', '使用指导\\n', 'iSulad使用–privileged给容器添加特权模式，在非必要情况下，不要给容器添加特权，遵循最小特权原则，减少存在的安全风险。\\n', '\\n', 'isula run --rm -it --privileged busybox\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_安装指南_安装在服务器_FAQ.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Installation/FAQ.html", "text_entry": "['FAQ\\n', '安装openEuler时选择第二盘位为安装目标，操作系统无法启动\\n', '问题现象\\n', '安装操作系统时，直接将系统安装到第二块磁盘sdb，重启系统后启动失败。\\n', '\\n', '原因分析\\n', '当安装系统到第二块磁盘时，MBR和GRUB会默认安装到第二块磁盘sdb。这样会有下面两种情况：\\n', '\\n', '如果第一块磁盘中有完整系统，则加载第一块磁盘中的系统启动。\\n', '如果第一块磁盘中没有完好的操作系统，则会导致硬盘启动失败。\\n', '以上两种情况都是因为BIOS默认从第一块磁盘sda中加载引导程序启动系统，如果sda没有系统，则会导致启动失败。\\n', '\\n', '解决方法\\n', '有以下两种解决方案：\\n', '\\n', '当系统处于安装过程中，在选择磁盘（选择第一块或者两块都选择）后，指定引导程序安装到第一块盘sda中。\\n', '当系统已经安装完成，若BIOS支持选择从哪个磁盘启动，则可以通过修改BIOS中磁盘启动顺序，尝试重新启动系统。\\n', 'openEuler开机后进入emergency模式\\n', '问题现象\\n', 'openEuler系统开机后进入emergency模式，如下图所示：\\n', '\\n', '\\n', '\\n', '原因分析\\n', '操作系统文件系统损坏导致磁盘挂载失败，或者io压力过大导致磁盘挂载超时（超时时间为90秒）。\\n', '\\n', '系统异常掉电、物理磁盘io性能低等情况都可能导致该问题。\\n', '\\n', '解决方法\\n', '用户直接输入root账号的密码，登录系统。\\n', '\\n', '使用fsck工具，检测并修复文件系统，然后重启。\\n', '\\n', ' 说明：\\n', 'fsck（file system check）用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。 用户可以通过“fsck.ext3 -h”、“fsck.ext4 -h”命令查看fsck的使用方法。\\n', '\\n', '另外，如果用户需要取消磁盘挂载超时时间，可以直接在“/etc/fstab”文件中添加“x-systemd.device-timeout=0”。如下：\\n', '\\n', '#\\n', '# /etc/fstab\\n', '# Created by anaconda on Mon Sep 14 17:25:48 2015\\n', '#\\n', \"# Accessible filesystems, by reference, are maintained under '/dev/disk'\\n\", '# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info\\n', '#\\n', '/dev/mapper/openEuler-root / ext4 defaults,x-systemd.device-timeout=0 0 0\\n', 'UUID=afcc811f-4b20-42fc-9d31-7307a8cfe0df /boot ext4 defaults,x-systemd.device-timeout=0 0 0\\n', '/dev/mapper/openEuler-home /home ext4 defaults 0 0\\n', '/dev/mapper/openEuler-swap swap swap defaults 0 0\\n', '系统中存在无法激活的逻辑卷组时，重装系统失败\\n', '问题现象\\n', '由于磁盘故障，系统中存在无法激活的逻辑卷组，重装系统出现异常。\\n', '\\n', '原因分析\\n', '安装时有激活逻辑卷组的操作，无法激活时会提示异常。\\n', '\\n', '解决方法\\n', '重装系统前如果系统中存在无法激活的逻辑卷组，为了避免重装系统过程出现异常，需在重装前将逻辑卷组恢复到正常状态或者清除这些逻辑卷组。举例如下：\\n', '\\n', '恢复逻辑卷组状态\\n', '\\n', \"使用以下命令清除vg激活状态， 防止出现“Can't open /dev/sdc exclusively mounted filesystem”。\\n\", '\\n', ' vgchange -a n testvg32947\\n', '根据备份文件重新创建pv。\\n', '\\n', 'pvcreate --uuid JT7zlL-K5G4-izjB-3i5L-e94f-7yuX-rhkLjL --restorefile /etc/lvm/backup/testvg32947 /dev/sdc\\n', '恢复vg信息。\\n', '\\n', 'vgcfgrestore testvg32947\\n', '重新激活vg。\\n', '\\n', ' vgchange -ay testvg32947\\n', '清除逻辑卷组\\n', '\\n', 'vgchange -a n testvg32947\\n', 'vgremove -y testvg32947\\n', '选择安装源出现异常\\n', '问题现象\\n', '选择安装源后出现：“Error checking software selection”。\\n', '\\n', '原因分析\\n', '这种现象是由于安装源中的软件包依赖存在问题。\\n', '\\n', '解决方法\\n', '检查安装源是否存在异常。如果异常，使用新的安装源。\\n', '\\n', '如何手动开启kdump服务\\n', '问题现象\\n', '执行systemctl status kdump命令，显示状态信息如下，提示无预留内存。\\n', '\\n', '\\n', '\\n', '原因分析\\n', 'kdump服务需要系统预留一段内存用于运行kdump内核，而当前系统没有为kdump服务预留内存，所以无法运行kdump服务。\\n', '\\n', '解决方法\\n', '已安装操作系统的场景\\n', '\\n', '修改/boot/efi/EFI/openEuler/grub.cfg，添加crashkernel=1024M,high。\\n', '\\n', '重启系统使配置生效。\\n', '\\n', '执行如下命令，检查kdump状态：\\n', '\\n', 'systemctl status kdump\\n', '若回显如下，即kdump的状态为active，说明kdump已使能，操作结束。\\n', '\\n', '\\n', '\\n', '参数说明\\n', 'kdump内核预留内存参数说明如下：\\n', '\\n', '表 1 crashkernel参数说明\\n', '\\n', '\\n', '内核启动参数\\n', '\\n', '描述\\n', '\\n', '默认值\\n', '\\n', '备注\\n', '\\n', 'crashkernel=X\\n', '\\n', '在4G以下的物理内存预留X大小的内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整\\n', '\\n', '该配置方法只在4G以下内存预留，必须保证4G以下连续可用内存足够预留\\n', '\\n', 'crashkernel=X@Y\\n', '\\n', '在Y起始地址预留X大小的内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整\\n', '\\n', '需要确保Y起始地址的X大小内存未被其他模块预留\\n', '\\n', 'crashkernel=X,high\\n', '\\n', '在4G以下的物理内存中预留256M大小，在4G以上预留X大小内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整，推荐值为1024M,high\\n', '\\n', '确保4G以下内存有256M连续可用内存，4G以上有连续X大小内存可预留。实际预留内存大小为256M+X\\n', '\\n', 'crashkernel=X,low\\n', '\\n', 'crashkernel=Y,high\\n', '\\n', '在4G以下的物理内存中预留X大小，在4G以上预留Y大小内存给kdump使用\\n', '\\n', '无，用户根据实际情况调整\\n', '\\n', '需要确保4G以下有X大小连续可用内存，4G以上有Y大小连续可用内存。实际预留内存大小为X+Y\\n', '\\n', '多块磁盘组成逻辑卷安装系统后，再次安装不能只选其中一块磁盘\\n', '问题现象\\n', '在安装系统时，如果之前的系统选择多块磁盘组成逻辑卷进行安装，再次安装时，如果只选择了其中的一块或几块磁盘，没有全部选择，在保存配置时提示配置错误，如图1所示。\\n', '\\n', '图 1 配置错误提示\\n', '\\n', '\\n', '原因分析\\n', '之前的逻辑卷包含了多块磁盘，只在一块磁盘上安装会破坏逻辑卷。\\n', '\\n', '解决方法\\n', '因为多块磁盘组成逻辑卷相当于一个整体，所以只需要删除对应的卷组即可。\\n', '\\n', '按“Ctrl+Alt+F2”可以切换到命令行，执行如下命令找到卷组。\\n', '\\n', 'vgs\\n', '\\n', '\\n', '执行如下命令，删除卷组。\\n', '\\n', 'vgremove euleros\\n', '执行如下命令，重启安装程序即可生效。\\n', '\\n', 'systemctl restart anaconda\\n', ' 说明：\\n', '图形模式下也可以按“Ctrl+Alt+F6”回到图形界面，点击图1右下角的“Refresh”刷新存储配置生效。\\n', '\\n', 'x86物理机UEFI模式由于Secure Boot安全选项问题无法安装\\n', '问题现象\\n', 'x86物理机安装系统时，由于设置了BIOS选项Secure Boot 为enable（默认是disable），导致系统一直停留在“No bootable device”提示界面，无法继续安装，如图2所示。\\n', '\\n', '图 2 “No bootable device”提示界面\\n', '\\n', '\\n', '原因分析\\n', '开启Secure Boot后，主板会验证引导程序及操作系统 ，若没有用对应的私钥进行签名，则无法通过主板上内置公钥的认证。\\n', '\\n', '解决方法\\n', '进入BIOS，设置Secure Boot为disable，重新安装即可。\\n', '\\n', '系统启动时，按“F11”，输入密码“Admin@9000”进入BIOS。\\n', '\\n', '\\n', '\\n', '选择进入Administer Secure Boot。\\n', '\\n', '\\n', '\\n', '设置Enforce Secure Boot为Disabled。\\n', '\\n', '\\n', '\\n', ' 说明：\\n', '设置Secure Boot为disable之后，保存退出，重新安装即可。\\n', '\\n', '安装openEuler时，软件选择页面选择“服务器-性能工具”，安装后messages日志有pmie_check报错信息\\n', '问题现象\\n', '安装系统时软件选择勾选服务器-性能工具，会安装pcp相关软件包，正常安装并重启后，/var/log/messages日志文件中会产生报错：pmie_check failed in /usr/share/pcp/lib/pmie。\\n', '\\n', '原因分析\\n', 'anaconda不支持在chroot环境中安装selinux策略模块，当安装pcp-selinux时，postin脚本安装pcp相关selinux策略模块执行失败，从而导致重启后产生报错。\\n', '\\n', '解决办法\\n', '完成安装并重启后，以下方法选择其一。\\n', '\\n', '执行如下命令，安装selinux策略模块pcpupstream\\n', '\\n', '/usr/libexec/pcp/bin/selinux-setup /var/lib/pcp/selinux install \"pcpupstream\"\\n', '重新安装pcp-selinux\\n', '\\n', 'sudo dnf reinstall pcp-selinux\\n', '在两块已经安装了系统的磁盘上进行重复选择，并自定义分区时，安装失败\\n', '问题现象\\n', '用户在安装操作系统过程中，存在两块都已经安装过的磁盘，此时如果先选择一块盘，进行自定义分区，然后点击取消按钮，再选择第二块盘，并进行自定义分区时，会出现安装失败。\\n', '\\n', ' \\n', '\\n', '原因分析\\n', '用户存在两次选择磁盘的操作，当前点击取消后，再选择第二块磁盘，磁盘信息不正确，导致安装失败。\\n', '\\n', '解决方法\\n', '直接选择目标磁盘进行自定义分区，请勿频繁取消操作，如果一定要进行取消重选建议重新安装。\\n', '\\n', 'issue访问链接\\n', 'https://gitee.com/src-openeuler/anaconda/issues/I29P84?from=project-issue\\n', '\\n', '安装LSI MegaRAID卡的物理机kdump无法生成vmcore\\n', '问题现象\\n', '部署好kdump服务后，手动执行echo c > /proc/sysrq-trigger命令或由于kernel故障导致kernel宕机，触发kdump启动second kernel过程中，MegaRAID驱动报错“BRCM Debug mfi stat 0x2d，data len requested/completed 0x200/0x0”，报错信息如下图，最终导致无法生成vmcore。\\n', '\\n', '\\n', '\\n', '原因分析\\n', '由于默认配置了reset_devices启动参数，second kernel启动过程中会触发设备复位(reset_devices)操作，设备复位操作导致MegaRAID控制器或磁盘状态故障，转储vmcore文件时访问MegaRAID卡的磁盘报错，进而无法生成vmcore。\\n', '\\n', '解决方法\\n', '在物理机etc/sysconfig/kdump文件中将second kernel默认启动参数reset_devices删除，可以规避second kernel启动过程中由于MegaRAID卡驱动复位设备所致IO请求未完成问题，以成功生成vmcore。 ']"}
{"index": {"_index": "new-open", "_id": "openEuler_Kubernetes集群部署指南_手动部署集群_部署 Node 节点组件.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Kubernetes/%E9%83%A8%E7%BD%B2Node%E8%8A%82%E7%82%B9%E7%BB%84%E4%BB%B6.html", "text_entry": "['署 Node 节点组件\\n', '本章节仅以k8snode1节点为例。\\n', '\\n', '环境准备\\n', '# 内网需要配置代理\\n', '$ dnf install -y docker iSulad conntrack-tools socat containernetworking-plugins\\n', '$ swapoff -a\\n', '$ mkdir -p /etc/kubernetes/pki/\\n', '$ mkdir -p /etc/cni/net.d\\n', '$ mkdir -p /opt/cni\\n', '# 删除默认kubeconfig\\n', '$ rm /etc/kubernetes/kubelet.kubeconfig\\n', '\\n', '## 使用isulad作为运行时 ########\\n', '# 配置iSulad\\n', 'cat  /etc/isulad/daemon.json\\n', '{\\n', '        \"registry-mirrors\": [\\n', '                \"docker.io\"\\n', '        ],\\n', '        \"insecure-registries\": [\\n', '                \"k8s.gcr.io\",\\n', '                \"quay.io\"\\n', '        ],\\n', '        \"pod-sandbox-image\": \"k8s.gcr.io/pause:3.2\",# pause类型\\n', '        \"network-plugin\": \"cni\", # 置空表示禁用cni网络插件则下面两个路径失效， 安装插件后重启isulad即可\\n', '        \"cni-bin-dir\": \"/usr/libexec/cni/\",\\n', '        \"cni-conf-dir\": \"/etc/cni/net.d\",\\n', '}\\n', '\\n', '# 在iSulad环境变量中添加代理，下载镜像\\n', 'cat /usr/lib/systemd/system/isulad.service\\n', '[Service]\\n', 'Type=notify\\n', 'Environment=\"HTTP_PROXY=http://name:password@proxy:8080\"\\n', 'Environment=\"HTTPS_PROXY=http://name:password@proxy:8080\"\\n', '\\n', '# 重启iSulad并设置为开机自启\\n', 'systemctl daemon-reload\\n', 'systemctl restart isulad\\n', '\\n', '\\n', '\\n', '\\n', '## 如果使用docker作为运行时 ########\\n', '$ dnf install -y docker\\n', '# 如果需要代理的环境，可以给docker配置代理，新增配置文件http-proxy.conf，并编写如下内容，替换name，password和proxy-addr为实际的配置。\\n', '$ cat /etc/systemd/system/docker.service.d/http-proxy.conf\\n', '[Service]\\n', 'Environment=\"HTTP_PROXY=http://name:password@proxy-addr:8080\"\\n', '$ systemctl daemon-reload\\n', '$ systemctl restart docker\\n', '创建 kubeconfig 配置文件\\n', '对各节点依次如下操作创建配置文件：\\n', '\\n', '$ kubectl config set-cluster openeuler-k8s \\\\\\n', '    --certificate-authority=/etc/kubernetes/pki/ca.pem \\\\\\n', '    --embed-certs=true \\\\\\n', '    --server=https://192.168.122.154:6443 \\\\\\n', '    --kubeconfig=k8snode1.kubeconfig\\n', '\\n', '$ kubectl config set-credentials system:node:k8snode1 \\\\\\n', '    --client-certificate=/etc/kubernetes/pki/k8snode1.pem \\\\\\n', '    --client-key=/etc/kubernetes/pki/k8snode1-key.pem \\\\\\n', '    --embed-certs=true \\\\\\n', '    --kubeconfig=k8snode1.kubeconfig\\n', '\\n', '$ kubectl config set-context default \\\\\\n', '    --cluster=openeuler-k8s \\\\\\n', '    --user=system:node:k8snode1 \\\\\\n', '    --kubeconfig=k8snode1.kubeconfig\\n', '\\n', '$ kubectl config use-context default --kubeconfig=k8snode1.kubeconfig\\n', '注：修改k8snode1为对应节点名\\n', '\\n', '拷贝证书\\n', '和控制面一样，所有证书、密钥和相关配置都放到/etc/kubernetes/pki/目录。\\n', '\\n', '$ ls /etc/kubernetes/pki/\\n', 'ca.pem                 k8snode1.kubeconfig  kubelet_config.yaml     kube-proxy-key.pem     kube-proxy.pem\\n', 'k8snode1-key.pem  k8snode1.pem         kube_proxy_config.yaml  kube-proxy.kubeconfig\\n', 'CNI 网络配置\\n', '先通过 containernetworking-plugins 作为 kubelet 使用的 cni 插件，后续可以引入 calico，flannel 等插件，增强集群的网络能力。\\n', '\\n', '# 桥网络配置\\n', '$ cat /etc/cni/net.d/10-bridge.conf\\n', '{\\n', '  \"cniVersion\": \"0.3.1\",\\n', '  \"name\": \"bridge\",\\n', '  \"type\": \"bridge\",\\n', '  \"bridge\": \"cnio0\",\\n', '  \"isGateway\": true,\\n', '  \"ipMasq\": true,\\n', '  \"ipam\": {\\n', '    \"type\": \"host-local\",\\n', '    \"subnet\": \"10.244.0.0/16\",\\n', '    \"gateway\": \"10.244.0.1\"\\n', '  },\\n', '  \"dns\": {\\n', '    \"nameservers\": [\\n', '      \"10.244.0.1\"\\n', '    ]\\n', '  }\\n', '}\\n', '\\n', '# 回环网络配置\\n', '$ cat /etc/cni/net.d/99-loopback.conf\\n', '{\\n', '    \"cniVersion\": \"0.3.1\",\\n', '    \"name\": \"lo\",\\n', '    \"type\": \"loopback\"\\n', '}\\n', '部署 kubelet 服务\\n', 'kubelet 依赖的配置文件\\n', '$ cat /etc/kubernetes/pki/kubelet_config.yaml\\n', 'kind: KubeletConfiguration\\n', 'apiVersion: kubelet.config.k8s.io/v1beta1\\n', 'authentication:\\n', '  anonymous:\\n', '    enabled: false\\n', '  webhook:\\n', '    enabled: true\\n', '  x509:\\n', '    clientCAFile: /etc/kubernetes/pki/ca.pem\\n', 'authorization:\\n', '  mode: Webhook\\n', 'clusterDNS:\\n', '- 10.32.0.10\\n', 'clusterDomain: cluster.local\\n', 'runtimeRequestTimeout: \"15m\"\\n', 'tlsCertFile: \"/etc/kubernetes/pki/k8snode1.pem\"\\n', 'tlsPrivateKeyFile: \"/etc/kubernetes/pki/k8snode1-key.pem\"\\n', '注意：clusterDNS 的地址为：10.32.0.10，必须和之前设置的 service-cluster-ip-range 一致\\n', '\\n', '编写 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kubelet.service\\n', '[Unit]\\n', 'Description=kubelet: The Kubernetes Node Agent\\n', 'Documentation=https://kubernetes.io/docs/\\n', 'Wants=network-online.target\\n', 'After=network-online.target\\n', '\\n', '[Service]\\n', 'ExecStart=/usr/bin/kubelet \\\\\\n', '\\t--config=/etc/kubernetes/pki/kubelet_config.yaml \\\\\\n', '\\t--network-plugin=cni \\\\\\n', '\\t--pod-infra-container-image=k8s.gcr.io/pause:3.2 \\\\\\n', '\\t--kubeconfig=/etc/kubernetes/pki/k8snode1.kubeconfig \\\\\\n', '\\t--register-node=true \\\\\\n', '\\t--hostname-override=k8snode1 \\\\\\n', '\\t--cni-bin-dir=\"/usr/libexec/cni/\" \\\\\\n', '\\t--v=2\\n', '\\n', 'Restart=always\\n', 'StartLimitInterval=0\\n', 'RestartSec=10\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '注意：如果使用isulad作为runtime，需要增加如下配置\\n', '\\n', '--container-runtime=remote \\\\\\n', '--container-runtime-endpoint=unix:///var/run/isulad.sock \\\\\\n', '部署 kube-proxy\\n', 'kube-proxy 依赖的配置文件\\n', 'cat /etc/kubernetes/pki/kube_proxy_config.yaml\\n', 'kind: KubeProxyConfiguration\\n', 'apiVersion: kubeproxy.config.k8s.io/v1alpha1\\n', 'clientConnection:\\n', '  kubeconfig: /etc/kubernetes/pki/kube-proxy.kubeconfig\\n', 'clusterCIDR: 10.244.0.0/16\\n', 'mode: \"iptables\"\\n', '编写 systemd 配置文件\\n', '$ cat /usr/lib/systemd/system/kube-proxy.service\\n', '[Unit]\\n', 'Description=Kubernetes Kube-Proxy Server\\n', 'Documentation=https://kubernetes.io/docs/reference/generated/kube-proxy/\\n', 'After=network.target\\n', '\\n', '[Service]\\n', 'EnvironmentFile=-/etc/kubernetes/config\\n', 'EnvironmentFile=-/etc/kubernetes/proxy\\n', 'ExecStart=/usr/bin/kube-proxy \\\\\\n', '\\t    $KUBE_LOGTOSTDERR \\\\\\n', '\\t    $KUBE_LOG_LEVEL \\\\\\n', '\\t    --config=/etc/kubernetes/pki/kube_proxy_config.yaml \\\\\\n', '\\t    --hostname-override=k8snode1 \\\\\\n', '\\t    $KUBE_PROXY_ARGS\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '启动组件服务\\n', '$ systemctl enable kubelet kube-proxy\\n', '$ systemctl start kubelet kube-proxy\\n', '其他节点依次部署即可。\\n', '\\n', '验证集群状态\\n', '等待几分钟，使用如下命令查看node状态：\\n', '\\n', '$ kubectl get nodes --kubeconfig /etc/kubernetes/pki/admin.kubeconfig\\n', 'NAME            STATUS   ROLES    AGE   VERSION\\n', 'k8snode1   Ready    <none>   17h   v1.20.2\\n', 'k8snode2   Ready    <none>   19m   v1.20.2\\n', 'k8snode3   Ready    <none>   12m   v1.20.2\\n', '部署 coredns\\n', 'coredns可以部署到node节点或者master节点，本文这里部署到节点k8snode1。\\n', '\\n', '编写 coredns 配置文件\\n', '$ cat /etc/kubernetes/pki/dns/Corefile\\n', '.:53 {\\n', '    errors\\n', '    health {\\n', '      lameduck 5s\\n', '    }\\n', '    ready\\n', '    kubernetes cluster.local in-addr.arpa ip6.arpa {\\n', '      pods insecure\\n', '      endpoint https://192.168.122.154:6443\\n', '      tls /etc/kubernetes/pki/ca.pem /etc/kubernetes/pki/admin-key.pem /etc/kubernetes/pki/admin.pem\\n', '      kubeconfig /etc/kubernetes/pki/admin.kubeconfig default\\n', '      fallthrough in-addr.arpa ip6.arpa\\n', '    }\\n', '    prometheus :9153\\n', '    forward . /etc/resolv.conf {\\n', '      max_concurrent 1000\\n', '    }\\n', '    cache 30\\n', '    loop\\n', '    reload\\n', '    loadbalance\\n', '}\\n', '说明：\\n', '\\n', '监听53端口；\\n', '设置kubernetes插件配置：证书、kube api的URL；\\n', '准备 systemd 的 service 文件\\n', 'cat /usr/lib/systemd/system/coredns.service\\n', '[Unit]\\n', 'Description=Kubernetes Core DNS server\\n', 'Documentation=https://github.com/coredns/coredns\\n', 'After=network.target\\n', '\\n', '[Service]\\n', 'ExecStart=bash -c \"KUBE_DNS_SERVICE_HOST=10.32.0.10 coredns -conf /etc/kubernetes/pki/dns/Corefile\"\\n', '\\n', 'Restart=on-failure\\n', 'LimitNOFILE=65536\\n', '\\n', '[Install]\\n', 'WantedBy=multi-user.target\\n', '启动服务\\n', '$ systemctl enable coredns\\n', '$ systemctl start coredns\\n', '创建 coredns 的 Service 对象\\n', '$ cat coredns_server.yaml\\n', 'apiVersion: v1\\n', 'kind: Service\\n', 'metadata:\\n', '  name: kube-dns\\n', '  namespace: kube-system\\n', '  annotations:\\n', '    prometheus.io/port: \"9153\"\\n', '    prometheus.io/scrape: \"true\"\\n', '  labels:\\n', '    k8s-app: kube-dns\\n', '    kubernetes.io/cluster-service: \"true\"\\n', '    kubernetes.io/name: \"CoreDNS\"\\n', 'spec:\\n', '  clusterIP: 10.32.0.10\\n', '  ports:\\n', '  - name: dns\\n', '    port: 53\\n', '    protocol: UDP\\n', '  - name: dns-tcp\\n', '    port: 53\\n', '    protocol: TCP\\n', '  - name: metrics\\n', '    port: 9153\\n', '    protocol: TCP\\n', '创建 coredns 的 endpoint 对象\\n', '$ cat coredns_ep.yaml\\n', 'apiVersion: v1\\n', 'kind: Endpoints\\n', 'metadata:\\n', '  name: kube-dns\\n', '  namespace: kube-system\\n', 'subsets:\\n', '  - addresses:\\n', '      - ip: 192.168.122.157\\n', '    ports:\\n', '      - name: dns-tcp\\n', '        port: 53\\n', '        protocol: TCP\\n', '      - name: dns\\n', '        port: 53\\n', '        protocol: UDP\\n', '      - name: metrics\\n', '        port: 9153\\n', '        protocol: TCP\\n', '确认 coredns 服务\\n', '# 查看service对象\\n', '$ kubectl get service -n kube-system kube-dns\\n', 'NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE\\n', 'kube-dns   ClusterIP   10.32.0.10   <none>        53/UDP,53/TCP,9153/TCP   51m\\n', '# 查看endpoint对象\\n', '$ kubectl get endpoints -n kube-system kube-dns\\n', 'NAME       ENDPOINTS                                                    AGE\\n', 'kube-dns   192.168.122.157:53,192.168.122.157:53,192.168.122.157:9153   52m\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_镜像管理.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86.html", "text_entry": "['镜像管理\\n', '镜像管理\\n', 'docker镜像管理\\n', '登录到镜像仓库\\n', '从镜像仓库退出登录\\n', '从镜像仓库拉取镜像\\n', '删除镜像\\n', '加载镜像\\n', '列出镜像\\n', '检视镜像\\n', '双向认证\\n', 'embedded镜像管理\\n', '加载镜像\\n', '列出镜像\\n', '检视镜像\\n', '删除镜像\\n', 'docker镜像管理\\n', '登录到镜像仓库\\n', '描述\\n', 'isula login命令用于登录到镜像仓库。登录成功后可以使用isula pull命令从该镜像仓库拉取镜像。如果镜像仓库不需要密码，则拉取镜像前不需要执行该命令。\\n', '\\n', '用法\\n', 'isula login [OPTIONS] SERVER\\n', '参数\\n', 'login命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表1 表1-20 login命令参数列表” 。\\n', '\\n', '示例\\n', '$ isula login -u abc my.csp-edge.com:5000\\n', '\\n', 'Login Succeeded\\n', '从镜像仓库退出登录\\n', '描述\\n', 'isula logout命令用于从镜像仓库退出登录。退出登录成功后再执行isula pull命令从该镜像仓库拉取镜像会因为未认证而拉取失败。\\n', '\\n', '用法\\n', 'isula logout SERVER\\n', '参数\\n', 'logout命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表2 logout命令参数列表”。\\n', '\\n', '示例\\n', '$ isula logout my.csp-edge.com:5000\\n', 'Logout Succeeded\\n', '从镜像仓库拉取镜像\\n', '描述\\n', '从镜像仓库拉取镜像到本地。\\n', '\\n', '用法\\n', 'isula pull [OPTIONS] NAME[:TAG|@DIGEST]\\n', '参数\\n', 'login命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表3 pull命令参数列表”。\\n', '\\n', '示例\\n', '$ isula pull localhost:5000/official/busybox\\n', 'Image \"localhost:5000/official/busybox\" pulling\\n', 'Image \"localhost:5000/official/busybox@sha256:bf510723d2cd2d4e3f5ce7e93bf1e52c8fd76831995ac3bd3f90ecc866643aff\" pulled\\n', '删除镜像\\n', '描述\\n', '删除一个或多个镜像。\\n', '\\n', '用法\\n', 'isula rmi [OPTIONS] IMAGE [IMAGE...]\\n', '参数\\n', 'rmi命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表4 rmi命令参数列表”。\\n', '\\n', '示例\\n', '$ isula rmi rnd-dockerhub.huawei.com/official/busybox\\n', 'Image \"rnd-dockerhub.huawei.com/official/busybox\" removed\\n', '加载镜像\\n', '描述\\n', '从一个tar包加载镜像。该tar包必须是使用docker save命令导出的tar包或格式一致的tar包。\\n', '\\n', '用法\\n', 'isula load [OPTIONS]\\n', '参数\\n', 'load命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表5 load命令参数列表”。\\n', '\\n', '示例\\n', '$ isula load -i busybox.tar\\n', 'Load image from \"/root/busybox.tar\" success\\n', '列出镜像\\n', '描述\\n', '列出当前环境中所有镜像。\\n', '\\n', '用法\\n', 'isula images\\n', '参数\\n', 'images命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表6 images命令参数列表”。\\n', '\\n', '示例\\n', '$ isula images\\n', 'REF                                              IMAGE ID             CREATED              SIZE\\n', 'rnd-dockerhub.huawei.com/official/busybox:latest e4db68de4ff2         2019-06-15 08:19:54  1.376 MB\\n', '检视镜像\\n', '描述\\n', '返回该镜像的配置信息。可以使用-f参数过滤出需要的信息。\\n', '\\n', '用法\\n', 'isula inspect [options] CONTAINER|IMAGE [CONTAINER|IMAGE...]\\n', '参数\\n', 'inspect命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表7 inspect命令参数列表”。\\n', '\\n', '示例\\n', '$ isula inspect -f \"{{json .image.id}}\" rnd-dockerhub.huawei.com/official/busybox\\n', '\"e4db68de4ff27c2adfea0c54bbb73a61a42f5b667c326de4d7d5b19ab71c6a3b\"\\n', '双向认证\\n', '描述\\n', '开启该功能后isulad和镜像仓库之间的通信采用https通信，isulad和镜像仓库都会验证对方的合法性。\\n', '\\n', '用法\\n', '要支持该功能，需要镜像仓库支持该功能，同时isulad也需要做相应的配置：\\n', '\\n', '修改isulad的配置(默认路径/etc/isulad/daemon.json)，将配置里的use-decrypted-key项配置为false。\\n', '\\n', '需要将相关的证书放置到/etc/isulad/certs.d目录下对应的镜像仓库命名的文件夹下，证书具体的生成方法见docker的官方链接：\\n', '\\n', 'https://docs.docker.com/engine/security/certificates/\\n', 'https://docs.docker.com/engine/security/https/\\n', '执行systemctl restart isulad重启isulad。\\n', '\\n', '参数\\n', '可以在/etc/isulad/daemon.json中配置参数，也可以在启动isulad时携带参数：\\n', '\\n', 'isulad --use-decrypted-key=false\\n', '示例\\n', '配置use-decrypted-key参数为false\\n', '\\n', '$ cat /etc/isulad/daemon.json\\n', '{\\n', '    \"group\": \"isulad\",\\n', '    \"graph\": \"/var/lib/isulad\",\\n', '    \"state\": \"/var/run/isulad\",\\n', '    \"engine\": \"lcr\",\\n', '    \"log-level\": \"ERROR\",\\n', '    \"pidfile\": \"/var/run/isulad.pid\",\\n', '    \"log-opts\": {\\n', '        \"log-file-mode\": \"0600\",\\n', '        \"log-path\": \"/var/lib/isulad\",\\n', '        \"max-file\": \"1\",\\n', '        \"max-size\": \"30KB\"\\n', '    },\\n', '    \"log-driver\": \"stdout\",\\n', '    \"hook-spec\": \"/etc/default/isulad/hooks/default.json\",\\n', '    \"start-timeout\": \"2m\",\\n', '    \"storage-driver\": \"overlay2\",\\n', '    \"storage-opts\": [\\n', '        \"overlay2.override_kernel_check=true\"\\n', '    ],\\n', '    \"registry-mirrors\": [\\n', '        \"docker.io\"\\n', '    ],\\n', '    \"insecure-registries\": [\\n', '        \"rnd-dockerhub.huawei.com\"\\n', '    ],\\n', '    \"pod-sandbox-image\": \"\",\\n', '    \"image-opt-timeout\": \"5m\",\\n', '    \"native.umask\": \"secure\",\\n', '    \"network-plugin\": \"\",\\n', '    \"cni-bin-dir\": \"\",\\n', '    \"cni-conf-dir\": \"\",\\n', '    \"image-layer-check\": false,\\n', '    \"use-decrypted-key\": false,\\n', '    \"insecure-skip-verify-enforce\": false\\n', '}\\n', '将证书放到对应的目录下\\n', '\\n', '$ pwd\\n', '/etc/isulad/certs.d/my.csp-edge.com:5000\\n', '$ ls\\n', 'ca.crt  tls.cert  tls.key\\n', '重启isulad\\n', '\\n', '$ systemctl restart isulad\\n', '执行pull命令从仓库下载镜像\\n', '\\n', '$ isula pull my.csp-edge.com:5000/busybox\\n', 'Image \"my.csp-edge.com:5000/busybox\" pulling\\n', 'Image \"my.csp-edge.com:5000/busybox@sha256:f1bdc62115dbfe8f54e52e19795ee34b4473babdeb9bc4f83045d85c7b2ad5c0\" pulled\\n', 'embedded镜像管理\\n', '加载镜像\\n', '描述\\n', '根据embedded镜像的manifest加载镜像。注意–type的值必须填写embedded。\\n', '\\n', '用法\\n', 'isula load [OPTIONS] --input=FILE --type=TYPE\\n', '参数\\n', 'load命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表5 load命令参数列表”。\\n', '\\n', '示例\\n', '$ isula load -i test.manifest --type embedded\\n', 'Load image from \"/root/work/bugfix/tmp/ci_testcase_data/embedded/img/test.manifest\" success\\n', '列出镜像\\n', '描述\\n', '列出当前环境中所有镜像。\\n', '\\n', '用法\\n', 'isula images [OPTIONS]\\n', '参数\\n', 'images命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表6 images命令参数列表”。\\n', '\\n', '示例\\n', '$ isula images\\n', 'REF                            IMAGE ID             CREATED              SIZE\\n', 'test:v1                        9319da1f5233         2018-03-01 10:55:44  1.273 MB\\n', '检视镜像\\n', '描述\\n', '返回该镜像的配置信息。可以使用-f参数过滤出需要的信息。\\n', '\\n', '用法\\n', 'isula inspect [options] CONTAINER|IMAGE [CONTAINER|IMAGE...]\\n', '参数\\n', 'inspect命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表7 inspect命令参数列表”。\\n', '\\n', '示例\\n', '$ isula inspect -f \"{{json .created}}\" test:v1\\n', '\"2018-03-01T15:55:44.322987811Z\"\\n', '删除镜像\\n', '描述\\n', '删除一个或多个镜像。\\n', '\\n', '用法\\n', 'isula rmi [OPTIONS] IMAGE [IMAGE...]\\n', '参数\\n', 'rmi命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表4 rmi命令参数列表”。\\n', '\\n', '示例\\n', '$ isula rmi test:v1\\n', 'Image \"test:v1\" removed\\n', '添加名称\\n', '描述\\n', '给镜像添加一个名称。\\n', '\\n', '用法\\n', 'isula tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]\\n', '参数\\n', 'tag命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表8 tag命令参数列表”。\\n', '\\n', '示例\\n', '$ isula tag test:v1 test:v2\\n', '导入镜像\\n', '描述\\n', '将tar格式的rootfs导入生成一个新的镜像，该tar包必须是通过export命令导出的tar包。\\n', '\\n', '用法\\n', 'isula export [command options] [ID|NAME]\\n', '参数\\n', 'export命令支持参数请参见\"附录 > 命令行参数说明\" 章节的 “表9 export命令参数列表”。\\n', '\\n', '示例\\n', '$ isula export -o test.tar containername\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_iSula容器引擎_使用指南_容器健康状态检查.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%AE%B9%E5%99%A8%E5%81%A5%E5%BA%B7%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5.html", "text_entry": "['容器健康状态检查\\n', '容器健康状态检查\\n', '场景说明\\n', '配置方法\\n', '检查规则\\n', '使用限制\\n', '场景说明\\n', '在实际的生产环境中，开发者提供的应用程序或者平台提供的服务难免存在bug，因此，一套管理系统对运行的应用程序进行周期性的健康检查和修复就是不可或缺的。容器健康检查机制便添加了用户定义的对容器进行健康检查的功能。在容器创建时配置--health-cmd选项，在容器内部周期性地执行命令，通过命令的返回值来监测容器的健康状态。\\n', '\\n', '配置方法\\n', '在容器启动时的配置：\\n', '\\n', 'isula run -itd --health-cmd \"echo iSulad >> /tmp/health_check_file || exit 1\" --health-interval 5m --health-timeout 3s --health-exit-on-unhealthy  busybox bash\\n', '可配置的选项：\\n', '\\n', '--health-cmd，必选，在容器内执行的命令。返回值为0表示成功，非0表示失败。\\n', '--health-interval，默认 30s，最大为int64上限（纳秒），自定义配置最小值1s，相邻两次命令执行的间隔时间（注：入参0s时视为default）。\\n', '--health-timeout，默认 30s，最大为int64上限（纳秒），自定义配置最小值1s，单次检查命令执行的时间上限，超时则任务命令执行失败（注：入参0s时视为default），仅支持runtime类型为lcr的容器。\\n', '--health-start-period，默认 0s，最大为int64上限（纳秒），自定义配置最小值1s，容器初始化时间。\\n', '--health-retries，默认 3，最大为int32上限，健康检查失败最大的重试次数。\\n', '--health-exit-on-unhealthy，默认false，检测到容器非健康时是否杀死容器。\\n', '检查规则\\n', '容器启动后，容器状态中显示health:starting。\\n', '经过start-period时间后开始，以interval为间隔周期性在容器中执行CMD。即：当一次命令执行完毕后，经过interval时间，执行下一次命令。\\n', '若CMD命令在timeout限制的时间内执行完毕，并且返回值为0，则视为一次检查成功。否则视为一次检查失败。检查成功后，容器状态变为health:healthy。\\n', '若CMD命令连续retries次检查失败，则容器状态变为health:unhealthy。失败后容器也会继续进行健康检查。\\n', '容器状态为health:unhealthy时，任意一次检查成功会使得容器状态变为health:healthy。\\n', '设置--exit-on-unhealthy的情况下，如果容器因为非被杀死退出（退出返回值137）后，健康检查只有容器在重新启动后才会继续生效。\\n', 'CMD执行完毕或超时时，docker daemon会将这次检查的起始时间、返回值和标准输出记录到容器的配置文件中。最多记录5条。此外，容器的配置文件中还存储着健康检查的相关参数。\\n', '运行中的容器的健康检查状态也会被写入容器配置中。通过isula inspect可以看到。\\n', '\"Health\": {\\n', '    \"Status\": \"healthy\",\\n', '    \"FailingStreak\": 0,\\n', '    \"Log\": [\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:15.481414707-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:15.556908311-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        {\\n', '            \"Start\": \"2018-03-07T07:44:18.557297462-05:00\",\\n', '            \"End\": \"2018-03-07T07:44:18.63035891-05:00\",\\n', '            \"ExitCode\": 0,\\n', '            \"Output\": \"\"\\n', '        },\\n', '        ......\\n', '}\\n', '使用限制\\n', '容器内健康检查的状态信息最多保存5条。会保存最后得到的5条记录。\\n', '容器启动时若健康检查相关参数配置为0，则按照默认值处理。\\n', '带有健康检查配置的容器启动后，若iSulad daemon退出，则健康检查不会执行。iSulad daemon再次启动后，正在运行且带有健康检查配置的容器其健康状态会变为starting。之后检查规则同上。\\n', '如果健康检查从第一次开始便一直失败，其状态保持与之前一致（starting）,直到达到指定失败次数（–health-retries）后变为unhealthy，或者检查成功后变为healthy。\\n', '对于OCI类型的runtime的容器，健康检查功能待完善。目前仅完整支持lcr类型的容器。\\n', '返回顶部\\n', '有奖捉虫\\n']"}
{"index": {"_index": "new-open", "_id": "openEuler_内核热升级指南_常见问题与解决方法.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/KernelLiveUpgrade/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html", "text_entry": "['执行nvwa update后未升级\\n', '\\n', '原因：保留现场或者内核替换过程中出现错误。\\n', '\\n', '解决方法：查看日志，找出错误原因。\\n', '\\n', '开启加速特性后，nvwa执行命令失败\\n', '\\n', '原因：nvwa提供了诸多加速特性，包括quick kexec，pin memory，cpu park等等。这些特性都涉及到cmdline的配置和内存的分配，在选取内存时，通过cat /proc/iomemory确保选取的内存没有与其他程序冲突。必要时，通过dmesg查看使能特性后是否存在错误日志。\\n', '\\n', '热升级后，相关现场未被恢复\\n', '\\n', '原因：首先检查nvwa服务是否运行，运行情况下，可能存在两种情况，一种是服务恢复失败，一种是进程恢复失败。\\n', '\\n', '解决方法：通过service nvwa status查看nvwa的日志，如果是服务启动失败，首先确认是否使能了该服务，再通过systemd查看对应服务的日志。进一步的日志，去criu_dir指定的路径对应命名的进程/服务文件夹中。其中dump.log为保存现场产生的日志，restore.log为恢复现场产生的。\\n', '\\n', \"恢复失败，日志显示Can't fork for 948: File exists\\n\", '\\n', '原因：内核热升级工具在恢复程序过程中，发现程序的pid已经被占用。\\n', '\\n', '解决方法：当前内核没有提供保留pid的机制，相关策略正在开发，预计会在将来的内核版本中解决这一限制，当前仅能手动重启相关进程。\\n', '\\n', '使用nvwa去保存和恢复简单程序(hello world)，显示失败或者程序未在执行\\n', '\\n', '原因: criu使用存在诸多限制\\n', '\\n', '解决办法：查看nvwa的日志，如果显示是criu相关的错误，去相应的目录下检查dump.log或者restore.log，criu相关的使用限制，可以参考w']"}
{"index": {"_index": "new-open", "_id": "openEuler_容器用户指南_系统容器_使用指南_共享内存通道.txt"}}
{"file_link": "https://docs.openeuler.org/zh/docs/22.03_LTS/docs/Container/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E9%80%9A%E9%81%93.html", "text_entry": "['共享内存通道\\n', '功能描述\\n', '系统容器提供容器与主机进程通过共享内存进行通信的功能，通过在容器创建时配置--host-channel参数，可以在容器与主机之间共享同一tmpfs，从而达到主机与容器间通信的功能。\\n', '\\n', '参数说明\\n', '\\n', '命令\\n', '\\n', '参数\\n', '\\n', '参数指定值说明\\n', '\\n', 'isula create/run\\n', '\\n', '--host-channel\\n', '\\n', '字符串变量，格式为：\\n', '<host path>:<container path>:<rw/ro>:<size limit>\\n', '参数说明如下：\\n', '<host path>：将在宿主机上挂载tmpfs的路径，必须是绝对路径。\\n', '\\n', '<container path>：将在容器内挂载tmpfs的路径，必须是绝对路径。\\n', '\\n', '<rw/ro>：在容器内挂载的文件系统的使用权限，只能配置为rw（可读写）或ro（只读），默认为rw。\\n', '\\n', '<size limit>：挂载的tmpfs能够使用的最大限制，最小支持1物理页（4KB），最大支持系统总物理内存的1/2 。默认为64MB。\\n', '\\n', '约束限制\\n', '宿主机上挂载的tmpfs的生命周期为从容器启动到容器删除，容器删除并解除对空间的占用后会移除这片空间。\\n', '容器删除时会将宿主机上挂载tmpfs的路径删除，所以不允许使用宿主机上已存在的目录。\\n', '为了宿主机上非root用户运行的进程能够与容器内进行通信，宿主机上tmpfs挂载的权限为1777。\\n', '使用示例\\n', '创建容器时指定--host-channel参数：\\n', '\\n', '[root@localhost ~]# isula run --rm -it --host-channel /testdir:/testdir:rw:32M --system-container --external-rootfs /root/myrootfs none init \\n', 'root@3b947668eb54:/# dd if=/dev/zero of=/testdir/test.file bs=1024 count=64K \\n', \"dd: error writing '/testdir/test.file': No space left on device \\n\", '32769+0 records in \\n', '32768+0 records out \\n', '33554432 bytes (34 MB, 32 MiB) copied, 0.0766899 s, 438 MB/s\\n', ' 说明：\\n', '\\n', '使用–host-channel大小限制时，若在容器内创建共享文件，则会受到容器内的内存配额限制（在容器内存使用达到极限时可能会产生oom）。\\n', '若用户在主机端创建共享文件，则不受容器内的内存配额限制。\\n', '若用户需要在容器内创建共享文件，且业务为内存密集型，可以通过设置容器内存配额为在原本基础上加上–host-channel配置的大小来消除影响。']"}
