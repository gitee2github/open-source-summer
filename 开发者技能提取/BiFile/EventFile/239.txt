在操作系统中，线程是一个独立的运行单元，一般认为每个线程是独立运行的；但是在实际应用中，经常出现一个业务功能需要多个线程协同处理，这时候线程和线程之间存在逻辑上的关联关系，经常出现线程之间的唤醒与被唤醒。线程的每次“交互”需要内核调度模块参与，一次完整的交互，内核调度模块需要参与选核，入队列，更新负载信息，选任务等流程。系统中如果线程比较多（有数千个线程）,线程负载比较小的场景下，会导致内核调度开销比较大，而且线程之间交互的效率比较低（线程B需要入队列，等待CPU资源，导致runable的时间比较长）。 在《The Case for Thread Migration- Predictable IPC in a Customizable and Reliable OS》这篇论文中讲述了一种新的线程切换思路：执行实体与调度实体分离，在同步IPC场景中，线程之间发生切换，只切换执行实体不切换调度实体，从而提升IPC的通信效率，降低调度开销。通过测试，这种技术可以使得同步IPC的效率提升近10倍。 执行实体与调度实体分离的技术适用于微内核架构，在linux系统中并不适用，主要因为linux系统在设计之初就将执行实体与调度实体融合成一个结构体：task_struct, 经过多年的开发，task_struct结构体已经散布到linux内核的各个模块中，此时拆分执行实体和调度实体，工作量大，难度高，质量难以保障。 我们可以重新审视执行实体和调度实体分离的技术原理，在线程交互时，切换执行实体而不切换调度实体，本质上是利用了原任务的剩余时间片来运行新任务，bypass调度，降低了内核调度开销，同时原任务直接切换到新任务时，新任务不用重新入队列等待CPU资源，这时没有尾时延（runnable时间），大大提升线程交互的效率。这种往往用在同步线程模型中（原任务进入休眠，新任务执行）。 我们将原任务直接切换到新任务，bypass调度的技术命名为direct-thread-switch, 这里强调下，bypass调度的前提必须是利用原任务的剩余时间片，否则会打破CFS调度的公平性。需求描述】
在Linux环境下实现direct-thread-switch功能，线程切换模型如下，上一个任务进入休眠状态，直接切换到下一个任务进行运行，上一个任务的剩余时间片和调度属性交换给下一个任务，切换到下一个任务继续运行； 不能打破系统的公平性，同时不能破坏dfx；
基本的软件模块包括： 1、内核线程切换方法（direct-thread-switch） 2、基于Google futex_swap patch验证内容： 1、对比有无direct-thread-switch的futex_swap在CPU调度开销大小； 2、验证有无direct-thread-switch的futex_swap在E2E的效率上提升的空间； 验证说明：系统环境需要有1000个运行线程（用于衡量runable的时间）；
【环境要求】
CPU架构：x86_64/aarch64
OS版本：OLK-5.10

1、实现相关的功能代码，功能验证OK；
2、输出完整的设计方案及测试用例；
3、代码符合clean code标准；

1、熟练掌握linux调度器的原理；
2、熟练掌握c语言及内核编程规范；